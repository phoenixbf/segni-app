/*! For license information please see THREE.bundle.js.LICENSE.txt */
(()=>{"use strict";var t={470:t=>{function e(t){if("string"!=typeof t)throw new TypeError("Path must be a string. Received "+JSON.stringify(t))}function n(t,e){for(var n,r="",i=0,s=-1,a=0,o=0;o<=t.length;++o){if(o<t.length)n=t.charCodeAt(o);else{if(47===n)break;n=47}if(47===n){if(s===o-1||1===a);else if(s!==o-1&&2===a){if(r.length<2||2!==i||46!==r.charCodeAt(r.length-1)||46!==r.charCodeAt(r.length-2))if(r.length>2){var l=r.lastIndexOf("/");if(l!==r.length-1){-1===l?(r="",i=0):i=(r=r.slice(0,l)).length-1-r.lastIndexOf("/"),s=o,a=0;continue}}else if(2===r.length||1===r.length){r="",i=0,s=o,a=0;continue}e&&(r.length>0?r+="/..":r="..",i=2)}else r.length>0?r+="/"+t.slice(s+1,o):r=t.slice(s+1,o),i=o-s-1;s=o,a=0}else 46===n&&-1!==a?++a:a=-1}return r}var r={resolve:function(){for(var t,r="",i=!1,s=arguments.length-1;s>=-1&&!i;s--){var a;s>=0?a=arguments[s]:(void 0===t&&(t=process.cwd()),a=t),e(a),0!==a.length&&(r=a+"/"+r,i=47===a.charCodeAt(0))}return r=n(r,!i),i?r.length>0?"/"+r:"/":r.length>0?r:"."},normalize:function(t){if(e(t),0===t.length)return".";var r=47===t.charCodeAt(0),i=47===t.charCodeAt(t.length-1);return 0!==(t=n(t,!r)).length||r||(t="."),t.length>0&&i&&(t+="/"),r?"/"+t:t},isAbsolute:function(t){return e(t),t.length>0&&47===t.charCodeAt(0)},join:function(){if(0===arguments.length)return".";for(var t,n=0;n<arguments.length;++n){var i=arguments[n];e(i),i.length>0&&(void 0===t?t=i:t+="/"+i)}return void 0===t?".":r.normalize(t)},relative:function(t,n){if(e(t),e(n),t===n)return"";if((t=r.resolve(t))===(n=r.resolve(n)))return"";for(var i=1;i<t.length&&47===t.charCodeAt(i);++i);for(var s=t.length,a=s-i,o=1;o<n.length&&47===n.charCodeAt(o);++o);for(var l=n.length-o,c=a<l?a:l,h=-1,u=0;u<=c;++u){if(u===c){if(l>c){if(47===n.charCodeAt(o+u))return n.slice(o+u+1);if(0===u)return n.slice(o+u)}else a>c&&(47===t.charCodeAt(i+u)?h=u:0===u&&(h=0));break}var d=t.charCodeAt(i+u);if(d!==n.charCodeAt(o+u))break;47===d&&(h=u)}var p="";for(u=i+h+1;u<=s;++u)u!==s&&47!==t.charCodeAt(u)||(0===p.length?p+="..":p+="/..");return p.length>0?p+n.slice(o+h):(o+=h,47===n.charCodeAt(o)&&++o,n.slice(o))},_makeLong:function(t){return t},dirname:function(t){if(e(t),0===t.length)return".";for(var n=t.charCodeAt(0),r=47===n,i=-1,s=!0,a=t.length-1;a>=1;--a)if(47===(n=t.charCodeAt(a))){if(!s){i=a;break}}else s=!1;return-1===i?r?"/":".":r&&1===i?"//":t.slice(0,i)},basename:function(t,n){if(void 0!==n&&"string"!=typeof n)throw new TypeError('"ext" argument must be a string');e(t);var r,i=0,s=-1,a=!0;if(void 0!==n&&n.length>0&&n.length<=t.length){if(n.length===t.length&&n===t)return"";var o=n.length-1,l=-1;for(r=t.length-1;r>=0;--r){var c=t.charCodeAt(r);if(47===c){if(!a){i=r+1;break}}else-1===l&&(a=!1,l=r+1),o>=0&&(c===n.charCodeAt(o)?-1==--o&&(s=r):(o=-1,s=l))}return i===s?s=l:-1===s&&(s=t.length),t.slice(i,s)}for(r=t.length-1;r>=0;--r)if(47===t.charCodeAt(r)){if(!a){i=r+1;break}}else-1===s&&(a=!1,s=r+1);return-1===s?"":t.slice(i,s)},extname:function(t){e(t);for(var n=-1,r=0,i=-1,s=!0,a=0,o=t.length-1;o>=0;--o){var l=t.charCodeAt(o);if(47!==l)-1===i&&(s=!1,i=o+1),46===l?-1===n?n=o:1!==a&&(a=1):-1!==n&&(a=-1);else if(!s){r=o+1;break}}return-1===n||-1===i||0===a||1===a&&n===i-1&&n===r+1?"":t.slice(n,i)},format:function(t){if(null===t||"object"!=typeof t)throw new TypeError('The "pathObject" argument must be of type Object. Received type '+typeof t);return function(t,e){var n=e.dir||e.root,r=e.base||(e.name||"")+(e.ext||"");return n?n===e.root?n+r:n+"/"+r:r}(0,t)},parse:function(t){e(t);var n={root:"",dir:"",base:"",ext:"",name:""};if(0===t.length)return n;var r,i=t.charCodeAt(0),s=47===i;s?(n.root="/",r=1):r=0;for(var a=-1,o=0,l=-1,c=!0,h=t.length-1,u=0;h>=r;--h)if(47!==(i=t.charCodeAt(h)))-1===l&&(c=!1,l=h+1),46===i?-1===a?a=h:1!==u&&(u=1):-1!==a&&(u=-1);else if(!c){o=h+1;break}return-1===a||-1===l||0===u||1===u&&a===l-1&&a===o+1?-1!==l&&(n.base=n.name=0===o&&s?t.slice(1,l):t.slice(o,l)):(0===o&&s?(n.name=t.slice(1,a),n.base=t.slice(1,l)):(n.name=t.slice(o,a),n.base=t.slice(o,l)),n.ext=t.slice(a,l)),o>0?n.dir=t.slice(0,o-1):s&&(n.dir="/"),n},sep:"/",delimiter:":",win32:null,posix:null};r.posix=r,t.exports=r}},e={};function n(r){var i=e[r];if(void 0!==i)return i.exports;var s=e[r]={exports:{}};return t[r](s,s.exports,n),s.exports}n.d=(t,e)=>{for(var r in e)n.o(e,r)&&!n.o(t,r)&&Object.defineProperty(t,r,{enumerable:!0,get:e[r]})},n.g=function(){if("object"==typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(t){if("object"==typeof window)return window}}(),n.o=(t,e)=>Object.prototype.hasOwnProperty.call(t,e),n.r=t=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})},(()=>{var t={};n.r(t),n.d(t,{ACESFilmicToneMapping:()=>at,AddEquation:()=>P,AddOperation:()=>et,AdditiveAnimationBlendMode:()=>Qe,AdditiveBlending:()=>S,AlphaFormat:()=>kt,AlwaysDepth:()=>j,AlwaysStencilFunc:()=>bn,AmbientLight:()=>rd,AmbientLightProbe:()=>wd,AnimationClip:()=>Cu,AnimationLoader:()=>Nu,AnimationMixer:()=>Kd,AnimationObjectGroup:()=>Zd,AnimationUtils:()=>mu,ArcCurve:()=>Zc,ArrayCamera:()=>yl,ArrowHelper:()=>Hp,Audio:()=>Fd,AudioAnalyser:()=>Bd,AudioContext:()=>vd,AudioListener:()=>Rd,AudioLoader:()=>xd,AxesHelper:()=>Gp,AxisHelper:()=>xf,BackSide:()=>y,BasicDepthPacking:()=>en,BasicShadowMap:()=>f,BinaryTextureLoader:()=>Mf,Bone:()=>sc,BooleanKeyframeTrack:()=>bu,BoundingBoxHelper:()=>yf,Box2:()=>lp,Box3:()=>ur,Box3Helper:()=>Np,BoxBufferGeometry:()=>xs,BoxGeometry:()=>xs,BoxHelper:()=>Up,BufferAttribute:()=>Ii,BufferGeometry:()=>Ki,BufferGeometryLoader:()=>hd,ByteType:()=>Pt,Cache:()=>Lu,Camera:()=>Ms,CameraHelper:()=>Fp,CanvasRenderer:()=>Sf,CanvasTexture:()=>Oc,CatmullRomCurve3:()=>nh,CineonToneMapping:()=>st,CircleBufferGeometry:()=>Bc,CircleGeometry:()=>Bc,ClampToEdgeWrapping:()=>gt,Clock:()=>Sd,Color:()=>Li,ColorKeyframeTrack:()=>_u,CompressedTexture:()=>Nc,CompressedTextureLoader:()=>Ou,ConeBufferGeometry:()=>kc,ConeGeometry:()=>kc,CubeCamera:()=>As,CubeReflectionMapping:()=>ct,CubeRefractionMapping:()=>ht,CubeTexture:()=>Es,CubeTextureLoader:()=>zu,CubeUVReflectionMapping:()=>pt,CubeUVRefractionMapping:()=>ft,CubicBezierCurve:()=>ah,CubicBezierCurve3:()=>oh,CubicInterpolant:()=>vu,CullFaceBack:()=>u,CullFaceFront:()=>d,CullFaceFrontBack:()=>p,CullFaceNone:()=>h,Curve:()=>qc,CurvePath:()=>fh,CustomBlending:()=>C,CustomToneMapping:()=>ot,CylinderBufferGeometry:()=>zc,CylinderGeometry:()=>zc,Cylindrical:()=>ap,DataTexture:()=>ac,DataTexture2DArray:()=>wa,DataTexture3D:()=>Aa,DataTextureLoader:()=>ku,DataUtils:()=>jp,DecrementStencilOp:()=>hn,DecrementWrapStencilOp:()=>dn,DefaultLoadingManager:()=>Fu,DepthFormat:()=>Xt,DepthStencilFormat:()=>jt,DepthTexture:()=>Ml,DirectionalLight:()=>nd,DirectionalLightHelper:()=>Pp,DiscreteInterpolant:()=>yu,DodecahedronBufferGeometry:()=>Gc,DodecahedronGeometry:()=>Gc,DoubleSide:()=>w,DstAlphaFactor:()=>k,DstColorFactor:()=>G,DynamicBufferAttribute:()=>lf,DynamicCopyUsage:()=>Pn,DynamicDrawUsage:()=>Mn,DynamicReadUsage:()=>An,EdgesGeometry:()=>Yc,EdgesHelper:()=>wf,EllipseCurve:()=>Qc,EqualDepth:()=>Q,EqualStencilFunc:()=>gn,EquirectangularReflectionMapping:()=>ut,EquirectangularRefractionMapping:()=>dt,Euler:()=>Qr,EventDispatcher:()=>Dn,ExtrudeBufferGeometry:()=>Wh,ExtrudeGeometry:()=>Wh,FaceColors:()=>Zp,FileLoader:()=>Uu,FlatShading:()=>b,Float16BufferAttribute:()=>Gi,Float32Attribute:()=>gf,Float32BufferAttribute:()=>Vi,Float64Attribute:()=>vf,Float64BufferAttribute:()=>Wi,FloatType:()=>It,Fog:()=>Pl,FogExp2:()=>Cl,Font:()=>Ff,FontLoader:()=>Rf,FramebufferTexture:()=>Uc,FrontSide:()=>x,Frustum:()=>Us,GLBufferAttribute:()=>ep,GLSL1:()=>Rn,GLSL3:()=>Fn,GreaterDepth:()=>J,GreaterEqualDepth:()=>Z,GreaterEqualStencilFunc:()=>wn,GreaterStencilFunc:()=>xn,GridHelper:()=>Tp,Group:()=>wl,HalfFloatType:()=>Ut,HemisphereLight:()=>Vu,HemisphereLightHelper:()=>Mp,HemisphereLightProbe:()=>yd,IcosahedronBufferGeometry:()=>jh,IcosahedronGeometry:()=>jh,ImageBitmapLoader:()=>md,ImageLoader:()=>Bu,ImageUtils:()=>$n,ImmediateRenderObject:()=>Df,IncrementStencilOp:()=>cn,IncrementWrapStencilOp:()=>un,InstancedBufferAttribute:()=>hc,InstancedBufferGeometry:()=>cd,InstancedInterleavedBuffer:()=>tp,InstancedMesh:()=>mc,Int16Attribute:()=>df,Int16BufferAttribute:()=>Bi,Int32Attribute:()=>ff,Int32BufferAttribute:()=>ki,Int8Attribute:()=>cf,Int8BufferAttribute:()=>Ui,IntType:()=>Ft,InterleavedBuffer:()=>Rl,InterleavedBufferAttribute:()=>Dl,Interpolant:()=>gu,InterpolateDiscrete:()=>Ge,InterpolateLinear:()=>Ve,InterpolateSmooth:()=>We,InvertStencilOp:()=>pn,JSONLoader:()=>Af,KeepStencilOp:()=>on,KeyframeTrack:()=>wu,LOD:()=>Kl,LatheBufferGeometry:()=>Yh,LatheGeometry:()=>Yh,Layers:()=>Zr,LensFlare:()=>Cf,LessDepth:()=>Y,LessEqualDepth:()=>q,LessEqualStencilFunc:()=>vn,LessStencilFunc:()=>mn,Light:()=>Gu,LightProbe:()=>ad,Line:()=>_c,Line3:()=>up,LineBasicMaterial:()=>gc,LineCurve:()=>lh,LineCurve3:()=>ch,LineDashedMaterial:()=>pu,LineLoop:()=>Ac,LinePieces:()=>qp,LineSegments:()=>Sc,LineStrip:()=>Yp,LinearEncoding:()=>$e,LinearFilter:()=>Mt,LinearInterpolant:()=>xu,LinearMipMapLinearFilter:()=>Et,LinearMipMapNearestFilter:()=>St,LinearMipmapLinearFilter:()=>At,LinearMipmapNearestFilter:()=>Tt,LinearToneMapping:()=>rt,Loader:()=>Du,LoaderUtils:()=>ld,LoadingManager:()=>Ru,LoopOnce:()=>ze,LoopPingPong:()=>He,LoopRepeat:()=>ke,LuminanceAlphaFormat:()=>Wt,LuminanceFormat:()=>Vt,MOUSE:()=>l,Material:()=>Mi,MaterialLoader:()=>od,Math:()=>Xn,MathUtils:()=>Xn,Matrix3:()=>Yn,Matrix4:()=>zr,MaxEquation:()=>D,Mesh:()=>gs,MeshBasicMaterial:()=>Ri,MeshDepthMaterial:()=>pl,MeshDistanceMaterial:()=>fl,MeshFaceMaterial:()=>Kp,MeshLambertMaterial:()=>uu,MeshMatcapMaterial:()=>du,MeshNormalMaterial:()=>hu,MeshPhongMaterial:()=>lu,MeshPhysicalMaterial:()=>ou,MeshStandardMaterial:()=>au,MeshToonMaterial:()=>cu,MinEquation:()=>F,MirroredRepeatWrapping:()=>vt,MixOperation:()=>tt,MultiMaterial:()=>$p,MultiplyBlending:()=>E,MultiplyOperation:()=>$,NearestFilter:()=>xt,NearestMipMapLinearFilter:()=>_t,NearestMipMapNearestFilter:()=>wt,NearestMipmapLinearFilter:()=>bt,NearestMipmapNearestFilter:()=>yt,NeverDepth:()=>X,NeverStencilFunc:()=>fn,NoBlending:()=>M,NoColors:()=>Qp,NoToneMapping:()=>nt,NormalAnimationBlendMode:()=>qe,NormalBlending:()=>T,NotEqualDepth:()=>K,NotEqualStencilFunc:()=>yn,NumberKeyframeTrack:()=>Mu,Object3D:()=>hi,ObjectLoader:()=>ud,ObjectSpaceNormalMap:()=>sn,OctahedronBufferGeometry:()=>qh,OctahedronGeometry:()=>qh,OneFactor:()=>U,OneMinusDstAlphaFactor:()=>H,OneMinusDstColorFactor:()=>V,OneMinusSrcAlphaFactor:()=>z,OneMinusSrcColorFactor:()=>O,OrthographicCamera:()=>qs,PCFShadowMap:()=>m,PCFSoftShadowMap:()=>g,PMREMGenerator:()=>ca,ParametricGeometry:()=>Pf,Particle:()=>ef,ParticleBasicMaterial:()=>sf,ParticleSystem:()=>nf,ParticleSystemMaterial:()=>af,Path:()=>mh,PerspectiveCamera:()=>Ts,Plane:()=>Fs,PlaneBufferGeometry:()=>Bs,PlaneGeometry:()=>Bs,PlaneHelper:()=>Op,PointCloud:()=>tf,PointCloudMaterial:()=>rf,PointLight:()=>td,PointLightHelper:()=>yp,Points:()=>Fc,PointsMaterial:()=>Ec,PolarGridHelper:()=>Sp,PolyhedronBufferGeometry:()=>Hc,PolyhedronGeometry:()=>Hc,PositionalAudio:()=>Od,PropertyBinding:()=>Qd,PropertyMixer:()=>zd,QuadraticBezierCurve:()=>hh,QuadraticBezierCurve3:()=>uh,Quaternion:()=>or,QuaternionKeyframeTrack:()=>Su,QuaternionLinearInterpolant:()=>Tu,REVISION:()=>o,RGBADepthPacking:()=>nn,RGBAFormat:()=>Gt,RGBAIntegerFormat:()=>Kt,RGBA_ASTC_10x10_Format:()=>be,RGBA_ASTC_10x5_Format:()=>xe,RGBA_ASTC_10x6_Format:()=>ye,RGBA_ASTC_10x8_Format:()=>we,RGBA_ASTC_12x10_Format:()=>_e,RGBA_ASTC_12x12_Format:()=>Me,RGBA_ASTC_4x4_Format:()=>he,RGBA_ASTC_5x4_Format:()=>ue,RGBA_ASTC_5x5_Format:()=>de,RGBA_ASTC_6x5_Format:()=>pe,RGBA_ASTC_6x6_Format:()=>fe,RGBA_ASTC_8x5_Format:()=>me,RGBA_ASTC_8x6_Format:()=>ge,RGBA_ASTC_8x8_Format:()=>ve,RGBA_BPTC_Format:()=>Te,RGBA_ETC2_EAC_Format:()=>ce,RGBA_PVRTC_2BPPV1_Format:()=>ae,RGBA_PVRTC_4BPPV1_Format:()=>se,RGBA_S3TC_DXT1_Format:()=>te,RGBA_S3TC_DXT3_Format:()=>ee,RGBA_S3TC_DXT5_Format:()=>ne,RGBFormat:()=>Ht,RGBIntegerFormat:()=>Jt,RGB_ETC1_Format:()=>oe,RGB_ETC2_Format:()=>le,RGB_PVRTC_2BPPV1_Format:()=>ie,RGB_PVRTC_4BPPV1_Format:()=>re,RGB_S3TC_DXT1_Format:()=>$t,RGFormat:()=>Qt,RGIntegerFormat:()=>Zt,RawShaderMaterial:()=>Qs,Ray:()=>Br,Raycaster:()=>np,RectAreaLight:()=>id,RedFormat:()=>Yt,RedIntegerFormat:()=>qt,ReinhardToneMapping:()=>it,RepeatWrapping:()=>mt,ReplaceStencilOp:()=>ln,ReverseSubtractEquation:()=>R,RingBufferGeometry:()=>Qh,RingGeometry:()=>Qh,SRGB8_ALPHA8_ASTC_10x10_Format:()=>Ne,SRGB8_ALPHA8_ASTC_10x5_Format:()=>De,SRGB8_ALPHA8_ASTC_10x6_Format:()=>Ie,SRGB8_ALPHA8_ASTC_10x8_Format:()=>Ue,SRGB8_ALPHA8_ASTC_12x10_Format:()=>Oe,SRGB8_ALPHA8_ASTC_12x12_Format:()=>Be,SRGB8_ALPHA8_ASTC_4x4_Format:()=>Se,SRGB8_ALPHA8_ASTC_5x4_Format:()=>Ae,SRGB8_ALPHA8_ASTC_5x5_Format:()=>Ee,SRGB8_ALPHA8_ASTC_6x5_Format:()=>Ce,SRGB8_ALPHA8_ASTC_6x6_Format:()=>Pe,SRGB8_ALPHA8_ASTC_8x5_Format:()=>Le,SRGB8_ALPHA8_ASTC_8x6_Format:()=>Re,SRGB8_ALPHA8_ASTC_8x8_Format:()=>Fe,Scene:()=>Ll,SceneUtils:()=>Ef,ShaderChunk:()=>zs,ShaderLib:()=>Hs,ShaderMaterial:()=>_s,ShadowMaterial:()=>su,Shape:()=>gh,ShapeBufferGeometry:()=>Zh,ShapeGeometry:()=>Zh,ShapePath:()=>Vp,ShapeUtils:()=>Hh,ShortType:()=>Lt,Skeleton:()=>cc,SkeletonHelper:()=>vp,SkinnedMesh:()=>ic,SmoothShading:()=>_,Sphere:()=>Lr,SphereBufferGeometry:()=>Jh,SphereGeometry:()=>Jh,Spherical:()=>sp,SphericalHarmonics3:()=>sd,SplineCurve:()=>dh,SpotLight:()=>Qu,SpotLightHelper:()=>pp,Sprite:()=>ql,SpriteMaterial:()=>Il,SrcAlphaFactor:()=>B,SrcAlphaSaturateFactor:()=>W,SrcColorFactor:()=>N,StaticCopyUsage:()=>Cn,StaticDrawUsage:()=>_n,StaticReadUsage:()=>Sn,StereoCamera:()=>Td,StreamCopyUsage:()=>Ln,StreamDrawUsage:()=>Tn,StreamReadUsage:()=>En,StringKeyframeTrack:()=>Au,SubtractEquation:()=>L,SubtractiveBlending:()=>A,TOUCH:()=>c,TangentSpaceNormalMap:()=>rn,TetrahedronBufferGeometry:()=>Kh,TetrahedronGeometry:()=>Kh,TextGeometry:()=>Lf,Texture:()=>er,TextureLoader:()=>Hu,TorusBufferGeometry:()=>$h,TorusGeometry:()=>$h,TorusKnotBufferGeometry:()=>tu,TorusKnotGeometry:()=>tu,Triangle:()=>bi,TriangleFanDrawMode:()=>Ke,TriangleStripDrawMode:()=>Je,TrianglesDrawMode:()=>Ze,TubeBufferGeometry:()=>eu,TubeGeometry:()=>eu,UVMapping:()=>lt,Uint16Attribute:()=>pf,Uint16BufferAttribute:()=>zi,Uint32Attribute:()=>mf,Uint32BufferAttribute:()=>Hi,Uint8Attribute:()=>hf,Uint8BufferAttribute:()=>Ni,Uint8ClampedAttribute:()=>uf,Uint8ClampedBufferAttribute:()=>Oi,Uniform:()=>$d,UniformsLib:()=>ks,UniformsUtils:()=>bs,UnsignedByteType:()=>Ct,UnsignedInt248Type:()=>zt,UnsignedIntType:()=>Dt,UnsignedShort4444Type:()=>Nt,UnsignedShort5551Type:()=>Ot,UnsignedShort565Type:()=>Bt,UnsignedShortType:()=>Rt,VSMShadowMap:()=>v,Vector2:()=>jn,Vector3:()=>lr,Vector4:()=>rr,VectorKeyframeTrack:()=>Eu,Vertex:()=>of,VertexColors:()=>Jp,VideoTexture:()=>Ic,WebGL1Renderer:()=>El,WebGLCubeRenderTarget:()=>Cs,WebGLMultipleRenderTargets:()=>sr,WebGLMultisampleRenderTarget:()=>ar,WebGLRenderTarget:()=>ir,WebGLRenderTargetCube:()=>Tf,WebGLRenderer:()=>Al,WebGLUtils:()=>xl,WireframeGeometry:()=>nu,WireframeHelper:()=>bf,WrapAroundEnding:()=>Ye,XHRLoader:()=>_f,ZeroCurvatureEnding:()=>Xe,ZeroFactor:()=>I,ZeroSlopeEnding:()=>je,ZeroStencilOp:()=>an,sRGBEncoding:()=>tn});var e={};n.r(e),n.d(e,{AsyncCompress:()=>nx,AsyncDecompress:()=>xx,AsyncDeflate:()=>qv,AsyncGunzip:()=>ax,AsyncGzip:()=>nx,AsyncInflate:()=>Kv,AsyncUnzipInflate:()=>Xx,AsyncUnzlib:()=>fx,AsyncZipDeflate:()=>zx,AsyncZlib:()=>hx,Compress:()=>ex,DecodeUTF8:()=>Ax,Decompress:()=>vx,Deflate:()=>Yv,EncodeUTF8:()=>Ex,Gunzip:()=>sx,Gzip:()=>ex,Inflate:()=>Jv,Unzip:()=>jx,UnzipInflate:()=>Wx,UnzipPassThrough:()=>Vx,Unzlib:()=>px,Zip:()=>kx,ZipDeflate:()=>Bx,ZipPassThrough:()=>Ox,Zlib:()=>cx,compress:()=>rx,compressSync:()=>ix,decompress:()=>yx,decompressSync:()=>wx,deflate:()=>Qv,deflateSync:()=>Zv,gunzip:()=>ox,gunzipSync:()=>lx,gzip:()=>rx,gzipSync:()=>ix,inflate:()=>$v,inflateSync:()=>tx,strFromU8:()=>Px,strToU8:()=>Cx,unzip:()=>Yx,unzipSync:()=>qx,unzlib:()=>mx,unzlibSync:()=>gx,zip:()=>Hx,zipSync:()=>Gx,zlib:()=>ux,zlibSync:()=>dx});var r={};n.r(r),n.d(r,{qf:()=>uy});var i={};n.r(i);var s={};n.r(s),n.d(s,{AVERAGE:()=>Xw,CENTER:()=>Ww,CONTAINED:()=>Qw,FloatVertexAttributeTexture:()=>V_,INTERSECTED:()=>qw,IntVertexAttributeTexture:()=>G_,MeshBVH:()=>g_,MeshBVHUniformStruct:()=>W_,MeshBVHVisualizer:()=>T_,NOT_INTERSECTED:()=>Yw,SAH:()=>jw,UIntVertexAttributeTexture:()=>H_,VertexAttributeTexture:()=>k_,acceleratedRaycast:()=>N_,computeBoundsTree:()=>O_,disposeBoundsTree:()=>B_,estimateMemoryInBytes:()=>L_,getBVHExtremes:()=>P_,getJSONStructure:()=>F_,getTriangleHitPointInfo:()=>Ib,shaderIntersectFunction:()=>j_,shaderStructs:()=>X_,validateBounds:()=>R_});var a={};n.r(a),n.d(a,{B3DMLoader:()=>gM,B3DMLoaderBase:()=>mM,CMPTLoader:()=>PM,CMPTLoaderBase:()=>CM,CUSTOM_COLOR:()=>gT,DEPTH:()=>uT,DISTANCE:()=>hT,DebugTilesRenderer:()=>vT,GEOMETRIC_ERROR:()=>cT,GLTFExtensionLoader:()=>LM,I3DMLoader:()=>EM,I3DMLoaderBase:()=>yM,IS_LEAF:()=>pT,LRUCache:()=>Z_,LoaderBase:()=>fM,NONE:()=>oT,PNTSLoader:()=>xM,PNTSLoaderBase:()=>vM,PriorityQueue:()=>J_,RANDOM_COLOR:()=>fT,RANDOM_NODE_COLOR:()=>mT,RELATIVE_DEPTH:()=>dT,SCREEN_ERROR:()=>lT,TilesRenderer:()=>$M,TilesRendererBase:()=>hM});const o="136",l={LEFT:0,MIDDLE:1,RIGHT:2,ROTATE:0,DOLLY:1,PAN:2},c={ROTATE:0,PAN:1,DOLLY_PAN:2,DOLLY_ROTATE:3},h=0,u=1,d=2,p=3,f=0,m=1,g=2,v=3,x=0,y=1,w=2,b=1,_=2,M=0,T=1,S=2,A=3,E=4,C=5,P=100,L=101,R=102,F=103,D=104,I=200,U=201,N=202,O=203,B=204,z=205,k=206,H=207,G=208,V=209,W=210,X=0,j=1,Y=2,q=3,Q=4,Z=5,J=6,K=7,$=0,tt=1,et=2,nt=0,rt=1,it=2,st=3,at=4,ot=5,lt=300,ct=301,ht=302,ut=303,dt=304,pt=306,ft=307,mt=1e3,gt=1001,vt=1002,xt=1003,yt=1004,wt=1004,bt=1005,_t=1005,Mt=1006,Tt=1007,St=1007,At=1008,Et=1008,Ct=1009,Pt=1010,Lt=1011,Rt=1012,Ft=1013,Dt=1014,It=1015,Ut=1016,Nt=1017,Ot=1018,Bt=1019,zt=1020,kt=1021,Ht=1022,Gt=1023,Vt=1024,Wt=1025,Xt=1026,jt=1027,Yt=1028,qt=1029,Qt=1030,Zt=1031,Jt=1032,Kt=1033,$t=33776,te=33777,ee=33778,ne=33779,re=35840,ie=35841,se=35842,ae=35843,oe=36196,le=37492,ce=37496,he=37808,ue=37809,de=37810,pe=37811,fe=37812,me=37813,ge=37814,ve=37815,xe=37816,ye=37817,we=37818,be=37819,_e=37820,Me=37821,Te=36492,Se=37840,Ae=37841,Ee=37842,Ce=37843,Pe=37844,Le=37845,Re=37846,Fe=37847,De=37848,Ie=37849,Ue=37850,Ne=37851,Oe=37852,Be=37853,ze=2200,ke=2201,He=2202,Ge=2300,Ve=2301,We=2302,Xe=2400,je=2401,Ye=2402,qe=2500,Qe=2501,Ze=0,Je=1,Ke=2,$e=3e3,tn=3001,en=3200,nn=3201,rn=0,sn=1,an=0,on=7680,ln=7681,cn=7682,hn=7683,un=34055,dn=34056,pn=5386,fn=512,mn=513,gn=514,vn=515,xn=516,yn=517,wn=518,bn=519,_n=35044,Mn=35048,Tn=35040,Sn=35045,An=35049,En=35041,Cn=35046,Pn=35050,Ln=35042,Rn="100",Fn="300 es";class Dn{addEventListener(t,e){void 0===this._listeners&&(this._listeners={});const n=this._listeners;void 0===n[t]&&(n[t]=[]),-1===n[t].indexOf(e)&&n[t].push(e)}hasEventListener(t,e){if(void 0===this._listeners)return!1;const n=this._listeners;return void 0!==n[t]&&-1!==n[t].indexOf(e)}removeEventListener(t,e){if(void 0===this._listeners)return;const n=this._listeners[t];if(void 0!==n){const t=n.indexOf(e);-1!==t&&n.splice(t,1)}}dispatchEvent(t){if(void 0===this._listeners)return;const e=this._listeners[t.type];if(void 0!==e){t.target=this;const n=e.slice(0);for(let e=0,r=n.length;e<r;e++)n[e].call(this,t);t.target=null}}}const In=[];for(let t=0;t<256;t++)In[t]=(t<16?"0":"")+t.toString(16);let Un=1234567;const Nn=Math.PI/180,On=180/Math.PI;function Bn(){const t=4294967295*Math.random()|0,e=4294967295*Math.random()|0,n=4294967295*Math.random()|0,r=4294967295*Math.random()|0;return(In[255&t]+In[t>>8&255]+In[t>>16&255]+In[t>>24&255]+"-"+In[255&e]+In[e>>8&255]+"-"+In[e>>16&15|64]+In[e>>24&255]+"-"+In[63&n|128]+In[n>>8&255]+"-"+In[n>>16&255]+In[n>>24&255]+In[255&r]+In[r>>8&255]+In[r>>16&255]+In[r>>24&255]).toUpperCase()}function zn(t,e,n){return Math.max(e,Math.min(n,t))}function kn(t,e){return(t%e+e)%e}function Hn(t,e,n){return(1-n)*t+n*e}function Gn(t){return 0==(t&t-1)&&0!==t}function Vn(t){return Math.pow(2,Math.ceil(Math.log(t)/Math.LN2))}function Wn(t){return Math.pow(2,Math.floor(Math.log(t)/Math.LN2))}var Xn=Object.freeze({__proto__:null,DEG2RAD:Nn,RAD2DEG:On,generateUUID:Bn,clamp:zn,euclideanModulo:kn,mapLinear:function(t,e,n,r,i){return r+(t-e)*(i-r)/(n-e)},inverseLerp:function(t,e,n){return t!==e?(n-t)/(e-t):0},lerp:Hn,damp:function(t,e,n,r){return Hn(t,e,1-Math.exp(-n*r))},pingpong:function(t,e=1){return e-Math.abs(kn(t,2*e)-e)},smoothstep:function(t,e,n){return t<=e?0:t>=n?1:(t=(t-e)/(n-e))*t*(3-2*t)},smootherstep:function(t,e,n){return t<=e?0:t>=n?1:(t=(t-e)/(n-e))*t*t*(t*(6*t-15)+10)},randInt:function(t,e){return t+Math.floor(Math.random()*(e-t+1))},randFloat:function(t,e){return t+Math.random()*(e-t)},randFloatSpread:function(t){return t*(.5-Math.random())},seededRandom:function(t){return void 0!==t&&(Un=t%2147483647),Un=16807*Un%2147483647,(Un-1)/2147483646},degToRad:function(t){return t*Nn},radToDeg:function(t){return t*On},isPowerOfTwo:Gn,ceilPowerOfTwo:Vn,floorPowerOfTwo:Wn,setQuaternionFromProperEuler:function(t,e,n,r,i){const s=Math.cos,a=Math.sin,o=s(n/2),l=a(n/2),c=s((e+r)/2),h=a((e+r)/2),u=s((e-r)/2),d=a((e-r)/2),p=s((r-e)/2),f=a((r-e)/2);switch(i){case"XYX":t.set(o*h,l*u,l*d,o*c);break;case"YZY":t.set(l*d,o*h,l*u,o*c);break;case"ZXZ":t.set(l*u,l*d,o*h,o*c);break;case"XZX":t.set(o*h,l*f,l*p,o*c);break;case"YXY":t.set(l*p,o*h,l*f,o*c);break;case"ZYZ":t.set(l*f,l*p,o*h,o*c);break;default:console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: "+i)}}});class jn{constructor(t=0,e=0){this.x=t,this.y=e}get width(){return this.x}set width(t){this.x=t}get height(){return this.y}set height(t){this.y=t}set(t,e){return this.x=t,this.y=e,this}setScalar(t){return this.x=t,this.y=t,this}setX(t){return this.x=t,this}setY(t){return this.y=t,this}setComponent(t,e){switch(t){case 0:this.x=e;break;case 1:this.y=e;break;default:throw new Error("index is out of range: "+t)}return this}getComponent(t){switch(t){case 0:return this.x;case 1:return this.y;default:throw new Error("index is out of range: "+t)}}clone(){return new this.constructor(this.x,this.y)}copy(t){return this.x=t.x,this.y=t.y,this}add(t,e){return void 0!==e?(console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),this.addVectors(t,e)):(this.x+=t.x,this.y+=t.y,this)}addScalar(t){return this.x+=t,this.y+=t,this}addVectors(t,e){return this.x=t.x+e.x,this.y=t.y+e.y,this}addScaledVector(t,e){return this.x+=t.x*e,this.y+=t.y*e,this}sub(t,e){return void 0!==e?(console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),this.subVectors(t,e)):(this.x-=t.x,this.y-=t.y,this)}subScalar(t){return this.x-=t,this.y-=t,this}subVectors(t,e){return this.x=t.x-e.x,this.y=t.y-e.y,this}multiply(t){return this.x*=t.x,this.y*=t.y,this}multiplyScalar(t){return this.x*=t,this.y*=t,this}divide(t){return this.x/=t.x,this.y/=t.y,this}divideScalar(t){return this.multiplyScalar(1/t)}applyMatrix3(t){const e=this.x,n=this.y,r=t.elements;return this.x=r[0]*e+r[3]*n+r[6],this.y=r[1]*e+r[4]*n+r[7],this}min(t){return this.x=Math.min(this.x,t.x),this.y=Math.min(this.y,t.y),this}max(t){return this.x=Math.max(this.x,t.x),this.y=Math.max(this.y,t.y),this}clamp(t,e){return this.x=Math.max(t.x,Math.min(e.x,this.x)),this.y=Math.max(t.y,Math.min(e.y,this.y)),this}clampScalar(t,e){return this.x=Math.max(t,Math.min(e,this.x)),this.y=Math.max(t,Math.min(e,this.y)),this}clampLength(t,e){const n=this.length();return this.divideScalar(n||1).multiplyScalar(Math.max(t,Math.min(e,n)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this}negate(){return this.x=-this.x,this.y=-this.y,this}dot(t){return this.x*t.x+this.y*t.y}cross(t){return this.x*t.y-this.y*t.x}lengthSq(){return this.x*this.x+this.y*this.y}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)}normalize(){return this.divideScalar(this.length()||1)}angle(){return Math.atan2(-this.y,-this.x)+Math.PI}distanceTo(t){return Math.sqrt(this.distanceToSquared(t))}distanceToSquared(t){const e=this.x-t.x,n=this.y-t.y;return e*e+n*n}manhattanDistanceTo(t){return Math.abs(this.x-t.x)+Math.abs(this.y-t.y)}setLength(t){return this.normalize().multiplyScalar(t)}lerp(t,e){return this.x+=(t.x-this.x)*e,this.y+=(t.y-this.y)*e,this}lerpVectors(t,e,n){return this.x=t.x+(e.x-t.x)*n,this.y=t.y+(e.y-t.y)*n,this}equals(t){return t.x===this.x&&t.y===this.y}fromArray(t,e=0){return this.x=t[e],this.y=t[e+1],this}toArray(t=[],e=0){return t[e]=this.x,t[e+1]=this.y,t}fromBufferAttribute(t,e,n){return void 0!==n&&console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute()."),this.x=t.getX(e),this.y=t.getY(e),this}rotateAround(t,e){const n=Math.cos(e),r=Math.sin(e),i=this.x-t.x,s=this.y-t.y;return this.x=i*n-s*r+t.x,this.y=i*r+s*n+t.y,this}random(){return this.x=Math.random(),this.y=Math.random(),this}*[Symbol.iterator](){yield this.x,yield this.y}}jn.prototype.isVector2=!0;class Yn{constructor(){this.elements=[1,0,0,0,1,0,0,0,1],arguments.length>0&&console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.")}set(t,e,n,r,i,s,a,o,l){const c=this.elements;return c[0]=t,c[1]=r,c[2]=a,c[3]=e,c[4]=i,c[5]=o,c[6]=n,c[7]=s,c[8]=l,this}identity(){return this.set(1,0,0,0,1,0,0,0,1),this}copy(t){const e=this.elements,n=t.elements;return e[0]=n[0],e[1]=n[1],e[2]=n[2],e[3]=n[3],e[4]=n[4],e[5]=n[5],e[6]=n[6],e[7]=n[7],e[8]=n[8],this}extractBasis(t,e,n){return t.setFromMatrix3Column(this,0),e.setFromMatrix3Column(this,1),n.setFromMatrix3Column(this,2),this}setFromMatrix4(t){const e=t.elements;return this.set(e[0],e[4],e[8],e[1],e[5],e[9],e[2],e[6],e[10]),this}multiply(t){return this.multiplyMatrices(this,t)}premultiply(t){return this.multiplyMatrices(t,this)}multiplyMatrices(t,e){const n=t.elements,r=e.elements,i=this.elements,s=n[0],a=n[3],o=n[6],l=n[1],c=n[4],h=n[7],u=n[2],d=n[5],p=n[8],f=r[0],m=r[3],g=r[6],v=r[1],x=r[4],y=r[7],w=r[2],b=r[5],_=r[8];return i[0]=s*f+a*v+o*w,i[3]=s*m+a*x+o*b,i[6]=s*g+a*y+o*_,i[1]=l*f+c*v+h*w,i[4]=l*m+c*x+h*b,i[7]=l*g+c*y+h*_,i[2]=u*f+d*v+p*w,i[5]=u*m+d*x+p*b,i[8]=u*g+d*y+p*_,this}multiplyScalar(t){const e=this.elements;return e[0]*=t,e[3]*=t,e[6]*=t,e[1]*=t,e[4]*=t,e[7]*=t,e[2]*=t,e[5]*=t,e[8]*=t,this}determinant(){const t=this.elements,e=t[0],n=t[1],r=t[2],i=t[3],s=t[4],a=t[5],o=t[6],l=t[7],c=t[8];return e*s*c-e*a*l-n*i*c+n*a*o+r*i*l-r*s*o}invert(){const t=this.elements,e=t[0],n=t[1],r=t[2],i=t[3],s=t[4],a=t[5],o=t[6],l=t[7],c=t[8],h=c*s-a*l,u=a*o-c*i,d=l*i-s*o,p=e*h+n*u+r*d;if(0===p)return this.set(0,0,0,0,0,0,0,0,0);const f=1/p;return t[0]=h*f,t[1]=(r*l-c*n)*f,t[2]=(a*n-r*s)*f,t[3]=u*f,t[4]=(c*e-r*o)*f,t[5]=(r*i-a*e)*f,t[6]=d*f,t[7]=(n*o-l*e)*f,t[8]=(s*e-n*i)*f,this}transpose(){let t;const e=this.elements;return t=e[1],e[1]=e[3],e[3]=t,t=e[2],e[2]=e[6],e[6]=t,t=e[5],e[5]=e[7],e[7]=t,this}getNormalMatrix(t){return this.setFromMatrix4(t).invert().transpose()}transposeIntoArray(t){const e=this.elements;return t[0]=e[0],t[1]=e[3],t[2]=e[6],t[3]=e[1],t[4]=e[4],t[5]=e[7],t[6]=e[2],t[7]=e[5],t[8]=e[8],this}setUvTransform(t,e,n,r,i,s,a){const o=Math.cos(i),l=Math.sin(i);return this.set(n*o,n*l,-n*(o*s+l*a)+s+t,-r*l,r*o,-r*(-l*s+o*a)+a+e,0,0,1),this}scale(t,e){const n=this.elements;return n[0]*=t,n[3]*=t,n[6]*=t,n[1]*=e,n[4]*=e,n[7]*=e,this}rotate(t){const e=Math.cos(t),n=Math.sin(t),r=this.elements,i=r[0],s=r[3],a=r[6],o=r[1],l=r[4],c=r[7];return r[0]=e*i+n*o,r[3]=e*s+n*l,r[6]=e*a+n*c,r[1]=-n*i+e*o,r[4]=-n*s+e*l,r[7]=-n*a+e*c,this}translate(t,e){const n=this.elements;return n[0]+=t*n[2],n[3]+=t*n[5],n[6]+=t*n[8],n[1]+=e*n[2],n[4]+=e*n[5],n[7]+=e*n[8],this}equals(t){const e=this.elements,n=t.elements;for(let t=0;t<9;t++)if(e[t]!==n[t])return!1;return!0}fromArray(t,e=0){for(let n=0;n<9;n++)this.elements[n]=t[n+e];return this}toArray(t=[],e=0){const n=this.elements;return t[e]=n[0],t[e+1]=n[1],t[e+2]=n[2],t[e+3]=n[3],t[e+4]=n[4],t[e+5]=n[5],t[e+6]=n[6],t[e+7]=n[7],t[e+8]=n[8],t}clone(){return(new this.constructor).fromArray(this.elements)}}function qn(t){if(0===t.length)return-1/0;let e=t[0];for(let n=1,r=t.length;n<r;++n)t[n]>e&&(e=t[n]);return e}Yn.prototype.isMatrix3=!0;const Qn={Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array};function Zn(t,e){return new Qn[t](e)}function Jn(t){return document.createElementNS("http://www.w3.org/1999/xhtml",t)}let Kn;class $n{static getDataURL(t){if(/^data:/i.test(t.src))return t.src;if("undefined"==typeof HTMLCanvasElement)return t.src;let e;if(t instanceof HTMLCanvasElement)e=t;else{void 0===Kn&&(Kn=Jn("canvas")),Kn.width=t.width,Kn.height=t.height;const n=Kn.getContext("2d");t instanceof ImageData?n.putImageData(t,0,0):n.drawImage(t,0,0,t.width,t.height),e=Kn}return e.width>2048||e.height>2048?(console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons",t),e.toDataURL("image/jpeg",.6)):e.toDataURL("image/png")}}let tr=0;class er extends Dn{constructor(t=er.DEFAULT_IMAGE,e=er.DEFAULT_MAPPING,n=gt,r=gt,i=Mt,s=At,a=Gt,o=Ct,l=1,c=$e){super(),Object.defineProperty(this,"id",{value:tr++}),this.uuid=Bn(),this.name="",this.image=t,this.mipmaps=[],this.mapping=e,this.wrapS=n,this.wrapT=r,this.magFilter=i,this.minFilter=s,this.anisotropy=l,this.format=a,this.internalFormat=null,this.type=o,this.offset=new jn(0,0),this.repeat=new jn(1,1),this.center=new jn(0,0),this.rotation=0,this.matrixAutoUpdate=!0,this.matrix=new Yn,this.generateMipmaps=!0,this.premultiplyAlpha=!1,this.flipY=!0,this.unpackAlignment=4,this.encoding=c,this.userData={},this.version=0,this.onUpdate=null,this.isRenderTargetTexture=!1}updateMatrix(){this.matrix.setUvTransform(this.offset.x,this.offset.y,this.repeat.x,this.repeat.y,this.rotation,this.center.x,this.center.y)}clone(){return(new this.constructor).copy(this)}copy(t){return this.name=t.name,this.image=t.image,this.mipmaps=t.mipmaps.slice(0),this.mapping=t.mapping,this.wrapS=t.wrapS,this.wrapT=t.wrapT,this.magFilter=t.magFilter,this.minFilter=t.minFilter,this.anisotropy=t.anisotropy,this.format=t.format,this.internalFormat=t.internalFormat,this.type=t.type,this.offset.copy(t.offset),this.repeat.copy(t.repeat),this.center.copy(t.center),this.rotation=t.rotation,this.matrixAutoUpdate=t.matrixAutoUpdate,this.matrix.copy(t.matrix),this.generateMipmaps=t.generateMipmaps,this.premultiplyAlpha=t.premultiplyAlpha,this.flipY=t.flipY,this.unpackAlignment=t.unpackAlignment,this.encoding=t.encoding,this.userData=JSON.parse(JSON.stringify(t.userData)),this}toJSON(t){const e=void 0===t||"string"==typeof t;if(!e&&void 0!==t.textures[this.uuid])return t.textures[this.uuid];const n={metadata:{version:4.5,type:"Texture",generator:"Texture.toJSON"},uuid:this.uuid,name:this.name,mapping:this.mapping,repeat:[this.repeat.x,this.repeat.y],offset:[this.offset.x,this.offset.y],center:[this.center.x,this.center.y],rotation:this.rotation,wrap:[this.wrapS,this.wrapT],format:this.format,type:this.type,encoding:this.encoding,minFilter:this.minFilter,magFilter:this.magFilter,anisotropy:this.anisotropy,flipY:this.flipY,premultiplyAlpha:this.premultiplyAlpha,unpackAlignment:this.unpackAlignment};if(void 0!==this.image){const r=this.image;if(void 0===r.uuid&&(r.uuid=Bn()),!e&&void 0===t.images[r.uuid]){let e;if(Array.isArray(r)){e=[];for(let t=0,n=r.length;t<n;t++)r[t].isDataTexture?e.push(nr(r[t].image)):e.push(nr(r[t]))}else e=nr(r);t.images[r.uuid]={uuid:r.uuid,url:e}}n.image=r.uuid}return"{}"!==JSON.stringify(this.userData)&&(n.userData=this.userData),e||(t.textures[this.uuid]=n),n}dispose(){this.dispatchEvent({type:"dispose"})}transformUv(t){if(this.mapping!==lt)return t;if(t.applyMatrix3(this.matrix),t.x<0||t.x>1)switch(this.wrapS){case mt:t.x=t.x-Math.floor(t.x);break;case gt:t.x=t.x<0?0:1;break;case vt:1===Math.abs(Math.floor(t.x)%2)?t.x=Math.ceil(t.x)-t.x:t.x=t.x-Math.floor(t.x)}if(t.y<0||t.y>1)switch(this.wrapT){case mt:t.y=t.y-Math.floor(t.y);break;case gt:t.y=t.y<0?0:1;break;case vt:1===Math.abs(Math.floor(t.y)%2)?t.y=Math.ceil(t.y)-t.y:t.y=t.y-Math.floor(t.y)}return this.flipY&&(t.y=1-t.y),t}set needsUpdate(t){!0===t&&this.version++}}function nr(t){return"undefined"!=typeof HTMLImageElement&&t instanceof HTMLImageElement||"undefined"!=typeof HTMLCanvasElement&&t instanceof HTMLCanvasElement||"undefined"!=typeof ImageBitmap&&t instanceof ImageBitmap?$n.getDataURL(t):t.data?{data:Array.prototype.slice.call(t.data),width:t.width,height:t.height,type:t.data.constructor.name}:(console.warn("THREE.Texture: Unable to serialize Texture."),{})}er.DEFAULT_IMAGE=void 0,er.DEFAULT_MAPPING=lt,er.prototype.isTexture=!0;class rr{constructor(t=0,e=0,n=0,r=1){this.x=t,this.y=e,this.z=n,this.w=r}get width(){return this.z}set width(t){this.z=t}get height(){return this.w}set height(t){this.w=t}set(t,e,n,r){return this.x=t,this.y=e,this.z=n,this.w=r,this}setScalar(t){return this.x=t,this.y=t,this.z=t,this.w=t,this}setX(t){return this.x=t,this}setY(t){return this.y=t,this}setZ(t){return this.z=t,this}setW(t){return this.w=t,this}setComponent(t,e){switch(t){case 0:this.x=e;break;case 1:this.y=e;break;case 2:this.z=e;break;case 3:this.w=e;break;default:throw new Error("index is out of range: "+t)}return this}getComponent(t){switch(t){case 0:return this.x;case 1:return this.y;case 2:return this.z;case 3:return this.w;default:throw new Error("index is out of range: "+t)}}clone(){return new this.constructor(this.x,this.y,this.z,this.w)}copy(t){return this.x=t.x,this.y=t.y,this.z=t.z,this.w=void 0!==t.w?t.w:1,this}add(t,e){return void 0!==e?(console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),this.addVectors(t,e)):(this.x+=t.x,this.y+=t.y,this.z+=t.z,this.w+=t.w,this)}addScalar(t){return this.x+=t,this.y+=t,this.z+=t,this.w+=t,this}addVectors(t,e){return this.x=t.x+e.x,this.y=t.y+e.y,this.z=t.z+e.z,this.w=t.w+e.w,this}addScaledVector(t,e){return this.x+=t.x*e,this.y+=t.y*e,this.z+=t.z*e,this.w+=t.w*e,this}sub(t,e){return void 0!==e?(console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),this.subVectors(t,e)):(this.x-=t.x,this.y-=t.y,this.z-=t.z,this.w-=t.w,this)}subScalar(t){return this.x-=t,this.y-=t,this.z-=t,this.w-=t,this}subVectors(t,e){return this.x=t.x-e.x,this.y=t.y-e.y,this.z=t.z-e.z,this.w=t.w-e.w,this}multiply(t){return this.x*=t.x,this.y*=t.y,this.z*=t.z,this.w*=t.w,this}multiplyScalar(t){return this.x*=t,this.y*=t,this.z*=t,this.w*=t,this}applyMatrix4(t){const e=this.x,n=this.y,r=this.z,i=this.w,s=t.elements;return this.x=s[0]*e+s[4]*n+s[8]*r+s[12]*i,this.y=s[1]*e+s[5]*n+s[9]*r+s[13]*i,this.z=s[2]*e+s[6]*n+s[10]*r+s[14]*i,this.w=s[3]*e+s[7]*n+s[11]*r+s[15]*i,this}divideScalar(t){return this.multiplyScalar(1/t)}setAxisAngleFromQuaternion(t){this.w=2*Math.acos(t.w);const e=Math.sqrt(1-t.w*t.w);return e<1e-4?(this.x=1,this.y=0,this.z=0):(this.x=t.x/e,this.y=t.y/e,this.z=t.z/e),this}setAxisAngleFromRotationMatrix(t){let e,n,r,i;const s=.01,a=.1,o=t.elements,l=o[0],c=o[4],h=o[8],u=o[1],d=o[5],p=o[9],f=o[2],m=o[6],g=o[10];if(Math.abs(c-u)<s&&Math.abs(h-f)<s&&Math.abs(p-m)<s){if(Math.abs(c+u)<a&&Math.abs(h+f)<a&&Math.abs(p+m)<a&&Math.abs(l+d+g-3)<a)return this.set(1,0,0,0),this;e=Math.PI;const t=(l+1)/2,o=(d+1)/2,v=(g+1)/2,x=(c+u)/4,y=(h+f)/4,w=(p+m)/4;return t>o&&t>v?t<s?(n=0,r=.707106781,i=.707106781):(n=Math.sqrt(t),r=x/n,i=y/n):o>v?o<s?(n=.707106781,r=0,i=.707106781):(r=Math.sqrt(o),n=x/r,i=w/r):v<s?(n=.707106781,r=.707106781,i=0):(i=Math.sqrt(v),n=y/i,r=w/i),this.set(n,r,i,e),this}let v=Math.sqrt((m-p)*(m-p)+(h-f)*(h-f)+(u-c)*(u-c));return Math.abs(v)<.001&&(v=1),this.x=(m-p)/v,this.y=(h-f)/v,this.z=(u-c)/v,this.w=Math.acos((l+d+g-1)/2),this}min(t){return this.x=Math.min(this.x,t.x),this.y=Math.min(this.y,t.y),this.z=Math.min(this.z,t.z),this.w=Math.min(this.w,t.w),this}max(t){return this.x=Math.max(this.x,t.x),this.y=Math.max(this.y,t.y),this.z=Math.max(this.z,t.z),this.w=Math.max(this.w,t.w),this}clamp(t,e){return this.x=Math.max(t.x,Math.min(e.x,this.x)),this.y=Math.max(t.y,Math.min(e.y,this.y)),this.z=Math.max(t.z,Math.min(e.z,this.z)),this.w=Math.max(t.w,Math.min(e.w,this.w)),this}clampScalar(t,e){return this.x=Math.max(t,Math.min(e,this.x)),this.y=Math.max(t,Math.min(e,this.y)),this.z=Math.max(t,Math.min(e,this.z)),this.w=Math.max(t,Math.min(e,this.w)),this}clampLength(t,e){const n=this.length();return this.divideScalar(n||1).multiplyScalar(Math.max(t,Math.min(e,n)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this.w=Math.floor(this.w),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this.w=Math.ceil(this.w),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this.w=Math.round(this.w),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this.z=this.z<0?Math.ceil(this.z):Math.floor(this.z),this.w=this.w<0?Math.ceil(this.w):Math.floor(this.w),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this.w=-this.w,this}dot(t){return this.x*t.x+this.y*t.y+this.z*t.z+this.w*t.w}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)+Math.abs(this.w)}normalize(){return this.divideScalar(this.length()||1)}setLength(t){return this.normalize().multiplyScalar(t)}lerp(t,e){return this.x+=(t.x-this.x)*e,this.y+=(t.y-this.y)*e,this.z+=(t.z-this.z)*e,this.w+=(t.w-this.w)*e,this}lerpVectors(t,e,n){return this.x=t.x+(e.x-t.x)*n,this.y=t.y+(e.y-t.y)*n,this.z=t.z+(e.z-t.z)*n,this.w=t.w+(e.w-t.w)*n,this}equals(t){return t.x===this.x&&t.y===this.y&&t.z===this.z&&t.w===this.w}fromArray(t,e=0){return this.x=t[e],this.y=t[e+1],this.z=t[e+2],this.w=t[e+3],this}toArray(t=[],e=0){return t[e]=this.x,t[e+1]=this.y,t[e+2]=this.z,t[e+3]=this.w,t}fromBufferAttribute(t,e,n){return void 0!==n&&console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute()."),this.x=t.getX(e),this.y=t.getY(e),this.z=t.getZ(e),this.w=t.getW(e),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this.w=Math.random(),this}*[Symbol.iterator](){yield this.x,yield this.y,yield this.z,yield this.w}}rr.prototype.isVector4=!0;class ir extends Dn{constructor(t,e,n={}){super(),this.width=t,this.height=e,this.depth=1,this.scissor=new rr(0,0,t,e),this.scissorTest=!1,this.viewport=new rr(0,0,t,e),this.texture=new er(void 0,n.mapping,n.wrapS,n.wrapT,n.magFilter,n.minFilter,n.format,n.type,n.anisotropy,n.encoding),this.texture.isRenderTargetTexture=!0,this.texture.image={width:t,height:e,depth:1},this.texture.generateMipmaps=void 0!==n.generateMipmaps&&n.generateMipmaps,this.texture.internalFormat=void 0!==n.internalFormat?n.internalFormat:null,this.texture.minFilter=void 0!==n.minFilter?n.minFilter:Mt,this.depthBuffer=void 0===n.depthBuffer||n.depthBuffer,this.stencilBuffer=void 0!==n.stencilBuffer&&n.stencilBuffer,this.depthTexture=void 0!==n.depthTexture?n.depthTexture:null}setTexture(t){t.image={width:this.width,height:this.height,depth:this.depth},this.texture=t}setSize(t,e,n=1){this.width===t&&this.height===e&&this.depth===n||(this.width=t,this.height=e,this.depth=n,this.texture.image.width=t,this.texture.image.height=e,this.texture.image.depth=n,this.dispose()),this.viewport.set(0,0,t,e),this.scissor.set(0,0,t,e)}clone(){return(new this.constructor).copy(this)}copy(t){return this.width=t.width,this.height=t.height,this.depth=t.depth,this.viewport.copy(t.viewport),this.texture=t.texture.clone(),this.texture.image={...this.texture.image},this.depthBuffer=t.depthBuffer,this.stencilBuffer=t.stencilBuffer,this.depthTexture=t.depthTexture,this}dispose(){this.dispatchEvent({type:"dispose"})}}ir.prototype.isWebGLRenderTarget=!0;class sr extends ir{constructor(t,e,n){super(t,e);const r=this.texture;this.texture=[];for(let t=0;t<n;t++)this.texture[t]=r.clone()}setSize(t,e,n=1){if(this.width!==t||this.height!==e||this.depth!==n){this.width=t,this.height=e,this.depth=n;for(let r=0,i=this.texture.length;r<i;r++)this.texture[r].image.width=t,this.texture[r].image.height=e,this.texture[r].image.depth=n;this.dispose()}return this.viewport.set(0,0,t,e),this.scissor.set(0,0,t,e),this}copy(t){this.dispose(),this.width=t.width,this.height=t.height,this.depth=t.depth,this.viewport.set(0,0,this.width,this.height),this.scissor.set(0,0,this.width,this.height),this.depthBuffer=t.depthBuffer,this.stencilBuffer=t.stencilBuffer,this.depthTexture=t.depthTexture,this.texture.length=0;for(let e=0,n=t.texture.length;e<n;e++)this.texture[e]=t.texture[e].clone();return this}}sr.prototype.isWebGLMultipleRenderTargets=!0;class ar extends ir{constructor(t,e,n={}){super(t,e,n),this.samples=4,this.ignoreDepthForMultisampleCopy=void 0===n.ignoreDepth||n.ignoreDepth,this.useRenderToTexture=void 0!==n.useRenderToTexture&&n.useRenderToTexture,this.useRenderbuffer=!1===this.useRenderToTexture}copy(t){return super.copy.call(this,t),this.samples=t.samples,this.useRenderToTexture=t.useRenderToTexture,this.useRenderbuffer=t.useRenderbuffer,this}}ar.prototype.isWebGLMultisampleRenderTarget=!0;class or{constructor(t=0,e=0,n=0,r=1){this._x=t,this._y=e,this._z=n,this._w=r}static slerp(t,e,n,r){return console.warn("THREE.Quaternion: Static .slerp() has been deprecated. Use qm.slerpQuaternions( qa, qb, t ) instead."),n.slerpQuaternions(t,e,r)}static slerpFlat(t,e,n,r,i,s,a){let o=n[r+0],l=n[r+1],c=n[r+2],h=n[r+3];const u=i[s+0],d=i[s+1],p=i[s+2],f=i[s+3];if(0===a)return t[e+0]=o,t[e+1]=l,t[e+2]=c,void(t[e+3]=h);if(1===a)return t[e+0]=u,t[e+1]=d,t[e+2]=p,void(t[e+3]=f);if(h!==f||o!==u||l!==d||c!==p){let t=1-a;const e=o*u+l*d+c*p+h*f,n=e>=0?1:-1,r=1-e*e;if(r>Number.EPSILON){const i=Math.sqrt(r),s=Math.atan2(i,e*n);t=Math.sin(t*s)/i,a=Math.sin(a*s)/i}const i=a*n;if(o=o*t+u*i,l=l*t+d*i,c=c*t+p*i,h=h*t+f*i,t===1-a){const t=1/Math.sqrt(o*o+l*l+c*c+h*h);o*=t,l*=t,c*=t,h*=t}}t[e]=o,t[e+1]=l,t[e+2]=c,t[e+3]=h}static multiplyQuaternionsFlat(t,e,n,r,i,s){const a=n[r],o=n[r+1],l=n[r+2],c=n[r+3],h=i[s],u=i[s+1],d=i[s+2],p=i[s+3];return t[e]=a*p+c*h+o*d-l*u,t[e+1]=o*p+c*u+l*h-a*d,t[e+2]=l*p+c*d+a*u-o*h,t[e+3]=c*p-a*h-o*u-l*d,t}get x(){return this._x}set x(t){this._x=t,this._onChangeCallback()}get y(){return this._y}set y(t){this._y=t,this._onChangeCallback()}get z(){return this._z}set z(t){this._z=t,this._onChangeCallback()}get w(){return this._w}set w(t){this._w=t,this._onChangeCallback()}set(t,e,n,r){return this._x=t,this._y=e,this._z=n,this._w=r,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._w)}copy(t){return this._x=t.x,this._y=t.y,this._z=t.z,this._w=t.w,this._onChangeCallback(),this}setFromEuler(t,e){if(!t||!t.isEuler)throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");const n=t._x,r=t._y,i=t._z,s=t._order,a=Math.cos,o=Math.sin,l=a(n/2),c=a(r/2),h=a(i/2),u=o(n/2),d=o(r/2),p=o(i/2);switch(s){case"XYZ":this._x=u*c*h+l*d*p,this._y=l*d*h-u*c*p,this._z=l*c*p+u*d*h,this._w=l*c*h-u*d*p;break;case"YXZ":this._x=u*c*h+l*d*p,this._y=l*d*h-u*c*p,this._z=l*c*p-u*d*h,this._w=l*c*h+u*d*p;break;case"ZXY":this._x=u*c*h-l*d*p,this._y=l*d*h+u*c*p,this._z=l*c*p+u*d*h,this._w=l*c*h-u*d*p;break;case"ZYX":this._x=u*c*h-l*d*p,this._y=l*d*h+u*c*p,this._z=l*c*p-u*d*h,this._w=l*c*h+u*d*p;break;case"YZX":this._x=u*c*h+l*d*p,this._y=l*d*h+u*c*p,this._z=l*c*p-u*d*h,this._w=l*c*h-u*d*p;break;case"XZY":this._x=u*c*h-l*d*p,this._y=l*d*h-u*c*p,this._z=l*c*p+u*d*h,this._w=l*c*h+u*d*p;break;default:console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: "+s)}return!1!==e&&this._onChangeCallback(),this}setFromAxisAngle(t,e){const n=e/2,r=Math.sin(n);return this._x=t.x*r,this._y=t.y*r,this._z=t.z*r,this._w=Math.cos(n),this._onChangeCallback(),this}setFromRotationMatrix(t){const e=t.elements,n=e[0],r=e[4],i=e[8],s=e[1],a=e[5],o=e[9],l=e[2],c=e[6],h=e[10],u=n+a+h;if(u>0){const t=.5/Math.sqrt(u+1);this._w=.25/t,this._x=(c-o)*t,this._y=(i-l)*t,this._z=(s-r)*t}else if(n>a&&n>h){const t=2*Math.sqrt(1+n-a-h);this._w=(c-o)/t,this._x=.25*t,this._y=(r+s)/t,this._z=(i+l)/t}else if(a>h){const t=2*Math.sqrt(1+a-n-h);this._w=(i-l)/t,this._x=(r+s)/t,this._y=.25*t,this._z=(o+c)/t}else{const t=2*Math.sqrt(1+h-n-a);this._w=(s-r)/t,this._x=(i+l)/t,this._y=(o+c)/t,this._z=.25*t}return this._onChangeCallback(),this}setFromUnitVectors(t,e){let n=t.dot(e)+1;return n<Number.EPSILON?(n=0,Math.abs(t.x)>Math.abs(t.z)?(this._x=-t.y,this._y=t.x,this._z=0,this._w=n):(this._x=0,this._y=-t.z,this._z=t.y,this._w=n)):(this._x=t.y*e.z-t.z*e.y,this._y=t.z*e.x-t.x*e.z,this._z=t.x*e.y-t.y*e.x,this._w=n),this.normalize()}angleTo(t){return 2*Math.acos(Math.abs(zn(this.dot(t),-1,1)))}rotateTowards(t,e){const n=this.angleTo(t);if(0===n)return this;const r=Math.min(1,e/n);return this.slerp(t,r),this}identity(){return this.set(0,0,0,1)}invert(){return this.conjugate()}conjugate(){return this._x*=-1,this._y*=-1,this._z*=-1,this._onChangeCallback(),this}dot(t){return this._x*t._x+this._y*t._y+this._z*t._z+this._w*t._w}lengthSq(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)}normalize(){let t=this.length();return 0===t?(this._x=0,this._y=0,this._z=0,this._w=1):(t=1/t,this._x=this._x*t,this._y=this._y*t,this._z=this._z*t,this._w=this._w*t),this._onChangeCallback(),this}multiply(t,e){return void 0!==e?(console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."),this.multiplyQuaternions(t,e)):this.multiplyQuaternions(this,t)}premultiply(t){return this.multiplyQuaternions(t,this)}multiplyQuaternions(t,e){const n=t._x,r=t._y,i=t._z,s=t._w,a=e._x,o=e._y,l=e._z,c=e._w;return this._x=n*c+s*a+r*l-i*o,this._y=r*c+s*o+i*a-n*l,this._z=i*c+s*l+n*o-r*a,this._w=s*c-n*a-r*o-i*l,this._onChangeCallback(),this}slerp(t,e){if(0===e)return this;if(1===e)return this.copy(t);const n=this._x,r=this._y,i=this._z,s=this._w;let a=s*t._w+n*t._x+r*t._y+i*t._z;if(a<0?(this._w=-t._w,this._x=-t._x,this._y=-t._y,this._z=-t._z,a=-a):this.copy(t),a>=1)return this._w=s,this._x=n,this._y=r,this._z=i,this;const o=1-a*a;if(o<=Number.EPSILON){const t=1-e;return this._w=t*s+e*this._w,this._x=t*n+e*this._x,this._y=t*r+e*this._y,this._z=t*i+e*this._z,this.normalize(),this._onChangeCallback(),this}const l=Math.sqrt(o),c=Math.atan2(l,a),h=Math.sin((1-e)*c)/l,u=Math.sin(e*c)/l;return this._w=s*h+this._w*u,this._x=n*h+this._x*u,this._y=r*h+this._y*u,this._z=i*h+this._z*u,this._onChangeCallback(),this}slerpQuaternions(t,e,n){this.copy(t).slerp(e,n)}random(){const t=Math.random(),e=Math.sqrt(1-t),n=Math.sqrt(t),r=2*Math.PI*Math.random(),i=2*Math.PI*Math.random();return this.set(e*Math.cos(r),n*Math.sin(i),n*Math.cos(i),e*Math.sin(r))}equals(t){return t._x===this._x&&t._y===this._y&&t._z===this._z&&t._w===this._w}fromArray(t,e=0){return this._x=t[e],this._y=t[e+1],this._z=t[e+2],this._w=t[e+3],this._onChangeCallback(),this}toArray(t=[],e=0){return t[e]=this._x,t[e+1]=this._y,t[e+2]=this._z,t[e+3]=this._w,t}fromBufferAttribute(t,e){return this._x=t.getX(e),this._y=t.getY(e),this._z=t.getZ(e),this._w=t.getW(e),this}_onChange(t){return this._onChangeCallback=t,this}_onChangeCallback(){}}or.prototype.isQuaternion=!0;class lr{constructor(t=0,e=0,n=0){this.x=t,this.y=e,this.z=n}set(t,e,n){return void 0===n&&(n=this.z),this.x=t,this.y=e,this.z=n,this}setScalar(t){return this.x=t,this.y=t,this.z=t,this}setX(t){return this.x=t,this}setY(t){return this.y=t,this}setZ(t){return this.z=t,this}setComponent(t,e){switch(t){case 0:this.x=e;break;case 1:this.y=e;break;case 2:this.z=e;break;default:throw new Error("index is out of range: "+t)}return this}getComponent(t){switch(t){case 0:return this.x;case 1:return this.y;case 2:return this.z;default:throw new Error("index is out of range: "+t)}}clone(){return new this.constructor(this.x,this.y,this.z)}copy(t){return this.x=t.x,this.y=t.y,this.z=t.z,this}add(t,e){return void 0!==e?(console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),this.addVectors(t,e)):(this.x+=t.x,this.y+=t.y,this.z+=t.z,this)}addScalar(t){return this.x+=t,this.y+=t,this.z+=t,this}addVectors(t,e){return this.x=t.x+e.x,this.y=t.y+e.y,this.z=t.z+e.z,this}addScaledVector(t,e){return this.x+=t.x*e,this.y+=t.y*e,this.z+=t.z*e,this}sub(t,e){return void 0!==e?(console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),this.subVectors(t,e)):(this.x-=t.x,this.y-=t.y,this.z-=t.z,this)}subScalar(t){return this.x-=t,this.y-=t,this.z-=t,this}subVectors(t,e){return this.x=t.x-e.x,this.y=t.y-e.y,this.z=t.z-e.z,this}multiply(t,e){return void 0!==e?(console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."),this.multiplyVectors(t,e)):(this.x*=t.x,this.y*=t.y,this.z*=t.z,this)}multiplyScalar(t){return this.x*=t,this.y*=t,this.z*=t,this}multiplyVectors(t,e){return this.x=t.x*e.x,this.y=t.y*e.y,this.z=t.z*e.z,this}applyEuler(t){return t&&t.isEuler||console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."),this.applyQuaternion(hr.setFromEuler(t))}applyAxisAngle(t,e){return this.applyQuaternion(hr.setFromAxisAngle(t,e))}applyMatrix3(t){const e=this.x,n=this.y,r=this.z,i=t.elements;return this.x=i[0]*e+i[3]*n+i[6]*r,this.y=i[1]*e+i[4]*n+i[7]*r,this.z=i[2]*e+i[5]*n+i[8]*r,this}applyNormalMatrix(t){return this.applyMatrix3(t).normalize()}applyMatrix4(t){const e=this.x,n=this.y,r=this.z,i=t.elements,s=1/(i[3]*e+i[7]*n+i[11]*r+i[15]);return this.x=(i[0]*e+i[4]*n+i[8]*r+i[12])*s,this.y=(i[1]*e+i[5]*n+i[9]*r+i[13])*s,this.z=(i[2]*e+i[6]*n+i[10]*r+i[14])*s,this}applyQuaternion(t){const e=this.x,n=this.y,r=this.z,i=t.x,s=t.y,a=t.z,o=t.w,l=o*e+s*r-a*n,c=o*n+a*e-i*r,h=o*r+i*n-s*e,u=-i*e-s*n-a*r;return this.x=l*o+u*-i+c*-a-h*-s,this.y=c*o+u*-s+h*-i-l*-a,this.z=h*o+u*-a+l*-s-c*-i,this}project(t){return this.applyMatrix4(t.matrixWorldInverse).applyMatrix4(t.projectionMatrix)}unproject(t){return this.applyMatrix4(t.projectionMatrixInverse).applyMatrix4(t.matrixWorld)}transformDirection(t){const e=this.x,n=this.y,r=this.z,i=t.elements;return this.x=i[0]*e+i[4]*n+i[8]*r,this.y=i[1]*e+i[5]*n+i[9]*r,this.z=i[2]*e+i[6]*n+i[10]*r,this.normalize()}divide(t){return this.x/=t.x,this.y/=t.y,this.z/=t.z,this}divideScalar(t){return this.multiplyScalar(1/t)}min(t){return this.x=Math.min(this.x,t.x),this.y=Math.min(this.y,t.y),this.z=Math.min(this.z,t.z),this}max(t){return this.x=Math.max(this.x,t.x),this.y=Math.max(this.y,t.y),this.z=Math.max(this.z,t.z),this}clamp(t,e){return this.x=Math.max(t.x,Math.min(e.x,this.x)),this.y=Math.max(t.y,Math.min(e.y,this.y)),this.z=Math.max(t.z,Math.min(e.z,this.z)),this}clampScalar(t,e){return this.x=Math.max(t,Math.min(e,this.x)),this.y=Math.max(t,Math.min(e,this.y)),this.z=Math.max(t,Math.min(e,this.z)),this}clampLength(t,e){const n=this.length();return this.divideScalar(n||1).multiplyScalar(Math.max(t,Math.min(e,n)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this.z=this.z<0?Math.ceil(this.z):Math.floor(this.z),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this}dot(t){return this.x*t.x+this.y*t.y+this.z*t.z}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)}normalize(){return this.divideScalar(this.length()||1)}setLength(t){return this.normalize().multiplyScalar(t)}lerp(t,e){return this.x+=(t.x-this.x)*e,this.y+=(t.y-this.y)*e,this.z+=(t.z-this.z)*e,this}lerpVectors(t,e,n){return this.x=t.x+(e.x-t.x)*n,this.y=t.y+(e.y-t.y)*n,this.z=t.z+(e.z-t.z)*n,this}cross(t,e){return void 0!==e?(console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."),this.crossVectors(t,e)):this.crossVectors(this,t)}crossVectors(t,e){const n=t.x,r=t.y,i=t.z,s=e.x,a=e.y,o=e.z;return this.x=r*o-i*a,this.y=i*s-n*o,this.z=n*a-r*s,this}projectOnVector(t){const e=t.lengthSq();if(0===e)return this.set(0,0,0);const n=t.dot(this)/e;return this.copy(t).multiplyScalar(n)}projectOnPlane(t){return cr.copy(this).projectOnVector(t),this.sub(cr)}reflect(t){return this.sub(cr.copy(t).multiplyScalar(2*this.dot(t)))}angleTo(t){const e=Math.sqrt(this.lengthSq()*t.lengthSq());if(0===e)return Math.PI/2;const n=this.dot(t)/e;return Math.acos(zn(n,-1,1))}distanceTo(t){return Math.sqrt(this.distanceToSquared(t))}distanceToSquared(t){const e=this.x-t.x,n=this.y-t.y,r=this.z-t.z;return e*e+n*n+r*r}manhattanDistanceTo(t){return Math.abs(this.x-t.x)+Math.abs(this.y-t.y)+Math.abs(this.z-t.z)}setFromSpherical(t){return this.setFromSphericalCoords(t.radius,t.phi,t.theta)}setFromSphericalCoords(t,e,n){const r=Math.sin(e)*t;return this.x=r*Math.sin(n),this.y=Math.cos(e)*t,this.z=r*Math.cos(n),this}setFromCylindrical(t){return this.setFromCylindricalCoords(t.radius,t.theta,t.y)}setFromCylindricalCoords(t,e,n){return this.x=t*Math.sin(e),this.y=n,this.z=t*Math.cos(e),this}setFromMatrixPosition(t){const e=t.elements;return this.x=e[12],this.y=e[13],this.z=e[14],this}setFromMatrixScale(t){const e=this.setFromMatrixColumn(t,0).length(),n=this.setFromMatrixColumn(t,1).length(),r=this.setFromMatrixColumn(t,2).length();return this.x=e,this.y=n,this.z=r,this}setFromMatrixColumn(t,e){return this.fromArray(t.elements,4*e)}setFromMatrix3Column(t,e){return this.fromArray(t.elements,3*e)}equals(t){return t.x===this.x&&t.y===this.y&&t.z===this.z}fromArray(t,e=0){return this.x=t[e],this.y=t[e+1],this.z=t[e+2],this}toArray(t=[],e=0){return t[e]=this.x,t[e+1]=this.y,t[e+2]=this.z,t}fromBufferAttribute(t,e,n){return void 0!==n&&console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute()."),this.x=t.getX(e),this.y=t.getY(e),this.z=t.getZ(e),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this}randomDirection(){const t=2*(Math.random()-.5),e=Math.random()*Math.PI*2,n=Math.sqrt(1-t**2);return this.x=n*Math.cos(e),this.y=n*Math.sin(e),this.z=t,this}*[Symbol.iterator](){yield this.x,yield this.y,yield this.z}}lr.prototype.isVector3=!0;const cr=new lr,hr=new or;class ur{constructor(t=new lr(1/0,1/0,1/0),e=new lr(-1/0,-1/0,-1/0)){this.min=t,this.max=e}set(t,e){return this.min.copy(t),this.max.copy(e),this}setFromArray(t){let e=1/0,n=1/0,r=1/0,i=-1/0,s=-1/0,a=-1/0;for(let o=0,l=t.length;o<l;o+=3){const l=t[o],c=t[o+1],h=t[o+2];l<e&&(e=l),c<n&&(n=c),h<r&&(r=h),l>i&&(i=l),c>s&&(s=c),h>a&&(a=h)}return this.min.set(e,n,r),this.max.set(i,s,a),this}setFromBufferAttribute(t){let e=1/0,n=1/0,r=1/0,i=-1/0,s=-1/0,a=-1/0;for(let o=0,l=t.count;o<l;o++){const l=t.getX(o),c=t.getY(o),h=t.getZ(o);l<e&&(e=l),c<n&&(n=c),h<r&&(r=h),l>i&&(i=l),c>s&&(s=c),h>a&&(a=h)}return this.min.set(e,n,r),this.max.set(i,s,a),this}setFromPoints(t){this.makeEmpty();for(let e=0,n=t.length;e<n;e++)this.expandByPoint(t[e]);return this}setFromCenterAndSize(t,e){const n=pr.copy(e).multiplyScalar(.5);return this.min.copy(t).sub(n),this.max.copy(t).add(n),this}setFromObject(t){return this.makeEmpty(),this.expandByObject(t)}clone(){return(new this.constructor).copy(this)}copy(t){return this.min.copy(t.min),this.max.copy(t.max),this}makeEmpty(){return this.min.x=this.min.y=this.min.z=1/0,this.max.x=this.max.y=this.max.z=-1/0,this}isEmpty(){return this.max.x<this.min.x||this.max.y<this.min.y||this.max.z<this.min.z}getCenter(t){return this.isEmpty()?t.set(0,0,0):t.addVectors(this.min,this.max).multiplyScalar(.5)}getSize(t){return this.isEmpty()?t.set(0,0,0):t.subVectors(this.max,this.min)}expandByPoint(t){return this.min.min(t),this.max.max(t),this}expandByVector(t){return this.min.sub(t),this.max.add(t),this}expandByScalar(t){return this.min.addScalar(-t),this.max.addScalar(t),this}expandByObject(t){t.updateWorldMatrix(!1,!1);const e=t.geometry;void 0!==e&&(null===e.boundingBox&&e.computeBoundingBox(),fr.copy(e.boundingBox),fr.applyMatrix4(t.matrixWorld),this.union(fr));const n=t.children;for(let t=0,e=n.length;t<e;t++)this.expandByObject(n[t]);return this}containsPoint(t){return!(t.x<this.min.x||t.x>this.max.x||t.y<this.min.y||t.y>this.max.y||t.z<this.min.z||t.z>this.max.z)}containsBox(t){return this.min.x<=t.min.x&&t.max.x<=this.max.x&&this.min.y<=t.min.y&&t.max.y<=this.max.y&&this.min.z<=t.min.z&&t.max.z<=this.max.z}getParameter(t,e){return e.set((t.x-this.min.x)/(this.max.x-this.min.x),(t.y-this.min.y)/(this.max.y-this.min.y),(t.z-this.min.z)/(this.max.z-this.min.z))}intersectsBox(t){return!(t.max.x<this.min.x||t.min.x>this.max.x||t.max.y<this.min.y||t.min.y>this.max.y||t.max.z<this.min.z||t.min.z>this.max.z)}intersectsSphere(t){return this.clampPoint(t.center,pr),pr.distanceToSquared(t.center)<=t.radius*t.radius}intersectsPlane(t){let e,n;return t.normal.x>0?(e=t.normal.x*this.min.x,n=t.normal.x*this.max.x):(e=t.normal.x*this.max.x,n=t.normal.x*this.min.x),t.normal.y>0?(e+=t.normal.y*this.min.y,n+=t.normal.y*this.max.y):(e+=t.normal.y*this.max.y,n+=t.normal.y*this.min.y),t.normal.z>0?(e+=t.normal.z*this.min.z,n+=t.normal.z*this.max.z):(e+=t.normal.z*this.max.z,n+=t.normal.z*this.min.z),e<=-t.constant&&n>=-t.constant}intersectsTriangle(t){if(this.isEmpty())return!1;this.getCenter(br),_r.subVectors(this.max,br),mr.subVectors(t.a,br),gr.subVectors(t.b,br),vr.subVectors(t.c,br),xr.subVectors(gr,mr),yr.subVectors(vr,gr),wr.subVectors(mr,vr);let e=[0,-xr.z,xr.y,0,-yr.z,yr.y,0,-wr.z,wr.y,xr.z,0,-xr.x,yr.z,0,-yr.x,wr.z,0,-wr.x,-xr.y,xr.x,0,-yr.y,yr.x,0,-wr.y,wr.x,0];return!!Sr(e,mr,gr,vr,_r)&&(e=[1,0,0,0,1,0,0,0,1],!!Sr(e,mr,gr,vr,_r)&&(Mr.crossVectors(xr,yr),e=[Mr.x,Mr.y,Mr.z],Sr(e,mr,gr,vr,_r)))}clampPoint(t,e){return e.copy(t).clamp(this.min,this.max)}distanceToPoint(t){return pr.copy(t).clamp(this.min,this.max).sub(t).length()}getBoundingSphere(t){return this.getCenter(t.center),t.radius=.5*this.getSize(pr).length(),t}intersect(t){return this.min.max(t.min),this.max.min(t.max),this.isEmpty()&&this.makeEmpty(),this}union(t){return this.min.min(t.min),this.max.max(t.max),this}applyMatrix4(t){return this.isEmpty()||(dr[0].set(this.min.x,this.min.y,this.min.z).applyMatrix4(t),dr[1].set(this.min.x,this.min.y,this.max.z).applyMatrix4(t),dr[2].set(this.min.x,this.max.y,this.min.z).applyMatrix4(t),dr[3].set(this.min.x,this.max.y,this.max.z).applyMatrix4(t),dr[4].set(this.max.x,this.min.y,this.min.z).applyMatrix4(t),dr[5].set(this.max.x,this.min.y,this.max.z).applyMatrix4(t),dr[6].set(this.max.x,this.max.y,this.min.z).applyMatrix4(t),dr[7].set(this.max.x,this.max.y,this.max.z).applyMatrix4(t),this.setFromPoints(dr)),this}translate(t){return this.min.add(t),this.max.add(t),this}equals(t){return t.min.equals(this.min)&&t.max.equals(this.max)}}ur.prototype.isBox3=!0;const dr=[new lr,new lr,new lr,new lr,new lr,new lr,new lr,new lr],pr=new lr,fr=new ur,mr=new lr,gr=new lr,vr=new lr,xr=new lr,yr=new lr,wr=new lr,br=new lr,_r=new lr,Mr=new lr,Tr=new lr;function Sr(t,e,n,r,i){for(let s=0,a=t.length-3;s<=a;s+=3){Tr.fromArray(t,s);const a=i.x*Math.abs(Tr.x)+i.y*Math.abs(Tr.y)+i.z*Math.abs(Tr.z),o=e.dot(Tr),l=n.dot(Tr),c=r.dot(Tr);if(Math.max(-Math.max(o,l,c),Math.min(o,l,c))>a)return!1}return!0}const Ar=new ur,Er=new lr,Cr=new lr,Pr=new lr;class Lr{constructor(t=new lr,e=-1){this.center=t,this.radius=e}set(t,e){return this.center.copy(t),this.radius=e,this}setFromPoints(t,e){const n=this.center;void 0!==e?n.copy(e):Ar.setFromPoints(t).getCenter(n);let r=0;for(let e=0,i=t.length;e<i;e++)r=Math.max(r,n.distanceToSquared(t[e]));return this.radius=Math.sqrt(r),this}copy(t){return this.center.copy(t.center),this.radius=t.radius,this}isEmpty(){return this.radius<0}makeEmpty(){return this.center.set(0,0,0),this.radius=-1,this}containsPoint(t){return t.distanceToSquared(this.center)<=this.radius*this.radius}distanceToPoint(t){return t.distanceTo(this.center)-this.radius}intersectsSphere(t){const e=this.radius+t.radius;return t.center.distanceToSquared(this.center)<=e*e}intersectsBox(t){return t.intersectsSphere(this)}intersectsPlane(t){return Math.abs(t.distanceToPoint(this.center))<=this.radius}clampPoint(t,e){const n=this.center.distanceToSquared(t);return e.copy(t),n>this.radius*this.radius&&(e.sub(this.center).normalize(),e.multiplyScalar(this.radius).add(this.center)),e}getBoundingBox(t){return this.isEmpty()?(t.makeEmpty(),t):(t.set(this.center,this.center),t.expandByScalar(this.radius),t)}applyMatrix4(t){return this.center.applyMatrix4(t),this.radius=this.radius*t.getMaxScaleOnAxis(),this}translate(t){return this.center.add(t),this}expandByPoint(t){Pr.subVectors(t,this.center);const e=Pr.lengthSq();if(e>this.radius*this.radius){const t=Math.sqrt(e),n=.5*(t-this.radius);this.center.add(Pr.multiplyScalar(n/t)),this.radius+=n}return this}union(t){return!0===this.center.equals(t.center)?Cr.set(0,0,1).multiplyScalar(t.radius):Cr.subVectors(t.center,this.center).normalize().multiplyScalar(t.radius),this.expandByPoint(Er.copy(t.center).add(Cr)),this.expandByPoint(Er.copy(t.center).sub(Cr)),this}equals(t){return t.center.equals(this.center)&&t.radius===this.radius}clone(){return(new this.constructor).copy(this)}}const Rr=new lr,Fr=new lr,Dr=new lr,Ir=new lr,Ur=new lr,Nr=new lr,Or=new lr;class Br{constructor(t=new lr,e=new lr(0,0,-1)){this.origin=t,this.direction=e}set(t,e){return this.origin.copy(t),this.direction.copy(e),this}copy(t){return this.origin.copy(t.origin),this.direction.copy(t.direction),this}at(t,e){return e.copy(this.direction).multiplyScalar(t).add(this.origin)}lookAt(t){return this.direction.copy(t).sub(this.origin).normalize(),this}recast(t){return this.origin.copy(this.at(t,Rr)),this}closestPointToPoint(t,e){e.subVectors(t,this.origin);const n=e.dot(this.direction);return n<0?e.copy(this.origin):e.copy(this.direction).multiplyScalar(n).add(this.origin)}distanceToPoint(t){return Math.sqrt(this.distanceSqToPoint(t))}distanceSqToPoint(t){const e=Rr.subVectors(t,this.origin).dot(this.direction);return e<0?this.origin.distanceToSquared(t):(Rr.copy(this.direction).multiplyScalar(e).add(this.origin),Rr.distanceToSquared(t))}distanceSqToSegment(t,e,n,r){Fr.copy(t).add(e).multiplyScalar(.5),Dr.copy(e).sub(t).normalize(),Ir.copy(this.origin).sub(Fr);const i=.5*t.distanceTo(e),s=-this.direction.dot(Dr),a=Ir.dot(this.direction),o=-Ir.dot(Dr),l=Ir.lengthSq(),c=Math.abs(1-s*s);let h,u,d,p;if(c>0)if(h=s*o-a,u=s*a-o,p=i*c,h>=0)if(u>=-p)if(u<=p){const t=1/c;h*=t,u*=t,d=h*(h+s*u+2*a)+u*(s*h+u+2*o)+l}else u=i,h=Math.max(0,-(s*u+a)),d=-h*h+u*(u+2*o)+l;else u=-i,h=Math.max(0,-(s*u+a)),d=-h*h+u*(u+2*o)+l;else u<=-p?(h=Math.max(0,-(-s*i+a)),u=h>0?-i:Math.min(Math.max(-i,-o),i),d=-h*h+u*(u+2*o)+l):u<=p?(h=0,u=Math.min(Math.max(-i,-o),i),d=u*(u+2*o)+l):(h=Math.max(0,-(s*i+a)),u=h>0?i:Math.min(Math.max(-i,-o),i),d=-h*h+u*(u+2*o)+l);else u=s>0?-i:i,h=Math.max(0,-(s*u+a)),d=-h*h+u*(u+2*o)+l;return n&&n.copy(this.direction).multiplyScalar(h).add(this.origin),r&&r.copy(Dr).multiplyScalar(u).add(Fr),d}intersectSphere(t,e){Rr.subVectors(t.center,this.origin);const n=Rr.dot(this.direction),r=Rr.dot(Rr)-n*n,i=t.radius*t.radius;if(r>i)return null;const s=Math.sqrt(i-r),a=n-s,o=n+s;return a<0&&o<0?null:a<0?this.at(o,e):this.at(a,e)}intersectsSphere(t){return this.distanceSqToPoint(t.center)<=t.radius*t.radius}distanceToPlane(t){const e=t.normal.dot(this.direction);if(0===e)return 0===t.distanceToPoint(this.origin)?0:null;const n=-(this.origin.dot(t.normal)+t.constant)/e;return n>=0?n:null}intersectPlane(t,e){const n=this.distanceToPlane(t);return null===n?null:this.at(n,e)}intersectsPlane(t){const e=t.distanceToPoint(this.origin);return 0===e||t.normal.dot(this.direction)*e<0}intersectBox(t,e){let n,r,i,s,a,o;const l=1/this.direction.x,c=1/this.direction.y,h=1/this.direction.z,u=this.origin;return l>=0?(n=(t.min.x-u.x)*l,r=(t.max.x-u.x)*l):(n=(t.max.x-u.x)*l,r=(t.min.x-u.x)*l),c>=0?(i=(t.min.y-u.y)*c,s=(t.max.y-u.y)*c):(i=(t.max.y-u.y)*c,s=(t.min.y-u.y)*c),n>s||i>r?null:((i>n||n!=n)&&(n=i),(s<r||r!=r)&&(r=s),h>=0?(a=(t.min.z-u.z)*h,o=(t.max.z-u.z)*h):(a=(t.max.z-u.z)*h,o=(t.min.z-u.z)*h),n>o||a>r?null:((a>n||n!=n)&&(n=a),(o<r||r!=r)&&(r=o),r<0?null:this.at(n>=0?n:r,e)))}intersectsBox(t){return null!==this.intersectBox(t,Rr)}intersectTriangle(t,e,n,r,i){Ur.subVectors(e,t),Nr.subVectors(n,t),Or.crossVectors(Ur,Nr);let s,a=this.direction.dot(Or);if(a>0){if(r)return null;s=1}else{if(!(a<0))return null;s=-1,a=-a}Ir.subVectors(this.origin,t);const o=s*this.direction.dot(Nr.crossVectors(Ir,Nr));if(o<0)return null;const l=s*this.direction.dot(Ur.cross(Ir));if(l<0)return null;if(o+l>a)return null;const c=-s*Ir.dot(Or);return c<0?null:this.at(c/a,i)}applyMatrix4(t){return this.origin.applyMatrix4(t),this.direction.transformDirection(t),this}equals(t){return t.origin.equals(this.origin)&&t.direction.equals(this.direction)}clone(){return(new this.constructor).copy(this)}}class zr{constructor(){this.elements=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],arguments.length>0&&console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.")}set(t,e,n,r,i,s,a,o,l,c,h,u,d,p,f,m){const g=this.elements;return g[0]=t,g[4]=e,g[8]=n,g[12]=r,g[1]=i,g[5]=s,g[9]=a,g[13]=o,g[2]=l,g[6]=c,g[10]=h,g[14]=u,g[3]=d,g[7]=p,g[11]=f,g[15]=m,this}identity(){return this.set(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1),this}clone(){return(new zr).fromArray(this.elements)}copy(t){const e=this.elements,n=t.elements;return e[0]=n[0],e[1]=n[1],e[2]=n[2],e[3]=n[3],e[4]=n[4],e[5]=n[5],e[6]=n[6],e[7]=n[7],e[8]=n[8],e[9]=n[9],e[10]=n[10],e[11]=n[11],e[12]=n[12],e[13]=n[13],e[14]=n[14],e[15]=n[15],this}copyPosition(t){const e=this.elements,n=t.elements;return e[12]=n[12],e[13]=n[13],e[14]=n[14],this}setFromMatrix3(t){const e=t.elements;return this.set(e[0],e[3],e[6],0,e[1],e[4],e[7],0,e[2],e[5],e[8],0,0,0,0,1),this}extractBasis(t,e,n){return t.setFromMatrixColumn(this,0),e.setFromMatrixColumn(this,1),n.setFromMatrixColumn(this,2),this}makeBasis(t,e,n){return this.set(t.x,e.x,n.x,0,t.y,e.y,n.y,0,t.z,e.z,n.z,0,0,0,0,1),this}extractRotation(t){const e=this.elements,n=t.elements,r=1/kr.setFromMatrixColumn(t,0).length(),i=1/kr.setFromMatrixColumn(t,1).length(),s=1/kr.setFromMatrixColumn(t,2).length();return e[0]=n[0]*r,e[1]=n[1]*r,e[2]=n[2]*r,e[3]=0,e[4]=n[4]*i,e[5]=n[5]*i,e[6]=n[6]*i,e[7]=0,e[8]=n[8]*s,e[9]=n[9]*s,e[10]=n[10]*s,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,this}makeRotationFromEuler(t){t&&t.isEuler||console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");const e=this.elements,n=t.x,r=t.y,i=t.z,s=Math.cos(n),a=Math.sin(n),o=Math.cos(r),l=Math.sin(r),c=Math.cos(i),h=Math.sin(i);if("XYZ"===t.order){const t=s*c,n=s*h,r=a*c,i=a*h;e[0]=o*c,e[4]=-o*h,e[8]=l,e[1]=n+r*l,e[5]=t-i*l,e[9]=-a*o,e[2]=i-t*l,e[6]=r+n*l,e[10]=s*o}else if("YXZ"===t.order){const t=o*c,n=o*h,r=l*c,i=l*h;e[0]=t+i*a,e[4]=r*a-n,e[8]=s*l,e[1]=s*h,e[5]=s*c,e[9]=-a,e[2]=n*a-r,e[6]=i+t*a,e[10]=s*o}else if("ZXY"===t.order){const t=o*c,n=o*h,r=l*c,i=l*h;e[0]=t-i*a,e[4]=-s*h,e[8]=r+n*a,e[1]=n+r*a,e[5]=s*c,e[9]=i-t*a,e[2]=-s*l,e[6]=a,e[10]=s*o}else if("ZYX"===t.order){const t=s*c,n=s*h,r=a*c,i=a*h;e[0]=o*c,e[4]=r*l-n,e[8]=t*l+i,e[1]=o*h,e[5]=i*l+t,e[9]=n*l-r,e[2]=-l,e[6]=a*o,e[10]=s*o}else if("YZX"===t.order){const t=s*o,n=s*l,r=a*o,i=a*l;e[0]=o*c,e[4]=i-t*h,e[8]=r*h+n,e[1]=h,e[5]=s*c,e[9]=-a*c,e[2]=-l*c,e[6]=n*h+r,e[10]=t-i*h}else if("XZY"===t.order){const t=s*o,n=s*l,r=a*o,i=a*l;e[0]=o*c,e[4]=-h,e[8]=l*c,e[1]=t*h+i,e[5]=s*c,e[9]=n*h-r,e[2]=r*h-n,e[6]=a*c,e[10]=i*h+t}return e[3]=0,e[7]=0,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,this}makeRotationFromQuaternion(t){return this.compose(Gr,t,Vr)}lookAt(t,e,n){const r=this.elements;return jr.subVectors(t,e),0===jr.lengthSq()&&(jr.z=1),jr.normalize(),Wr.crossVectors(n,jr),0===Wr.lengthSq()&&(1===Math.abs(n.z)?jr.x+=1e-4:jr.z+=1e-4,jr.normalize(),Wr.crossVectors(n,jr)),Wr.normalize(),Xr.crossVectors(jr,Wr),r[0]=Wr.x,r[4]=Xr.x,r[8]=jr.x,r[1]=Wr.y,r[5]=Xr.y,r[9]=jr.y,r[2]=Wr.z,r[6]=Xr.z,r[10]=jr.z,this}multiply(t,e){return void 0!==e?(console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."),this.multiplyMatrices(t,e)):this.multiplyMatrices(this,t)}premultiply(t){return this.multiplyMatrices(t,this)}multiplyMatrices(t,e){const n=t.elements,r=e.elements,i=this.elements,s=n[0],a=n[4],o=n[8],l=n[12],c=n[1],h=n[5],u=n[9],d=n[13],p=n[2],f=n[6],m=n[10],g=n[14],v=n[3],x=n[7],y=n[11],w=n[15],b=r[0],_=r[4],M=r[8],T=r[12],S=r[1],A=r[5],E=r[9],C=r[13],P=r[2],L=r[6],R=r[10],F=r[14],D=r[3],I=r[7],U=r[11],N=r[15];return i[0]=s*b+a*S+o*P+l*D,i[4]=s*_+a*A+o*L+l*I,i[8]=s*M+a*E+o*R+l*U,i[12]=s*T+a*C+o*F+l*N,i[1]=c*b+h*S+u*P+d*D,i[5]=c*_+h*A+u*L+d*I,i[9]=c*M+h*E+u*R+d*U,i[13]=c*T+h*C+u*F+d*N,i[2]=p*b+f*S+m*P+g*D,i[6]=p*_+f*A+m*L+g*I,i[10]=p*M+f*E+m*R+g*U,i[14]=p*T+f*C+m*F+g*N,i[3]=v*b+x*S+y*P+w*D,i[7]=v*_+x*A+y*L+w*I,i[11]=v*M+x*E+y*R+w*U,i[15]=v*T+x*C+y*F+w*N,this}multiplyScalar(t){const e=this.elements;return e[0]*=t,e[4]*=t,e[8]*=t,e[12]*=t,e[1]*=t,e[5]*=t,e[9]*=t,e[13]*=t,e[2]*=t,e[6]*=t,e[10]*=t,e[14]*=t,e[3]*=t,e[7]*=t,e[11]*=t,e[15]*=t,this}determinant(){const t=this.elements,e=t[0],n=t[4],r=t[8],i=t[12],s=t[1],a=t[5],o=t[9],l=t[13],c=t[2],h=t[6],u=t[10],d=t[14];return t[3]*(+i*o*h-r*l*h-i*a*u+n*l*u+r*a*d-n*o*d)+t[7]*(+e*o*d-e*l*u+i*s*u-r*s*d+r*l*c-i*o*c)+t[11]*(+e*l*h-e*a*d-i*s*h+n*s*d+i*a*c-n*l*c)+t[15]*(-r*a*c-e*o*h+e*a*u+r*s*h-n*s*u+n*o*c)}transpose(){const t=this.elements;let e;return e=t[1],t[1]=t[4],t[4]=e,e=t[2],t[2]=t[8],t[8]=e,e=t[6],t[6]=t[9],t[9]=e,e=t[3],t[3]=t[12],t[12]=e,e=t[7],t[7]=t[13],t[13]=e,e=t[11],t[11]=t[14],t[14]=e,this}setPosition(t,e,n){const r=this.elements;return t.isVector3?(r[12]=t.x,r[13]=t.y,r[14]=t.z):(r[12]=t,r[13]=e,r[14]=n),this}invert(){const t=this.elements,e=t[0],n=t[1],r=t[2],i=t[3],s=t[4],a=t[5],o=t[6],l=t[7],c=t[8],h=t[9],u=t[10],d=t[11],p=t[12],f=t[13],m=t[14],g=t[15],v=h*m*l-f*u*l+f*o*d-a*m*d-h*o*g+a*u*g,x=p*u*l-c*m*l-p*o*d+s*m*d+c*o*g-s*u*g,y=c*f*l-p*h*l+p*a*d-s*f*d-c*a*g+s*h*g,w=p*h*o-c*f*o-p*a*u+s*f*u+c*a*m-s*h*m,b=e*v+n*x+r*y+i*w;if(0===b)return this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);const _=1/b;return t[0]=v*_,t[1]=(f*u*i-h*m*i-f*r*d+n*m*d+h*r*g-n*u*g)*_,t[2]=(a*m*i-f*o*i+f*r*l-n*m*l-a*r*g+n*o*g)*_,t[3]=(h*o*i-a*u*i-h*r*l+n*u*l+a*r*d-n*o*d)*_,t[4]=x*_,t[5]=(c*m*i-p*u*i+p*r*d-e*m*d-c*r*g+e*u*g)*_,t[6]=(p*o*i-s*m*i-p*r*l+e*m*l+s*r*g-e*o*g)*_,t[7]=(s*u*i-c*o*i+c*r*l-e*u*l-s*r*d+e*o*d)*_,t[8]=y*_,t[9]=(p*h*i-c*f*i-p*n*d+e*f*d+c*n*g-e*h*g)*_,t[10]=(s*f*i-p*a*i+p*n*l-e*f*l-s*n*g+e*a*g)*_,t[11]=(c*a*i-s*h*i-c*n*l+e*h*l+s*n*d-e*a*d)*_,t[12]=w*_,t[13]=(c*f*r-p*h*r+p*n*u-e*f*u-c*n*m+e*h*m)*_,t[14]=(p*a*r-s*f*r-p*n*o+e*f*o+s*n*m-e*a*m)*_,t[15]=(s*h*r-c*a*r+c*n*o-e*h*o-s*n*u+e*a*u)*_,this}scale(t){const e=this.elements,n=t.x,r=t.y,i=t.z;return e[0]*=n,e[4]*=r,e[8]*=i,e[1]*=n,e[5]*=r,e[9]*=i,e[2]*=n,e[6]*=r,e[10]*=i,e[3]*=n,e[7]*=r,e[11]*=i,this}getMaxScaleOnAxis(){const t=this.elements,e=t[0]*t[0]+t[1]*t[1]+t[2]*t[2],n=t[4]*t[4]+t[5]*t[5]+t[6]*t[6],r=t[8]*t[8]+t[9]*t[9]+t[10]*t[10];return Math.sqrt(Math.max(e,n,r))}makeTranslation(t,e,n){return this.set(1,0,0,t,0,1,0,e,0,0,1,n,0,0,0,1),this}makeRotationX(t){const e=Math.cos(t),n=Math.sin(t);return this.set(1,0,0,0,0,e,-n,0,0,n,e,0,0,0,0,1),this}makeRotationY(t){const e=Math.cos(t),n=Math.sin(t);return this.set(e,0,n,0,0,1,0,0,-n,0,e,0,0,0,0,1),this}makeRotationZ(t){const e=Math.cos(t),n=Math.sin(t);return this.set(e,-n,0,0,n,e,0,0,0,0,1,0,0,0,0,1),this}makeRotationAxis(t,e){const n=Math.cos(e),r=Math.sin(e),i=1-n,s=t.x,a=t.y,o=t.z,l=i*s,c=i*a;return this.set(l*s+n,l*a-r*o,l*o+r*a,0,l*a+r*o,c*a+n,c*o-r*s,0,l*o-r*a,c*o+r*s,i*o*o+n,0,0,0,0,1),this}makeScale(t,e,n){return this.set(t,0,0,0,0,e,0,0,0,0,n,0,0,0,0,1),this}makeShear(t,e,n,r,i,s){return this.set(1,n,i,0,t,1,s,0,e,r,1,0,0,0,0,1),this}compose(t,e,n){const r=this.elements,i=e._x,s=e._y,a=e._z,o=e._w,l=i+i,c=s+s,h=a+a,u=i*l,d=i*c,p=i*h,f=s*c,m=s*h,g=a*h,v=o*l,x=o*c,y=o*h,w=n.x,b=n.y,_=n.z;return r[0]=(1-(f+g))*w,r[1]=(d+y)*w,r[2]=(p-x)*w,r[3]=0,r[4]=(d-y)*b,r[5]=(1-(u+g))*b,r[6]=(m+v)*b,r[7]=0,r[8]=(p+x)*_,r[9]=(m-v)*_,r[10]=(1-(u+f))*_,r[11]=0,r[12]=t.x,r[13]=t.y,r[14]=t.z,r[15]=1,this}decompose(t,e,n){const r=this.elements;let i=kr.set(r[0],r[1],r[2]).length();const s=kr.set(r[4],r[5],r[6]).length(),a=kr.set(r[8],r[9],r[10]).length();this.determinant()<0&&(i=-i),t.x=r[12],t.y=r[13],t.z=r[14],Hr.copy(this);const o=1/i,l=1/s,c=1/a;return Hr.elements[0]*=o,Hr.elements[1]*=o,Hr.elements[2]*=o,Hr.elements[4]*=l,Hr.elements[5]*=l,Hr.elements[6]*=l,Hr.elements[8]*=c,Hr.elements[9]*=c,Hr.elements[10]*=c,e.setFromRotationMatrix(Hr),n.x=i,n.y=s,n.z=a,this}makePerspective(t,e,n,r,i,s){void 0===s&&console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");const a=this.elements,o=2*i/(e-t),l=2*i/(n-r),c=(e+t)/(e-t),h=(n+r)/(n-r),u=-(s+i)/(s-i),d=-2*s*i/(s-i);return a[0]=o,a[4]=0,a[8]=c,a[12]=0,a[1]=0,a[5]=l,a[9]=h,a[13]=0,a[2]=0,a[6]=0,a[10]=u,a[14]=d,a[3]=0,a[7]=0,a[11]=-1,a[15]=0,this}makeOrthographic(t,e,n,r,i,s){const a=this.elements,o=1/(e-t),l=1/(n-r),c=1/(s-i),h=(e+t)*o,u=(n+r)*l,d=(s+i)*c;return a[0]=2*o,a[4]=0,a[8]=0,a[12]=-h,a[1]=0,a[5]=2*l,a[9]=0,a[13]=-u,a[2]=0,a[6]=0,a[10]=-2*c,a[14]=-d,a[3]=0,a[7]=0,a[11]=0,a[15]=1,this}equals(t){const e=this.elements,n=t.elements;for(let t=0;t<16;t++)if(e[t]!==n[t])return!1;return!0}fromArray(t,e=0){for(let n=0;n<16;n++)this.elements[n]=t[n+e];return this}toArray(t=[],e=0){const n=this.elements;return t[e]=n[0],t[e+1]=n[1],t[e+2]=n[2],t[e+3]=n[3],t[e+4]=n[4],t[e+5]=n[5],t[e+6]=n[6],t[e+7]=n[7],t[e+8]=n[8],t[e+9]=n[9],t[e+10]=n[10],t[e+11]=n[11],t[e+12]=n[12],t[e+13]=n[13],t[e+14]=n[14],t[e+15]=n[15],t}}zr.prototype.isMatrix4=!0;const kr=new lr,Hr=new zr,Gr=new lr(0,0,0),Vr=new lr(1,1,1),Wr=new lr,Xr=new lr,jr=new lr,Yr=new zr,qr=new or;class Qr{constructor(t=0,e=0,n=0,r=Qr.DefaultOrder){this._x=t,this._y=e,this._z=n,this._order=r}get x(){return this._x}set x(t){this._x=t,this._onChangeCallback()}get y(){return this._y}set y(t){this._y=t,this._onChangeCallback()}get z(){return this._z}set z(t){this._z=t,this._onChangeCallback()}get order(){return this._order}set order(t){this._order=t,this._onChangeCallback()}set(t,e,n,r=this._order){return this._x=t,this._y=e,this._z=n,this._order=r,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._order)}copy(t){return this._x=t._x,this._y=t._y,this._z=t._z,this._order=t._order,this._onChangeCallback(),this}setFromRotationMatrix(t,e=this._order,n=!0){const r=t.elements,i=r[0],s=r[4],a=r[8],o=r[1],l=r[5],c=r[9],h=r[2],u=r[6],d=r[10];switch(e){case"XYZ":this._y=Math.asin(zn(a,-1,1)),Math.abs(a)<.9999999?(this._x=Math.atan2(-c,d),this._z=Math.atan2(-s,i)):(this._x=Math.atan2(u,l),this._z=0);break;case"YXZ":this._x=Math.asin(-zn(c,-1,1)),Math.abs(c)<.9999999?(this._y=Math.atan2(a,d),this._z=Math.atan2(o,l)):(this._y=Math.atan2(-h,i),this._z=0);break;case"ZXY":this._x=Math.asin(zn(u,-1,1)),Math.abs(u)<.9999999?(this._y=Math.atan2(-h,d),this._z=Math.atan2(-s,l)):(this._y=0,this._z=Math.atan2(o,i));break;case"ZYX":this._y=Math.asin(-zn(h,-1,1)),Math.abs(h)<.9999999?(this._x=Math.atan2(u,d),this._z=Math.atan2(o,i)):(this._x=0,this._z=Math.atan2(-s,l));break;case"YZX":this._z=Math.asin(zn(o,-1,1)),Math.abs(o)<.9999999?(this._x=Math.atan2(-c,l),this._y=Math.atan2(-h,i)):(this._x=0,this._y=Math.atan2(a,d));break;case"XZY":this._z=Math.asin(-zn(s,-1,1)),Math.abs(s)<.9999999?(this._x=Math.atan2(u,l),this._y=Math.atan2(a,i)):(this._x=Math.atan2(-c,d),this._y=0);break;default:console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: "+e)}return this._order=e,!0===n&&this._onChangeCallback(),this}setFromQuaternion(t,e,n){return Yr.makeRotationFromQuaternion(t),this.setFromRotationMatrix(Yr,e,n)}setFromVector3(t,e=this._order){return this.set(t.x,t.y,t.z,e)}reorder(t){return qr.setFromEuler(this),this.setFromQuaternion(qr,t)}equals(t){return t._x===this._x&&t._y===this._y&&t._z===this._z&&t._order===this._order}fromArray(t){return this._x=t[0],this._y=t[1],this._z=t[2],void 0!==t[3]&&(this._order=t[3]),this._onChangeCallback(),this}toArray(t=[],e=0){return t[e]=this._x,t[e+1]=this._y,t[e+2]=this._z,t[e+3]=this._order,t}toVector3(t){return t?t.set(this._x,this._y,this._z):new lr(this._x,this._y,this._z)}_onChange(t){return this._onChangeCallback=t,this}_onChangeCallback(){}}Qr.prototype.isEuler=!0,Qr.DefaultOrder="XYZ",Qr.RotationOrders=["XYZ","YZX","ZXY","XZY","YXZ","ZYX"];class Zr{constructor(){this.mask=1}set(t){this.mask=(1<<t|0)>>>0}enable(t){this.mask|=1<<t|0}enableAll(){this.mask=-1}toggle(t){this.mask^=1<<t|0}disable(t){this.mask&=~(1<<t|0)}disableAll(){this.mask=0}test(t){return 0!=(this.mask&t.mask)}isEnabled(t){return 0!=(this.mask&(1<<t|0))}}let Jr=0;const Kr=new lr,$r=new or,ti=new zr,ei=new lr,ni=new lr,ri=new lr,ii=new or,si=new lr(1,0,0),ai=new lr(0,1,0),oi=new lr(0,0,1),li={type:"added"},ci={type:"removed"};class hi extends Dn{constructor(){super(),Object.defineProperty(this,"id",{value:Jr++}),this.uuid=Bn(),this.name="",this.type="Object3D",this.parent=null,this.children=[],this.up=hi.DefaultUp.clone();const t=new lr,e=new Qr,n=new or,r=new lr(1,1,1);e._onChange((function(){n.setFromEuler(e,!1)})),n._onChange((function(){e.setFromQuaternion(n,void 0,!1)})),Object.defineProperties(this,{position:{configurable:!0,enumerable:!0,value:t},rotation:{configurable:!0,enumerable:!0,value:e},quaternion:{configurable:!0,enumerable:!0,value:n},scale:{configurable:!0,enumerable:!0,value:r},modelViewMatrix:{value:new zr},normalMatrix:{value:new Yn}}),this.matrix=new zr,this.matrixWorld=new zr,this.matrixAutoUpdate=hi.DefaultMatrixAutoUpdate,this.matrixWorldNeedsUpdate=!1,this.layers=new Zr,this.visible=!0,this.castShadow=!1,this.receiveShadow=!1,this.frustumCulled=!0,this.renderOrder=0,this.animations=[],this.userData={}}onBeforeRender(){}onAfterRender(){}applyMatrix4(t){this.matrixAutoUpdate&&this.updateMatrix(),this.matrix.premultiply(t),this.matrix.decompose(this.position,this.quaternion,this.scale)}applyQuaternion(t){return this.quaternion.premultiply(t),this}setRotationFromAxisAngle(t,e){this.quaternion.setFromAxisAngle(t,e)}setRotationFromEuler(t){this.quaternion.setFromEuler(t,!0)}setRotationFromMatrix(t){this.quaternion.setFromRotationMatrix(t)}setRotationFromQuaternion(t){this.quaternion.copy(t)}rotateOnAxis(t,e){return $r.setFromAxisAngle(t,e),this.quaternion.multiply($r),this}rotateOnWorldAxis(t,e){return $r.setFromAxisAngle(t,e),this.quaternion.premultiply($r),this}rotateX(t){return this.rotateOnAxis(si,t)}rotateY(t){return this.rotateOnAxis(ai,t)}rotateZ(t){return this.rotateOnAxis(oi,t)}translateOnAxis(t,e){return Kr.copy(t).applyQuaternion(this.quaternion),this.position.add(Kr.multiplyScalar(e)),this}translateX(t){return this.translateOnAxis(si,t)}translateY(t){return this.translateOnAxis(ai,t)}translateZ(t){return this.translateOnAxis(oi,t)}localToWorld(t){return t.applyMatrix4(this.matrixWorld)}worldToLocal(t){return t.applyMatrix4(ti.copy(this.matrixWorld).invert())}lookAt(t,e,n){t.isVector3?ei.copy(t):ei.set(t,e,n);const r=this.parent;this.updateWorldMatrix(!0,!1),ni.setFromMatrixPosition(this.matrixWorld),this.isCamera||this.isLight?ti.lookAt(ni,ei,this.up):ti.lookAt(ei,ni,this.up),this.quaternion.setFromRotationMatrix(ti),r&&(ti.extractRotation(r.matrixWorld),$r.setFromRotationMatrix(ti),this.quaternion.premultiply($r.invert()))}add(t){if(arguments.length>1){for(let t=0;t<arguments.length;t++)this.add(arguments[t]);return this}return t===this?(console.error("THREE.Object3D.add: object can't be added as a child of itself.",t),this):(t&&t.isObject3D?(null!==t.parent&&t.parent.remove(t),t.parent=this,this.children.push(t),t.dispatchEvent(li)):console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.",t),this)}remove(t){if(arguments.length>1){for(let t=0;t<arguments.length;t++)this.remove(arguments[t]);return this}const e=this.children.indexOf(t);return-1!==e&&(t.parent=null,this.children.splice(e,1),t.dispatchEvent(ci)),this}removeFromParent(){const t=this.parent;return null!==t&&t.remove(this),this}clear(){for(let t=0;t<this.children.length;t++){const e=this.children[t];e.parent=null,e.dispatchEvent(ci)}return this.children.length=0,this}attach(t){return this.updateWorldMatrix(!0,!1),ti.copy(this.matrixWorld).invert(),null!==t.parent&&(t.parent.updateWorldMatrix(!0,!1),ti.multiply(t.parent.matrixWorld)),t.applyMatrix4(ti),this.add(t),t.updateWorldMatrix(!1,!0),this}getObjectById(t){return this.getObjectByProperty("id",t)}getObjectByName(t){return this.getObjectByProperty("name",t)}getObjectByProperty(t,e){if(this[t]===e)return this;for(let n=0,r=this.children.length;n<r;n++){const r=this.children[n].getObjectByProperty(t,e);if(void 0!==r)return r}}getWorldPosition(t){return this.updateWorldMatrix(!0,!1),t.setFromMatrixPosition(this.matrixWorld)}getWorldQuaternion(t){return this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(ni,t,ri),t}getWorldScale(t){return this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(ni,ii,t),t}getWorldDirection(t){this.updateWorldMatrix(!0,!1);const e=this.matrixWorld.elements;return t.set(e[8],e[9],e[10]).normalize()}raycast(){}traverse(t){t(this);const e=this.children;for(let n=0,r=e.length;n<r;n++)e[n].traverse(t)}traverseVisible(t){if(!1===this.visible)return;t(this);const e=this.children;for(let n=0,r=e.length;n<r;n++)e[n].traverseVisible(t)}traverseAncestors(t){const e=this.parent;null!==e&&(t(e),e.traverseAncestors(t))}updateMatrix(){this.matrix.compose(this.position,this.quaternion,this.scale),this.matrixWorldNeedsUpdate=!0}updateMatrixWorld(t){this.matrixAutoUpdate&&this.updateMatrix(),(this.matrixWorldNeedsUpdate||t)&&(null===this.parent?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix),this.matrixWorldNeedsUpdate=!1,t=!0);const e=this.children;for(let n=0,r=e.length;n<r;n++)e[n].updateMatrixWorld(t)}updateWorldMatrix(t,e){const n=this.parent;if(!0===t&&null!==n&&n.updateWorldMatrix(!0,!1),this.matrixAutoUpdate&&this.updateMatrix(),null===this.parent?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix),!0===e){const t=this.children;for(let e=0,n=t.length;e<n;e++)t[e].updateWorldMatrix(!1,!0)}}toJSON(t){const e=void 0===t||"string"==typeof t,n={};e&&(t={geometries:{},materials:{},textures:{},images:{},shapes:{},skeletons:{},animations:{}},n.metadata={version:4.5,type:"Object",generator:"Object3D.toJSON"});const r={};function i(e,n){return void 0===e[n.uuid]&&(e[n.uuid]=n.toJSON(t)),n.uuid}if(r.uuid=this.uuid,r.type=this.type,""!==this.name&&(r.name=this.name),!0===this.castShadow&&(r.castShadow=!0),!0===this.receiveShadow&&(r.receiveShadow=!0),!1===this.visible&&(r.visible=!1),!1===this.frustumCulled&&(r.frustumCulled=!1),0!==this.renderOrder&&(r.renderOrder=this.renderOrder),"{}"!==JSON.stringify(this.userData)&&(r.userData=this.userData),r.layers=this.layers.mask,r.matrix=this.matrix.toArray(),!1===this.matrixAutoUpdate&&(r.matrixAutoUpdate=!1),this.isInstancedMesh&&(r.type="InstancedMesh",r.count=this.count,r.instanceMatrix=this.instanceMatrix.toJSON(),null!==this.instanceColor&&(r.instanceColor=this.instanceColor.toJSON())),this.isScene)this.background&&(this.background.isColor?r.background=this.background.toJSON():this.background.isTexture&&(r.background=this.background.toJSON(t).uuid)),this.environment&&this.environment.isTexture&&(r.environment=this.environment.toJSON(t).uuid);else if(this.isMesh||this.isLine||this.isPoints){r.geometry=i(t.geometries,this.geometry);const e=this.geometry.parameters;if(void 0!==e&&void 0!==e.shapes){const n=e.shapes;if(Array.isArray(n))for(let e=0,r=n.length;e<r;e++){const r=n[e];i(t.shapes,r)}else i(t.shapes,n)}}if(this.isSkinnedMesh&&(r.bindMode=this.bindMode,r.bindMatrix=this.bindMatrix.toArray(),void 0!==this.skeleton&&(i(t.skeletons,this.skeleton),r.skeleton=this.skeleton.uuid)),void 0!==this.material)if(Array.isArray(this.material)){const e=[];for(let n=0,r=this.material.length;n<r;n++)e.push(i(t.materials,this.material[n]));r.material=e}else r.material=i(t.materials,this.material);if(this.children.length>0){r.children=[];for(let e=0;e<this.children.length;e++)r.children.push(this.children[e].toJSON(t).object)}if(this.animations.length>0){r.animations=[];for(let e=0;e<this.animations.length;e++){const n=this.animations[e];r.animations.push(i(t.animations,n))}}if(e){const e=s(t.geometries),r=s(t.materials),i=s(t.textures),a=s(t.images),o=s(t.shapes),l=s(t.skeletons),c=s(t.animations);e.length>0&&(n.geometries=e),r.length>0&&(n.materials=r),i.length>0&&(n.textures=i),a.length>0&&(n.images=a),o.length>0&&(n.shapes=o),l.length>0&&(n.skeletons=l),c.length>0&&(n.animations=c)}return n.object=r,n;function s(t){const e=[];for(const n in t){const r=t[n];delete r.metadata,e.push(r)}return e}}clone(t){return(new this.constructor).copy(this,t)}copy(t,e=!0){if(this.name=t.name,this.up.copy(t.up),this.position.copy(t.position),this.rotation.order=t.rotation.order,this.quaternion.copy(t.quaternion),this.scale.copy(t.scale),this.matrix.copy(t.matrix),this.matrixWorld.copy(t.matrixWorld),this.matrixAutoUpdate=t.matrixAutoUpdate,this.matrixWorldNeedsUpdate=t.matrixWorldNeedsUpdate,this.layers.mask=t.layers.mask,this.visible=t.visible,this.castShadow=t.castShadow,this.receiveShadow=t.receiveShadow,this.frustumCulled=t.frustumCulled,this.renderOrder=t.renderOrder,this.userData=JSON.parse(JSON.stringify(t.userData)),!0===e)for(let e=0;e<t.children.length;e++){const n=t.children[e];this.add(n.clone())}return this}}hi.DefaultUp=new lr(0,1,0),hi.DefaultMatrixAutoUpdate=!0,hi.prototype.isObject3D=!0;const ui=new lr,di=new lr,pi=new lr,fi=new lr,mi=new lr,gi=new lr,vi=new lr,xi=new lr,yi=new lr,wi=new lr;class bi{constructor(t=new lr,e=new lr,n=new lr){this.a=t,this.b=e,this.c=n}static getNormal(t,e,n,r){r.subVectors(n,e),ui.subVectors(t,e),r.cross(ui);const i=r.lengthSq();return i>0?r.multiplyScalar(1/Math.sqrt(i)):r.set(0,0,0)}static getBarycoord(t,e,n,r,i){ui.subVectors(r,e),di.subVectors(n,e),pi.subVectors(t,e);const s=ui.dot(ui),a=ui.dot(di),o=ui.dot(pi),l=di.dot(di),c=di.dot(pi),h=s*l-a*a;if(0===h)return i.set(-2,-1,-1);const u=1/h,d=(l*o-a*c)*u,p=(s*c-a*o)*u;return i.set(1-d-p,p,d)}static containsPoint(t,e,n,r){return this.getBarycoord(t,e,n,r,fi),fi.x>=0&&fi.y>=0&&fi.x+fi.y<=1}static getUV(t,e,n,r,i,s,a,o){return this.getBarycoord(t,e,n,r,fi),o.set(0,0),o.addScaledVector(i,fi.x),o.addScaledVector(s,fi.y),o.addScaledVector(a,fi.z),o}static isFrontFacing(t,e,n,r){return ui.subVectors(n,e),di.subVectors(t,e),ui.cross(di).dot(r)<0}set(t,e,n){return this.a.copy(t),this.b.copy(e),this.c.copy(n),this}setFromPointsAndIndices(t,e,n,r){return this.a.copy(t[e]),this.b.copy(t[n]),this.c.copy(t[r]),this}setFromAttributeAndIndices(t,e,n,r){return this.a.fromBufferAttribute(t,e),this.b.fromBufferAttribute(t,n),this.c.fromBufferAttribute(t,r),this}clone(){return(new this.constructor).copy(this)}copy(t){return this.a.copy(t.a),this.b.copy(t.b),this.c.copy(t.c),this}getArea(){return ui.subVectors(this.c,this.b),di.subVectors(this.a,this.b),.5*ui.cross(di).length()}getMidpoint(t){return t.addVectors(this.a,this.b).add(this.c).multiplyScalar(1/3)}getNormal(t){return bi.getNormal(this.a,this.b,this.c,t)}getPlane(t){return t.setFromCoplanarPoints(this.a,this.b,this.c)}getBarycoord(t,e){return bi.getBarycoord(t,this.a,this.b,this.c,e)}getUV(t,e,n,r,i){return bi.getUV(t,this.a,this.b,this.c,e,n,r,i)}containsPoint(t){return bi.containsPoint(t,this.a,this.b,this.c)}isFrontFacing(t){return bi.isFrontFacing(this.a,this.b,this.c,t)}intersectsBox(t){return t.intersectsTriangle(this)}closestPointToPoint(t,e){const n=this.a,r=this.b,i=this.c;let s,a;mi.subVectors(r,n),gi.subVectors(i,n),xi.subVectors(t,n);const o=mi.dot(xi),l=gi.dot(xi);if(o<=0&&l<=0)return e.copy(n);yi.subVectors(t,r);const c=mi.dot(yi),h=gi.dot(yi);if(c>=0&&h<=c)return e.copy(r);const u=o*h-c*l;if(u<=0&&o>=0&&c<=0)return s=o/(o-c),e.copy(n).addScaledVector(mi,s);wi.subVectors(t,i);const d=mi.dot(wi),p=gi.dot(wi);if(p>=0&&d<=p)return e.copy(i);const f=d*l-o*p;if(f<=0&&l>=0&&p<=0)return a=l/(l-p),e.copy(n).addScaledVector(gi,a);const m=c*p-d*h;if(m<=0&&h-c>=0&&d-p>=0)return vi.subVectors(i,r),a=(h-c)/(h-c+(d-p)),e.copy(r).addScaledVector(vi,a);const g=1/(m+f+u);return s=f*g,a=u*g,e.copy(n).addScaledVector(mi,s).addScaledVector(gi,a)}equals(t){return t.a.equals(this.a)&&t.b.equals(this.b)&&t.c.equals(this.c)}}let _i=0;class Mi extends Dn{constructor(){super(),Object.defineProperty(this,"id",{value:_i++}),this.uuid=Bn(),this.name="",this.type="Material",this.fog=!0,this.blending=T,this.side=x,this.vertexColors=!1,this.opacity=1,this.format=Gt,this.transparent=!1,this.blendSrc=B,this.blendDst=z,this.blendEquation=P,this.blendSrcAlpha=null,this.blendDstAlpha=null,this.blendEquationAlpha=null,this.depthFunc=q,this.depthTest=!0,this.depthWrite=!0,this.stencilWriteMask=255,this.stencilFunc=bn,this.stencilRef=0,this.stencilFuncMask=255,this.stencilFail=on,this.stencilZFail=on,this.stencilZPass=on,this.stencilWrite=!1,this.clippingPlanes=null,this.clipIntersection=!1,this.clipShadows=!1,this.shadowSide=null,this.colorWrite=!0,this.precision=null,this.polygonOffset=!1,this.polygonOffsetFactor=0,this.polygonOffsetUnits=0,this.dithering=!1,this.alphaToCoverage=!1,this.premultipliedAlpha=!1,this.visible=!0,this.toneMapped=!0,this.userData={},this.version=0,this._alphaTest=0}get alphaTest(){return this._alphaTest}set alphaTest(t){this._alphaTest>0!=t>0&&this.version++,this._alphaTest=t}onBuild(){}onBeforeRender(){}onBeforeCompile(){}customProgramCacheKey(){return this.onBeforeCompile.toString()}setValues(t){if(void 0!==t)for(const e in t){const n=t[e];if(void 0===n){console.warn("THREE.Material: '"+e+"' parameter is undefined.");continue}if("shading"===e){console.warn("THREE."+this.type+": .shading has been removed. Use the boolean .flatShading instead."),this.flatShading=n===b;continue}const r=this[e];void 0!==r?r&&r.isColor?r.set(n):r&&r.isVector3&&n&&n.isVector3?r.copy(n):this[e]=n:console.warn("THREE."+this.type+": '"+e+"' is not a property of this material.")}}toJSON(t){const e=void 0===t||"string"==typeof t;e&&(t={textures:{},images:{}});const n={metadata:{version:4.5,type:"Material",generator:"Material.toJSON"}};function r(t){const e=[];for(const n in t){const r=t[n];delete r.metadata,e.push(r)}return e}if(n.uuid=this.uuid,n.type=this.type,""!==this.name&&(n.name=this.name),this.color&&this.color.isColor&&(n.color=this.color.getHex()),void 0!==this.roughness&&(n.roughness=this.roughness),void 0!==this.metalness&&(n.metalness=this.metalness),void 0!==this.sheen&&(n.sheen=this.sheen),this.sheenColor&&this.sheenColor.isColor&&(n.sheenColor=this.sheenColor.getHex()),void 0!==this.sheenRoughness&&(n.sheenRoughness=this.sheenRoughness),this.emissive&&this.emissive.isColor&&(n.emissive=this.emissive.getHex()),this.emissiveIntensity&&1!==this.emissiveIntensity&&(n.emissiveIntensity=this.emissiveIntensity),this.specular&&this.specular.isColor&&(n.specular=this.specular.getHex()),void 0!==this.specularIntensity&&(n.specularIntensity=this.specularIntensity),this.specularColor&&this.specularColor.isColor&&(n.specularColor=this.specularColor.getHex()),void 0!==this.shininess&&(n.shininess=this.shininess),void 0!==this.clearcoat&&(n.clearcoat=this.clearcoat),void 0!==this.clearcoatRoughness&&(n.clearcoatRoughness=this.clearcoatRoughness),this.clearcoatMap&&this.clearcoatMap.isTexture&&(n.clearcoatMap=this.clearcoatMap.toJSON(t).uuid),this.clearcoatRoughnessMap&&this.clearcoatRoughnessMap.isTexture&&(n.clearcoatRoughnessMap=this.clearcoatRoughnessMap.toJSON(t).uuid),this.clearcoatNormalMap&&this.clearcoatNormalMap.isTexture&&(n.clearcoatNormalMap=this.clearcoatNormalMap.toJSON(t).uuid,n.clearcoatNormalScale=this.clearcoatNormalScale.toArray()),this.map&&this.map.isTexture&&(n.map=this.map.toJSON(t).uuid),this.matcap&&this.matcap.isTexture&&(n.matcap=this.matcap.toJSON(t).uuid),this.alphaMap&&this.alphaMap.isTexture&&(n.alphaMap=this.alphaMap.toJSON(t).uuid),this.lightMap&&this.lightMap.isTexture&&(n.lightMap=this.lightMap.toJSON(t).uuid,n.lightMapIntensity=this.lightMapIntensity),this.aoMap&&this.aoMap.isTexture&&(n.aoMap=this.aoMap.toJSON(t).uuid,n.aoMapIntensity=this.aoMapIntensity),this.bumpMap&&this.bumpMap.isTexture&&(n.bumpMap=this.bumpMap.toJSON(t).uuid,n.bumpScale=this.bumpScale),this.normalMap&&this.normalMap.isTexture&&(n.normalMap=this.normalMap.toJSON(t).uuid,n.normalMapType=this.normalMapType,n.normalScale=this.normalScale.toArray()),this.displacementMap&&this.displacementMap.isTexture&&(n.displacementMap=this.displacementMap.toJSON(t).uuid,n.displacementScale=this.displacementScale,n.displacementBias=this.displacementBias),this.roughnessMap&&this.roughnessMap.isTexture&&(n.roughnessMap=this.roughnessMap.toJSON(t).uuid),this.metalnessMap&&this.metalnessMap.isTexture&&(n.metalnessMap=this.metalnessMap.toJSON(t).uuid),this.emissiveMap&&this.emissiveMap.isTexture&&(n.emissiveMap=this.emissiveMap.toJSON(t).uuid),this.specularMap&&this.specularMap.isTexture&&(n.specularMap=this.specularMap.toJSON(t).uuid),this.specularIntensityMap&&this.specularIntensityMap.isTexture&&(n.specularIntensityMap=this.specularIntensityMap.toJSON(t).uuid),this.specularColorMap&&this.specularColorMap.isTexture&&(n.specularColorMap=this.specularColorMap.toJSON(t).uuid),this.envMap&&this.envMap.isTexture&&(n.envMap=this.envMap.toJSON(t).uuid,void 0!==this.combine&&(n.combine=this.combine)),void 0!==this.envMapIntensity&&(n.envMapIntensity=this.envMapIntensity),void 0!==this.reflectivity&&(n.reflectivity=this.reflectivity),void 0!==this.refractionRatio&&(n.refractionRatio=this.refractionRatio),this.gradientMap&&this.gradientMap.isTexture&&(n.gradientMap=this.gradientMap.toJSON(t).uuid),void 0!==this.transmission&&(n.transmission=this.transmission),this.transmissionMap&&this.transmissionMap.isTexture&&(n.transmissionMap=this.transmissionMap.toJSON(t).uuid),void 0!==this.thickness&&(n.thickness=this.thickness),this.thicknessMap&&this.thicknessMap.isTexture&&(n.thicknessMap=this.thicknessMap.toJSON(t).uuid),void 0!==this.attenuationDistance&&(n.attenuationDistance=this.attenuationDistance),void 0!==this.attenuationColor&&(n.attenuationColor=this.attenuationColor.getHex()),void 0!==this.size&&(n.size=this.size),null!==this.shadowSide&&(n.shadowSide=this.shadowSide),void 0!==this.sizeAttenuation&&(n.sizeAttenuation=this.sizeAttenuation),this.blending!==T&&(n.blending=this.blending),this.side!==x&&(n.side=this.side),this.vertexColors&&(n.vertexColors=!0),this.opacity<1&&(n.opacity=this.opacity),this.format!==Gt&&(n.format=this.format),!0===this.transparent&&(n.transparent=this.transparent),n.depthFunc=this.depthFunc,n.depthTest=this.depthTest,n.depthWrite=this.depthWrite,n.colorWrite=this.colorWrite,n.stencilWrite=this.stencilWrite,n.stencilWriteMask=this.stencilWriteMask,n.stencilFunc=this.stencilFunc,n.stencilRef=this.stencilRef,n.stencilFuncMask=this.stencilFuncMask,n.stencilFail=this.stencilFail,n.stencilZFail=this.stencilZFail,n.stencilZPass=this.stencilZPass,this.rotation&&0!==this.rotation&&(n.rotation=this.rotation),!0===this.polygonOffset&&(n.polygonOffset=!0),0!==this.polygonOffsetFactor&&(n.polygonOffsetFactor=this.polygonOffsetFactor),0!==this.polygonOffsetUnits&&(n.polygonOffsetUnits=this.polygonOffsetUnits),this.linewidth&&1!==this.linewidth&&(n.linewidth=this.linewidth),void 0!==this.dashSize&&(n.dashSize=this.dashSize),void 0!==this.gapSize&&(n.gapSize=this.gapSize),void 0!==this.scale&&(n.scale=this.scale),!0===this.dithering&&(n.dithering=!0),this.alphaTest>0&&(n.alphaTest=this.alphaTest),!0===this.alphaToCoverage&&(n.alphaToCoverage=this.alphaToCoverage),!0===this.premultipliedAlpha&&(n.premultipliedAlpha=this.premultipliedAlpha),!0===this.wireframe&&(n.wireframe=this.wireframe),this.wireframeLinewidth>1&&(n.wireframeLinewidth=this.wireframeLinewidth),"round"!==this.wireframeLinecap&&(n.wireframeLinecap=this.wireframeLinecap),"round"!==this.wireframeLinejoin&&(n.wireframeLinejoin=this.wireframeLinejoin),!0===this.flatShading&&(n.flatShading=this.flatShading),!1===this.visible&&(n.visible=!1),!1===this.toneMapped&&(n.toneMapped=!1),"{}"!==JSON.stringify(this.userData)&&(n.userData=this.userData),e){const e=r(t.textures),i=r(t.images);e.length>0&&(n.textures=e),i.length>0&&(n.images=i)}return n}clone(){return(new this.constructor).copy(this)}copy(t){this.name=t.name,this.fog=t.fog,this.blending=t.blending,this.side=t.side,this.vertexColors=t.vertexColors,this.opacity=t.opacity,this.format=t.format,this.transparent=t.transparent,this.blendSrc=t.blendSrc,this.blendDst=t.blendDst,this.blendEquation=t.blendEquation,this.blendSrcAlpha=t.blendSrcAlpha,this.blendDstAlpha=t.blendDstAlpha,this.blendEquationAlpha=t.blendEquationAlpha,this.depthFunc=t.depthFunc,this.depthTest=t.depthTest,this.depthWrite=t.depthWrite,this.stencilWriteMask=t.stencilWriteMask,this.stencilFunc=t.stencilFunc,this.stencilRef=t.stencilRef,this.stencilFuncMask=t.stencilFuncMask,this.stencilFail=t.stencilFail,this.stencilZFail=t.stencilZFail,this.stencilZPass=t.stencilZPass,this.stencilWrite=t.stencilWrite;const e=t.clippingPlanes;let n=null;if(null!==e){const t=e.length;n=new Array(t);for(let r=0;r!==t;++r)n[r]=e[r].clone()}return this.clippingPlanes=n,this.clipIntersection=t.clipIntersection,this.clipShadows=t.clipShadows,this.shadowSide=t.shadowSide,this.colorWrite=t.colorWrite,this.precision=t.precision,this.polygonOffset=t.polygonOffset,this.polygonOffsetFactor=t.polygonOffsetFactor,this.polygonOffsetUnits=t.polygonOffsetUnits,this.dithering=t.dithering,this.alphaTest=t.alphaTest,this.alphaToCoverage=t.alphaToCoverage,this.premultipliedAlpha=t.premultipliedAlpha,this.visible=t.visible,this.toneMapped=t.toneMapped,this.userData=JSON.parse(JSON.stringify(t.userData)),this}dispose(){this.dispatchEvent({type:"dispose"})}set needsUpdate(t){!0===t&&this.version++}}Mi.prototype.isMaterial=!0;const Ti={aliceblue:15792383,antiquewhite:16444375,aqua:65535,aquamarine:8388564,azure:15794175,beige:16119260,bisque:16770244,black:0,blanchedalmond:16772045,blue:255,blueviolet:9055202,brown:10824234,burlywood:14596231,cadetblue:6266528,chartreuse:8388352,chocolate:13789470,coral:16744272,cornflowerblue:6591981,cornsilk:16775388,crimson:14423100,cyan:65535,darkblue:139,darkcyan:35723,darkgoldenrod:12092939,darkgray:11119017,darkgreen:25600,darkgrey:11119017,darkkhaki:12433259,darkmagenta:9109643,darkolivegreen:5597999,darkorange:16747520,darkorchid:10040012,darkred:9109504,darksalmon:15308410,darkseagreen:9419919,darkslateblue:4734347,darkslategray:3100495,darkslategrey:3100495,darkturquoise:52945,darkviolet:9699539,deeppink:16716947,deepskyblue:49151,dimgray:6908265,dimgrey:6908265,dodgerblue:2003199,firebrick:11674146,floralwhite:16775920,forestgreen:2263842,fuchsia:16711935,gainsboro:14474460,ghostwhite:16316671,gold:16766720,goldenrod:14329120,gray:8421504,green:32768,greenyellow:11403055,grey:8421504,honeydew:15794160,hotpink:16738740,indianred:13458524,indigo:4915330,ivory:16777200,khaki:15787660,lavender:15132410,lavenderblush:16773365,lawngreen:8190976,lemonchiffon:16775885,lightblue:11393254,lightcoral:15761536,lightcyan:14745599,lightgoldenrodyellow:16448210,lightgray:13882323,lightgreen:9498256,lightgrey:13882323,lightpink:16758465,lightsalmon:16752762,lightseagreen:2142890,lightskyblue:8900346,lightslategray:7833753,lightslategrey:7833753,lightsteelblue:11584734,lightyellow:16777184,lime:65280,limegreen:3329330,linen:16445670,magenta:16711935,maroon:8388608,mediumaquamarine:6737322,mediumblue:205,mediumorchid:12211667,mediumpurple:9662683,mediumseagreen:3978097,mediumslateblue:8087790,mediumspringgreen:64154,mediumturquoise:4772300,mediumvioletred:13047173,midnightblue:1644912,mintcream:16121850,mistyrose:16770273,moccasin:16770229,navajowhite:16768685,navy:128,oldlace:16643558,olive:8421376,olivedrab:7048739,orange:16753920,orangered:16729344,orchid:14315734,palegoldenrod:15657130,palegreen:10025880,paleturquoise:11529966,palevioletred:14381203,papayawhip:16773077,peachpuff:16767673,peru:13468991,pink:16761035,plum:14524637,powderblue:11591910,purple:8388736,rebeccapurple:6697881,red:16711680,rosybrown:12357519,royalblue:4286945,saddlebrown:9127187,salmon:16416882,sandybrown:16032864,seagreen:3050327,seashell:16774638,sienna:10506797,silver:12632256,skyblue:8900331,slateblue:6970061,slategray:7372944,slategrey:7372944,snow:16775930,springgreen:65407,steelblue:4620980,tan:13808780,teal:32896,thistle:14204888,tomato:16737095,turquoise:4251856,violet:15631086,wheat:16113331,white:16777215,whitesmoke:16119285,yellow:16776960,yellowgreen:10145074},Si={h:0,s:0,l:0},Ai={h:0,s:0,l:0};function Ei(t,e,n){return n<0&&(n+=1),n>1&&(n-=1),n<1/6?t+6*(e-t)*n:n<.5?e:n<2/3?t+6*(e-t)*(2/3-n):t}function Ci(t){return t<.04045?.0773993808*t:Math.pow(.9478672986*t+.0521327014,2.4)}function Pi(t){return t<.0031308?12.92*t:1.055*Math.pow(t,.41666)-.055}class Li{constructor(t,e,n){return void 0===e&&void 0===n?this.set(t):this.setRGB(t,e,n)}set(t){return t&&t.isColor?this.copy(t):"number"==typeof t?this.setHex(t):"string"==typeof t&&this.setStyle(t),this}setScalar(t){return this.r=t,this.g=t,this.b=t,this}setHex(t){return t=Math.floor(t),this.r=(t>>16&255)/255,this.g=(t>>8&255)/255,this.b=(255&t)/255,this}setRGB(t,e,n){return this.r=t,this.g=e,this.b=n,this}setHSL(t,e,n){if(t=kn(t,1),e=zn(e,0,1),n=zn(n,0,1),0===e)this.r=this.g=this.b=n;else{const r=n<=.5?n*(1+e):n+e-n*e,i=2*n-r;this.r=Ei(i,r,t+1/3),this.g=Ei(i,r,t),this.b=Ei(i,r,t-1/3)}return this}setStyle(t){function e(e){void 0!==e&&parseFloat(e)<1&&console.warn("THREE.Color: Alpha component of "+t+" will be ignored.")}let n;if(n=/^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(t)){let t;const r=n[1],i=n[2];switch(r){case"rgb":case"rgba":if(t=/^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(i))return this.r=Math.min(255,parseInt(t[1],10))/255,this.g=Math.min(255,parseInt(t[2],10))/255,this.b=Math.min(255,parseInt(t[3],10))/255,e(t[4]),this;if(t=/^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(i))return this.r=Math.min(100,parseInt(t[1],10))/100,this.g=Math.min(100,parseInt(t[2],10))/100,this.b=Math.min(100,parseInt(t[3],10))/100,e(t[4]),this;break;case"hsl":case"hsla":if(t=/^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(i)){const n=parseFloat(t[1])/360,r=parseInt(t[2],10)/100,i=parseInt(t[3],10)/100;return e(t[4]),this.setHSL(n,r,i)}}}else if(n=/^\#([A-Fa-f\d]+)$/.exec(t)){const t=n[1],e=t.length;if(3===e)return this.r=parseInt(t.charAt(0)+t.charAt(0),16)/255,this.g=parseInt(t.charAt(1)+t.charAt(1),16)/255,this.b=parseInt(t.charAt(2)+t.charAt(2),16)/255,this;if(6===e)return this.r=parseInt(t.charAt(0)+t.charAt(1),16)/255,this.g=parseInt(t.charAt(2)+t.charAt(3),16)/255,this.b=parseInt(t.charAt(4)+t.charAt(5),16)/255,this}return t&&t.length>0?this.setColorName(t):this}setColorName(t){const e=Ti[t.toLowerCase()];return void 0!==e?this.setHex(e):console.warn("THREE.Color: Unknown color "+t),this}clone(){return new this.constructor(this.r,this.g,this.b)}copy(t){return this.r=t.r,this.g=t.g,this.b=t.b,this}copySRGBToLinear(t){return this.r=Ci(t.r),this.g=Ci(t.g),this.b=Ci(t.b),this}copyLinearToSRGB(t){return this.r=Pi(t.r),this.g=Pi(t.g),this.b=Pi(t.b),this}convertSRGBToLinear(){return this.copySRGBToLinear(this),this}convertLinearToSRGB(){return this.copyLinearToSRGB(this),this}getHex(){return 255*this.r<<16^255*this.g<<8^255*this.b<<0}getHexString(){return("000000"+this.getHex().toString(16)).slice(-6)}getHSL(t){const e=this.r,n=this.g,r=this.b,i=Math.max(e,n,r),s=Math.min(e,n,r);let a,o;const l=(s+i)/2;if(s===i)a=0,o=0;else{const t=i-s;switch(o=l<=.5?t/(i+s):t/(2-i-s),i){case e:a=(n-r)/t+(n<r?6:0);break;case n:a=(r-e)/t+2;break;case r:a=(e-n)/t+4}a/=6}return t.h=a,t.s=o,t.l=l,t}getStyle(){return"rgb("+(255*this.r|0)+","+(255*this.g|0)+","+(255*this.b|0)+")"}offsetHSL(t,e,n){return this.getHSL(Si),Si.h+=t,Si.s+=e,Si.l+=n,this.setHSL(Si.h,Si.s,Si.l),this}add(t){return this.r+=t.r,this.g+=t.g,this.b+=t.b,this}addColors(t,e){return this.r=t.r+e.r,this.g=t.g+e.g,this.b=t.b+e.b,this}addScalar(t){return this.r+=t,this.g+=t,this.b+=t,this}sub(t){return this.r=Math.max(0,this.r-t.r),this.g=Math.max(0,this.g-t.g),this.b=Math.max(0,this.b-t.b),this}multiply(t){return this.r*=t.r,this.g*=t.g,this.b*=t.b,this}multiplyScalar(t){return this.r*=t,this.g*=t,this.b*=t,this}lerp(t,e){return this.r+=(t.r-this.r)*e,this.g+=(t.g-this.g)*e,this.b+=(t.b-this.b)*e,this}lerpColors(t,e,n){return this.r=t.r+(e.r-t.r)*n,this.g=t.g+(e.g-t.g)*n,this.b=t.b+(e.b-t.b)*n,this}lerpHSL(t,e){this.getHSL(Si),t.getHSL(Ai);const n=Hn(Si.h,Ai.h,e),r=Hn(Si.s,Ai.s,e),i=Hn(Si.l,Ai.l,e);return this.setHSL(n,r,i),this}equals(t){return t.r===this.r&&t.g===this.g&&t.b===this.b}fromArray(t,e=0){return this.r=t[e],this.g=t[e+1],this.b=t[e+2],this}toArray(t=[],e=0){return t[e]=this.r,t[e+1]=this.g,t[e+2]=this.b,t}fromBufferAttribute(t,e){return this.r=t.getX(e),this.g=t.getY(e),this.b=t.getZ(e),!0===t.normalized&&(this.r/=255,this.g/=255,this.b/=255),this}toJSON(){return this.getHex()}}Li.NAMES=Ti,Li.prototype.isColor=!0,Li.prototype.r=1,Li.prototype.g=1,Li.prototype.b=1;class Ri extends Mi{constructor(t){super(),this.type="MeshBasicMaterial",this.color=new Li(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=$,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.map=t.map,this.lightMap=t.lightMap,this.lightMapIntensity=t.lightMapIntensity,this.aoMap=t.aoMap,this.aoMapIntensity=t.aoMapIntensity,this.specularMap=t.specularMap,this.alphaMap=t.alphaMap,this.envMap=t.envMap,this.combine=t.combine,this.reflectivity=t.reflectivity,this.refractionRatio=t.refractionRatio,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.wireframeLinecap=t.wireframeLinecap,this.wireframeLinejoin=t.wireframeLinejoin,this}}Ri.prototype.isMeshBasicMaterial=!0;const Fi=new lr,Di=new jn;class Ii{constructor(t,e,n){if(Array.isArray(t))throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");this.name="",this.array=t,this.itemSize=e,this.count=void 0!==t?t.length/e:0,this.normalized=!0===n,this.usage=_n,this.updateRange={offset:0,count:-1},this.version=0}onUploadCallback(){}set needsUpdate(t){!0===t&&this.version++}setUsage(t){return this.usage=t,this}copy(t){return this.name=t.name,this.array=new t.array.constructor(t.array),this.itemSize=t.itemSize,this.count=t.count,this.normalized=t.normalized,this.usage=t.usage,this}copyAt(t,e,n){t*=this.itemSize,n*=e.itemSize;for(let r=0,i=this.itemSize;r<i;r++)this.array[t+r]=e.array[n+r];return this}copyArray(t){return this.array.set(t),this}copyColorsArray(t){const e=this.array;let n=0;for(let r=0,i=t.length;r<i;r++){let i=t[r];void 0===i&&(console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined",r),i=new Li),e[n++]=i.r,e[n++]=i.g,e[n++]=i.b}return this}copyVector2sArray(t){const e=this.array;let n=0;for(let r=0,i=t.length;r<i;r++){let i=t[r];void 0===i&&(console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined",r),i=new jn),e[n++]=i.x,e[n++]=i.y}return this}copyVector3sArray(t){const e=this.array;let n=0;for(let r=0,i=t.length;r<i;r++){let i=t[r];void 0===i&&(console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined",r),i=new lr),e[n++]=i.x,e[n++]=i.y,e[n++]=i.z}return this}copyVector4sArray(t){const e=this.array;let n=0;for(let r=0,i=t.length;r<i;r++){let i=t[r];void 0===i&&(console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined",r),i=new rr),e[n++]=i.x,e[n++]=i.y,e[n++]=i.z,e[n++]=i.w}return this}applyMatrix3(t){if(2===this.itemSize)for(let e=0,n=this.count;e<n;e++)Di.fromBufferAttribute(this,e),Di.applyMatrix3(t),this.setXY(e,Di.x,Di.y);else if(3===this.itemSize)for(let e=0,n=this.count;e<n;e++)Fi.fromBufferAttribute(this,e),Fi.applyMatrix3(t),this.setXYZ(e,Fi.x,Fi.y,Fi.z);return this}applyMatrix4(t){for(let e=0,n=this.count;e<n;e++)Fi.x=this.getX(e),Fi.y=this.getY(e),Fi.z=this.getZ(e),Fi.applyMatrix4(t),this.setXYZ(e,Fi.x,Fi.y,Fi.z);return this}applyNormalMatrix(t){for(let e=0,n=this.count;e<n;e++)Fi.x=this.getX(e),Fi.y=this.getY(e),Fi.z=this.getZ(e),Fi.applyNormalMatrix(t),this.setXYZ(e,Fi.x,Fi.y,Fi.z);return this}transformDirection(t){for(let e=0,n=this.count;e<n;e++)Fi.x=this.getX(e),Fi.y=this.getY(e),Fi.z=this.getZ(e),Fi.transformDirection(t),this.setXYZ(e,Fi.x,Fi.y,Fi.z);return this}set(t,e=0){return this.array.set(t,e),this}getX(t){return this.array[t*this.itemSize]}setX(t,e){return this.array[t*this.itemSize]=e,this}getY(t){return this.array[t*this.itemSize+1]}setY(t,e){return this.array[t*this.itemSize+1]=e,this}getZ(t){return this.array[t*this.itemSize+2]}setZ(t,e){return this.array[t*this.itemSize+2]=e,this}getW(t){return this.array[t*this.itemSize+3]}setW(t,e){return this.array[t*this.itemSize+3]=e,this}setXY(t,e,n){return t*=this.itemSize,this.array[t+0]=e,this.array[t+1]=n,this}setXYZ(t,e,n,r){return t*=this.itemSize,this.array[t+0]=e,this.array[t+1]=n,this.array[t+2]=r,this}setXYZW(t,e,n,r,i){return t*=this.itemSize,this.array[t+0]=e,this.array[t+1]=n,this.array[t+2]=r,this.array[t+3]=i,this}onUpload(t){return this.onUploadCallback=t,this}clone(){return new this.constructor(this.array,this.itemSize).copy(this)}toJSON(){const t={itemSize:this.itemSize,type:this.array.constructor.name,array:Array.prototype.slice.call(this.array),normalized:this.normalized};return""!==this.name&&(t.name=this.name),this.usage!==_n&&(t.usage=this.usage),0===this.updateRange.offset&&-1===this.updateRange.count||(t.updateRange=this.updateRange),t}}Ii.prototype.isBufferAttribute=!0;class Ui extends Ii{constructor(t,e,n){super(new Int8Array(t),e,n)}}class Ni extends Ii{constructor(t,e,n){super(new Uint8Array(t),e,n)}}class Oi extends Ii{constructor(t,e,n){super(new Uint8ClampedArray(t),e,n)}}class Bi extends Ii{constructor(t,e,n){super(new Int16Array(t),e,n)}}class zi extends Ii{constructor(t,e,n){super(new Uint16Array(t),e,n)}}class ki extends Ii{constructor(t,e,n){super(new Int32Array(t),e,n)}}class Hi extends Ii{constructor(t,e,n){super(new Uint32Array(t),e,n)}}class Gi extends Ii{constructor(t,e,n){super(new Uint16Array(t),e,n)}}Gi.prototype.isFloat16BufferAttribute=!0;class Vi extends Ii{constructor(t,e,n){super(new Float32Array(t),e,n)}}class Wi extends Ii{constructor(t,e,n){super(new Float64Array(t),e,n)}}let Xi=0;const ji=new zr,Yi=new hi,qi=new lr,Qi=new ur,Zi=new ur,Ji=new lr;class Ki extends Dn{constructor(){super(),Object.defineProperty(this,"id",{value:Xi++}),this.uuid=Bn(),this.name="",this.type="BufferGeometry",this.index=null,this.attributes={},this.morphAttributes={},this.morphTargetsRelative=!1,this.groups=[],this.boundingBox=null,this.boundingSphere=null,this.drawRange={start:0,count:1/0},this.userData={}}getIndex(){return this.index}setIndex(t){return Array.isArray(t)?this.index=new(qn(t)>65535?Hi:zi)(t,1):this.index=t,this}getAttribute(t){return this.attributes[t]}setAttribute(t,e){return this.attributes[t]=e,this}deleteAttribute(t){return delete this.attributes[t],this}hasAttribute(t){return void 0!==this.attributes[t]}addGroup(t,e,n=0){this.groups.push({start:t,count:e,materialIndex:n})}clearGroups(){this.groups=[]}setDrawRange(t,e){this.drawRange.start=t,this.drawRange.count=e}applyMatrix4(t){const e=this.attributes.position;void 0!==e&&(e.applyMatrix4(t),e.needsUpdate=!0);const n=this.attributes.normal;if(void 0!==n){const e=(new Yn).getNormalMatrix(t);n.applyNormalMatrix(e),n.needsUpdate=!0}const r=this.attributes.tangent;return void 0!==r&&(r.transformDirection(t),r.needsUpdate=!0),null!==this.boundingBox&&this.computeBoundingBox(),null!==this.boundingSphere&&this.computeBoundingSphere(),this}applyQuaternion(t){return ji.makeRotationFromQuaternion(t),this.applyMatrix4(ji),this}rotateX(t){return ji.makeRotationX(t),this.applyMatrix4(ji),this}rotateY(t){return ji.makeRotationY(t),this.applyMatrix4(ji),this}rotateZ(t){return ji.makeRotationZ(t),this.applyMatrix4(ji),this}translate(t,e,n){return ji.makeTranslation(t,e,n),this.applyMatrix4(ji),this}scale(t,e,n){return ji.makeScale(t,e,n),this.applyMatrix4(ji),this}lookAt(t){return Yi.lookAt(t),Yi.updateMatrix(),this.applyMatrix4(Yi.matrix),this}center(){return this.computeBoundingBox(),this.boundingBox.getCenter(qi).negate(),this.translate(qi.x,qi.y,qi.z),this}setFromPoints(t){const e=[];for(let n=0,r=t.length;n<r;n++){const r=t[n];e.push(r.x,r.y,r.z||0)}return this.setAttribute("position",new Vi(e,3)),this}computeBoundingBox(){null===this.boundingBox&&(this.boundingBox=new ur);const t=this.attributes.position,e=this.morphAttributes.position;if(t&&t.isGLBufferAttribute)return console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".',this),void this.boundingBox.set(new lr(-1/0,-1/0,-1/0),new lr(1/0,1/0,1/0));if(void 0!==t){if(this.boundingBox.setFromBufferAttribute(t),e)for(let t=0,n=e.length;t<n;t++){const n=e[t];Qi.setFromBufferAttribute(n),this.morphTargetsRelative?(Ji.addVectors(this.boundingBox.min,Qi.min),this.boundingBox.expandByPoint(Ji),Ji.addVectors(this.boundingBox.max,Qi.max),this.boundingBox.expandByPoint(Ji)):(this.boundingBox.expandByPoint(Qi.min),this.boundingBox.expandByPoint(Qi.max))}}else this.boundingBox.makeEmpty();(isNaN(this.boundingBox.min.x)||isNaN(this.boundingBox.min.y)||isNaN(this.boundingBox.min.z))&&console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',this)}computeBoundingSphere(){null===this.boundingSphere&&(this.boundingSphere=new Lr);const t=this.attributes.position,e=this.morphAttributes.position;if(t&&t.isGLBufferAttribute)return console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".',this),void this.boundingSphere.set(new lr,1/0);if(t){const n=this.boundingSphere.center;if(Qi.setFromBufferAttribute(t),e)for(let t=0,n=e.length;t<n;t++){const n=e[t];Zi.setFromBufferAttribute(n),this.morphTargetsRelative?(Ji.addVectors(Qi.min,Zi.min),Qi.expandByPoint(Ji),Ji.addVectors(Qi.max,Zi.max),Qi.expandByPoint(Ji)):(Qi.expandByPoint(Zi.min),Qi.expandByPoint(Zi.max))}Qi.getCenter(n);let r=0;for(let e=0,i=t.count;e<i;e++)Ji.fromBufferAttribute(t,e),r=Math.max(r,n.distanceToSquared(Ji));if(e)for(let i=0,s=e.length;i<s;i++){const s=e[i],a=this.morphTargetsRelative;for(let e=0,i=s.count;e<i;e++)Ji.fromBufferAttribute(s,e),a&&(qi.fromBufferAttribute(t,e),Ji.add(qi)),r=Math.max(r,n.distanceToSquared(Ji))}this.boundingSphere.radius=Math.sqrt(r),isNaN(this.boundingSphere.radius)&&console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',this)}}computeTangents(){const t=this.index,e=this.attributes;if(null===t||void 0===e.position||void 0===e.normal||void 0===e.uv)return void console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");const n=t.array,r=e.position.array,i=e.normal.array,s=e.uv.array,a=r.length/3;void 0===e.tangent&&this.setAttribute("tangent",new Ii(new Float32Array(4*a),4));const o=e.tangent.array,l=[],c=[];for(let t=0;t<a;t++)l[t]=new lr,c[t]=new lr;const h=new lr,u=new lr,d=new lr,p=new jn,f=new jn,m=new jn,g=new lr,v=new lr;function x(t,e,n){h.fromArray(r,3*t),u.fromArray(r,3*e),d.fromArray(r,3*n),p.fromArray(s,2*t),f.fromArray(s,2*e),m.fromArray(s,2*n),u.sub(h),d.sub(h),f.sub(p),m.sub(p);const i=1/(f.x*m.y-m.x*f.y);isFinite(i)&&(g.copy(u).multiplyScalar(m.y).addScaledVector(d,-f.y).multiplyScalar(i),v.copy(d).multiplyScalar(f.x).addScaledVector(u,-m.x).multiplyScalar(i),l[t].add(g),l[e].add(g),l[n].add(g),c[t].add(v),c[e].add(v),c[n].add(v))}let y=this.groups;0===y.length&&(y=[{start:0,count:n.length}]);for(let t=0,e=y.length;t<e;++t){const e=y[t],r=e.start;for(let t=r,i=r+e.count;t<i;t+=3)x(n[t+0],n[t+1],n[t+2])}const w=new lr,b=new lr,_=new lr,M=new lr;function T(t){_.fromArray(i,3*t),M.copy(_);const e=l[t];w.copy(e),w.sub(_.multiplyScalar(_.dot(e))).normalize(),b.crossVectors(M,e);const n=b.dot(c[t])<0?-1:1;o[4*t]=w.x,o[4*t+1]=w.y,o[4*t+2]=w.z,o[4*t+3]=n}for(let t=0,e=y.length;t<e;++t){const e=y[t],r=e.start;for(let t=r,i=r+e.count;t<i;t+=3)T(n[t+0]),T(n[t+1]),T(n[t+2])}}computeVertexNormals(){const t=this.index,e=this.getAttribute("position");if(void 0!==e){let n=this.getAttribute("normal");if(void 0===n)n=new Ii(new Float32Array(3*e.count),3),this.setAttribute("normal",n);else for(let t=0,e=n.count;t<e;t++)n.setXYZ(t,0,0,0);const r=new lr,i=new lr,s=new lr,a=new lr,o=new lr,l=new lr,c=new lr,h=new lr;if(t)for(let u=0,d=t.count;u<d;u+=3){const d=t.getX(u+0),p=t.getX(u+1),f=t.getX(u+2);r.fromBufferAttribute(e,d),i.fromBufferAttribute(e,p),s.fromBufferAttribute(e,f),c.subVectors(s,i),h.subVectors(r,i),c.cross(h),a.fromBufferAttribute(n,d),o.fromBufferAttribute(n,p),l.fromBufferAttribute(n,f),a.add(c),o.add(c),l.add(c),n.setXYZ(d,a.x,a.y,a.z),n.setXYZ(p,o.x,o.y,o.z),n.setXYZ(f,l.x,l.y,l.z)}else for(let t=0,a=e.count;t<a;t+=3)r.fromBufferAttribute(e,t+0),i.fromBufferAttribute(e,t+1),s.fromBufferAttribute(e,t+2),c.subVectors(s,i),h.subVectors(r,i),c.cross(h),n.setXYZ(t+0,c.x,c.y,c.z),n.setXYZ(t+1,c.x,c.y,c.z),n.setXYZ(t+2,c.x,c.y,c.z);this.normalizeNormals(),n.needsUpdate=!0}}merge(t,e){if(!t||!t.isBufferGeometry)return void console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.",t);void 0===e&&(e=0,console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."));const n=this.attributes;for(const r in n){if(void 0===t.attributes[r])continue;const i=n[r].array,s=t.attributes[r],a=s.array,o=s.itemSize*e,l=Math.min(a.length,i.length-o);for(let t=0,e=o;t<l;t++,e++)i[e]=a[t]}return this}normalizeNormals(){const t=this.attributes.normal;for(let e=0,n=t.count;e<n;e++)Ji.fromBufferAttribute(t,e),Ji.normalize(),t.setXYZ(e,Ji.x,Ji.y,Ji.z)}toNonIndexed(){function t(t,e){const n=t.array,r=t.itemSize,i=t.normalized,s=new n.constructor(e.length*r);let a=0,o=0;for(let i=0,l=e.length;i<l;i++){a=t.isInterleavedBufferAttribute?e[i]*t.data.stride+t.offset:e[i]*r;for(let t=0;t<r;t++)s[o++]=n[a++]}return new Ii(s,r,i)}if(null===this.index)return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."),this;const e=new Ki,n=this.index.array,r=this.attributes;for(const i in r){const s=t(r[i],n);e.setAttribute(i,s)}const i=this.morphAttributes;for(const r in i){const s=[],a=i[r];for(let e=0,r=a.length;e<r;e++){const r=t(a[e],n);s.push(r)}e.morphAttributes[r]=s}e.morphTargetsRelative=this.morphTargetsRelative;const s=this.groups;for(let t=0,n=s.length;t<n;t++){const n=s[t];e.addGroup(n.start,n.count,n.materialIndex)}return e}toJSON(){const t={metadata:{version:4.5,type:"BufferGeometry",generator:"BufferGeometry.toJSON"}};if(t.uuid=this.uuid,t.type=this.type,""!==this.name&&(t.name=this.name),Object.keys(this.userData).length>0&&(t.userData=this.userData),void 0!==this.parameters){const e=this.parameters;for(const n in e)void 0!==e[n]&&(t[n]=e[n]);return t}t.data={attributes:{}};const e=this.index;null!==e&&(t.data.index={type:e.array.constructor.name,array:Array.prototype.slice.call(e.array)});const n=this.attributes;for(const e in n){const r=n[e];t.data.attributes[e]=r.toJSON(t.data)}const r={};let i=!1;for(const e in this.morphAttributes){const n=this.morphAttributes[e],s=[];for(let e=0,r=n.length;e<r;e++){const r=n[e];s.push(r.toJSON(t.data))}s.length>0&&(r[e]=s,i=!0)}i&&(t.data.morphAttributes=r,t.data.morphTargetsRelative=this.morphTargetsRelative);const s=this.groups;s.length>0&&(t.data.groups=JSON.parse(JSON.stringify(s)));const a=this.boundingSphere;return null!==a&&(t.data.boundingSphere={center:a.center.toArray(),radius:a.radius}),t}clone(){return(new this.constructor).copy(this)}copy(t){this.index=null,this.attributes={},this.morphAttributes={},this.groups=[],this.boundingBox=null,this.boundingSphere=null;const e={};this.name=t.name;const n=t.index;null!==n&&this.setIndex(n.clone(e));const r=t.attributes;for(const t in r){const n=r[t];this.setAttribute(t,n.clone(e))}const i=t.morphAttributes;for(const t in i){const n=[],r=i[t];for(let t=0,i=r.length;t<i;t++)n.push(r[t].clone(e));this.morphAttributes[t]=n}this.morphTargetsRelative=t.morphTargetsRelative;const s=t.groups;for(let t=0,e=s.length;t<e;t++){const e=s[t];this.addGroup(e.start,e.count,e.materialIndex)}const a=t.boundingBox;null!==a&&(this.boundingBox=a.clone());const o=t.boundingSphere;return null!==o&&(this.boundingSphere=o.clone()),this.drawRange.start=t.drawRange.start,this.drawRange.count=t.drawRange.count,this.userData=t.userData,void 0!==t.parameters&&(this.parameters=Object.assign({},t.parameters)),this}dispose(){this.dispatchEvent({type:"dispose"})}}Ki.prototype.isBufferGeometry=!0;const $i=new zr,ts=new Br,es=new Lr,ns=new lr,rs=new lr,is=new lr,ss=new lr,as=new lr,os=new lr,ls=new lr,cs=new lr,hs=new lr,us=new jn,ds=new jn,ps=new jn,fs=new lr,ms=new lr;class gs extends hi{constructor(t=new Ki,e=new Ri){super(),this.type="Mesh",this.geometry=t,this.material=e,this.updateMorphTargets()}copy(t){return super.copy(t),void 0!==t.morphTargetInfluences&&(this.morphTargetInfluences=t.morphTargetInfluences.slice()),void 0!==t.morphTargetDictionary&&(this.morphTargetDictionary=Object.assign({},t.morphTargetDictionary)),this.material=t.material,this.geometry=t.geometry,this}updateMorphTargets(){const t=this.geometry;if(t.isBufferGeometry){const e=t.morphAttributes,n=Object.keys(e);if(n.length>0){const t=e[n[0]];if(void 0!==t){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let e=0,n=t.length;e<n;e++){const n=t[e].name||String(e);this.morphTargetInfluences.push(0),this.morphTargetDictionary[n]=e}}}}else{const e=t.morphTargets;void 0!==e&&e.length>0&&console.error("THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")}}raycast(t,e){const n=this.geometry,r=this.material,i=this.matrixWorld;if(void 0===r)return;if(null===n.boundingSphere&&n.computeBoundingSphere(),es.copy(n.boundingSphere),es.applyMatrix4(i),!1===t.ray.intersectsSphere(es))return;if($i.copy(i).invert(),ts.copy(t.ray).applyMatrix4($i),null!==n.boundingBox&&!1===ts.intersectsBox(n.boundingBox))return;let s;if(n.isBufferGeometry){const i=n.index,a=n.attributes.position,o=n.morphAttributes.position,l=n.morphTargetsRelative,c=n.attributes.uv,h=n.attributes.uv2,u=n.groups,d=n.drawRange;if(null!==i)if(Array.isArray(r))for(let n=0,p=u.length;n<p;n++){const p=u[n],f=r[p.materialIndex];for(let n=Math.max(p.start,d.start),r=Math.min(i.count,Math.min(p.start+p.count,d.start+d.count));n<r;n+=3){const r=i.getX(n),u=i.getX(n+1),d=i.getX(n+2);s=vs(this,f,t,ts,a,o,l,c,h,r,u,d),s&&(s.faceIndex=Math.floor(n/3),s.face.materialIndex=p.materialIndex,e.push(s))}}else for(let n=Math.max(0,d.start),u=Math.min(i.count,d.start+d.count);n<u;n+=3){const u=i.getX(n),d=i.getX(n+1),p=i.getX(n+2);s=vs(this,r,t,ts,a,o,l,c,h,u,d,p),s&&(s.faceIndex=Math.floor(n/3),e.push(s))}else if(void 0!==a)if(Array.isArray(r))for(let n=0,i=u.length;n<i;n++){const i=u[n],p=r[i.materialIndex];for(let n=Math.max(i.start,d.start),r=Math.min(a.count,Math.min(i.start+i.count,d.start+d.count));n<r;n+=3)s=vs(this,p,t,ts,a,o,l,c,h,n,n+1,n+2),s&&(s.faceIndex=Math.floor(n/3),s.face.materialIndex=i.materialIndex,e.push(s))}else for(let n=Math.max(0,d.start),i=Math.min(a.count,d.start+d.count);n<i;n+=3)s=vs(this,r,t,ts,a,o,l,c,h,n,n+1,n+2),s&&(s.faceIndex=Math.floor(n/3),e.push(s))}else n.isGeometry&&console.error("THREE.Mesh.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")}}function vs(t,e,n,r,i,s,a,o,l,c,h,u){ns.fromBufferAttribute(i,c),rs.fromBufferAttribute(i,h),is.fromBufferAttribute(i,u);const d=t.morphTargetInfluences;if(s&&d){ls.set(0,0,0),cs.set(0,0,0),hs.set(0,0,0);for(let t=0,e=s.length;t<e;t++){const e=d[t],n=s[t];0!==e&&(ss.fromBufferAttribute(n,c),as.fromBufferAttribute(n,h),os.fromBufferAttribute(n,u),a?(ls.addScaledVector(ss,e),cs.addScaledVector(as,e),hs.addScaledVector(os,e)):(ls.addScaledVector(ss.sub(ns),e),cs.addScaledVector(as.sub(rs),e),hs.addScaledVector(os.sub(is),e)))}ns.add(ls),rs.add(cs),is.add(hs)}t.isSkinnedMesh&&(t.boneTransform(c,ns),t.boneTransform(h,rs),t.boneTransform(u,is));const p=function(t,e,n,r,i,s,a,o){let l;if(l=e.side===y?r.intersectTriangle(a,s,i,!0,o):r.intersectTriangle(i,s,a,e.side!==w,o),null===l)return null;ms.copy(o),ms.applyMatrix4(t.matrixWorld);const c=n.ray.origin.distanceTo(ms);return c<n.near||c>n.far?null:{distance:c,point:ms.clone(),object:t}}(t,e,n,r,ns,rs,is,fs);if(p){o&&(us.fromBufferAttribute(o,c),ds.fromBufferAttribute(o,h),ps.fromBufferAttribute(o,u),p.uv=bi.getUV(fs,ns,rs,is,us,ds,ps,new jn)),l&&(us.fromBufferAttribute(l,c),ds.fromBufferAttribute(l,h),ps.fromBufferAttribute(l,u),p.uv2=bi.getUV(fs,ns,rs,is,us,ds,ps,new jn));const t={a:c,b:h,c:u,normal:new lr,materialIndex:0};bi.getNormal(ns,rs,is,t.normal),p.face=t}return p}gs.prototype.isMesh=!0;class xs extends Ki{constructor(t=1,e=1,n=1,r=1,i=1,s=1){super(),this.type="BoxGeometry",this.parameters={width:t,height:e,depth:n,widthSegments:r,heightSegments:i,depthSegments:s};const a=this;r=Math.floor(r),i=Math.floor(i),s=Math.floor(s);const o=[],l=[],c=[],h=[];let u=0,d=0;function p(t,e,n,r,i,s,p,f,m,g,v){const x=s/m,y=p/g,w=s/2,b=p/2,_=f/2,M=m+1,T=g+1;let S=0,A=0;const E=new lr;for(let s=0;s<T;s++){const a=s*y-b;for(let o=0;o<M;o++){const u=o*x-w;E[t]=u*r,E[e]=a*i,E[n]=_,l.push(E.x,E.y,E.z),E[t]=0,E[e]=0,E[n]=f>0?1:-1,c.push(E.x,E.y,E.z),h.push(o/m),h.push(1-s/g),S+=1}}for(let t=0;t<g;t++)for(let e=0;e<m;e++){const n=u+e+M*t,r=u+e+M*(t+1),i=u+(e+1)+M*(t+1),s=u+(e+1)+M*t;o.push(n,r,s),o.push(r,i,s),A+=6}a.addGroup(d,A,v),d+=A,u+=S}p("z","y","x",-1,-1,n,e,t,s,i,0),p("z","y","x",1,-1,n,e,-t,s,i,1),p("x","z","y",1,1,t,n,e,r,s,2),p("x","z","y",1,-1,t,n,-e,r,s,3),p("x","y","z",1,-1,t,e,n,r,i,4),p("x","y","z",-1,-1,t,e,-n,r,i,5),this.setIndex(o),this.setAttribute("position",new Vi(l,3)),this.setAttribute("normal",new Vi(c,3)),this.setAttribute("uv",new Vi(h,2))}static fromJSON(t){return new xs(t.width,t.height,t.depth,t.widthSegments,t.heightSegments,t.depthSegments)}}function ys(t){const e={};for(const n in t){e[n]={};for(const r in t[n]){const i=t[n][r];i&&(i.isColor||i.isMatrix3||i.isMatrix4||i.isVector2||i.isVector3||i.isVector4||i.isTexture||i.isQuaternion)?e[n][r]=i.clone():Array.isArray(i)?e[n][r]=i.slice():e[n][r]=i}}return e}function ws(t){const e={};for(let n=0;n<t.length;n++){const r=ys(t[n]);for(const t in r)e[t]=r[t]}return e}const bs={clone:ys,merge:ws};class _s extends Mi{constructor(t){super(),this.type="ShaderMaterial",this.defines={},this.uniforms={},this.vertexShader="void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",this.fragmentShader="void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}",this.linewidth=1,this.wireframe=!1,this.wireframeLinewidth=1,this.fog=!1,this.lights=!1,this.clipping=!1,this.extensions={derivatives:!1,fragDepth:!1,drawBuffers:!1,shaderTextureLOD:!1},this.defaultAttributeValues={color:[1,1,1],uv:[0,0],uv2:[0,0]},this.index0AttributeName=void 0,this.uniformsNeedUpdate=!1,this.glslVersion=null,void 0!==t&&(void 0!==t.attributes&&console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."),this.setValues(t))}copy(t){return super.copy(t),this.fragmentShader=t.fragmentShader,this.vertexShader=t.vertexShader,this.uniforms=ys(t.uniforms),this.defines=Object.assign({},t.defines),this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.lights=t.lights,this.clipping=t.clipping,this.extensions=Object.assign({},t.extensions),this.glslVersion=t.glslVersion,this}toJSON(t){const e=super.toJSON(t);e.glslVersion=this.glslVersion,e.uniforms={};for(const n in this.uniforms){const r=this.uniforms[n].value;r&&r.isTexture?e.uniforms[n]={type:"t",value:r.toJSON(t).uuid}:r&&r.isColor?e.uniforms[n]={type:"c",value:r.getHex()}:r&&r.isVector2?e.uniforms[n]={type:"v2",value:r.toArray()}:r&&r.isVector3?e.uniforms[n]={type:"v3",value:r.toArray()}:r&&r.isVector4?e.uniforms[n]={type:"v4",value:r.toArray()}:r&&r.isMatrix3?e.uniforms[n]={type:"m3",value:r.toArray()}:r&&r.isMatrix4?e.uniforms[n]={type:"m4",value:r.toArray()}:e.uniforms[n]={value:r}}Object.keys(this.defines).length>0&&(e.defines=this.defines),e.vertexShader=this.vertexShader,e.fragmentShader=this.fragmentShader;const n={};for(const t in this.extensions)!0===this.extensions[t]&&(n[t]=!0);return Object.keys(n).length>0&&(e.extensions=n),e}}_s.prototype.isShaderMaterial=!0;class Ms extends hi{constructor(){super(),this.type="Camera",this.matrixWorldInverse=new zr,this.projectionMatrix=new zr,this.projectionMatrixInverse=new zr}copy(t,e){return super.copy(t,e),this.matrixWorldInverse.copy(t.matrixWorldInverse),this.projectionMatrix.copy(t.projectionMatrix),this.projectionMatrixInverse.copy(t.projectionMatrixInverse),this}getWorldDirection(t){this.updateWorldMatrix(!0,!1);const e=this.matrixWorld.elements;return t.set(-e[8],-e[9],-e[10]).normalize()}updateMatrixWorld(t){super.updateMatrixWorld(t),this.matrixWorldInverse.copy(this.matrixWorld).invert()}updateWorldMatrix(t,e){super.updateWorldMatrix(t,e),this.matrixWorldInverse.copy(this.matrixWorld).invert()}clone(){return(new this.constructor).copy(this)}}Ms.prototype.isCamera=!0;class Ts extends Ms{constructor(t=50,e=1,n=.1,r=2e3){super(),this.type="PerspectiveCamera",this.fov=t,this.zoom=1,this.near=n,this.far=r,this.focus=10,this.aspect=e,this.view=null,this.filmGauge=35,this.filmOffset=0,this.updateProjectionMatrix()}copy(t,e){return super.copy(t,e),this.fov=t.fov,this.zoom=t.zoom,this.near=t.near,this.far=t.far,this.focus=t.focus,this.aspect=t.aspect,this.view=null===t.view?null:Object.assign({},t.view),this.filmGauge=t.filmGauge,this.filmOffset=t.filmOffset,this}setFocalLength(t){const e=.5*this.getFilmHeight()/t;this.fov=2*On*Math.atan(e),this.updateProjectionMatrix()}getFocalLength(){const t=Math.tan(.5*Nn*this.fov);return.5*this.getFilmHeight()/t}getEffectiveFOV(){return 2*On*Math.atan(Math.tan(.5*Nn*this.fov)/this.zoom)}getFilmWidth(){return this.filmGauge*Math.min(this.aspect,1)}getFilmHeight(){return this.filmGauge/Math.max(this.aspect,1)}setViewOffset(t,e,n,r,i,s){this.aspect=t/e,null===this.view&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=t,this.view.fullHeight=e,this.view.offsetX=n,this.view.offsetY=r,this.view.width=i,this.view.height=s,this.updateProjectionMatrix()}clearViewOffset(){null!==this.view&&(this.view.enabled=!1),this.updateProjectionMatrix()}updateProjectionMatrix(){const t=this.near;let e=t*Math.tan(.5*Nn*this.fov)/this.zoom,n=2*e,r=this.aspect*n,i=-.5*r;const s=this.view;if(null!==this.view&&this.view.enabled){const t=s.fullWidth,a=s.fullHeight;i+=s.offsetX*r/t,e-=s.offsetY*n/a,r*=s.width/t,n*=s.height/a}const a=this.filmOffset;0!==a&&(i+=t*a/this.getFilmWidth()),this.projectionMatrix.makePerspective(i,i+r,e,e-n,t,this.far),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()}toJSON(t){const e=super.toJSON(t);return e.object.fov=this.fov,e.object.zoom=this.zoom,e.object.near=this.near,e.object.far=this.far,e.object.focus=this.focus,e.object.aspect=this.aspect,null!==this.view&&(e.object.view=Object.assign({},this.view)),e.object.filmGauge=this.filmGauge,e.object.filmOffset=this.filmOffset,e}}Ts.prototype.isPerspectiveCamera=!0;const Ss=90;class As extends hi{constructor(t,e,n){if(super(),this.type="CubeCamera",!0!==n.isWebGLCubeRenderTarget)return void console.error("THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.");this.renderTarget=n;const r=new Ts(Ss,1,t,e);r.layers=this.layers,r.up.set(0,-1,0),r.lookAt(new lr(1,0,0)),this.add(r);const i=new Ts(Ss,1,t,e);i.layers=this.layers,i.up.set(0,-1,0),i.lookAt(new lr(-1,0,0)),this.add(i);const s=new Ts(Ss,1,t,e);s.layers=this.layers,s.up.set(0,0,1),s.lookAt(new lr(0,1,0)),this.add(s);const a=new Ts(Ss,1,t,e);a.layers=this.layers,a.up.set(0,0,-1),a.lookAt(new lr(0,-1,0)),this.add(a);const o=new Ts(Ss,1,t,e);o.layers=this.layers,o.up.set(0,-1,0),o.lookAt(new lr(0,0,1)),this.add(o);const l=new Ts(Ss,1,t,e);l.layers=this.layers,l.up.set(0,-1,0),l.lookAt(new lr(0,0,-1)),this.add(l)}update(t,e){null===this.parent&&this.updateMatrixWorld();const n=this.renderTarget,[r,i,s,a,o,l]=this.children,c=t.xr.enabled,h=t.getRenderTarget();t.xr.enabled=!1;const u=n.texture.generateMipmaps;n.texture.generateMipmaps=!1,t.setRenderTarget(n,0),t.render(e,r),t.setRenderTarget(n,1),t.render(e,i),t.setRenderTarget(n,2),t.render(e,s),t.setRenderTarget(n,3),t.render(e,a),t.setRenderTarget(n,4),t.render(e,o),n.texture.generateMipmaps=u,t.setRenderTarget(n,5),t.render(e,l),t.setRenderTarget(h),t.xr.enabled=c}}class Es extends er{constructor(t,e,n,r,i,s,a,o,l,c){super(t=void 0!==t?t:[],e=void 0!==e?e:ct,n,r,i,s,a,o,l,c),this.flipY=!1}get images(){return this.image}set images(t){this.image=t}}Es.prototype.isCubeTexture=!0;class Cs extends ir{constructor(t,e,n){Number.isInteger(e)&&(console.warn("THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )"),e=n),super(t,t,e),e=e||{},this.texture=new Es(void 0,e.mapping,e.wrapS,e.wrapT,e.magFilter,e.minFilter,e.format,e.type,e.anisotropy,e.encoding),this.texture.isRenderTargetTexture=!0,this.texture.generateMipmaps=void 0!==e.generateMipmaps&&e.generateMipmaps,this.texture.minFilter=void 0!==e.minFilter?e.minFilter:Mt,this.texture._needsFlipEnvMap=!1}fromEquirectangularTexture(t,e){this.texture.type=e.type,this.texture.format=Gt,this.texture.encoding=e.encoding,this.texture.generateMipmaps=e.generateMipmaps,this.texture.minFilter=e.minFilter,this.texture.magFilter=e.magFilter;const n={tEquirect:{value:null}},r="\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\tvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n\t\t\t\t\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvWorldDirection = transformDirection( position, modelMatrix );\n\n\t\t\t\t\t#include <begin_vertex>\n\t\t\t\t\t#include <project_vertex>\n\n\t\t\t\t}\n\t\t\t",i="\n\n\t\t\t\tuniform sampler2D tEquirect;\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\t#include <common>\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec3 direction = normalize( vWorldDirection );\n\n\t\t\t\t\tvec2 sampleUV = equirectUv( direction );\n\n\t\t\t\t\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\n\t\t\t\t}\n\t\t\t",s=new xs(5,5,5),a=new _s({name:"CubemapFromEquirect",uniforms:ys(n),vertexShader:r,fragmentShader:i,side:y,blending:M});a.uniforms.tEquirect.value=e;const o=new gs(s,a),l=e.minFilter;return e.minFilter===At&&(e.minFilter=Mt),new As(1,10,this).update(t,o),e.minFilter=l,o.geometry.dispose(),o.material.dispose(),this}clear(t,e,n,r){const i=t.getRenderTarget();for(let i=0;i<6;i++)t.setRenderTarget(this,i),t.clear(e,n,r);t.setRenderTarget(i)}}Cs.prototype.isWebGLCubeRenderTarget=!0;const Ps=new lr,Ls=new lr,Rs=new Yn;class Fs{constructor(t=new lr(1,0,0),e=0){this.normal=t,this.constant=e}set(t,e){return this.normal.copy(t),this.constant=e,this}setComponents(t,e,n,r){return this.normal.set(t,e,n),this.constant=r,this}setFromNormalAndCoplanarPoint(t,e){return this.normal.copy(t),this.constant=-e.dot(this.normal),this}setFromCoplanarPoints(t,e,n){const r=Ps.subVectors(n,e).cross(Ls.subVectors(t,e)).normalize();return this.setFromNormalAndCoplanarPoint(r,t),this}copy(t){return this.normal.copy(t.normal),this.constant=t.constant,this}normalize(){const t=1/this.normal.length();return this.normal.multiplyScalar(t),this.constant*=t,this}negate(){return this.constant*=-1,this.normal.negate(),this}distanceToPoint(t){return this.normal.dot(t)+this.constant}distanceToSphere(t){return this.distanceToPoint(t.center)-t.radius}projectPoint(t,e){return e.copy(this.normal).multiplyScalar(-this.distanceToPoint(t)).add(t)}intersectLine(t,e){const n=t.delta(Ps),r=this.normal.dot(n);if(0===r)return 0===this.distanceToPoint(t.start)?e.copy(t.start):null;const i=-(t.start.dot(this.normal)+this.constant)/r;return i<0||i>1?null:e.copy(n).multiplyScalar(i).add(t.start)}intersectsLine(t){const e=this.distanceToPoint(t.start),n=this.distanceToPoint(t.end);return e<0&&n>0||n<0&&e>0}intersectsBox(t){return t.intersectsPlane(this)}intersectsSphere(t){return t.intersectsPlane(this)}coplanarPoint(t){return t.copy(this.normal).multiplyScalar(-this.constant)}applyMatrix4(t,e){const n=e||Rs.getNormalMatrix(t),r=this.coplanarPoint(Ps).applyMatrix4(t),i=this.normal.applyMatrix3(n).normalize();return this.constant=-r.dot(i),this}translate(t){return this.constant-=t.dot(this.normal),this}equals(t){return t.normal.equals(this.normal)&&t.constant===this.constant}clone(){return(new this.constructor).copy(this)}}Fs.prototype.isPlane=!0;const Ds=new Lr,Is=new lr;class Us{constructor(t=new Fs,e=new Fs,n=new Fs,r=new Fs,i=new Fs,s=new Fs){this.planes=[t,e,n,r,i,s]}set(t,e,n,r,i,s){const a=this.planes;return a[0].copy(t),a[1].copy(e),a[2].copy(n),a[3].copy(r),a[4].copy(i),a[5].copy(s),this}copy(t){const e=this.planes;for(let n=0;n<6;n++)e[n].copy(t.planes[n]);return this}setFromProjectionMatrix(t){const e=this.planes,n=t.elements,r=n[0],i=n[1],s=n[2],a=n[3],o=n[4],l=n[5],c=n[6],h=n[7],u=n[8],d=n[9],p=n[10],f=n[11],m=n[12],g=n[13],v=n[14],x=n[15];return e[0].setComponents(a-r,h-o,f-u,x-m).normalize(),e[1].setComponents(a+r,h+o,f+u,x+m).normalize(),e[2].setComponents(a+i,h+l,f+d,x+g).normalize(),e[3].setComponents(a-i,h-l,f-d,x-g).normalize(),e[4].setComponents(a-s,h-c,f-p,x-v).normalize(),e[5].setComponents(a+s,h+c,f+p,x+v).normalize(),this}intersectsObject(t){const e=t.geometry;return null===e.boundingSphere&&e.computeBoundingSphere(),Ds.copy(e.boundingSphere).applyMatrix4(t.matrixWorld),this.intersectsSphere(Ds)}intersectsSprite(t){return Ds.center.set(0,0,0),Ds.radius=.7071067811865476,Ds.applyMatrix4(t.matrixWorld),this.intersectsSphere(Ds)}intersectsSphere(t){const e=this.planes,n=t.center,r=-t.radius;for(let t=0;t<6;t++)if(e[t].distanceToPoint(n)<r)return!1;return!0}intersectsBox(t){const e=this.planes;for(let n=0;n<6;n++){const r=e[n];if(Is.x=r.normal.x>0?t.max.x:t.min.x,Is.y=r.normal.y>0?t.max.y:t.min.y,Is.z=r.normal.z>0?t.max.z:t.min.z,r.distanceToPoint(Is)<0)return!1}return!0}containsPoint(t){const e=this.planes;for(let n=0;n<6;n++)if(e[n].distanceToPoint(t)<0)return!1;return!0}clone(){return(new this.constructor).copy(this)}}function Ns(){let t=null,e=!1,n=null,r=null;function i(e,s){n(e,s),r=t.requestAnimationFrame(i)}return{start:function(){!0!==e&&null!==n&&(r=t.requestAnimationFrame(i),e=!0)},stop:function(){t.cancelAnimationFrame(r),e=!1},setAnimationLoop:function(t){n=t},setContext:function(e){t=e}}}function Os(t,e){const n=e.isWebGL2,r=new WeakMap;return{get:function(t){return t.isInterleavedBufferAttribute&&(t=t.data),r.get(t)},remove:function(e){e.isInterleavedBufferAttribute&&(e=e.data);const n=r.get(e);n&&(t.deleteBuffer(n.buffer),r.delete(e))},update:function(e,i){if(e.isGLBufferAttribute){const t=r.get(e);return void((!t||t.version<e.version)&&r.set(e,{buffer:e.buffer,type:e.type,bytesPerElement:e.elementSize,version:e.version}))}e.isInterleavedBufferAttribute&&(e=e.data);const s=r.get(e);void 0===s?r.set(e,function(e,r){const i=e.array,s=e.usage,a=t.createBuffer();t.bindBuffer(r,a),t.bufferData(r,i,s),e.onUploadCallback();let o=5126;return i instanceof Float32Array?o=5126:i instanceof Float64Array?console.warn("THREE.WebGLAttributes: Unsupported data buffer format: Float64Array."):i instanceof Uint16Array?e.isFloat16BufferAttribute?n?o=5131:console.warn("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2."):o=5123:i instanceof Int16Array?o=5122:i instanceof Uint32Array?o=5125:i instanceof Int32Array?o=5124:i instanceof Int8Array?o=5120:(i instanceof Uint8Array||i instanceof Uint8ClampedArray)&&(o=5121),{buffer:a,type:o,bytesPerElement:i.BYTES_PER_ELEMENT,version:e.version}}(e,i)):s.version<e.version&&(function(e,r,i){const s=r.array,a=r.updateRange;t.bindBuffer(i,e),-1===a.count?t.bufferSubData(i,0,s):(n?t.bufferSubData(i,a.offset*s.BYTES_PER_ELEMENT,s,a.offset,a.count):t.bufferSubData(i,a.offset*s.BYTES_PER_ELEMENT,s.subarray(a.offset,a.offset+a.count)),a.count=-1)}(s.buffer,e,i),s.version=e.version)}}}class Bs extends Ki{constructor(t=1,e=1,n=1,r=1){super(),this.type="PlaneGeometry",this.parameters={width:t,height:e,widthSegments:n,heightSegments:r};const i=t/2,s=e/2,a=Math.floor(n),o=Math.floor(r),l=a+1,c=o+1,h=t/a,u=e/o,d=[],p=[],f=[],m=[];for(let t=0;t<c;t++){const e=t*u-s;for(let n=0;n<l;n++){const r=n*h-i;p.push(r,-e,0),f.push(0,0,1),m.push(n/a),m.push(1-t/o)}}for(let t=0;t<o;t++)for(let e=0;e<a;e++){const n=e+l*t,r=e+l*(t+1),i=e+1+l*(t+1),s=e+1+l*t;d.push(n,r,s),d.push(r,i,s)}this.setIndex(d),this.setAttribute("position",new Vi(p,3)),this.setAttribute("normal",new Vi(f,3)),this.setAttribute("uv",new Vi(m,2))}static fromJSON(t){return new Bs(t.width,t.height,t.widthSegments,t.heightSegments)}}const zs={alphamap_fragment:"#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif",alphamap_pars_fragment:"#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",alphatest_fragment:"#ifdef USE_ALPHATEST\n\tif ( diffuseColor.a < alphaTest ) discard;\n#endif",alphatest_pars_fragment:"#ifdef USE_ALPHATEST\n\tuniform float alphaTest;\n#endif",aomap_fragment:"#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n\t#endif\n#endif",aomap_pars_fragment:"#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif",begin_vertex:"vec3 transformed = vec3( position );",beginnormal_vertex:"vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif",bsdfs:"vec3 BRDF_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nfloat V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( f0, f90, dotVH );\n\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( V * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, 1.0, dotVH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie( float roughness, float dotNH ) {\n\tfloat alpha = pow2( roughness );\n\tfloat invAlpha = 1.0 / alpha;\n\tfloat cos2h = dotNH * dotNH;\n\tfloat sin2h = max( 1.0 - cos2h, 0.0078125 );\n\treturn ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );\n}\nfloat V_Neubelt( float dotNV, float dotNL ) {\n\treturn saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );\n}\nvec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat D = D_Charlie( sheenRoughness, dotNH );\n\tfloat V = V_Neubelt( dotNV, dotNL );\n\treturn sheenColor * ( D * V );\n}\n#endif",bumpmap_pars_fragment:"#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 ) * faceDirection;\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif",clipping_planes_fragment:"#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#pragma unroll_loop_end\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\tif ( clipped ) discard;\n\t#endif\n#endif",clipping_planes_pars_fragment:"#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif",clipping_planes_pars_vertex:"#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif",clipping_planes_vertex:"#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif",color_fragment:"#if defined( USE_COLOR_ALPHA )\n\tdiffuseColor *= vColor;\n#elif defined( USE_COLOR )\n\tdiffuseColor.rgb *= vColor;\n#endif",color_pars_fragment:"#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR )\n\tvarying vec3 vColor;\n#endif",color_pars_vertex:"#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvarying vec3 vColor;\n#endif",color_vertex:"#if defined( USE_COLOR_ALPHA )\n\tvColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif",common:"#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}",cube_uv_reflection_fragment:"#ifdef ENVMAP_TYPE_CUBE_UV\n\t#define cubeUV_maxMipLevel 8.0\n\t#define cubeUV_minMipLevel 4.0\n\t#define cubeUV_maxTileSize 256.0\n\t#define cubeUV_minTileSize 16.0\n\tfloat getFace( vec3 direction ) {\n\t\tvec3 absDirection = abs( direction );\n\t\tfloat face = - 1.0;\n\t\tif ( absDirection.x > absDirection.z ) {\n\t\t\tif ( absDirection.x > absDirection.y )\n\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t} else {\n\t\t\tif ( absDirection.z > absDirection.y )\n\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t}\n\t\treturn face;\n\t}\n\tvec2 getUV( vec3 direction, float face ) {\n\t\tvec2 uv;\n\t\tif ( face == 0.0 ) {\n\t\t\tuv = vec2( direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 1.0 ) {\n\t\t\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n\t\t} else if ( face == 2.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.y ) / abs( direction.z );\n\t\t} else if ( face == 3.0 ) {\n\t\t\tuv = vec2( - direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 4.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.z ) / abs( direction.y );\n\t\t} else {\n\t\t\tuv = vec2( direction.x, direction.y ) / abs( direction.z );\n\t\t}\n\t\treturn 0.5 * ( uv + 1.0 );\n\t}\n\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n\t\tfloat face = getFace( direction );\n\t\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n\t\tmipInt = max( mipInt, cubeUV_minMipLevel );\n\t\tfloat faceSize = exp2( mipInt );\n\t\tfloat texelSize = 1.0 / ( 3.0 * cubeUV_maxTileSize );\n\t\tvec2 uv = getUV( direction, face ) * ( faceSize - 1.0 ) + 0.5;\n\t\tif ( face > 2.0 ) {\n\t\t\tuv.y += faceSize;\n\t\t\tface -= 3.0;\n\t\t}\n\t\tuv.x += face * faceSize;\n\t\tif ( mipInt < cubeUV_maxMipLevel ) {\n\t\t\tuv.y += 2.0 * cubeUV_maxTileSize;\n\t\t}\n\t\tuv.y += filterInt * 2.0 * cubeUV_minTileSize;\n\t\tuv.x += 3.0 * max( 0.0, cubeUV_maxTileSize - 2.0 * faceSize );\n\t\tuv *= texelSize;\n\t\treturn texture2D( envMap, uv ).rgb;\n\t}\n\t#define r0 1.0\n\t#define v0 0.339\n\t#define m0 - 2.0\n\t#define r1 0.8\n\t#define v1 0.276\n\t#define m1 - 1.0\n\t#define r4 0.4\n\t#define v4 0.046\n\t#define m4 2.0\n\t#define r5 0.305\n\t#define v5 0.016\n\t#define m5 3.0\n\t#define r6 0.21\n\t#define v6 0.0038\n\t#define m6 4.0\n\tfloat roughnessToMip( float roughness ) {\n\t\tfloat mip = 0.0;\n\t\tif ( roughness >= r1 ) {\n\t\t\tmip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;\n\t\t} else if ( roughness >= r4 ) {\n\t\t\tmip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;\n\t\t} else if ( roughness >= r5 ) {\n\t\t\tmip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;\n\t\t} else if ( roughness >= r6 ) {\n\t\t\tmip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;\n\t\t} else {\n\t\t\tmip = - 2.0 * log2( 1.16 * roughness );\t\t}\n\t\treturn mip;\n\t}\n\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n\t\tfloat mip = clamp( roughnessToMip( roughness ), m0, cubeUV_maxMipLevel );\n\t\tfloat mipF = fract( mip );\n\t\tfloat mipInt = floor( mip );\n\t\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n\t\tif ( mipF == 0.0 ) {\n\t\t\treturn vec4( color0, 1.0 );\n\t\t} else {\n\t\t\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n\t\t\treturn vec4( mix( color0, color1, mipF ), 1.0 );\n\t\t}\n\t}\n#endif",defaultnormal_vertex:"vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif",displacementmap_pars_vertex:"#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif",displacementmap_vertex:"#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif",emissivemap_fragment:"#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif",emissivemap_pars_fragment:"#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif",encodings_fragment:"gl_FragColor = linearToOutputTexel( gl_FragColor );",encodings_pars_fragment:"vec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}",envmap_fragment:"#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t\tenvColor = envMapTexelToLinear( envColor );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif",envmap_common_pars_fragment:"#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif",envmap_pars_fragment:"#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif",envmap_pars_vertex:"#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif",envmap_physical_pars_fragment:"#if defined( USE_ENVMAP )\n\t#ifdef ENVMAP_MODE_REFRACTION\n\t\tuniform float refractionRatio;\n\t#endif\n\tvec3 getIBLIrradiance( const in vec3 normal ) {\n\t\t#if defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n\t\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n\tvec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {\n\t\t#if defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 reflectVec;\n\t\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\t\treflectVec = reflect( - viewDir, normal );\n\t\t\t\treflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t\t#else\n\t\t\t\treflectVec = refract( - viewDir, normal, refractionRatio );\n\t\t\t#endif\n\t\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n\t\t\treturn envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n#endif",envmap_vertex:"#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif",fog_vertex:"#ifdef USE_FOG\n\tvFogDepth = - mvPosition.z;\n#endif",fog_pars_vertex:"#ifdef USE_FOG\n\tvarying float vFogDepth;\n#endif",fog_fragment:"#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif",fog_pars_fragment:"#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float vFogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif",gradientmap_pars_fragment:"#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn vec3( texture2D( gradientMap, coord ).r );\n\t#else\n\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t#endif\n}",lightmap_fragment:"#ifdef USE_LIGHTMAP\n\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\tvec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tlightMapIrradiance *= PI;\n\t#endif\n\treflectedLight.indirectDiffuse += lightMapIrradiance;\n#endif",lightmap_pars_fragment:"#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif",lights_lambert_vertex:"vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n\tvIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\nvIndirectFront += getAmbientLightIrradiance( ambientLightColor );\nvIndirectFront += getLightProbeIrradiance( lightProbe, geometry.normal );\n#ifdef DOUBLE_SIDED\n\tvIndirectBack += getAmbientLightIrradiance( ambientLightColor );\n\tvIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry.normal );\n#endif\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointLightInfo( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotLightInfo( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalLightInfo( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry.normal );\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif",lights_pars_begin:"uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {\n\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\treturn irradiance;\n}\nfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\t#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\t\tif ( cutoffDistance > 0.0 ) {\n\t\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t\t}\n\t\treturn distanceFalloff;\n\t#else\n\t\tif ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\t\treturn pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t\t}\n\t\treturn 1.0;\n\t#endif\n}\nfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\n\treturn smoothstep( coneCosine, penumbraCosine, angleCosine );\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tlight.color = directionalLight.color;\n\t\tlight.direction = directionalLight.direction;\n\t\tlight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tlight.color = pointLight.color;\n\t\tlight.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );\n\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat angleCos = dot( light.direction, spotLight.direction );\n\t\tfloat spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\tif ( spotAttenuation > 0.0 ) {\n\t\t\tfloat lightDistance = length( lVector );\n\t\t\tlight.color = spotLight.color * spotAttenuation;\n\t\t\tlight.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t\t} else {\n\t\t\tlight.color = vec3( 0.0 );\n\t\t\tlight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {\n\t\tfloat dotNL = dot( normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\treturn irradiance;\n\t}\n#endif",lights_toon_fragment:"ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;",lights_toon_pars_fragment:"varying vec3 vViewPosition;\nstruct ToonMaterial {\n\tvec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon\n#define Material_LightProbeLOD( material )\t(0)",lights_phong_fragment:"BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;",lights_phong_pars_fragment:"varying vec3 vViewPosition;\nstruct BlinnPhongMaterial {\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat specularShininess;\n\tfloat specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)",lights_physical_fragment:"PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;\nmaterial.roughness = min( material.roughness, 1.0 );\n#ifdef IOR\n\t#ifdef SPECULAR\n\t\tfloat specularIntensityFactor = specularIntensity;\n\t\tvec3 specularColorFactor = specularColor;\n\t\t#ifdef USE_SPECULARINTENSITYMAP\n\t\t\tspecularIntensityFactor *= texture2D( specularIntensityMap, vUv ).a;\n\t\t#endif\n\t\t#ifdef USE_SPECULARCOLORMAP\n\t\t\tspecularColorFactor *= specularColorMapTexelToLinear( texture2D( specularColorMap, vUv ) ).rgb;\n\t\t#endif\n\t\tmaterial.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );\n\t#else\n\t\tfloat specularIntensityFactor = 1.0;\n\t\tvec3 specularColorFactor = vec3( 1.0 );\n\t\tmaterial.specularF90 = 1.0;\n\t#endif\n\tmaterial.specularColor = mix( min( pow2( ( ior - 1.0 ) / ( ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.specularF90 = 1.0;\n#endif\n#ifdef USE_CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\tmaterial.clearcoatF0 = vec3( 0.04 );\n\tmaterial.clearcoatF90 = 1.0;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheenColor;\n\t#ifdef USE_SHEENCOLORMAP\n\t\tmaterial.sheenColor *= sheenColorMapTexelToLinear( texture2D( sheenColorMap, vUv ) ).rgb;\n\t#endif\n\tmaterial.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );\n\t#ifdef USE_SHEENROUGHNESSMAP\n\t\tmaterial.sheenRoughness *= texture2D( sheenRoughnessMap, vUv ).a;\n\t#endif\n#endif",lights_physical_pars_fragment:"struct PhysicalMaterial {\n\tvec3 diffuseColor;\n\tfloat roughness;\n\tvec3 specularColor;\n\tfloat specularF90;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat clearcoat;\n\t\tfloat clearcoatRoughness;\n\t\tvec3 clearcoatF0;\n\t\tfloat clearcoatF90;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tvec3 sheenColor;\n\t\tfloat sheenRoughness;\n\t#endif\n};\nvec3 clearcoatSpecular = vec3( 0.0 );\nvec3 sheenSpecular = vec3( 0.0 );\nfloat IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat r2 = roughness * roughness;\n\tfloat a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;\n\tfloat b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;\n\tfloat DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );\n\treturn saturate( DG * RECIPROCAL_PI );\n}\nvec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;\n\treturn fab;\n}\nvec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\treturn specularColor * fab.x + specularF90 * fab.y;\n}\nvoid computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\tvec3 FssEss = specularColor * fab.x + specularF90 * fab.y;\n\tfloat Ess = fab.x + fab.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.roughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = dotNLcc * directLight.color;\n\t\tclearcoatSpecular += ccIrradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.clearcoatNormal, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecular += irradiance * BRDF_Sheen( directLight.direction, geometry.viewDir, geometry.normal, material.sheenColor, material.sheenRoughness );\n\t#endif\n\treflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.roughness );\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecular += irradiance * material.sheenColor * IBLSheenBRDF( geometry.normal, geometry.viewDir, material.sheenRoughness );\n\t#endif\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\tcomputeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\n\treflectedLight.indirectSpecular += radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}",lights_fragment_begin:"\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef USE_CLEARCOAT\n\tgeometry.clearcoatNormal = clearcoatNormal;\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointLightInfo( pointLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotLightInfo( spotLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalLightInfo( directionalLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry.normal );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif",lights_fragment_maps:"#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\t\tvec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getIBLIrradiance( geometry.normal );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );\n\t#endif\n#endif",lights_fragment_end:"#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif",logdepthbuf_fragment:"#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif",logdepthbuf_pars_fragment:"#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif",logdepthbuf_pars_vertex:"#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif",logdepthbuf_vertex:"#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif",map_fragment:"#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif",map_pars_fragment:"#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif",map_particle_fragment:"#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n\tvec4 mapTexel = texture2D( map, uv );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif",map_particle_pars_fragment:"#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tuniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",metalnessmap_fragment:"float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif",metalnessmap_pars_fragment:"#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif",morphnormal_vertex:"#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] > 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1, 2 ) * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\t\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\t\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\t\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n\t#endif\n#endif",morphtarget_pars_vertex:"#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tuniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n\t\tuniform sampler2DArray morphTargetsTexture;\n\t\tuniform vec2 morphTargetsTextureSize;\n\t\tvec3 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset, const in int stride ) {\n\t\t\tfloat texelIndex = float( vertexIndex * stride + offset );\n\t\t\tfloat y = floor( texelIndex / morphTargetsTextureSize.x );\n\t\t\tfloat x = texelIndex - y * morphTargetsTextureSize.x;\n\t\t\tvec3 morphUV = vec3( ( x + 0.5 ) / morphTargetsTextureSize.x, y / morphTargetsTextureSize.y, morphTargetIndex );\n\t\t\treturn texture( morphTargetsTexture, morphUV ).xyz;\n\t\t}\n\t#else\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\tuniform float morphTargetInfluences[ 8 ];\n\t\t#else\n\t\t\tuniform float morphTargetInfluences[ 4 ];\n\t\t#endif\n\t#endif\n#endif",morphtarget_vertex:"#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\t#ifndef USE_MORPHNORMALS\n\t\t\t\tif ( morphTargetInfluences[ i ] > 0.0 ) transformed += getMorph( gl_VertexID, i, 0, 1 ) * morphTargetInfluences[ i ];\n\t\t\t#else\n\t\t\t\tif ( morphTargetInfluences[ i ] > 0.0 ) transformed += getMorph( gl_VertexID, i, 0, 2 ) * morphTargetInfluences[ i ];\n\t\t\t#endif\n\t\t}\n\t#else\n\t\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\t\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\t\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\t\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\t\t\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\t\t\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\t\t\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t\t#endif\n\t#endif\n#endif",normal_fragment_begin:"float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * faceDirection;\n\t\t\tbitangent = bitangent * faceDirection;\n\t\t#endif\n\t\t#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\t#endif\n\t#endif\n#endif\nvec3 geometryNormal = normal;",normal_fragment_maps:"#ifdef OBJECTSPACE_NORMALMAP\n\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\t#ifdef USE_TANGENT\n\t\tnormal = normalize( vTBN * mapN );\n\t#else\n\t\tnormal = perturbNormal2Arb( - vViewPosition, normal, mapN, faceDirection );\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif",normal_pars_fragment:"#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif",normal_pars_vertex:"#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif",normal_vertex:"#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif",normalmap_pars_fragment:"#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {\n\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tvec3 N = surf_norm;\n\t\tvec3 q1perp = cross( q1, N );\n\t\tvec3 q0perp = cross( N, q0 );\n\t\tvec3 T = q1perp * st0.x + q0perp * st1.x;\n\t\tvec3 B = q1perp * st0.y + q0perp * st1.y;\n\t\tfloat det = max( dot( T, T ), dot( B, B ) );\n\t\tfloat scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );\n\t\treturn normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );\n\t}\n#endif",clearcoat_normal_fragment_begin:"#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal = geometryNormal;\n#endif",clearcoat_normal_fragment_maps:"#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\t#ifdef USE_TANGENT\n\t\tclearcoatNormal = normalize( vTBN * clearcoatMapN );\n\t#else\n\t\tclearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );\n\t#endif\n#endif",clearcoat_pars_fragment:"#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif",output_fragment:"#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= transmissionAlpha + 0.1;\n#endif\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );",packing:"vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}",premultiplied_alpha_fragment:"#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif",project_vertex:"vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;",dithering_fragment:"#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif",dithering_pars_fragment:"#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif",roughnessmap_fragment:"float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif",roughnessmap_pars_fragment:"#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif",shadowmap_pars_fragment:"#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif",shadowmap_pars_vertex:"#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif",shadowmap_vertex:"#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0\n\t\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\tvec4 shadowWorldPosition;\n\t#endif\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n#endif",shadowmask_pars_fragment:"float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}",skinbase_vertex:"#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif",skinning_pars_vertex:"#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform highp sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif",skinning_vertex:"#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif",skinnormal_vertex:"#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif",specularmap_fragment:"float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif",specularmap_pars_fragment:"#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif",tonemapping_fragment:"#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif",tonemapping_pars_fragment:"#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n\treturn a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tconst mat3 ACESInputMat = mat3(\n\t\tvec3( 0.59719, 0.07600, 0.02840 ),\t\tvec3( 0.35458, 0.90834, 0.13383 ),\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\n\t);\n\tconst mat3 ACESOutputMat = mat3(\n\t\tvec3(  1.60475, -0.10208, -0.00327 ),\t\tvec3( -0.53108,  1.10813, -0.07276 ),\n\t\tvec3( -0.07367, -0.00605,  1.07602 )\n\t);\n\tcolor *= toneMappingExposure / 0.6;\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit( color );\n\tcolor = ACESOutputMat * color;\n\treturn saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }",transmission_fragment:"#ifdef USE_TRANSMISSION\n\tfloat transmissionAlpha = 1.0;\n\tfloat transmissionFactor = transmission;\n\tfloat thicknessFactor = thickness;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\ttransmissionFactor *= texture2D( transmissionMap, vUv ).r;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tthicknessFactor *= texture2D( thicknessMap, vUv ).g;\n\t#endif\n\tvec3 pos = vWorldPosition;\n\tvec3 v = normalize( cameraPosition - pos );\n\tvec3 n = inverseTransformDirection( normal, viewMatrix );\n\tvec4 transmission = getIBLVolumeRefraction(\n\t\tn, v, roughnessFactor, material.diffuseColor, material.specularColor, material.specularF90,\n\t\tpos, modelMatrix, viewMatrix, projectionMatrix, ior, thicknessFactor,\n\t\tattenuationColor, attenuationDistance );\n\ttotalDiffuse = mix( totalDiffuse, transmission.rgb, transmissionFactor );\n\ttransmissionAlpha = mix( transmissionAlpha, transmission.a, transmissionFactor );\n#endif",transmission_pars_fragment:"#ifdef USE_TRANSMISSION\n\tuniform float transmission;\n\tuniform float thickness;\n\tuniform float attenuationDistance;\n\tuniform vec3 attenuationColor;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tuniform sampler2D transmissionMap;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tuniform sampler2D thicknessMap;\n\t#endif\n\tuniform vec2 transmissionSamplerSize;\n\tuniform sampler2D transmissionSamplerMap;\n\tuniform mat4 modelMatrix;\n\tuniform mat4 projectionMatrix;\n\tvarying vec3 vWorldPosition;\n\tvec3 getVolumeTransmissionRay( vec3 n, vec3 v, float thickness, float ior, mat4 modelMatrix ) {\n\t\tvec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );\n\t\tvec3 modelScale;\n\t\tmodelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );\n\t\tmodelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );\n\t\tmodelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );\n\t\treturn normalize( refractionVector ) * thickness * modelScale;\n\t}\n\tfloat applyIorToRoughness( float roughness, float ior ) {\n\t\treturn roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\n\t}\n\tvec4 getTransmissionSample( vec2 fragCoord, float roughness, float ior ) {\n\t\tfloat framebufferLod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );\n\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\treturn texture2DLodEXT( transmissionSamplerMap, fragCoord.xy, framebufferLod );\n\t\t#else\n\t\t\treturn texture2D( transmissionSamplerMap, fragCoord.xy, framebufferLod );\n\t\t#endif\n\t}\n\tvec3 applyVolumeAttenuation( vec3 radiance, float transmissionDistance, vec3 attenuationColor, float attenuationDistance ) {\n\t\tif ( attenuationDistance == 0.0 ) {\n\t\t\treturn radiance;\n\t\t} else {\n\t\t\tvec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;\n\t\t\tvec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );\t\t\treturn transmittance * radiance;\n\t\t}\n\t}\n\tvec4 getIBLVolumeRefraction( vec3 n, vec3 v, float roughness, vec3 diffuseColor, vec3 specularColor, float specularF90,\n\t\tvec3 position, mat4 modelMatrix, mat4 viewMatrix, mat4 projMatrix, float ior, float thickness,\n\t\tvec3 attenuationColor, float attenuationDistance ) {\n\t\tvec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\n\t\tvec3 refractedRayExit = position + transmissionRay;\n\t\tvec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n\t\tvec2 refractionCoords = ndcPos.xy / ndcPos.w;\n\t\trefractionCoords += 1.0;\n\t\trefractionCoords /= 2.0;\n\t\tvec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );\n\t\tvec3 attenuatedColor = applyVolumeAttenuation( transmittedLight.rgb, length( transmissionRay ), attenuationColor, attenuationDistance );\n\t\tvec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );\n\t\treturn vec4( ( 1.0 - F ) * attenuatedColor * diffuseColor, transmittedLight.a );\n\t}\n#endif",uv_pars_fragment:"#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n\tvarying vec2 vUv;\n#endif",uv_pars_vertex:"#ifdef USE_UV\n\t#ifdef UVS_VERTEX_ONLY\n\t\tvec2 vUv;\n\t#else\n\t\tvarying vec2 vUv;\n\t#endif\n\tuniform mat3 uvTransform;\n#endif",uv_vertex:"#ifdef USE_UV\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif",uv2_pars_fragment:"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif",uv2_pars_vertex:"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n\tuniform mat3 uv2Transform;\n#endif",uv2_vertex:"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif",worldpos_vertex:"#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION )\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif",background_vert:"varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}",background_frag:"uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",cube_vert:"varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}",cube_frag:"#include <envmap_common_pars_fragment>\nuniform float opacity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\tvec3 vReflect = vWorldDirection;\n\t#include <envmap_fragment>\n\tgl_FragColor = envColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",depth_vert:"#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}",depth_frag:"#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#endif\n}",distanceRGBA_vert:"#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}",distanceRGBA_frag:"#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}",equirect_vert:"varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}",equirect_frag:"uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tvec4 texColor = texture2D( tEquirect, sampleUV );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",linedashed_vert:"uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",linedashed_frag:"uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",meshbasic_vert:"#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinbase_vertex>\n\t\t#include <skinnormal_vertex>\n\t\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}",meshbasic_frag:"uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\treflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",meshlambert_vert:"#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",meshlambert_frag:"uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n\t#else\n\t\treflectedLight.indirectDiffuse += vIndirectFront;\n\t#endif\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",meshmatcap_vert:"#define MATCAP\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}",meshmatcap_frag:"#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t\tmatcapColor = matcapTexelToLinear( matcapColor );\n\t#else\n\t\tvec4 matcapColor = vec4( 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",meshnormal_vert:"#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}",meshnormal_frag:"#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}",meshphong_vert:"#define PHONG\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",meshphong_frag:"#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",meshphysical_vert:"#define STANDARD\nvarying vec3 vViewPosition;\n#ifdef USE_TRANSMISSION\n\tvarying vec3 vWorldPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n\tvWorldPosition = worldPosition.xyz;\n#endif\n}",meshphysical_frag:"#define STANDARD\n#ifdef PHYSICAL\n\t#define IOR\n\t#define SPECULAR\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef IOR\n\tuniform float ior;\n#endif\n#ifdef SPECULAR\n\tuniform float specularIntensity;\n\tuniform vec3 specularColor;\n\t#ifdef USE_SPECULARINTENSITYMAP\n\t\tuniform sampler2D specularIntensityMap;\n\t#endif\n\t#ifdef USE_SPECULARCOLORMAP\n\t\tuniform sampler2D specularColorMap;\n\t#endif\n#endif\n#ifdef USE_CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheenColor;\n\tuniform float sheenRoughness;\n\t#ifdef USE_SHEENCOLORMAP\n\t\tuniform sampler2D sheenColorMap;\n\t#endif\n\t#ifdef USE_SHEENROUGHNESSMAP\n\t\tuniform sampler2D sheenRoughnessMap;\n\t#endif\n#endif\nvarying vec3 vViewPosition;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_physical_pars_fragment>\n#include <transmission_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n\tvec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n\t#include <transmission_fragment>\n\tvec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n\t#ifdef USE_SHEEN\n\t\tfloat sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );\n\t\toutgoingLight = outgoingLight * sheenEnergyComp + sheenSpecular;\n\t#endif\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n\t\tvec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );\n\t\toutgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + clearcoatSpecular * material.clearcoat;\n\t#endif\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",meshtoon_vert:"#define TOON\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",meshtoon_frag:"#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",points_vert:"uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}",points_frag:"uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",shadow_vert:"#include <common>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",shadow_frag:"uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",sprite_vert:"uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",sprite_frag:"uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}"},ks={common:{diffuse:{value:new Li(16777215)},opacity:{value:1},map:{value:null},uvTransform:{value:new Yn},uv2Transform:{value:new Yn},alphaMap:{value:null},alphaTest:{value:0}},specularmap:{specularMap:{value:null}},envmap:{envMap:{value:null},flipEnvMap:{value:-1},reflectivity:{value:1},ior:{value:1.5},refractionRatio:{value:.98}},aomap:{aoMap:{value:null},aoMapIntensity:{value:1}},lightmap:{lightMap:{value:null},lightMapIntensity:{value:1}},emissivemap:{emissiveMap:{value:null}},bumpmap:{bumpMap:{value:null},bumpScale:{value:1}},normalmap:{normalMap:{value:null},normalScale:{value:new jn(1,1)}},displacementmap:{displacementMap:{value:null},displacementScale:{value:1},displacementBias:{value:0}},roughnessmap:{roughnessMap:{value:null}},metalnessmap:{metalnessMap:{value:null}},gradientmap:{gradientMap:{value:null}},fog:{fogDensity:{value:25e-5},fogNear:{value:1},fogFar:{value:2e3},fogColor:{value:new Li(16777215)}},lights:{ambientLightColor:{value:[]},lightProbe:{value:[]},directionalLights:{value:[],properties:{direction:{},color:{}}},directionalLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},directionalShadowMap:{value:[]},directionalShadowMatrix:{value:[]},spotLights:{value:[],properties:{color:{},position:{},direction:{},distance:{},coneCos:{},penumbraCos:{},decay:{}}},spotLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},spotShadowMap:{value:[]},spotShadowMatrix:{value:[]},pointLights:{value:[],properties:{color:{},position:{},decay:{},distance:{}}},pointLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{},shadowCameraNear:{},shadowCameraFar:{}}},pointShadowMap:{value:[]},pointShadowMatrix:{value:[]},hemisphereLights:{value:[],properties:{direction:{},skyColor:{},groundColor:{}}},rectAreaLights:{value:[],properties:{color:{},position:{},width:{},height:{}}},ltc_1:{value:null},ltc_2:{value:null}},points:{diffuse:{value:new Li(16777215)},opacity:{value:1},size:{value:1},scale:{value:1},map:{value:null},alphaMap:{value:null},alphaTest:{value:0},uvTransform:{value:new Yn}},sprite:{diffuse:{value:new Li(16777215)},opacity:{value:1},center:{value:new jn(.5,.5)},rotation:{value:0},map:{value:null},alphaMap:{value:null},alphaTest:{value:0},uvTransform:{value:new Yn}}},Hs={basic:{uniforms:ws([ks.common,ks.specularmap,ks.envmap,ks.aomap,ks.lightmap,ks.fog]),vertexShader:zs.meshbasic_vert,fragmentShader:zs.meshbasic_frag},lambert:{uniforms:ws([ks.common,ks.specularmap,ks.envmap,ks.aomap,ks.lightmap,ks.emissivemap,ks.fog,ks.lights,{emissive:{value:new Li(0)}}]),vertexShader:zs.meshlambert_vert,fragmentShader:zs.meshlambert_frag},phong:{uniforms:ws([ks.common,ks.specularmap,ks.envmap,ks.aomap,ks.lightmap,ks.emissivemap,ks.bumpmap,ks.normalmap,ks.displacementmap,ks.fog,ks.lights,{emissive:{value:new Li(0)},specular:{value:new Li(1118481)},shininess:{value:30}}]),vertexShader:zs.meshphong_vert,fragmentShader:zs.meshphong_frag},standard:{uniforms:ws([ks.common,ks.envmap,ks.aomap,ks.lightmap,ks.emissivemap,ks.bumpmap,ks.normalmap,ks.displacementmap,ks.roughnessmap,ks.metalnessmap,ks.fog,ks.lights,{emissive:{value:new Li(0)},roughness:{value:1},metalness:{value:0},envMapIntensity:{value:1}}]),vertexShader:zs.meshphysical_vert,fragmentShader:zs.meshphysical_frag},toon:{uniforms:ws([ks.common,ks.aomap,ks.lightmap,ks.emissivemap,ks.bumpmap,ks.normalmap,ks.displacementmap,ks.gradientmap,ks.fog,ks.lights,{emissive:{value:new Li(0)}}]),vertexShader:zs.meshtoon_vert,fragmentShader:zs.meshtoon_frag},matcap:{uniforms:ws([ks.common,ks.bumpmap,ks.normalmap,ks.displacementmap,ks.fog,{matcap:{value:null}}]),vertexShader:zs.meshmatcap_vert,fragmentShader:zs.meshmatcap_frag},points:{uniforms:ws([ks.points,ks.fog]),vertexShader:zs.points_vert,fragmentShader:zs.points_frag},dashed:{uniforms:ws([ks.common,ks.fog,{scale:{value:1},dashSize:{value:1},totalSize:{value:2}}]),vertexShader:zs.linedashed_vert,fragmentShader:zs.linedashed_frag},depth:{uniforms:ws([ks.common,ks.displacementmap]),vertexShader:zs.depth_vert,fragmentShader:zs.depth_frag},normal:{uniforms:ws([ks.common,ks.bumpmap,ks.normalmap,ks.displacementmap,{opacity:{value:1}}]),vertexShader:zs.meshnormal_vert,fragmentShader:zs.meshnormal_frag},sprite:{uniforms:ws([ks.sprite,ks.fog]),vertexShader:zs.sprite_vert,fragmentShader:zs.sprite_frag},background:{uniforms:{uvTransform:{value:new Yn},t2D:{value:null}},vertexShader:zs.background_vert,fragmentShader:zs.background_frag},cube:{uniforms:ws([ks.envmap,{opacity:{value:1}}]),vertexShader:zs.cube_vert,fragmentShader:zs.cube_frag},equirect:{uniforms:{tEquirect:{value:null}},vertexShader:zs.equirect_vert,fragmentShader:zs.equirect_frag},distanceRGBA:{uniforms:ws([ks.common,ks.displacementmap,{referencePosition:{value:new lr},nearDistance:{value:1},farDistance:{value:1e3}}]),vertexShader:zs.distanceRGBA_vert,fragmentShader:zs.distanceRGBA_frag},shadow:{uniforms:ws([ks.lights,ks.fog,{color:{value:new Li(0)},opacity:{value:1}}]),vertexShader:zs.shadow_vert,fragmentShader:zs.shadow_frag}};function Gs(t,e,n,r,i){const s=new Li(0);let a,o,l=0,c=null,h=0,u=null;function d(t,e){n.buffers.color.setClear(t.r,t.g,t.b,e,i)}return{getClearColor:function(){return s},setClearColor:function(t,e=1){s.set(t),l=e,d(s,l)},getClearAlpha:function(){return l},setClearAlpha:function(t){l=t,d(s,l)},render:function(n,i){let p=!1,f=!0===i.isScene?i.background:null;f&&f.isTexture&&(f=e.get(f));const m=t.xr,g=m.getSession&&m.getSession();g&&"additive"===g.environmentBlendMode&&(f=null),null===f?d(s,l):f&&f.isColor&&(d(f,1),p=!0),(t.autoClear||p)&&t.clear(t.autoClearColor,t.autoClearDepth,t.autoClearStencil),f&&(f.isCubeTexture||f.mapping===pt)?(void 0===o&&(o=new gs(new xs(1,1,1),new _s({name:"BackgroundCubeMaterial",uniforms:ys(Hs.cube.uniforms),vertexShader:Hs.cube.vertexShader,fragmentShader:Hs.cube.fragmentShader,side:y,depthTest:!1,depthWrite:!1,fog:!1})),o.geometry.deleteAttribute("normal"),o.geometry.deleteAttribute("uv"),o.onBeforeRender=function(t,e,n){this.matrixWorld.copyPosition(n.matrixWorld)},Object.defineProperty(o.material,"envMap",{get:function(){return this.uniforms.envMap.value}}),r.update(o)),o.material.uniforms.envMap.value=f,o.material.uniforms.flipEnvMap.value=f.isCubeTexture&&!1===f.isRenderTargetTexture?-1:1,c===f&&h===f.version&&u===t.toneMapping||(o.material.needsUpdate=!0,c=f,h=f.version,u=t.toneMapping),n.unshift(o,o.geometry,o.material,0,0,null)):f&&f.isTexture&&(void 0===a&&(a=new gs(new Bs(2,2),new _s({name:"BackgroundMaterial",uniforms:ys(Hs.background.uniforms),vertexShader:Hs.background.vertexShader,fragmentShader:Hs.background.fragmentShader,side:x,depthTest:!1,depthWrite:!1,fog:!1})),a.geometry.deleteAttribute("normal"),Object.defineProperty(a.material,"map",{get:function(){return this.uniforms.t2D.value}}),r.update(a)),a.material.uniforms.t2D.value=f,!0===f.matrixAutoUpdate&&f.updateMatrix(),a.material.uniforms.uvTransform.value.copy(f.matrix),c===f&&h===f.version&&u===t.toneMapping||(a.material.needsUpdate=!0,c=f,h=f.version,u=t.toneMapping),n.unshift(a,a.geometry,a.material,0,0,null))}}}function Vs(t,e,n,r){const i=t.getParameter(34921),s=r.isWebGL2?null:e.get("OES_vertex_array_object"),a=r.isWebGL2||null!==s,o={},l=d(null);let c=l;function h(e){return r.isWebGL2?t.bindVertexArray(e):s.bindVertexArrayOES(e)}function u(e){return r.isWebGL2?t.deleteVertexArray(e):s.deleteVertexArrayOES(e)}function d(t){const e=[],n=[],r=[];for(let t=0;t<i;t++)e[t]=0,n[t]=0,r[t]=0;return{geometry:null,program:null,wireframe:!1,newAttributes:e,enabledAttributes:n,attributeDivisors:r,object:t,attributes:{},index:null}}function p(){const t=c.newAttributes;for(let e=0,n=t.length;e<n;e++)t[e]=0}function f(t){m(t,0)}function m(n,i){const s=c.newAttributes,a=c.enabledAttributes,o=c.attributeDivisors;s[n]=1,0===a[n]&&(t.enableVertexAttribArray(n),a[n]=1),o[n]!==i&&((r.isWebGL2?t:e.get("ANGLE_instanced_arrays"))[r.isWebGL2?"vertexAttribDivisor":"vertexAttribDivisorANGLE"](n,i),o[n]=i)}function g(){const e=c.newAttributes,n=c.enabledAttributes;for(let r=0,i=n.length;r<i;r++)n[r]!==e[r]&&(t.disableVertexAttribArray(r),n[r]=0)}function v(e,n,i,s,a,o){!0!==r.isWebGL2||5124!==i&&5125!==i?t.vertexAttribPointer(e,n,i,s,a,o):t.vertexAttribIPointer(e,n,i,a,o)}function x(){y(),c!==l&&(c=l,h(c.object))}function y(){l.geometry=null,l.program=null,l.wireframe=!1}return{setup:function(i,l,u,x,y){let w=!1;if(a){const e=function(e,n,i){const a=!0===i.wireframe;let l=o[e.id];void 0===l&&(l={},o[e.id]=l);let c=l[n.id];void 0===c&&(c={},l[n.id]=c);let h=c[a];return void 0===h&&(h=d(r.isWebGL2?t.createVertexArray():s.createVertexArrayOES()),c[a]=h),h}(x,u,l);c!==e&&(c=e,h(c.object)),w=function(t,e){const n=c.attributes,r=t.attributes;let i=0;for(const t in r){const e=n[t],s=r[t];if(void 0===e)return!0;if(e.attribute!==s)return!0;if(e.data!==s.data)return!0;i++}return c.attributesNum!==i||c.index!==e}(x,y),w&&function(t,e){const n={},r=t.attributes;let i=0;for(const t in r){const e=r[t],s={};s.attribute=e,e.data&&(s.data=e.data),n[t]=s,i++}c.attributes=n,c.attributesNum=i,c.index=e}(x,y)}else{const t=!0===l.wireframe;c.geometry===x.id&&c.program===u.id&&c.wireframe===t||(c.geometry=x.id,c.program=u.id,c.wireframe=t,w=!0)}!0===i.isInstancedMesh&&(w=!0),null!==y&&n.update(y,34963),w&&(function(i,s,a,o){if(!1===r.isWebGL2&&(i.isInstancedMesh||o.isInstancedBufferGeometry)&&null===e.get("ANGLE_instanced_arrays"))return;p();const l=o.attributes,c=a.getAttributes(),h=s.defaultAttributeValues;for(const e in c){const r=c[e];if(r.location>=0){let s=l[e];if(void 0===s&&("instanceMatrix"===e&&i.instanceMatrix&&(s=i.instanceMatrix),"instanceColor"===e&&i.instanceColor&&(s=i.instanceColor)),void 0!==s){const e=s.normalized,a=s.itemSize,l=n.get(s);if(void 0===l)continue;const c=l.buffer,h=l.type,u=l.bytesPerElement;if(s.isInterleavedBufferAttribute){const n=s.data,l=n.stride,d=s.offset;if(n&&n.isInstancedInterleavedBuffer){for(let t=0;t<r.locationSize;t++)m(r.location+t,n.meshPerAttribute);!0!==i.isInstancedMesh&&void 0===o._maxInstanceCount&&(o._maxInstanceCount=n.meshPerAttribute*n.count)}else for(let t=0;t<r.locationSize;t++)f(r.location+t);t.bindBuffer(34962,c);for(let t=0;t<r.locationSize;t++)v(r.location+t,a/r.locationSize,h,e,l*u,(d+a/r.locationSize*t)*u)}else{if(s.isInstancedBufferAttribute){for(let t=0;t<r.locationSize;t++)m(r.location+t,s.meshPerAttribute);!0!==i.isInstancedMesh&&void 0===o._maxInstanceCount&&(o._maxInstanceCount=s.meshPerAttribute*s.count)}else for(let t=0;t<r.locationSize;t++)f(r.location+t);t.bindBuffer(34962,c);for(let t=0;t<r.locationSize;t++)v(r.location+t,a/r.locationSize,h,e,a*u,a/r.locationSize*t*u)}}else if(void 0!==h){const n=h[e];if(void 0!==n)switch(n.length){case 2:t.vertexAttrib2fv(r.location,n);break;case 3:t.vertexAttrib3fv(r.location,n);break;case 4:t.vertexAttrib4fv(r.location,n);break;default:t.vertexAttrib1fv(r.location,n)}}}}g()}(i,l,u,x),null!==y&&t.bindBuffer(34963,n.get(y).buffer))},reset:x,resetDefaultState:y,dispose:function(){x();for(const t in o){const e=o[t];for(const t in e){const n=e[t];for(const t in n)u(n[t].object),delete n[t];delete e[t]}delete o[t]}},releaseStatesOfGeometry:function(t){if(void 0===o[t.id])return;const e=o[t.id];for(const t in e){const n=e[t];for(const t in n)u(n[t].object),delete n[t];delete e[t]}delete o[t.id]},releaseStatesOfProgram:function(t){for(const e in o){const n=o[e];if(void 0===n[t.id])continue;const r=n[t.id];for(const t in r)u(r[t].object),delete r[t];delete n[t.id]}},initAttributes:p,enableAttribute:f,disableUnusedAttributes:g}}function Ws(t,e,n,r){const i=r.isWebGL2;let s;this.setMode=function(t){s=t},this.render=function(e,r){t.drawArrays(s,e,r),n.update(r,s,1)},this.renderInstances=function(r,a,o){if(0===o)return;let l,c;if(i)l=t,c="drawArraysInstanced";else if(l=e.get("ANGLE_instanced_arrays"),c="drawArraysInstancedANGLE",null===l)return void console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");l[c](s,r,a,o),n.update(a,s,o)}}function Xs(t,e,n){let r;function i(e){if("highp"===e){if(t.getShaderPrecisionFormat(35633,36338).precision>0&&t.getShaderPrecisionFormat(35632,36338).precision>0)return"highp";e="mediump"}return"mediump"===e&&t.getShaderPrecisionFormat(35633,36337).precision>0&&t.getShaderPrecisionFormat(35632,36337).precision>0?"mediump":"lowp"}const s="undefined"!=typeof WebGL2RenderingContext&&t instanceof WebGL2RenderingContext||"undefined"!=typeof WebGL2ComputeRenderingContext&&t instanceof WebGL2ComputeRenderingContext;let a=void 0!==n.precision?n.precision:"highp";const o=i(a);o!==a&&(console.warn("THREE.WebGLRenderer:",a,"not supported, using",o,"instead."),a=o);const l=s||e.has("WEBGL_draw_buffers"),c=!0===n.logarithmicDepthBuffer,h=t.getParameter(34930),u=t.getParameter(35660),d=t.getParameter(3379),p=t.getParameter(34076),f=t.getParameter(34921),m=t.getParameter(36347),g=t.getParameter(36348),v=t.getParameter(36349),x=u>0,y=s||e.has("OES_texture_float");return{isWebGL2:s,drawBuffers:l,getMaxAnisotropy:function(){if(void 0!==r)return r;if(!0===e.has("EXT_texture_filter_anisotropic")){const n=e.get("EXT_texture_filter_anisotropic");r=t.getParameter(n.MAX_TEXTURE_MAX_ANISOTROPY_EXT)}else r=0;return r},getMaxPrecision:i,precision:a,logarithmicDepthBuffer:c,maxTextures:h,maxVertexTextures:u,maxTextureSize:d,maxCubemapSize:p,maxAttributes:f,maxVertexUniforms:m,maxVaryings:g,maxFragmentUniforms:v,vertexTextures:x,floatFragmentTextures:y,floatVertexTextures:x&&y,maxSamples:s?t.getParameter(36183):0}}function js(t){const e=this;let n=null,r=0,i=!1,s=!1;const a=new Fs,o=new Yn,l={value:null,needsUpdate:!1};function c(){l.value!==n&&(l.value=n,l.needsUpdate=r>0),e.numPlanes=r,e.numIntersection=0}function h(t,n,r,i){const s=null!==t?t.length:0;let c=null;if(0!==s){if(c=l.value,!0!==i||null===c){const e=r+4*s,i=n.matrixWorldInverse;o.getNormalMatrix(i),(null===c||c.length<e)&&(c=new Float32Array(e));for(let e=0,n=r;e!==s;++e,n+=4)a.copy(t[e]).applyMatrix4(i,o),a.normal.toArray(c,n),c[n+3]=a.constant}l.value=c,l.needsUpdate=!0}return e.numPlanes=s,e.numIntersection=0,c}this.uniform=l,this.numPlanes=0,this.numIntersection=0,this.init=function(t,e,s){const a=0!==t.length||e||0!==r||i;return i=e,n=h(t,s,0),r=t.length,a},this.beginShadows=function(){s=!0,h(null)},this.endShadows=function(){s=!1,c()},this.setState=function(e,a,o){const u=e.clippingPlanes,d=e.clipIntersection,p=e.clipShadows,f=t.get(e);if(!i||null===u||0===u.length||s&&!p)s?h(null):c();else{const t=s?0:r,e=4*t;let i=f.clippingState||null;l.value=i,i=h(u,a,e,o);for(let t=0;t!==e;++t)i[t]=n[t];f.clippingState=i,this.numIntersection=d?this.numPlanes:0,this.numPlanes+=t}}}function Ys(t){let e=new WeakMap;function n(t,e){return e===ut?t.mapping=ct:e===dt&&(t.mapping=ht),t}function r(t){const n=t.target;n.removeEventListener("dispose",r);const i=e.get(n);void 0!==i&&(e.delete(n),i.dispose())}return{get:function(i){if(i&&i.isTexture&&!1===i.isRenderTargetTexture){const s=i.mapping;if(s===ut||s===dt){if(e.has(i))return n(e.get(i).texture,i.mapping);{const s=i.image;if(s&&s.height>0){const a=t.getRenderTarget(),o=new Cs(s.height/2);return o.fromEquirectangularTexture(t,i),e.set(i,o),t.setRenderTarget(a),i.addEventListener("dispose",r),n(o.texture,i.mapping)}return null}}}return i},dispose:function(){e=new WeakMap}}}Hs.physical={uniforms:ws([Hs.standard.uniforms,{clearcoat:{value:0},clearcoatMap:{value:null},clearcoatRoughness:{value:0},clearcoatRoughnessMap:{value:null},clearcoatNormalScale:{value:new jn(1,1)},clearcoatNormalMap:{value:null},sheen:{value:0},sheenColor:{value:new Li(0)},sheenColorMap:{value:null},sheenRoughness:{value:0},sheenRoughnessMap:{value:null},transmission:{value:0},transmissionMap:{value:null},transmissionSamplerSize:{value:new jn},transmissionSamplerMap:{value:null},thickness:{value:0},thicknessMap:{value:null},attenuationDistance:{value:0},attenuationColor:{value:new Li(0)},specularIntensity:{value:0},specularIntensityMap:{value:null},specularColor:{value:new Li(1,1,1)},specularColorMap:{value:null}}]),vertexShader:zs.meshphysical_vert,fragmentShader:zs.meshphysical_frag};class qs extends Ms{constructor(t=-1,e=1,n=1,r=-1,i=.1,s=2e3){super(),this.type="OrthographicCamera",this.zoom=1,this.view=null,this.left=t,this.right=e,this.top=n,this.bottom=r,this.near=i,this.far=s,this.updateProjectionMatrix()}copy(t,e){return super.copy(t,e),this.left=t.left,this.right=t.right,this.top=t.top,this.bottom=t.bottom,this.near=t.near,this.far=t.far,this.zoom=t.zoom,this.view=null===t.view?null:Object.assign({},t.view),this}setViewOffset(t,e,n,r,i,s){null===this.view&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=t,this.view.fullHeight=e,this.view.offsetX=n,this.view.offsetY=r,this.view.width=i,this.view.height=s,this.updateProjectionMatrix()}clearViewOffset(){null!==this.view&&(this.view.enabled=!1),this.updateProjectionMatrix()}updateProjectionMatrix(){const t=(this.right-this.left)/(2*this.zoom),e=(this.top-this.bottom)/(2*this.zoom),n=(this.right+this.left)/2,r=(this.top+this.bottom)/2;let i=n-t,s=n+t,a=r+e,o=r-e;if(null!==this.view&&this.view.enabled){const t=(this.right-this.left)/this.view.fullWidth/this.zoom,e=(this.top-this.bottom)/this.view.fullHeight/this.zoom;i+=t*this.view.offsetX,s=i+t*this.view.width,a-=e*this.view.offsetY,o=a-e*this.view.height}this.projectionMatrix.makeOrthographic(i,s,a,o,this.near,this.far),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()}toJSON(t){const e=super.toJSON(t);return e.object.zoom=this.zoom,e.object.left=this.left,e.object.right=this.right,e.object.top=this.top,e.object.bottom=this.bottom,e.object.near=this.near,e.object.far=this.far,null!==this.view&&(e.object.view=Object.assign({},this.view)),e}}qs.prototype.isOrthographicCamera=!0;class Qs extends _s{constructor(t){super(t),this.type="RawShaderMaterial"}}Qs.prototype.isRawShaderMaterial=!0;const Zs=Math.pow(2,8),Js=[.125,.215,.35,.446,.526,.582],Ks=5+Js.length,$s={[$e]:0,[tn]:1},ta=new qs,{_lodPlanes:ea,_sizeLods:na,_sigmas:ra}=ha(),ia=new Li;let sa=null;const aa=(1+Math.sqrt(5))/2,oa=1/aa,la=[new lr(1,1,1),new lr(-1,1,1),new lr(1,1,-1),new lr(-1,1,-1),new lr(0,aa,oa),new lr(0,aa,-oa),new lr(oa,0,aa),new lr(-oa,0,aa),new lr(aa,oa,0),new lr(-aa,oa,0)];class ca{constructor(t){this._renderer=t,this._pingPongRenderTarget=null,this._blurMaterial=function(t){const e=new Float32Array(20),n=new lr(0,1,0);return new Qs({name:"SphericalGaussianBlur",defines:{n:20},uniforms:{envMap:{value:null},samples:{value:1},weights:{value:e},latitudinal:{value:!1},dTheta:{value:0},mipInt:{value:0},poleAxis:{value:n}},vertexShader:"\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute vec3 position;\n\t\tattribute vec2 uv;\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t",fragmentShader:"\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform int samples;\n\t\t\tuniform float weights[ n ];\n\t\t\tuniform bool latitudinal;\n\t\t\tuniform float dTheta;\n\t\t\tuniform float mipInt;\n\t\t\tuniform vec3 poleAxis;\n\n\t\t\t\n\n\t\tuniform int inputEncoding;\n\n\t\t#include <encodings_pars_fragment>\n\n\t\tvec4 inputTexelToLinear( vec4 value ) {\n\n\t\t\tif ( inputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else {\n\n\t\t\t\treturn sRGBToLinear( value );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 envMapTexelToLinear( vec4 color ) {\n\n\t\t\treturn inputTexelToLinear( color );\n\n\t\t}\n\t\n\n\t\t\t#define ENVMAP_TYPE_CUBE_UV\n\t\t\t#include <cube_uv_reflection_fragment>\n\n\t\t\tvec3 getSample( float theta, vec3 axis ) {\n\n\t\t\t\tfloat cosTheta = cos( theta );\n\t\t\t\t// Rodrigues' axis-angle rotation\n\t\t\t\tvec3 sampleDirection = vOutputDirection * cosTheta\n\t\t\t\t\t+ cross( axis, vOutputDirection ) * sin( theta )\n\t\t\t\t\t+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );\n\n\t\t\t\treturn bilinearCubeUV( envMap, sampleDirection, mipInt );\n\n\t\t\t}\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );\n\n\t\t\t\tif ( all( equal( axis, vec3( 0.0 ) ) ) ) {\n\n\t\t\t\t\taxis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );\n\n\t\t\t\t}\n\n\t\t\t\taxis = normalize( axis );\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );\n\n\t\t\t\tfor ( int i = 1; i < n; i++ ) {\n\n\t\t\t\t\tif ( i >= samples ) {\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfloat theta = dTheta * float( i );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( theta, axis );\n\n\t\t\t\t}\n\n\t\t\t}\n\t\t",blending:M,depthTest:!1,depthWrite:!1})}(),this._equirectShader=null,this._cubemapShader=null,this._compileMaterial(this._blurMaterial)}fromScene(t,e=0,n=.1,r=100){sa=this._renderer.getRenderTarget();const i=this._allocateTargets();return this._sceneToCubeUV(t,n,r,i),e>0&&this._blur(i,0,0,e),this._applyPMREM(i),this._cleanup(i),i}fromEquirectangular(t){return this._fromTexture(t)}fromCubemap(t){return this._fromTexture(t)}compileCubemapShader(){null===this._cubemapShader&&(this._cubemapShader=fa(),this._compileMaterial(this._cubemapShader))}compileEquirectangularShader(){null===this._equirectShader&&(this._equirectShader=pa(),this._compileMaterial(this._equirectShader))}dispose(){this._blurMaterial.dispose(),null!==this._cubemapShader&&this._cubemapShader.dispose(),null!==this._equirectShader&&this._equirectShader.dispose();for(let t=0;t<ea.length;t++)ea[t].dispose()}_cleanup(t){this._pingPongRenderTarget.dispose(),this._renderer.setRenderTarget(sa),t.scissorTest=!1,da(t,0,0,t.width,t.height)}_fromTexture(t){sa=this._renderer.getRenderTarget();const e=this._allocateTargets(t);return this._textureToCubeUV(t,e),this._applyPMREM(e),this._cleanup(e),e}_allocateTargets(t){const e={magFilter:Mt,minFilter:Mt,generateMipmaps:!1,type:Ut,format:Gt,encoding:$e,depthBuffer:!1},n=ua(e);return n.depthBuffer=!t,this._pingPongRenderTarget=ua(e),n}_compileMaterial(t){const e=new gs(ea[0],t);this._renderer.compile(e,ta)}_sceneToCubeUV(t,e,n,r){const i=new Ts(90,1,e,n),s=[1,-1,1,1,1,1],a=[1,1,1,-1,-1,-1],o=this._renderer,l=o.autoClear,c=o.toneMapping;o.getClearColor(ia),o.toneMapping=nt,o.autoClear=!1;const h=new Ri({name:"PMREM.Background",side:y,depthWrite:!1,depthTest:!1}),u=new gs(new xs,h);let d=!1;const p=t.background;p?p.isColor&&(h.color.copy(p),t.background=null,d=!0):(h.color.copy(ia),d=!0);for(let e=0;e<6;e++){const n=e%3;0==n?(i.up.set(0,s[e],0),i.lookAt(a[e],0,0)):1==n?(i.up.set(0,0,s[e]),i.lookAt(0,a[e],0)):(i.up.set(0,s[e],0),i.lookAt(0,0,a[e])),da(r,n*Zs,e>2?Zs:0,Zs,Zs),o.setRenderTarget(r),d&&o.render(u,i),o.render(t,i)}u.geometry.dispose(),u.material.dispose(),o.toneMapping=c,o.autoClear=l,t.background=p}_setEncoding(t,e){!0===this._renderer.capabilities.isWebGL2&&e.format===Gt&&e.type===Ct&&e.encoding===tn?t.value=$s[$e]:t.value=$s[e.encoding]}_textureToCubeUV(t,e){const n=this._renderer,r=t.mapping===ct||t.mapping===ht;r?null==this._cubemapShader&&(this._cubemapShader=fa()):null==this._equirectShader&&(this._equirectShader=pa());const i=r?this._cubemapShader:this._equirectShader,s=new gs(ea[0],i),a=i.uniforms;a.envMap.value=t,r||a.texelSize.value.set(1/t.image.width,1/t.image.height),this._setEncoding(a.inputEncoding,t),da(e,0,0,3*Zs,2*Zs),n.setRenderTarget(e),n.render(s,ta)}_applyPMREM(t){const e=this._renderer,n=e.autoClear;e.autoClear=!1;for(let e=1;e<Ks;e++){const n=Math.sqrt(ra[e]*ra[e]-ra[e-1]*ra[e-1]),r=la[(e-1)%la.length];this._blur(t,e-1,e,n,r)}e.autoClear=n}_blur(t,e,n,r,i){const s=this._pingPongRenderTarget;this._halfBlur(t,s,e,n,r,"latitudinal",i),this._halfBlur(s,t,n,n,r,"longitudinal",i)}_halfBlur(t,e,n,r,i,s,a){const o=this._renderer,l=this._blurMaterial;"latitudinal"!==s&&"longitudinal"!==s&&console.error("blur direction must be either latitudinal or longitudinal!");const c=new gs(ea[r],l),h=l.uniforms,u=na[n]-1,d=isFinite(i)?Math.PI/(2*u):2*Math.PI/39,p=i/d,f=isFinite(i)?1+Math.floor(3*p):20;f>20&&console.warn(`sigmaRadians, ${i}, is too large and will clip, as it requested ${f} samples when the maximum is set to 20`);const m=[];let g=0;for(let t=0;t<20;++t){const e=t/p,n=Math.exp(-e*e/2);m.push(n),0==t?g+=n:t<f&&(g+=2*n)}for(let t=0;t<m.length;t++)m[t]=m[t]/g;h.envMap.value=t.texture,h.samples.value=f,h.weights.value=m,h.latitudinal.value="latitudinal"===s,a&&(h.poleAxis.value=a),h.dTheta.value=d,h.mipInt.value=8-n;const v=na[r];da(e,3*Math.max(0,Zs-2*v),(0===r?0:2*Zs)+2*v*(r>4?r-8+4:0),3*v,2*v),o.setRenderTarget(e),o.render(c,ta)}}function ha(){const t=[],e=[],n=[];let r=8;for(let i=0;i<Ks;i++){const s=Math.pow(2,r);e.push(s);let a=1/s;i>4?a=Js[i-8+4-1]:0==i&&(a=0),n.push(a);const o=1/(s-1),l=-o/2,c=1+o/2,h=[l,l,c,l,c,c,l,l,c,c,l,c],u=6,d=6,p=3,f=2,m=1,g=new Float32Array(p*d*u),v=new Float32Array(f*d*u),x=new Float32Array(m*d*u);for(let t=0;t<u;t++){const e=t%3*2/3-1,n=t>2?0:-1,r=[e,n,0,e+2/3,n,0,e+2/3,n+1,0,e,n,0,e+2/3,n+1,0,e,n+1,0];g.set(r,p*d*t),v.set(h,f*d*t);const i=[t,t,t,t,t,t];x.set(i,m*d*t)}const y=new Ki;y.setAttribute("position",new Ii(g,p)),y.setAttribute("uv",new Ii(v,f)),y.setAttribute("faceIndex",new Ii(x,m)),t.push(y),r>4&&r--}return{_lodPlanes:t,_sizeLods:e,_sigmas:n}}function ua(t){const e=new ir(3*Zs,3*Zs,t);return e.texture.mapping=pt,e.texture.name="PMREM.cubeUv",e.scissorTest=!0,e}function da(t,e,n,r,i){t.viewport.set(e,n,r,i),t.scissor.set(e,n,r,i)}function pa(){const t=new jn(1,1);return new Qs({name:"EquirectangularToCubeUV",uniforms:{envMap:{value:null},texelSize:{value:t},inputEncoding:{value:$s[$e]}},vertexShader:"\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute vec3 position;\n\t\tattribute vec2 uv;\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t",fragmentShader:"\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform vec2 texelSize;\n\n\t\t\t\n\n\t\tuniform int inputEncoding;\n\n\t\t#include <encodings_pars_fragment>\n\n\t\tvec4 inputTexelToLinear( vec4 value ) {\n\n\t\t\tif ( inputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else {\n\n\t\t\t\treturn sRGBToLinear( value );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 envMapTexelToLinear( vec4 color ) {\n\n\t\t\treturn inputTexelToLinear( color );\n\n\t\t}\n\t\n\n\t\t\t#include <common>\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\n\t\t\t\tvec3 outputDirection = normalize( vOutputDirection );\n\t\t\t\tvec2 uv = equirectUv( outputDirection );\n\n\t\t\t\tvec2 f = fract( uv / texelSize - 0.5 );\n\t\t\t\tuv -= f * texelSize;\n\t\t\t\tvec3 tl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\t\t\t\tuv.x += texelSize.x;\n\t\t\t\tvec3 tr = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\t\t\t\tuv.y += texelSize.y;\n\t\t\t\tvec3 br = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\t\t\t\tuv.x -= texelSize.x;\n\t\t\t\tvec3 bl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\n\t\t\t\tvec3 tm = mix( tl, tr, f.x );\n\t\t\t\tvec3 bm = mix( bl, br, f.x );\n\t\t\t\tgl_FragColor.rgb = mix( tm, bm, f.y );\n\n\t\t\t}\n\t\t",blending:M,depthTest:!1,depthWrite:!1})}function fa(){return new Qs({name:"CubemapToCubeUV",uniforms:{envMap:{value:null},inputEncoding:{value:$s[$e]}},vertexShader:"\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute vec3 position;\n\t\tattribute vec2 uv;\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t",fragmentShader:"\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform samplerCube envMap;\n\n\t\t\t\n\n\t\tuniform int inputEncoding;\n\n\t\t#include <encodings_pars_fragment>\n\n\t\tvec4 inputTexelToLinear( vec4 value ) {\n\n\t\t\tif ( inputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else {\n\n\t\t\t\treturn sRGBToLinear( value );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 envMapTexelToLinear( vec4 color ) {\n\n\t\t\treturn inputTexelToLinear( color );\n\n\t\t}\n\t\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = envMapTexelToLinear( textureCube( envMap, vec3( - vOutputDirection.x, vOutputDirection.yz ) ) );\n\n\t\t\t}\n\t\t",blending:M,depthTest:!1,depthWrite:!1})}function ma(t){let e=new WeakMap,n=null;function r(t){const n=t.target;n.removeEventListener("dispose",r);const i=e.get(n);void 0!==i&&(e.delete(n),i.dispose())}return{get:function(i){if(i&&i.isTexture&&!1===i.isRenderTargetTexture){const s=i.mapping,a=s===ut||s===dt,o=s===ct||s===ht;if(a||o){if(e.has(i))return e.get(i).texture;{const s=i.image;if(a&&s&&s.height>0||o&&s&&function(t){let e=0;for(let n=0;n<6;n++)void 0!==t[n]&&e++;return 6===e}(s)){const s=t.getRenderTarget();null===n&&(n=new ca(t));const o=a?n.fromEquirectangular(i):n.fromCubemap(i);return e.set(i,o),t.setRenderTarget(s),i.addEventListener("dispose",r),o.texture}return null}}}return i},dispose:function(){e=new WeakMap,null!==n&&(n.dispose(),n=null)}}}function ga(t){const e={};function n(n){if(void 0!==e[n])return e[n];let r;switch(n){case"WEBGL_depth_texture":r=t.getExtension("WEBGL_depth_texture")||t.getExtension("MOZ_WEBGL_depth_texture")||t.getExtension("WEBKIT_WEBGL_depth_texture");break;case"EXT_texture_filter_anisotropic":r=t.getExtension("EXT_texture_filter_anisotropic")||t.getExtension("MOZ_EXT_texture_filter_anisotropic")||t.getExtension("WEBKIT_EXT_texture_filter_anisotropic");break;case"WEBGL_compressed_texture_s3tc":r=t.getExtension("WEBGL_compressed_texture_s3tc")||t.getExtension("MOZ_WEBGL_compressed_texture_s3tc")||t.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");break;case"WEBGL_compressed_texture_pvrtc":r=t.getExtension("WEBGL_compressed_texture_pvrtc")||t.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");break;default:r=t.getExtension(n)}return e[n]=r,r}return{has:function(t){return null!==n(t)},init:function(t){t.isWebGL2?n("EXT_color_buffer_float"):(n("WEBGL_depth_texture"),n("OES_texture_float"),n("OES_texture_half_float"),n("OES_texture_half_float_linear"),n("OES_standard_derivatives"),n("OES_element_index_uint"),n("OES_vertex_array_object"),n("ANGLE_instanced_arrays")),n("OES_texture_float_linear"),n("EXT_color_buffer_half_float"),n("WEBGL_multisampled_render_to_texture")},get:function(t){const e=n(t);return null===e&&console.warn("THREE.WebGLRenderer: "+t+" extension not supported."),e}}}function va(t,e,n,r){const i={},s=new WeakMap;function a(t){const o=t.target;null!==o.index&&e.remove(o.index);for(const t in o.attributes)e.remove(o.attributes[t]);o.removeEventListener("dispose",a),delete i[o.id];const l=s.get(o);l&&(e.remove(l),s.delete(o)),r.releaseStatesOfGeometry(o),!0===o.isInstancedBufferGeometry&&delete o._maxInstanceCount,n.memory.geometries--}function o(t){const n=[],r=t.index,i=t.attributes.position;let a=0;if(null!==r){const t=r.array;a=r.version;for(let e=0,r=t.length;e<r;e+=3){const r=t[e+0],i=t[e+1],s=t[e+2];n.push(r,i,i,s,s,r)}}else{const t=i.array;a=i.version;for(let e=0,r=t.length/3-1;e<r;e+=3){const t=e+0,r=e+1,i=e+2;n.push(t,r,r,i,i,t)}}const o=new(qn(n)>65535?Hi:zi)(n,1);o.version=a;const l=s.get(t);l&&e.remove(l),s.set(t,o)}return{get:function(t,e){return!0===i[e.id]||(e.addEventListener("dispose",a),i[e.id]=!0,n.memory.geometries++),e},update:function(t){const n=t.attributes;for(const t in n)e.update(n[t],34962);const r=t.morphAttributes;for(const t in r){const n=r[t];for(let t=0,r=n.length;t<r;t++)e.update(n[t],34962)}},getWireframeAttribute:function(t){const e=s.get(t);if(e){const n=t.index;null!==n&&e.version<n.version&&o(t)}else o(t);return s.get(t)}}}function xa(t,e,n,r){const i=r.isWebGL2;let s,a,o;this.setMode=function(t){s=t},this.setIndex=function(t){a=t.type,o=t.bytesPerElement},this.render=function(e,r){t.drawElements(s,r,a,e*o),n.update(r,s,1)},this.renderInstances=function(r,l,c){if(0===c)return;let h,u;if(i)h=t,u="drawElementsInstanced";else if(h=e.get("ANGLE_instanced_arrays"),u="drawElementsInstancedANGLE",null===h)return void console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");h[u](s,l,a,r*o,c),n.update(l,s,c)}}function ya(t){const e={frame:0,calls:0,triangles:0,points:0,lines:0};return{memory:{geometries:0,textures:0},render:e,programs:null,autoReset:!0,reset:function(){e.frame++,e.calls=0,e.triangles=0,e.points=0,e.lines=0},update:function(t,n,r){switch(e.calls++,n){case 4:e.triangles+=r*(t/3);break;case 1:e.lines+=r*(t/2);break;case 3:e.lines+=r*(t-1);break;case 2:e.lines+=r*t;break;case 0:e.points+=r*t;break;default:console.error("THREE.WebGLInfo: Unknown draw mode:",n)}}}}class wa extends er{constructor(t=null,e=1,n=1,r=1){super(null),this.image={data:t,width:e,height:n,depth:r},this.magFilter=xt,this.minFilter=xt,this.wrapR=gt,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1}}function ba(t,e){return t[0]-e[0]}function _a(t,e){return Math.abs(e[1])-Math.abs(t[1])}function Ma(t,e){let n=1;const r=e.isInterleavedBufferAttribute?e.data.array:e.array;r instanceof Int8Array?n=127:r instanceof Int16Array?n=32767:r instanceof Int32Array?n=2147483647:console.error("THREE.WebGLMorphtargets: Unsupported morph attribute data type: ",r),t.divideScalar(n)}function Ta(t,e,n){const r={},i=new Float32Array(8),s=new WeakMap,a=new lr,o=[];for(let t=0;t<8;t++)o[t]=[t,0];return{update:function(l,c,h,u){const d=l.morphTargetInfluences;if(!0===e.isWebGL2){const r=c.morphAttributes.position.length;let i=s.get(c);if(void 0===i||i.count!==r){void 0!==i&&i.texture.dispose();const t=void 0!==c.morphAttributes.normal,n=c.morphAttributes.position,o=c.morphAttributes.normal||[],l=!0===t?2:1;let h=c.attributes.position.count*l,u=1;h>e.maxTextureSize&&(u=Math.ceil(h/e.maxTextureSize),h=e.maxTextureSize);const d=new Float32Array(h*u*4*r),p=new wa(d,h,u,r);p.format=Gt,p.type=It,p.needsUpdate=!0;const f=4*l;for(let e=0;e<r;e++){const r=n[e],i=o[e],s=h*u*4*e;for(let e=0;e<r.count;e++){a.fromBufferAttribute(r,e),!0===r.normalized&&Ma(a,r);const n=e*f;d[s+n+0]=a.x,d[s+n+1]=a.y,d[s+n+2]=a.z,d[s+n+3]=0,!0===t&&(a.fromBufferAttribute(i,e),!0===i.normalized&&Ma(a,i),d[s+n+4]=a.x,d[s+n+5]=a.y,d[s+n+6]=a.z,d[s+n+7]=0)}}i={count:r,texture:p,size:new jn(h,u)},s.set(c,i)}let o=0;for(let t=0;t<d.length;t++)o+=d[t];const l=c.morphTargetsRelative?1:1-o;u.getUniforms().setValue(t,"morphTargetBaseInfluence",l),u.getUniforms().setValue(t,"morphTargetInfluences",d),u.getUniforms().setValue(t,"morphTargetsTexture",i.texture,n),u.getUniforms().setValue(t,"morphTargetsTextureSize",i.size)}else{const e=void 0===d?0:d.length;let n=r[c.id];if(void 0===n||n.length!==e){n=[];for(let t=0;t<e;t++)n[t]=[t,0];r[c.id]=n}for(let t=0;t<e;t++){const e=n[t];e[0]=t,e[1]=d[t]}n.sort(_a);for(let t=0;t<8;t++)t<e&&n[t][1]?(o[t][0]=n[t][0],o[t][1]=n[t][1]):(o[t][0]=Number.MAX_SAFE_INTEGER,o[t][1]=0);o.sort(ba);const s=c.morphAttributes.position,a=c.morphAttributes.normal;let l=0;for(let t=0;t<8;t++){const e=o[t],n=e[0],r=e[1];n!==Number.MAX_SAFE_INTEGER&&r?(s&&c.getAttribute("morphTarget"+t)!==s[n]&&c.setAttribute("morphTarget"+t,s[n]),a&&c.getAttribute("morphNormal"+t)!==a[n]&&c.setAttribute("morphNormal"+t,a[n]),i[t]=r,l+=r):(s&&!0===c.hasAttribute("morphTarget"+t)&&c.deleteAttribute("morphTarget"+t),a&&!0===c.hasAttribute("morphNormal"+t)&&c.deleteAttribute("morphNormal"+t),i[t]=0)}const h=c.morphTargetsRelative?1:1-l;u.getUniforms().setValue(t,"morphTargetBaseInfluence",h),u.getUniforms().setValue(t,"morphTargetInfluences",i)}}}}function Sa(t,e,n,r){let i=new WeakMap;function s(t){const e=t.target;e.removeEventListener("dispose",s),n.remove(e.instanceMatrix),null!==e.instanceColor&&n.remove(e.instanceColor)}return{update:function(t){const a=r.render.frame,o=t.geometry,l=e.get(t,o);return i.get(l)!==a&&(e.update(l),i.set(l,a)),t.isInstancedMesh&&(!1===t.hasEventListener("dispose",s)&&t.addEventListener("dispose",s),n.update(t.instanceMatrix,34962),null!==t.instanceColor&&n.update(t.instanceColor,34962)),l},dispose:function(){i=new WeakMap}}}wa.prototype.isDataTexture2DArray=!0;class Aa extends er{constructor(t=null,e=1,n=1,r=1){super(null),this.image={data:t,width:e,height:n,depth:r},this.magFilter=xt,this.minFilter=xt,this.wrapR=gt,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1}}Aa.prototype.isDataTexture3D=!0;const Ea=new er,Ca=new wa,Pa=new Aa,La=new Es,Ra=[],Fa=[],Da=new Float32Array(16),Ia=new Float32Array(9),Ua=new Float32Array(4);function Na(t,e,n){const r=t[0];if(r<=0||r>0)return t;const i=e*n;let s=Ra[i];if(void 0===s&&(s=new Float32Array(i),Ra[i]=s),0!==e){r.toArray(s,0);for(let r=1,i=0;r!==e;++r)i+=n,t[r].toArray(s,i)}return s}function Oa(t,e){if(t.length!==e.length)return!1;for(let n=0,r=t.length;n<r;n++)if(t[n]!==e[n])return!1;return!0}function Ba(t,e){for(let n=0,r=e.length;n<r;n++)t[n]=e[n]}function za(t,e){let n=Fa[e];void 0===n&&(n=new Int32Array(e),Fa[e]=n);for(let r=0;r!==e;++r)n[r]=t.allocateTextureUnit();return n}function ka(t,e){const n=this.cache;n[0]!==e&&(t.uniform1f(this.addr,e),n[0]=e)}function Ha(t,e){const n=this.cache;if(void 0!==e.x)n[0]===e.x&&n[1]===e.y||(t.uniform2f(this.addr,e.x,e.y),n[0]=e.x,n[1]=e.y);else{if(Oa(n,e))return;t.uniform2fv(this.addr,e),Ba(n,e)}}function Ga(t,e){const n=this.cache;if(void 0!==e.x)n[0]===e.x&&n[1]===e.y&&n[2]===e.z||(t.uniform3f(this.addr,e.x,e.y,e.z),n[0]=e.x,n[1]=e.y,n[2]=e.z);else if(void 0!==e.r)n[0]===e.r&&n[1]===e.g&&n[2]===e.b||(t.uniform3f(this.addr,e.r,e.g,e.b),n[0]=e.r,n[1]=e.g,n[2]=e.b);else{if(Oa(n,e))return;t.uniform3fv(this.addr,e),Ba(n,e)}}function Va(t,e){const n=this.cache;if(void 0!==e.x)n[0]===e.x&&n[1]===e.y&&n[2]===e.z&&n[3]===e.w||(t.uniform4f(this.addr,e.x,e.y,e.z,e.w),n[0]=e.x,n[1]=e.y,n[2]=e.z,n[3]=e.w);else{if(Oa(n,e))return;t.uniform4fv(this.addr,e),Ba(n,e)}}function Wa(t,e){const n=this.cache,r=e.elements;if(void 0===r){if(Oa(n,e))return;t.uniformMatrix2fv(this.addr,!1,e),Ba(n,e)}else{if(Oa(n,r))return;Ua.set(r),t.uniformMatrix2fv(this.addr,!1,Ua),Ba(n,r)}}function Xa(t,e){const n=this.cache,r=e.elements;if(void 0===r){if(Oa(n,e))return;t.uniformMatrix3fv(this.addr,!1,e),Ba(n,e)}else{if(Oa(n,r))return;Ia.set(r),t.uniformMatrix3fv(this.addr,!1,Ia),Ba(n,r)}}function ja(t,e){const n=this.cache,r=e.elements;if(void 0===r){if(Oa(n,e))return;t.uniformMatrix4fv(this.addr,!1,e),Ba(n,e)}else{if(Oa(n,r))return;Da.set(r),t.uniformMatrix4fv(this.addr,!1,Da),Ba(n,r)}}function Ya(t,e){const n=this.cache;n[0]!==e&&(t.uniform1i(this.addr,e),n[0]=e)}function qa(t,e){const n=this.cache;Oa(n,e)||(t.uniform2iv(this.addr,e),Ba(n,e))}function Qa(t,e){const n=this.cache;Oa(n,e)||(t.uniform3iv(this.addr,e),Ba(n,e))}function Za(t,e){const n=this.cache;Oa(n,e)||(t.uniform4iv(this.addr,e),Ba(n,e))}function Ja(t,e){const n=this.cache;n[0]!==e&&(t.uniform1ui(this.addr,e),n[0]=e)}function Ka(t,e){const n=this.cache;Oa(n,e)||(t.uniform2uiv(this.addr,e),Ba(n,e))}function $a(t,e){const n=this.cache;Oa(n,e)||(t.uniform3uiv(this.addr,e),Ba(n,e))}function to(t,e){const n=this.cache;Oa(n,e)||(t.uniform4uiv(this.addr,e),Ba(n,e))}function eo(t,e,n){const r=this.cache,i=n.allocateTextureUnit();r[0]!==i&&(t.uniform1i(this.addr,i),r[0]=i),n.safeSetTexture2D(e||Ea,i)}function no(t,e,n){const r=this.cache,i=n.allocateTextureUnit();r[0]!==i&&(t.uniform1i(this.addr,i),r[0]=i),n.setTexture3D(e||Pa,i)}function ro(t,e,n){const r=this.cache,i=n.allocateTextureUnit();r[0]!==i&&(t.uniform1i(this.addr,i),r[0]=i),n.safeSetTextureCube(e||La,i)}function io(t,e,n){const r=this.cache,i=n.allocateTextureUnit();r[0]!==i&&(t.uniform1i(this.addr,i),r[0]=i),n.setTexture2DArray(e||Ca,i)}function so(t,e){t.uniform1fv(this.addr,e)}function ao(t,e){const n=Na(e,this.size,2);t.uniform2fv(this.addr,n)}function oo(t,e){const n=Na(e,this.size,3);t.uniform3fv(this.addr,n)}function lo(t,e){const n=Na(e,this.size,4);t.uniform4fv(this.addr,n)}function co(t,e){const n=Na(e,this.size,4);t.uniformMatrix2fv(this.addr,!1,n)}function ho(t,e){const n=Na(e,this.size,9);t.uniformMatrix3fv(this.addr,!1,n)}function uo(t,e){const n=Na(e,this.size,16);t.uniformMatrix4fv(this.addr,!1,n)}function po(t,e){t.uniform1iv(this.addr,e)}function fo(t,e){t.uniform2iv(this.addr,e)}function mo(t,e){t.uniform3iv(this.addr,e)}function go(t,e){t.uniform4iv(this.addr,e)}function vo(t,e){t.uniform1uiv(this.addr,e)}function xo(t,e){t.uniform2uiv(this.addr,e)}function yo(t,e){t.uniform3uiv(this.addr,e)}function wo(t,e){t.uniform4uiv(this.addr,e)}function bo(t,e,n){const r=e.length,i=za(n,r);t.uniform1iv(this.addr,i);for(let t=0;t!==r;++t)n.safeSetTexture2D(e[t]||Ea,i[t])}function _o(t,e,n){const r=e.length,i=za(n,r);t.uniform1iv(this.addr,i);for(let t=0;t!==r;++t)n.setTexture3D(e[t]||Pa,i[t])}function Mo(t,e,n){const r=e.length,i=za(n,r);t.uniform1iv(this.addr,i);for(let t=0;t!==r;++t)n.safeSetTextureCube(e[t]||La,i[t])}function To(t,e,n){const r=e.length,i=za(n,r);t.uniform1iv(this.addr,i);for(let t=0;t!==r;++t)n.setTexture2DArray(e[t]||Ca,i[t])}function So(t,e,n){this.id=t,this.addr=n,this.cache=[],this.setValue=function(t){switch(t){case 5126:return ka;case 35664:return Ha;case 35665:return Ga;case 35666:return Va;case 35674:return Wa;case 35675:return Xa;case 35676:return ja;case 5124:case 35670:return Ya;case 35667:case 35671:return qa;case 35668:case 35672:return Qa;case 35669:case 35673:return Za;case 5125:return Ja;case 36294:return Ka;case 36295:return $a;case 36296:return to;case 35678:case 36198:case 36298:case 36306:case 35682:return eo;case 35679:case 36299:case 36307:return no;case 35680:case 36300:case 36308:case 36293:return ro;case 36289:case 36303:case 36311:case 36292:return io}}(e.type)}function Ao(t,e,n){this.id=t,this.addr=n,this.cache=[],this.size=e.size,this.setValue=function(t){switch(t){case 5126:return so;case 35664:return ao;case 35665:return oo;case 35666:return lo;case 35674:return co;case 35675:return ho;case 35676:return uo;case 5124:case 35670:return po;case 35667:case 35671:return fo;case 35668:case 35672:return mo;case 35669:case 35673:return go;case 5125:return vo;case 36294:return xo;case 36295:return yo;case 36296:return wo;case 35678:case 36198:case 36298:case 36306:case 35682:return bo;case 35679:case 36299:case 36307:return _o;case 35680:case 36300:case 36308:case 36293:return Mo;case 36289:case 36303:case 36311:case 36292:return To}}(e.type)}function Eo(t){this.id=t,this.seq=[],this.map={}}Ao.prototype.updateCache=function(t){const e=this.cache;t instanceof Float32Array&&e.length!==t.length&&(this.cache=new Float32Array(t.length)),Ba(e,t)},Eo.prototype.setValue=function(t,e,n){const r=this.seq;for(let i=0,s=r.length;i!==s;++i){const s=r[i];s.setValue(t,e[s.id],n)}};const Co=/(\w+)(\])?(\[|\.)?/g;function Po(t,e){t.seq.push(e),t.map[e.id]=e}function Lo(t,e,n){const r=t.name,i=r.length;for(Co.lastIndex=0;;){const s=Co.exec(r),a=Co.lastIndex;let o=s[1];const l="]"===s[2],c=s[3];if(l&&(o|=0),void 0===c||"["===c&&a+2===i){Po(n,void 0===c?new So(o,t,e):new Ao(o,t,e));break}{let t=n.map[o];void 0===t&&(t=new Eo(o),Po(n,t)),n=t}}}function Ro(t,e){this.seq=[],this.map={};const n=t.getProgramParameter(e,35718);for(let r=0;r<n;++r){const n=t.getActiveUniform(e,r);Lo(n,t.getUniformLocation(e,n.name),this)}}function Fo(t,e,n){const r=t.createShader(e);return t.shaderSource(r,n),t.compileShader(r),r}Ro.prototype.setValue=function(t,e,n,r){const i=this.map[e];void 0!==i&&i.setValue(t,n,r)},Ro.prototype.setOptional=function(t,e,n){const r=e[n];void 0!==r&&this.setValue(t,n,r)},Ro.upload=function(t,e,n,r){for(let i=0,s=e.length;i!==s;++i){const s=e[i],a=n[s.id];!1!==a.needsUpdate&&s.setValue(t,a.value,r)}},Ro.seqWithValue=function(t,e){const n=[];for(let r=0,i=t.length;r!==i;++r){const i=t[r];i.id in e&&n.push(i)}return n};let Do=0;function Io(t){switch(t){case $e:return["Linear","( value )"];case tn:return["sRGB","( value )"];default:return console.warn("THREE.WebGLProgram: Unsupported encoding:",t),["Linear","( value )"]}}function Uo(t,e,n){const r=t.getShaderParameter(e,35713),i=t.getShaderInfoLog(e).trim();return r&&""===i?"":n.toUpperCase()+"\n\n"+i+"\n\n"+function(t){const e=t.split("\n");for(let t=0;t<e.length;t++)e[t]=t+1+": "+e[t];return e.join("\n")}(t.getShaderSource(e))}function No(t,e){const n=Io(e);return"vec4 "+t+"( vec4 value ) { return "+n[0]+"ToLinear"+n[1]+"; }"}function Oo(t,e){const n=Io(e);return"vec4 "+t+"( vec4 value ) { return LinearTo"+n[0]+n[1]+"; }"}function Bo(t,e){let n;switch(e){case rt:n="Linear";break;case it:n="Reinhard";break;case st:n="OptimizedCineon";break;case at:n="ACESFilmic";break;case ot:n="Custom";break;default:console.warn("THREE.WebGLProgram: Unsupported toneMapping:",e),n="Linear"}return"vec3 "+t+"( vec3 color ) { return "+n+"ToneMapping( color ); }"}function zo(t){return""!==t}function ko(t,e){return t.replace(/NUM_DIR_LIGHTS/g,e.numDirLights).replace(/NUM_SPOT_LIGHTS/g,e.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g,e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g,e.numPointLights).replace(/NUM_HEMI_LIGHTS/g,e.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g,e.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g,e.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g,e.numPointLightShadows)}function Ho(t,e){return t.replace(/NUM_CLIPPING_PLANES/g,e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g,e.numClippingPlanes-e.numClipIntersection)}const Go=/^[ \t]*#include +<([\w\d./]+)>/gm;function Vo(t){return t.replace(Go,Wo)}function Wo(t,e){const n=zs[e];if(void 0===n)throw new Error("Can not resolve #include <"+e+">");return Vo(n)}const Xo=/#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g,jo=/#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;function Yo(t){return t.replace(jo,Qo).replace(Xo,qo)}function qo(t,e,n,r){return console.warn("WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead."),Qo(0,e,n,r)}function Qo(t,e,n,r){let i="";for(let t=parseInt(e);t<parseInt(n);t++)i+=r.replace(/\[\s*i\s*\]/g,"[ "+t+" ]").replace(/UNROLLED_LOOP_INDEX/g,t);return i}function Zo(t){let e="precision "+t.precision+" float;\nprecision "+t.precision+" int;";return"highp"===t.precision?e+="\n#define HIGH_PRECISION":"mediump"===t.precision?e+="\n#define MEDIUM_PRECISION":"lowp"===t.precision&&(e+="\n#define LOW_PRECISION"),e}function Jo(t,e,n,r){const i=t.getContext(),s=n.defines;let a=n.vertexShader,o=n.fragmentShader;const l=function(t){let e="SHADOWMAP_TYPE_BASIC";return t.shadowMapType===m?e="SHADOWMAP_TYPE_PCF":t.shadowMapType===g?e="SHADOWMAP_TYPE_PCF_SOFT":t.shadowMapType===v&&(e="SHADOWMAP_TYPE_VSM"),e}(n),c=function(t){let e="ENVMAP_TYPE_CUBE";if(t.envMap)switch(t.envMapMode){case ct:case ht:e="ENVMAP_TYPE_CUBE";break;case pt:case ft:e="ENVMAP_TYPE_CUBE_UV"}return e}(n),h=function(t){let e="ENVMAP_MODE_REFLECTION";if(t.envMap)switch(t.envMapMode){case ht:case ft:e="ENVMAP_MODE_REFRACTION"}return e}(n),u=function(t){let e="ENVMAP_BLENDING_NONE";if(t.envMap)switch(t.combine){case $:e="ENVMAP_BLENDING_MULTIPLY";break;case tt:e="ENVMAP_BLENDING_MIX";break;case et:e="ENVMAP_BLENDING_ADD"}return e}(n),d=n.isWebGL2?"":function(t){return[t.extensionDerivatives||t.envMapCubeUV||t.bumpMap||t.tangentSpaceNormalMap||t.clearcoatNormalMap||t.flatShading||"physical"===t.shaderID?"#extension GL_OES_standard_derivatives : enable":"",(t.extensionFragDepth||t.logarithmicDepthBuffer)&&t.rendererExtensionFragDepth?"#extension GL_EXT_frag_depth : enable":"",t.extensionDrawBuffers&&t.rendererExtensionDrawBuffers?"#extension GL_EXT_draw_buffers : require":"",(t.extensionShaderTextureLOD||t.envMap||t.transmission)&&t.rendererExtensionShaderTextureLod?"#extension GL_EXT_shader_texture_lod : enable":""].filter(zo).join("\n")}(n),p=function(t){const e=[];for(const n in t){const r=t[n];!1!==r&&e.push("#define "+n+" "+r)}return e.join("\n")}(s),f=i.createProgram();let x,y,w=n.glslVersion?"#version "+n.glslVersion+"\n":"";n.isRawShaderMaterial?(x=[p].filter(zo).join("\n"),x.length>0&&(x+="\n"),y=[d,p].filter(zo).join("\n"),y.length>0&&(y+="\n")):(x=[Zo(n),"#define SHADER_NAME "+n.shaderName,p,n.instancing?"#define USE_INSTANCING":"",n.instancingColor?"#define USE_INSTANCING_COLOR":"",n.supportsVertexTextures?"#define VERTEX_TEXTURES":"","#define MAX_BONES "+n.maxBones,n.useFog&&n.fog?"#define USE_FOG":"",n.useFog&&n.fogExp2?"#define FOG_EXP2":"",n.map?"#define USE_MAP":"",n.envMap?"#define USE_ENVMAP":"",n.envMap?"#define "+h:"",n.lightMap?"#define USE_LIGHTMAP":"",n.aoMap?"#define USE_AOMAP":"",n.emissiveMap?"#define USE_EMISSIVEMAP":"",n.bumpMap?"#define USE_BUMPMAP":"",n.normalMap?"#define USE_NORMALMAP":"",n.normalMap&&n.objectSpaceNormalMap?"#define OBJECTSPACE_NORMALMAP":"",n.normalMap&&n.tangentSpaceNormalMap?"#define TANGENTSPACE_NORMALMAP":"",n.clearcoatMap?"#define USE_CLEARCOATMAP":"",n.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",n.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",n.displacementMap&&n.supportsVertexTextures?"#define USE_DISPLACEMENTMAP":"",n.specularMap?"#define USE_SPECULARMAP":"",n.specularIntensityMap?"#define USE_SPECULARINTENSITYMAP":"",n.specularColorMap?"#define USE_SPECULARCOLORMAP":"",n.roughnessMap?"#define USE_ROUGHNESSMAP":"",n.metalnessMap?"#define USE_METALNESSMAP":"",n.alphaMap?"#define USE_ALPHAMAP":"",n.transmission?"#define USE_TRANSMISSION":"",n.transmissionMap?"#define USE_TRANSMISSIONMAP":"",n.thicknessMap?"#define USE_THICKNESSMAP":"",n.sheenColorMap?"#define USE_SHEENCOLORMAP":"",n.sheenRoughnessMap?"#define USE_SHEENROUGHNESSMAP":"",n.vertexTangents?"#define USE_TANGENT":"",n.vertexColors?"#define USE_COLOR":"",n.vertexAlphas?"#define USE_COLOR_ALPHA":"",n.vertexUvs?"#define USE_UV":"",n.uvsVertexOnly?"#define UVS_VERTEX_ONLY":"",n.flatShading?"#define FLAT_SHADED":"",n.skinning?"#define USE_SKINNING":"",n.useVertexTexture?"#define BONE_TEXTURE":"",n.morphTargets?"#define USE_MORPHTARGETS":"",n.morphNormals&&!1===n.flatShading?"#define USE_MORPHNORMALS":"",n.morphTargets&&n.isWebGL2?"#define MORPHTARGETS_TEXTURE":"",n.morphTargets&&n.isWebGL2?"#define MORPHTARGETS_COUNT "+n.morphTargetsCount:"",n.doubleSided?"#define DOUBLE_SIDED":"",n.flipSided?"#define FLIP_SIDED":"",n.shadowMapEnabled?"#define USE_SHADOWMAP":"",n.shadowMapEnabled?"#define "+l:"",n.sizeAttenuation?"#define USE_SIZEATTENUATION":"",n.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",n.logarithmicDepthBuffer&&n.rendererExtensionFragDepth?"#define USE_LOGDEPTHBUF_EXT":"","uniform mat4 modelMatrix;","uniform mat4 modelViewMatrix;","uniform mat4 projectionMatrix;","uniform mat4 viewMatrix;","uniform mat3 normalMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;","#ifdef USE_INSTANCING","\tattribute mat4 instanceMatrix;","#endif","#ifdef USE_INSTANCING_COLOR","\tattribute vec3 instanceColor;","#endif","attribute vec3 position;","attribute vec3 normal;","attribute vec2 uv;","#ifdef USE_TANGENT","\tattribute vec4 tangent;","#endif","#if defined( USE_COLOR_ALPHA )","\tattribute vec4 color;","#elif defined( USE_COLOR )","\tattribute vec3 color;","#endif","#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )","\tattribute vec3 morphTarget0;","\tattribute vec3 morphTarget1;","\tattribute vec3 morphTarget2;","\tattribute vec3 morphTarget3;","\t#ifdef USE_MORPHNORMALS","\t\tattribute vec3 morphNormal0;","\t\tattribute vec3 morphNormal1;","\t\tattribute vec3 morphNormal2;","\t\tattribute vec3 morphNormal3;","\t#else","\t\tattribute vec3 morphTarget4;","\t\tattribute vec3 morphTarget5;","\t\tattribute vec3 morphTarget6;","\t\tattribute vec3 morphTarget7;","\t#endif","#endif","#ifdef USE_SKINNING","\tattribute vec4 skinIndex;","\tattribute vec4 skinWeight;","#endif","\n"].filter(zo).join("\n"),y=[d,Zo(n),"#define SHADER_NAME "+n.shaderName,p,n.useFog&&n.fog?"#define USE_FOG":"",n.useFog&&n.fogExp2?"#define FOG_EXP2":"",n.map?"#define USE_MAP":"",n.matcap?"#define USE_MATCAP":"",n.envMap?"#define USE_ENVMAP":"",n.envMap?"#define "+c:"",n.envMap?"#define "+h:"",n.envMap?"#define "+u:"",n.lightMap?"#define USE_LIGHTMAP":"",n.aoMap?"#define USE_AOMAP":"",n.emissiveMap?"#define USE_EMISSIVEMAP":"",n.bumpMap?"#define USE_BUMPMAP":"",n.normalMap?"#define USE_NORMALMAP":"",n.normalMap&&n.objectSpaceNormalMap?"#define OBJECTSPACE_NORMALMAP":"",n.normalMap&&n.tangentSpaceNormalMap?"#define TANGENTSPACE_NORMALMAP":"",n.clearcoat?"#define USE_CLEARCOAT":"",n.clearcoatMap?"#define USE_CLEARCOATMAP":"",n.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",n.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",n.specularMap?"#define USE_SPECULARMAP":"",n.specularIntensityMap?"#define USE_SPECULARINTENSITYMAP":"",n.specularColorMap?"#define USE_SPECULARCOLORMAP":"",n.roughnessMap?"#define USE_ROUGHNESSMAP":"",n.metalnessMap?"#define USE_METALNESSMAP":"",n.alphaMap?"#define USE_ALPHAMAP":"",n.alphaTest?"#define USE_ALPHATEST":"",n.sheen?"#define USE_SHEEN":"",n.sheenColorMap?"#define USE_SHEENCOLORMAP":"",n.sheenRoughnessMap?"#define USE_SHEENROUGHNESSMAP":"",n.transmission?"#define USE_TRANSMISSION":"",n.transmissionMap?"#define USE_TRANSMISSIONMAP":"",n.thicknessMap?"#define USE_THICKNESSMAP":"",n.vertexTangents?"#define USE_TANGENT":"",n.vertexColors||n.instancingColor?"#define USE_COLOR":"",n.vertexAlphas?"#define USE_COLOR_ALPHA":"",n.vertexUvs?"#define USE_UV":"",n.uvsVertexOnly?"#define UVS_VERTEX_ONLY":"",n.gradientMap?"#define USE_GRADIENTMAP":"",n.flatShading?"#define FLAT_SHADED":"",n.doubleSided?"#define DOUBLE_SIDED":"",n.flipSided?"#define FLIP_SIDED":"",n.shadowMapEnabled?"#define USE_SHADOWMAP":"",n.shadowMapEnabled?"#define "+l:"",n.premultipliedAlpha?"#define PREMULTIPLIED_ALPHA":"",n.physicallyCorrectLights?"#define PHYSICALLY_CORRECT_LIGHTS":"",n.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",n.logarithmicDepthBuffer&&n.rendererExtensionFragDepth?"#define USE_LOGDEPTHBUF_EXT":"",(n.extensionShaderTextureLOD||n.envMap)&&n.rendererExtensionShaderTextureLod?"#define TEXTURE_LOD_EXT":"","uniform mat4 viewMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;",n.toneMapping!==nt?"#define TONE_MAPPING":"",n.toneMapping!==nt?zs.tonemapping_pars_fragment:"",n.toneMapping!==nt?Bo("toneMapping",n.toneMapping):"",n.dithering?"#define DITHERING":"",n.format===Ht?"#define OPAQUE":"",zs.encodings_pars_fragment,n.map?No("mapTexelToLinear",n.mapEncoding):"",n.matcap?No("matcapTexelToLinear",n.matcapEncoding):"",n.envMap?No("envMapTexelToLinear",n.envMapEncoding):"",n.emissiveMap?No("emissiveMapTexelToLinear",n.emissiveMapEncoding):"",n.specularColorMap?No("specularColorMapTexelToLinear",n.specularColorMapEncoding):"",n.sheenColorMap?No("sheenColorMapTexelToLinear",n.sheenColorMapEncoding):"",n.lightMap?No("lightMapTexelToLinear",n.lightMapEncoding):"",Oo("linearToOutputTexel",n.outputEncoding),n.depthPacking?"#define DEPTH_PACKING "+n.depthPacking:"","\n"].filter(zo).join("\n")),a=Vo(a),a=ko(a,n),a=Ho(a,n),o=Vo(o),o=ko(o,n),o=Ho(o,n),a=Yo(a),o=Yo(o),n.isWebGL2&&!0!==n.isRawShaderMaterial&&(w="#version 300 es\n",x=["precision mediump sampler2DArray;","#define attribute in","#define varying out","#define texture2D texture"].join("\n")+"\n"+x,y=["#define varying in",n.glslVersion===Fn?"":"layout(location = 0) out highp vec4 pc_fragColor;",n.glslVersion===Fn?"":"#define gl_FragColor pc_fragColor","#define gl_FragDepthEXT gl_FragDepth","#define texture2D texture","#define textureCube texture","#define texture2DProj textureProj","#define texture2DLodEXT textureLod","#define texture2DProjLodEXT textureProjLod","#define textureCubeLodEXT textureLod","#define texture2DGradEXT textureGrad","#define texture2DProjGradEXT textureProjGrad","#define textureCubeGradEXT textureGrad"].join("\n")+"\n"+y);const b=w+y+o,_=Fo(i,35633,w+x+a),M=Fo(i,35632,b);if(i.attachShader(f,_),i.attachShader(f,M),void 0!==n.index0AttributeName?i.bindAttribLocation(f,0,n.index0AttributeName):!0===n.morphTargets&&i.bindAttribLocation(f,0,"position"),i.linkProgram(f),t.debug.checkShaderErrors){const t=i.getProgramInfoLog(f).trim(),e=i.getShaderInfoLog(_).trim(),n=i.getShaderInfoLog(M).trim();let r=!0,s=!0;if(!1===i.getProgramParameter(f,35714)){r=!1;const e=Uo(i,_,"vertex"),n=Uo(i,M,"fragment");console.error("THREE.WebGLProgram: Shader Error "+i.getError()+" - VALIDATE_STATUS "+i.getProgramParameter(f,35715)+"\n\nProgram Info Log: "+t+"\n"+e+"\n"+n)}else""!==t?console.warn("THREE.WebGLProgram: Program Info Log:",t):""!==e&&""!==n||(s=!1);s&&(this.diagnostics={runnable:r,programLog:t,vertexShader:{log:e,prefix:x},fragmentShader:{log:n,prefix:y}})}let T,S;return i.deleteShader(_),i.deleteShader(M),this.getUniforms=function(){return void 0===T&&(T=new Ro(i,f)),T},this.getAttributes=function(){return void 0===S&&(S=function(t,e){const n={},r=t.getProgramParameter(e,35721);for(let i=0;i<r;i++){const r=t.getActiveAttrib(e,i),s=r.name;let a=1;35674===r.type&&(a=2),35675===r.type&&(a=3),35676===r.type&&(a=4),n[s]={type:r.type,location:t.getAttribLocation(e,s),locationSize:a}}return n}(i,f)),S},this.destroy=function(){r.releaseStatesOfProgram(this),i.deleteProgram(f),this.program=void 0},this.name=n.shaderName,this.id=Do++,this.cacheKey=e,this.usedTimes=1,this.program=f,this.vertexShader=_,this.fragmentShader=M,this}let Ko=0;class $o{constructor(){this.shaderCache=new Map,this.materialCache=new Map}update(t){const e=t.vertexShader,n=t.fragmentShader,r=this._getShaderStage(e),i=this._getShaderStage(n),s=this._getShaderCacheForMaterial(t);return!1===s.has(r)&&(s.add(r),r.usedTimes++),!1===s.has(i)&&(s.add(i),i.usedTimes++),this}remove(t){const e=this.materialCache.get(t);for(const t of e)t.usedTimes--,0===t.usedTimes&&this.shaderCache.delete(t);return this.materialCache.delete(t),this}getVertexShaderID(t){return this._getShaderStage(t.vertexShader).id}getFragmentShaderID(t){return this._getShaderStage(t.fragmentShader).id}dispose(){this.shaderCache.clear(),this.materialCache.clear()}_getShaderCacheForMaterial(t){const e=this.materialCache;return!1===e.has(t)&&e.set(t,new Set),e.get(t)}_getShaderStage(t){const e=this.shaderCache;if(!1===e.has(t)){const n=new tl;e.set(t,n)}return e.get(t)}}class tl{constructor(){this.id=Ko++,this.usedTimes=0}}function el(t,e,n,r,i,s,a){const o=new Zr,l=new $o,c=[],h=i.isWebGL2,u=i.logarithmicDepthBuffer,d=i.floatVertexTextures,p=i.maxVertexUniforms,f=i.vertexTextures;let m=i.precision;const g={MeshDepthMaterial:"depth",MeshDistanceMaterial:"distanceRGBA",MeshNormalMaterial:"normal",MeshBasicMaterial:"basic",MeshLambertMaterial:"lambert",MeshPhongMaterial:"phong",MeshToonMaterial:"toon",MeshStandardMaterial:"physical",MeshPhysicalMaterial:"physical",MeshMatcapMaterial:"matcap",LineBasicMaterial:"basic",LineDashedMaterial:"dashed",PointsMaterial:"points",ShadowMaterial:"shadow",SpriteMaterial:"sprite"};function v(t){let e;return t&&t.isTexture?e=t.encoding:t&&t.isWebGLRenderTarget?(console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."),e=t.texture.encoding):e=$e,h&&t&&t.isTexture&&t.format===Gt&&t.type===Ct&&t.encoding===tn&&(e=$e),e}return{getParameters:function(s,o,c,x,b){const _=x.fog,M=s.isMeshStandardMaterial?x.environment:null,T=(s.isMeshStandardMaterial?n:e).get(s.envMap||M),S=g[s.type],A=b.isSkinnedMesh?function(t){const e=t.skeleton.bones;if(d)return 1024;{const t=p,n=Math.floor((t-20)/4),r=Math.min(n,e.length);return r<e.length?(console.warn("THREE.WebGLRenderer: Skeleton has "+e.length+" bones. This GPU supports "+r+"."),0):r}}(b):0;let E,C,P,L;if(null!==s.precision&&(m=i.getMaxPrecision(s.precision),m!==s.precision&&console.warn("THREE.WebGLProgram.getParameters:",s.precision,"not supported, using",m,"instead.")),S){const t=Hs[S];E=t.vertexShader,C=t.fragmentShader}else E=s.vertexShader,C=s.fragmentShader,l.update(s),P=l.getVertexShaderID(s),L=l.getFragmentShaderID(s);const R=t.getRenderTarget(),F=s.alphaTest>0,D=s.clearcoat>0;return{isWebGL2:h,shaderID:S,shaderName:s.type,vertexShader:E,fragmentShader:C,defines:s.defines,customVertexShaderID:P,customFragmentShaderID:L,isRawShaderMaterial:!0===s.isRawShaderMaterial,glslVersion:s.glslVersion,precision:m,instancing:!0===b.isInstancedMesh,instancingColor:!0===b.isInstancedMesh&&null!==b.instanceColor,supportsVertexTextures:f,outputEncoding:null!==R?v(R.texture):t.outputEncoding,map:!!s.map,mapEncoding:v(s.map),matcap:!!s.matcap,matcapEncoding:v(s.matcap),envMap:!!T,envMapMode:T&&T.mapping,envMapEncoding:v(T),envMapCubeUV:!!T&&(T.mapping===pt||T.mapping===ft),lightMap:!!s.lightMap,lightMapEncoding:v(s.lightMap),aoMap:!!s.aoMap,emissiveMap:!!s.emissiveMap,emissiveMapEncoding:v(s.emissiveMap),bumpMap:!!s.bumpMap,normalMap:!!s.normalMap,objectSpaceNormalMap:s.normalMapType===sn,tangentSpaceNormalMap:s.normalMapType===rn,clearcoat:D,clearcoatMap:D&&!!s.clearcoatMap,clearcoatRoughnessMap:D&&!!s.clearcoatRoughnessMap,clearcoatNormalMap:D&&!!s.clearcoatNormalMap,displacementMap:!!s.displacementMap,roughnessMap:!!s.roughnessMap,metalnessMap:!!s.metalnessMap,specularMap:!!s.specularMap,specularIntensityMap:!!s.specularIntensityMap,specularColorMap:!!s.specularColorMap,specularColorMapEncoding:v(s.specularColorMap),alphaMap:!!s.alphaMap,alphaTest:F,gradientMap:!!s.gradientMap,sheen:s.sheen>0,sheenColorMap:!!s.sheenColorMap,sheenColorMapEncoding:v(s.sheenColorMap),sheenRoughnessMap:!!s.sheenRoughnessMap,transmission:s.transmission>0,transmissionMap:!!s.transmissionMap,thicknessMap:!!s.thicknessMap,combine:s.combine,vertexTangents:!!s.normalMap&&!!b.geometry&&!!b.geometry.attributes.tangent,vertexColors:s.vertexColors,vertexAlphas:!0===s.vertexColors&&!!b.geometry&&!!b.geometry.attributes.color&&4===b.geometry.attributes.color.itemSize,vertexUvs:!!(s.map||s.bumpMap||s.normalMap||s.specularMap||s.alphaMap||s.emissiveMap||s.roughnessMap||s.metalnessMap||s.clearcoatMap||s.clearcoatRoughnessMap||s.clearcoatNormalMap||s.displacementMap||s.transmissionMap||s.thicknessMap||s.specularIntensityMap||s.specularColorMap||s.sheenColorMap||s.sheenRoughnessMap),uvsVertexOnly:!(s.map||s.bumpMap||s.normalMap||s.specularMap||s.alphaMap||s.emissiveMap||s.roughnessMap||s.metalnessMap||s.clearcoatNormalMap||s.transmission>0||s.transmissionMap||s.thicknessMap||s.specularIntensityMap||s.specularColorMap||s.sheen>0||s.sheenColorMap||s.sheenRoughnessMap||!s.displacementMap),fog:!!_,useFog:s.fog,fogExp2:_&&_.isFogExp2,flatShading:!!s.flatShading,sizeAttenuation:s.sizeAttenuation,logarithmicDepthBuffer:u,skinning:!0===b.isSkinnedMesh&&A>0,maxBones:A,useVertexTexture:d,morphTargets:!!b.geometry&&!!b.geometry.morphAttributes.position,morphNormals:!!b.geometry&&!!b.geometry.morphAttributes.normal,morphTargetsCount:b.geometry&&b.geometry.morphAttributes.position?b.geometry.morphAttributes.position.length:0,numDirLights:o.directional.length,numPointLights:o.point.length,numSpotLights:o.spot.length,numRectAreaLights:o.rectArea.length,numHemiLights:o.hemi.length,numDirLightShadows:o.directionalShadowMap.length,numPointLightShadows:o.pointShadowMap.length,numSpotLightShadows:o.spotShadowMap.length,numClippingPlanes:a.numPlanes,numClipIntersection:a.numIntersection,format:s.format,dithering:s.dithering,shadowMapEnabled:t.shadowMap.enabled&&c.length>0,shadowMapType:t.shadowMap.type,toneMapping:s.toneMapped?t.toneMapping:nt,physicallyCorrectLights:t.physicallyCorrectLights,premultipliedAlpha:s.premultipliedAlpha,doubleSided:s.side===w,flipSided:s.side===y,depthPacking:void 0!==s.depthPacking&&s.depthPacking,index0AttributeName:s.index0AttributeName,extensionDerivatives:s.extensions&&s.extensions.derivatives,extensionFragDepth:s.extensions&&s.extensions.fragDepth,extensionDrawBuffers:s.extensions&&s.extensions.drawBuffers,extensionShaderTextureLOD:s.extensions&&s.extensions.shaderTextureLOD,rendererExtensionFragDepth:h||r.has("EXT_frag_depth"),rendererExtensionDrawBuffers:h||r.has("WEBGL_draw_buffers"),rendererExtensionShaderTextureLod:h||r.has("EXT_shader_texture_lod"),customProgramCacheKey:s.customProgramCacheKey()}},getProgramCacheKey:function(e){const n=[];if(e.shaderID?n.push(e.shaderID):(n.push(e.customVertexShaderID),n.push(e.customFragmentShaderID)),void 0!==e.defines)for(const t in e.defines)n.push(t),n.push(e.defines[t]);return!1===e.isRawShaderMaterial&&(function(t,e){t.push(e.precision),t.push(e.outputEncoding),t.push(e.mapEncoding),t.push(e.matcapEncoding),t.push(e.envMapMode),t.push(e.envMapEncoding),t.push(e.lightMapEncoding),t.push(e.emissiveMapEncoding),t.push(e.combine),t.push(e.vertexUvs),t.push(e.fogExp2),t.push(e.sizeAttenuation),t.push(e.maxBones),t.push(e.morphTargetsCount),t.push(e.numDirLights),t.push(e.numPointLights),t.push(e.numSpotLights),t.push(e.numHemiLights),t.push(e.numRectAreaLights),t.push(e.numDirLightShadows),t.push(e.numPointLightShadows),t.push(e.numSpotLightShadows),t.push(e.shadowMapType),t.push(e.toneMapping),t.push(e.numClippingPlanes),t.push(e.numClipIntersection),t.push(e.format),t.push(e.specularColorMapEncoding),t.push(e.sheenColorMapEncoding)}(n,e),function(t,e){o.disableAll(),e.isWebGL2&&o.enable(0),e.supportsVertexTextures&&o.enable(1),e.instancing&&o.enable(2),e.instancingColor&&o.enable(3),e.map&&o.enable(4),e.matcap&&o.enable(5),e.envMap&&o.enable(6),e.envMapCubeUV&&o.enable(7),e.lightMap&&o.enable(8),e.aoMap&&o.enable(9),e.emissiveMap&&o.enable(10),e.bumpMap&&o.enable(11),e.normalMap&&o.enable(12),e.objectSpaceNormalMap&&o.enable(13),e.tangentSpaceNormalMap&&o.enable(14),e.clearcoat&&o.enable(15),e.clearcoatMap&&o.enable(16),e.clearcoatRoughnessMap&&o.enable(17),e.clearcoatNormalMap&&o.enable(18),e.displacementMap&&o.enable(19),e.specularMap&&o.enable(20),e.roughnessMap&&o.enable(21),e.metalnessMap&&o.enable(22),e.gradientMap&&o.enable(23),e.alphaMap&&o.enable(24),e.alphaTest&&o.enable(25),e.vertexColors&&o.enable(26),e.vertexAlphas&&o.enable(27),e.vertexUvs&&o.enable(28),e.vertexTangents&&o.enable(29),e.uvsVertexOnly&&o.enable(30),e.fog&&o.enable(31),t.push(o.mask),o.disableAll(),e.useFog&&o.enable(0),e.flatShading&&o.enable(1),e.logarithmicDepthBuffer&&o.enable(2),e.skinning&&o.enable(3),e.useVertexTexture&&o.enable(4),e.morphTargets&&o.enable(5),e.morphNormals&&o.enable(6),e.premultipliedAlpha&&o.enable(7),e.shadowMapEnabled&&o.enable(8),e.physicallyCorrectLights&&o.enable(9),e.doubleSided&&o.enable(10),e.flipSided&&o.enable(11),e.depthPacking&&o.enable(12),e.dithering&&o.enable(13),e.specularIntensityMap&&o.enable(14),e.specularColorMap&&o.enable(15),e.transmission&&o.enable(16),e.transmissionMap&&o.enable(17),e.thicknessMap&&o.enable(18),e.sheen&&o.enable(19),e.sheenColorMap&&o.enable(20),e.sheenRoughnessMap&&o.enable(21),t.push(o.mask)}(n,e),n.push(t.outputEncoding)),n.push(e.customProgramCacheKey),n.join()},getUniforms:function(t){const e=g[t.type];let n;if(e){const t=Hs[e];n=bs.clone(t.uniforms)}else n=t.uniforms;return n},acquireProgram:function(e,n){let r;for(let t=0,e=c.length;t<e;t++){const e=c[t];if(e.cacheKey===n){r=e,++r.usedTimes;break}}return void 0===r&&(r=new Jo(t,n,e,s),c.push(r)),r},releaseProgram:function(t){if(0==--t.usedTimes){const e=c.indexOf(t);c[e]=c[c.length-1],c.pop(),t.destroy()}},releaseShaderCache:function(t){l.remove(t)},programs:c,dispose:function(){l.dispose()}}}function nl(){let t=new WeakMap;return{get:function(e){let n=t.get(e);return void 0===n&&(n={},t.set(e,n)),n},remove:function(e){t.delete(e)},update:function(e,n,r){t.get(e)[n]=r},dispose:function(){t=new WeakMap}}}function rl(t,e){return t.groupOrder!==e.groupOrder?t.groupOrder-e.groupOrder:t.renderOrder!==e.renderOrder?t.renderOrder-e.renderOrder:t.material.id!==e.material.id?t.material.id-e.material.id:t.z!==e.z?t.z-e.z:t.id-e.id}function il(t,e){return t.groupOrder!==e.groupOrder?t.groupOrder-e.groupOrder:t.renderOrder!==e.renderOrder?t.renderOrder-e.renderOrder:t.z!==e.z?e.z-t.z:t.id-e.id}function sl(){const t=[];let e=0;const n=[],r=[],i=[];function s(n,r,i,s,a,o){let l=t[e];return void 0===l?(l={id:n.id,object:n,geometry:r,material:i,groupOrder:s,renderOrder:n.renderOrder,z:a,group:o},t[e]=l):(l.id=n.id,l.object=n,l.geometry=r,l.material=i,l.groupOrder=s,l.renderOrder=n.renderOrder,l.z=a,l.group=o),e++,l}return{opaque:n,transmissive:r,transparent:i,init:function(){e=0,n.length=0,r.length=0,i.length=0},push:function(t,e,a,o,l,c){const h=s(t,e,a,o,l,c);a.transmission>0?r.push(h):!0===a.transparent?i.push(h):n.push(h)},unshift:function(t,e,a,o,l,c){const h=s(t,e,a,o,l,c);a.transmission>0?r.unshift(h):!0===a.transparent?i.unshift(h):n.unshift(h)},finish:function(){for(let n=e,r=t.length;n<r;n++){const e=t[n];if(null===e.id)break;e.id=null,e.object=null,e.geometry=null,e.material=null,e.group=null}},sort:function(t,e){n.length>1&&n.sort(t||rl),r.length>1&&r.sort(e||il),i.length>1&&i.sort(e||il)}}}function al(){let t=new WeakMap;return{get:function(e,n){let r;return!1===t.has(e)?(r=new sl,t.set(e,[r])):n>=t.get(e).length?(r=new sl,t.get(e).push(r)):r=t.get(e)[n],r},dispose:function(){t=new WeakMap}}}function ol(){const t={};return{get:function(e){if(void 0!==t[e.id])return t[e.id];let n;switch(e.type){case"DirectionalLight":n={direction:new lr,color:new Li};break;case"SpotLight":n={position:new lr,direction:new lr,color:new Li,distance:0,coneCos:0,penumbraCos:0,decay:0};break;case"PointLight":n={position:new lr,color:new Li,distance:0,decay:0};break;case"HemisphereLight":n={direction:new lr,skyColor:new Li,groundColor:new Li};break;case"RectAreaLight":n={color:new Li,position:new lr,halfWidth:new lr,halfHeight:new lr}}return t[e.id]=n,n}}}let ll=0;function cl(t,e){return(e.castShadow?1:0)-(t.castShadow?1:0)}function hl(t,e){const n=new ol,r=function(){const t={};return{get:function(e){if(void 0!==t[e.id])return t[e.id];let n;switch(e.type){case"DirectionalLight":case"SpotLight":n={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new jn};break;case"PointLight":n={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new jn,shadowCameraNear:1,shadowCameraFar:1e3}}return t[e.id]=n,n}}}(),i={version:0,hash:{directionalLength:-1,pointLength:-1,spotLength:-1,rectAreaLength:-1,hemiLength:-1,numDirectionalShadows:-1,numPointShadows:-1,numSpotShadows:-1},ambient:[0,0,0],probe:[],directional:[],directionalShadow:[],directionalShadowMap:[],directionalShadowMatrix:[],spot:[],spotShadow:[],spotShadowMap:[],spotShadowMatrix:[],rectArea:[],rectAreaLTC1:null,rectAreaLTC2:null,point:[],pointShadow:[],pointShadowMap:[],pointShadowMatrix:[],hemi:[]};for(let t=0;t<9;t++)i.probe.push(new lr);const s=new lr,a=new zr,o=new zr;return{setup:function(s,a){let o=0,l=0,c=0;for(let t=0;t<9;t++)i.probe[t].set(0,0,0);let h=0,u=0,d=0,p=0,f=0,m=0,g=0,v=0;s.sort(cl);const x=!0!==a?Math.PI:1;for(let t=0,e=s.length;t<e;t++){const e=s[t],a=e.color,y=e.intensity,w=e.distance,b=e.shadow&&e.shadow.map?e.shadow.map.texture:null;if(e.isAmbientLight)o+=a.r*y*x,l+=a.g*y*x,c+=a.b*y*x;else if(e.isLightProbe)for(let t=0;t<9;t++)i.probe[t].addScaledVector(e.sh.coefficients[t],y);else if(e.isDirectionalLight){const t=n.get(e);if(t.color.copy(e.color).multiplyScalar(e.intensity*x),e.castShadow){const t=e.shadow,n=r.get(e);n.shadowBias=t.bias,n.shadowNormalBias=t.normalBias,n.shadowRadius=t.radius,n.shadowMapSize=t.mapSize,i.directionalShadow[h]=n,i.directionalShadowMap[h]=b,i.directionalShadowMatrix[h]=e.shadow.matrix,m++}i.directional[h]=t,h++}else if(e.isSpotLight){const t=n.get(e);if(t.position.setFromMatrixPosition(e.matrixWorld),t.color.copy(a).multiplyScalar(y*x),t.distance=w,t.coneCos=Math.cos(e.angle),t.penumbraCos=Math.cos(e.angle*(1-e.penumbra)),t.decay=e.decay,e.castShadow){const t=e.shadow,n=r.get(e);n.shadowBias=t.bias,n.shadowNormalBias=t.normalBias,n.shadowRadius=t.radius,n.shadowMapSize=t.mapSize,i.spotShadow[d]=n,i.spotShadowMap[d]=b,i.spotShadowMatrix[d]=e.shadow.matrix,v++}i.spot[d]=t,d++}else if(e.isRectAreaLight){const t=n.get(e);t.color.copy(a).multiplyScalar(y),t.halfWidth.set(.5*e.width,0,0),t.halfHeight.set(0,.5*e.height,0),i.rectArea[p]=t,p++}else if(e.isPointLight){const t=n.get(e);if(t.color.copy(e.color).multiplyScalar(e.intensity*x),t.distance=e.distance,t.decay=e.decay,e.castShadow){const t=e.shadow,n=r.get(e);n.shadowBias=t.bias,n.shadowNormalBias=t.normalBias,n.shadowRadius=t.radius,n.shadowMapSize=t.mapSize,n.shadowCameraNear=t.camera.near,n.shadowCameraFar=t.camera.far,i.pointShadow[u]=n,i.pointShadowMap[u]=b,i.pointShadowMatrix[u]=e.shadow.matrix,g++}i.point[u]=t,u++}else if(e.isHemisphereLight){const t=n.get(e);t.skyColor.copy(e.color).multiplyScalar(y*x),t.groundColor.copy(e.groundColor).multiplyScalar(y*x),i.hemi[f]=t,f++}}p>0&&(e.isWebGL2||!0===t.has("OES_texture_float_linear")?(i.rectAreaLTC1=ks.LTC_FLOAT_1,i.rectAreaLTC2=ks.LTC_FLOAT_2):!0===t.has("OES_texture_half_float_linear")?(i.rectAreaLTC1=ks.LTC_HALF_1,i.rectAreaLTC2=ks.LTC_HALF_2):console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")),i.ambient[0]=o,i.ambient[1]=l,i.ambient[2]=c;const y=i.hash;y.directionalLength===h&&y.pointLength===u&&y.spotLength===d&&y.rectAreaLength===p&&y.hemiLength===f&&y.numDirectionalShadows===m&&y.numPointShadows===g&&y.numSpotShadows===v||(i.directional.length=h,i.spot.length=d,i.rectArea.length=p,i.point.length=u,i.hemi.length=f,i.directionalShadow.length=m,i.directionalShadowMap.length=m,i.pointShadow.length=g,i.pointShadowMap.length=g,i.spotShadow.length=v,i.spotShadowMap.length=v,i.directionalShadowMatrix.length=m,i.pointShadowMatrix.length=g,i.spotShadowMatrix.length=v,y.directionalLength=h,y.pointLength=u,y.spotLength=d,y.rectAreaLength=p,y.hemiLength=f,y.numDirectionalShadows=m,y.numPointShadows=g,y.numSpotShadows=v,i.version=ll++)},setupView:function(t,e){let n=0,r=0,l=0,c=0,h=0;const u=e.matrixWorldInverse;for(let e=0,d=t.length;e<d;e++){const d=t[e];if(d.isDirectionalLight){const t=i.directional[n];t.direction.setFromMatrixPosition(d.matrixWorld),s.setFromMatrixPosition(d.target.matrixWorld),t.direction.sub(s),t.direction.transformDirection(u),n++}else if(d.isSpotLight){const t=i.spot[l];t.position.setFromMatrixPosition(d.matrixWorld),t.position.applyMatrix4(u),t.direction.setFromMatrixPosition(d.matrixWorld),s.setFromMatrixPosition(d.target.matrixWorld),t.direction.sub(s),t.direction.transformDirection(u),l++}else if(d.isRectAreaLight){const t=i.rectArea[c];t.position.setFromMatrixPosition(d.matrixWorld),t.position.applyMatrix4(u),o.identity(),a.copy(d.matrixWorld),a.premultiply(u),o.extractRotation(a),t.halfWidth.set(.5*d.width,0,0),t.halfHeight.set(0,.5*d.height,0),t.halfWidth.applyMatrix4(o),t.halfHeight.applyMatrix4(o),c++}else if(d.isPointLight){const t=i.point[r];t.position.setFromMatrixPosition(d.matrixWorld),t.position.applyMatrix4(u),r++}else if(d.isHemisphereLight){const t=i.hemi[h];t.direction.setFromMatrixPosition(d.matrixWorld),t.direction.transformDirection(u),t.direction.normalize(),h++}}},state:i}}function ul(t,e){const n=new hl(t,e),r=[],i=[];return{init:function(){r.length=0,i.length=0},state:{lightsArray:r,shadowsArray:i,lights:n},setupLights:function(t){n.setup(r,t)},setupLightsView:function(t){n.setupView(r,t)},pushLight:function(t){r.push(t)},pushShadow:function(t){i.push(t)}}}function dl(t,e){let n=new WeakMap;return{get:function(r,i=0){let s;return!1===n.has(r)?(s=new ul(t,e),n.set(r,[s])):i>=n.get(r).length?(s=new ul(t,e),n.get(r).push(s)):s=n.get(r)[i],s},dispose:function(){n=new WeakMap}}}class pl extends Mi{constructor(t){super(),this.type="MeshDepthMaterial",this.depthPacking=en,this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.wireframe=!1,this.wireframeLinewidth=1,this.fog=!1,this.setValues(t)}copy(t){return super.copy(t),this.depthPacking=t.depthPacking,this.map=t.map,this.alphaMap=t.alphaMap,this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this}}pl.prototype.isMeshDepthMaterial=!0;class fl extends Mi{constructor(t){super(),this.type="MeshDistanceMaterial",this.referencePosition=new lr,this.nearDistance=1,this.farDistance=1e3,this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.fog=!1,this.setValues(t)}copy(t){return super.copy(t),this.referencePosition.copy(t.referencePosition),this.nearDistance=t.nearDistance,this.farDistance=t.farDistance,this.map=t.map,this.alphaMap=t.alphaMap,this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this}}function ml(t,e,n){let r=new Us;const i=new jn,s=new jn,a=new rr,o=new pl({depthPacking:nn}),l=new fl,c={},h=n.maxTextureSize,u={0:y,1:x,2:w},d=new _s({defines:{VSM_SAMPLES:8},uniforms:{shadow_pass:{value:null},resolution:{value:new jn},radius:{value:4}},vertexShader:"void main() {\n\tgl_Position = vec4( position, 1.0 );\n}",fragmentShader:"uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n\tconst float samples = float( VSM_SAMPLES );\n\tfloat mean = 0.0;\n\tfloat squared_mean = 0.0;\n\tfloat uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );\n\tfloat uvStart = samples <= 1.0 ? 0.0 : - 1.0;\n\tfor ( float i = 0.0; i < samples; i ++ ) {\n\t\tfloat uvOffset = uvStart + i * uvStride;\n\t\t#ifdef HORIZONTAL_PASS\n\t\t\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );\n\t\t\tmean += distribution.x;\n\t\t\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n\t\t#else\n\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );\n\t\t\tmean += depth;\n\t\t\tsquared_mean += depth * depth;\n\t\t#endif\n\t}\n\tmean = mean / samples;\n\tsquared_mean = squared_mean / samples;\n\tfloat std_dev = sqrt( squared_mean - mean * mean );\n\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}"}),p=d.clone();p.defines.HORIZONTAL_PASS=1;const f=new Ki;f.setAttribute("position",new Ii(new Float32Array([-1,-1,.5,3,-1,.5,-1,3,.5]),3));const g=new gs(f,d),b=this;function _(n,r){const i=e.update(g);d.defines.VSM_SAMPLES!==n.blurSamples&&(d.defines.VSM_SAMPLES=n.blurSamples,p.defines.VSM_SAMPLES=n.blurSamples,d.needsUpdate=!0,p.needsUpdate=!0),d.uniforms.shadow_pass.value=n.map.texture,d.uniforms.resolution.value=n.mapSize,d.uniforms.radius.value=n.radius,t.setRenderTarget(n.mapPass),t.clear(),t.renderBufferDirect(r,null,i,d,g,null),p.uniforms.shadow_pass.value=n.mapPass.texture,p.uniforms.resolution.value=n.mapSize,p.uniforms.radius.value=n.radius,t.setRenderTarget(n.map),t.clear(),t.renderBufferDirect(r,null,i,p,g,null)}function T(e,n,r,i,s,a,h){let d=null;const p=!0===i.isPointLight?e.customDistanceMaterial:e.customDepthMaterial;if(d=void 0!==p?p:!0===i.isPointLight?l:o,t.localClippingEnabled&&!0===r.clipShadows&&0!==r.clippingPlanes.length||r.displacementMap&&0!==r.displacementScale||r.alphaMap&&r.alphaTest>0){const t=d.uuid,e=r.uuid;let n=c[t];void 0===n&&(n={},c[t]=n);let i=n[e];void 0===i&&(i=d.clone(),n[e]=i),d=i}return d.visible=r.visible,d.wireframe=r.wireframe,d.side=h===v?null!==r.shadowSide?r.shadowSide:r.side:null!==r.shadowSide?r.shadowSide:u[r.side],d.alphaMap=r.alphaMap,d.alphaTest=r.alphaTest,d.clipShadows=r.clipShadows,d.clippingPlanes=r.clippingPlanes,d.clipIntersection=r.clipIntersection,d.displacementMap=r.displacementMap,d.displacementScale=r.displacementScale,d.displacementBias=r.displacementBias,d.wireframeLinewidth=r.wireframeLinewidth,d.linewidth=r.linewidth,!0===i.isPointLight&&!0===d.isMeshDistanceMaterial&&(d.referencePosition.setFromMatrixPosition(i.matrixWorld),d.nearDistance=s,d.farDistance=a),d}function S(n,i,s,a,o){if(!1===n.visible)return;if(n.layers.test(i.layers)&&(n.isMesh||n.isLine||n.isPoints)&&(n.castShadow||n.receiveShadow&&o===v)&&(!n.frustumCulled||r.intersectsObject(n))){n.modelViewMatrix.multiplyMatrices(s.matrixWorldInverse,n.matrixWorld);const r=e.update(n),i=n.material;if(Array.isArray(i)){const e=r.groups;for(let l=0,c=e.length;l<c;l++){const c=e[l],h=i[c.materialIndex];if(h&&h.visible){const e=T(n,0,h,a,s.near,s.far,o);t.renderBufferDirect(s,null,r,e,n,c)}}}else if(i.visible){const e=T(n,0,i,a,s.near,s.far,o);t.renderBufferDirect(s,null,r,e,n,null)}}const l=n.children;for(let t=0,e=l.length;t<e;t++)S(l[t],i,s,a,o)}this.enabled=!1,this.autoUpdate=!0,this.needsUpdate=!1,this.type=m,this.render=function(e,n,o){if(!1===b.enabled)return;if(!1===b.autoUpdate&&!1===b.needsUpdate)return;if(0===e.length)return;const l=t.getRenderTarget(),c=t.getActiveCubeFace(),u=t.getActiveMipmapLevel(),d=t.state;d.setBlending(M),d.buffers.color.setClear(1,1,1,1),d.buffers.depth.setTest(!0),d.setScissorTest(!1);for(let l=0,c=e.length;l<c;l++){const c=e[l],u=c.shadow;if(void 0===u){console.warn("THREE.WebGLShadowMap:",c,"has no shadow.");continue}if(!1===u.autoUpdate&&!1===u.needsUpdate)continue;i.copy(u.mapSize);const p=u.getFrameExtents();if(i.multiply(p),s.copy(u.mapSize),(i.x>h||i.y>h)&&(i.x>h&&(s.x=Math.floor(h/p.x),i.x=s.x*p.x,u.mapSize.x=s.x),i.y>h&&(s.y=Math.floor(h/p.y),i.y=s.y*p.y,u.mapSize.y=s.y)),null===u.map&&!u.isPointLightShadow&&this.type===v){const t={minFilter:Mt,magFilter:Mt,format:Gt};u.map=new ir(i.x,i.y,t),u.map.texture.name=c.name+".shadowMap",u.mapPass=new ir(i.x,i.y,t),u.camera.updateProjectionMatrix()}if(null===u.map){const t={minFilter:xt,magFilter:xt,format:Gt};u.map=new ir(i.x,i.y,t),u.map.texture.name=c.name+".shadowMap",u.camera.updateProjectionMatrix()}t.setRenderTarget(u.map),t.clear();const f=u.getViewportCount();for(let t=0;t<f;t++){const e=u.getViewport(t);a.set(s.x*e.x,s.y*e.y,s.x*e.z,s.y*e.w),d.viewport(a),u.updateMatrices(c,t),r=u.getFrustum(),S(n,o,u.camera,c,this.type)}u.isPointLightShadow||this.type!==v||_(u,o),u.needsUpdate=!1}b.needsUpdate=!1,t.setRenderTarget(l,c,u)}}function gl(t,e,n){const r=n.isWebGL2,i=new function(){let e=!1;const n=new rr;let r=null;const i=new rr(0,0,0,0);return{setMask:function(n){r===n||e||(t.colorMask(n,n,n,n),r=n)},setLocked:function(t){e=t},setClear:function(e,r,s,a,o){!0===o&&(e*=a,r*=a,s*=a),n.set(e,r,s,a),!1===i.equals(n)&&(t.clearColor(e,r,s,a),i.copy(n))},reset:function(){e=!1,r=null,i.set(-1,0,0,0)}}},s=new function(){let e=!1,n=null,r=null,i=null;return{setTest:function(t){t?vt(2929):xt(2929)},setMask:function(r){n===r||e||(t.depthMask(r),n=r)},setFunc:function(e){if(r!==e){if(e)switch(e){case X:t.depthFunc(512);break;case j:t.depthFunc(519);break;case Y:t.depthFunc(513);break;default:t.depthFunc(515);break;case Q:t.depthFunc(514);break;case Z:t.depthFunc(518);break;case J:t.depthFunc(516);break;case K:t.depthFunc(517)}else t.depthFunc(515);r=e}},setLocked:function(t){e=t},setClear:function(e){i!==e&&(t.clearDepth(e),i=e)},reset:function(){e=!1,n=null,r=null,i=null}}},a=new function(){let e=!1,n=null,r=null,i=null,s=null,a=null,o=null,l=null,c=null;return{setTest:function(t){e||(t?vt(2960):xt(2960))},setMask:function(r){n===r||e||(t.stencilMask(r),n=r)},setFunc:function(e,n,a){r===e&&i===n&&s===a||(t.stencilFunc(e,n,a),r=e,i=n,s=a)},setOp:function(e,n,r){a===e&&o===n&&l===r||(t.stencilOp(e,n,r),a=e,o=n,l=r)},setLocked:function(t){e=t},setClear:function(e){c!==e&&(t.clearStencil(e),c=e)},reset:function(){e=!1,n=null,r=null,i=null,s=null,a=null,o=null,l=null,c=null}}};let o={},l={},c=null,p=!1,f=null,m=null,g=null,v=null,x=null,b=null,_=null,$=!1,tt=null,et=null,nt=null,rt=null,it=null;const st=t.getParameter(35661);let at=!1,ot=0;const lt=t.getParameter(7938);-1!==lt.indexOf("WebGL")?(ot=parseFloat(/^WebGL (\d)/.exec(lt)[1]),at=ot>=1):-1!==lt.indexOf("OpenGL ES")&&(ot=parseFloat(/^OpenGL ES (\d)/.exec(lt)[1]),at=ot>=2);let ct=null,ht={};const ut=t.getParameter(3088),dt=t.getParameter(2978),pt=(new rr).fromArray(ut),ft=(new rr).fromArray(dt);function mt(e,n,r){const i=new Uint8Array(4),s=t.createTexture();t.bindTexture(e,s),t.texParameteri(e,10241,9728),t.texParameteri(e,10240,9728);for(let e=0;e<r;e++)t.texImage2D(n+e,0,6408,1,1,0,6408,5121,i);return s}const gt={};function vt(e){!0!==o[e]&&(t.enable(e),o[e]=!0)}function xt(e){!1!==o[e]&&(t.disable(e),o[e]=!1)}gt[3553]=mt(3553,3553,1),gt[34067]=mt(34067,34069,6),i.setClear(0,0,0,1),s.setClear(1),a.setClear(0),vt(2929),s.setFunc(q),_t(!1),Mt(u),vt(2884),bt(M);const yt={[P]:32774,[L]:32778,[R]:32779};if(r)yt[F]=32775,yt[D]=32776;else{const t=e.get("EXT_blend_minmax");null!==t&&(yt[F]=t.MIN_EXT,yt[D]=t.MAX_EXT)}const wt={[I]:0,[U]:1,[N]:768,[B]:770,[W]:776,[G]:774,[k]:772,[O]:769,[z]:771,[V]:775,[H]:773};function bt(e,n,r,i,s,a,o,l){if(e!==M){if(!1===p&&(vt(3042),p=!0),e===C)s=s||n,a=a||r,o=o||i,n===m&&s===x||(t.blendEquationSeparate(yt[n],yt[s]),m=n,x=s),r===g&&i===v&&a===b&&o===_||(t.blendFuncSeparate(wt[r],wt[i],wt[a],wt[o]),g=r,v=i,b=a,_=o),f=e,$=null;else if(e!==f||l!==$){if(m===P&&x===P||(t.blendEquation(32774),m=P,x=P),l)switch(e){case T:t.blendFuncSeparate(1,771,1,771);break;case S:t.blendFunc(1,1);break;case A:t.blendFuncSeparate(0,0,769,771);break;case E:t.blendFuncSeparate(0,768,0,770);break;default:console.error("THREE.WebGLState: Invalid blending: ",e)}else switch(e){case T:t.blendFuncSeparate(770,771,1,771);break;case S:t.blendFunc(770,1);break;case A:t.blendFunc(0,769);break;case E:t.blendFunc(0,768);break;default:console.error("THREE.WebGLState: Invalid blending: ",e)}g=null,v=null,b=null,_=null,f=e,$=l}}else!0===p&&(xt(3042),p=!1)}function _t(e){tt!==e&&(e?t.frontFace(2304):t.frontFace(2305),tt=e)}function Mt(e){e!==h?(vt(2884),e!==et&&(e===u?t.cullFace(1029):e===d?t.cullFace(1028):t.cullFace(1032))):xt(2884),et=e}function Tt(e,n,r){e?(vt(32823),rt===n&&it===r||(t.polygonOffset(n,r),rt=n,it=r)):xt(32823)}function St(e){void 0===e&&(e=33984+st-1),ct!==e&&(t.activeTexture(e),ct=e)}return{buffers:{color:i,depth:s,stencil:a},enable:vt,disable:xt,bindFramebuffer:function(e,n){return l[e]!==n&&(t.bindFramebuffer(e,n),l[e]=n,r&&(36009===e&&(l[36160]=n),36160===e&&(l[36009]=n)),!0)},useProgram:function(e){return c!==e&&(t.useProgram(e),c=e,!0)},setBlending:bt,setMaterial:function(t,e){t.side===w?xt(2884):vt(2884);let n=t.side===y;e&&(n=!n),_t(n),t.blending===T&&!1===t.transparent?bt(M):bt(t.blending,t.blendEquation,t.blendSrc,t.blendDst,t.blendEquationAlpha,t.blendSrcAlpha,t.blendDstAlpha,t.premultipliedAlpha),s.setFunc(t.depthFunc),s.setTest(t.depthTest),s.setMask(t.depthWrite),i.setMask(t.colorWrite);const r=t.stencilWrite;a.setTest(r),r&&(a.setMask(t.stencilWriteMask),a.setFunc(t.stencilFunc,t.stencilRef,t.stencilFuncMask),a.setOp(t.stencilFail,t.stencilZFail,t.stencilZPass)),Tt(t.polygonOffset,t.polygonOffsetFactor,t.polygonOffsetUnits),!0===t.alphaToCoverage?vt(32926):xt(32926)},setFlipSided:_t,setCullFace:Mt,setLineWidth:function(e){e!==nt&&(at&&t.lineWidth(e),nt=e)},setPolygonOffset:Tt,setScissorTest:function(t){t?vt(3089):xt(3089)},activeTexture:St,bindTexture:function(e,n){null===ct&&St();let r=ht[ct];void 0===r&&(r={type:void 0,texture:void 0},ht[ct]=r),r.type===e&&r.texture===n||(t.bindTexture(e,n||gt[e]),r.type=e,r.texture=n)},unbindTexture:function(){const e=ht[ct];void 0!==e&&void 0!==e.type&&(t.bindTexture(e.type,null),e.type=void 0,e.texture=void 0)},compressedTexImage2D:function(){try{t.compressedTexImage2D.apply(t,arguments)}catch(t){console.error("THREE.WebGLState:",t)}},texImage2D:function(){try{t.texImage2D.apply(t,arguments)}catch(t){console.error("THREE.WebGLState:",t)}},texImage3D:function(){try{t.texImage3D.apply(t,arguments)}catch(t){console.error("THREE.WebGLState:",t)}},texStorage2D:function(){try{t.texStorage2D.apply(t,arguments)}catch(t){console.error("THREE.WebGLState:",t)}},texStorage3D:function(){try{t.texStorage3D.apply(t,arguments)}catch(t){console.error("THREE.WebGLState:",t)}},texSubImage2D:function(){try{t.texSubImage2D.apply(t,arguments)}catch(t){console.error("THREE.WebGLState:",t)}},texSubImage3D:function(){try{t.texSubImage3D.apply(t,arguments)}catch(t){console.error("THREE.WebGLState:",t)}},compressedTexSubImage2D:function(){try{t.compressedTexSubImage2D.apply(t,arguments)}catch(t){console.error("THREE.WebGLState:",t)}},scissor:function(e){!1===pt.equals(e)&&(t.scissor(e.x,e.y,e.z,e.w),pt.copy(e))},viewport:function(e){!1===ft.equals(e)&&(t.viewport(e.x,e.y,e.z,e.w),ft.copy(e))},reset:function(){t.disable(3042),t.disable(2884),t.disable(2929),t.disable(32823),t.disable(3089),t.disable(2960),t.disable(32926),t.blendEquation(32774),t.blendFunc(1,0),t.blendFuncSeparate(1,0,1,0),t.colorMask(!0,!0,!0,!0),t.clearColor(0,0,0,0),t.depthMask(!0),t.depthFunc(513),t.clearDepth(1),t.stencilMask(4294967295),t.stencilFunc(519,0,4294967295),t.stencilOp(7680,7680,7680),t.clearStencil(0),t.cullFace(1029),t.frontFace(2305),t.polygonOffset(0,0),t.activeTexture(33984),t.bindFramebuffer(36160,null),!0===r&&(t.bindFramebuffer(36009,null),t.bindFramebuffer(36008,null)),t.useProgram(null),t.lineWidth(1),t.scissor(0,0,t.canvas.width,t.canvas.height),t.viewport(0,0,t.canvas.width,t.canvas.height),o={},ct=null,ht={},l={},c=null,p=!1,f=null,m=null,g=null,v=null,x=null,b=null,_=null,$=!1,tt=null,et=null,nt=null,rt=null,it=null,pt.set(0,0,t.canvas.width,t.canvas.height),ft.set(0,0,t.canvas.width,t.canvas.height),i.reset(),s.reset(),a.reset()}}}function vl(t,e,n,r,i,s,a){const o=i.isWebGL2,l=i.maxTextures,c=i.maxCubemapSize,h=i.maxTextureSize,u=i.maxSamples,d=e.has("WEBGL_multisampled_render_to_texture")?e.get("WEBGL_multisampled_render_to_texture"):void 0,p=new WeakMap;let f,m=!1;try{m="undefined"!=typeof OffscreenCanvas&&null!==new OffscreenCanvas(1,1).getContext("2d")}catch(t){}function g(t,e){return m?new OffscreenCanvas(t,e):Jn("canvas")}function v(t,e,n,r){let i=1;if((t.width>r||t.height>r)&&(i=r/Math.max(t.width,t.height)),i<1||!0===e){if("undefined"!=typeof HTMLImageElement&&t instanceof HTMLImageElement||"undefined"!=typeof HTMLCanvasElement&&t instanceof HTMLCanvasElement||"undefined"!=typeof ImageBitmap&&t instanceof ImageBitmap){const r=e?Wn:Math.floor,s=r(i*t.width),a=r(i*t.height);void 0===f&&(f=g(s,a));const o=n?g(s,a):f;return o.width=s,o.height=a,o.getContext("2d").drawImage(t,0,0,s,a),console.warn("THREE.WebGLRenderer: Texture has been resized from ("+t.width+"x"+t.height+") to ("+s+"x"+a+")."),o}return"data"in t&&console.warn("THREE.WebGLRenderer: Image in DataTexture is too big ("+t.width+"x"+t.height+")."),t}return t}function x(t){return Gn(t.width)&&Gn(t.height)}function y(t,e){return t.generateMipmaps&&e&&t.minFilter!==xt&&t.minFilter!==Mt}function w(e){t.generateMipmap(e)}function b(n,r,i,s){if(!1===o)return r;if(null!==n){if(void 0!==t[n])return t[n];console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '"+n+"'")}let a=r;return 6403===r&&(5126===i&&(a=33326),5131===i&&(a=33325),5121===i&&(a=33321)),6407===r&&(5126===i&&(a=34837),5131===i&&(a=34843),5121===i&&(a=32849)),6408===r&&(5126===i&&(a=34836),5131===i&&(a=34842),5121===i&&(a=s===tn?35907:32856)),33325!==a&&33326!==a&&34842!==a&&34836!==a||e.get("EXT_color_buffer_float"),a}function _(t,e,n){return!0===y(t,n)||t.isFramebufferTexture&&t.minFilter!==xt&&t.minFilter!==Mt?Math.log2(Math.max(e.width,e.height))+1:void 0!==t.mipmaps&&t.mipmaps.length>0?t.mipmaps.length:t.isCompressedTexture&&Array.isArray(t.image)?e.mipmaps.length:1}function M(t){return t===xt||t===yt||t===bt?9728:9729}function T(e){const n=e.target;n.removeEventListener("dispose",T),function(e){const n=r.get(e);void 0!==n.__webglInit&&(t.deleteTexture(n.__webglTexture),r.remove(e))}(n),n.isVideoTexture&&p.delete(n),a.memory.textures--}function S(e){const n=e.target;n.removeEventListener("dispose",S),function(e){const n=e.texture,i=r.get(e),s=r.get(n);if(e){if(void 0!==s.__webglTexture&&(t.deleteTexture(s.__webglTexture),a.memory.textures--),e.depthTexture&&e.depthTexture.dispose(),e.isWebGLCubeRenderTarget)for(let e=0;e<6;e++)t.deleteFramebuffer(i.__webglFramebuffer[e]),i.__webglDepthbuffer&&t.deleteRenderbuffer(i.__webglDepthbuffer[e]);else t.deleteFramebuffer(i.__webglFramebuffer),i.__webglDepthbuffer&&t.deleteRenderbuffer(i.__webglDepthbuffer),i.__webglMultisampledFramebuffer&&t.deleteFramebuffer(i.__webglMultisampledFramebuffer),i.__webglColorRenderbuffer&&t.deleteRenderbuffer(i.__webglColorRenderbuffer),i.__webglDepthRenderbuffer&&t.deleteRenderbuffer(i.__webglDepthRenderbuffer);if(e.isWebGLMultipleRenderTargets)for(let e=0,i=n.length;e<i;e++){const i=r.get(n[e]);i.__webglTexture&&(t.deleteTexture(i.__webglTexture),a.memory.textures--),r.remove(n[e])}r.remove(n),r.remove(e)}}(n)}let A=0;function E(t,e){const i=r.get(t);if(t.isVideoTexture&&function(t){const e=a.render.frame;p.get(t)!==e&&(p.set(t,e),t.update())}(t),t.version>0&&i.__version!==t.version){const n=t.image;if(void 0===n)console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined");else{if(!1!==n.complete)return void D(i,t,e);console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete")}}n.activeTexture(33984+e),n.bindTexture(3553,i.__webglTexture)}function C(e,i){const a=r.get(e);e.version>0&&a.__version!==e.version?function(e,r,i){if(6!==r.image.length)return;F(e,r),n.activeTexture(33984+i),n.bindTexture(34067,e.__webglTexture),t.pixelStorei(37440,r.flipY),t.pixelStorei(37441,r.premultiplyAlpha),t.pixelStorei(3317,r.unpackAlignment),t.pixelStorei(37443,0);const a=r&&(r.isCompressedTexture||r.image[0].isCompressedTexture),l=r.image[0]&&r.image[0].isDataTexture,h=[];for(let t=0;t<6;t++)h[t]=a||l?l?r.image[t].image:r.image[t]:v(r.image[t],!1,!0,c);const u=h[0],d=x(u)||o,p=s.convert(r.format),f=s.convert(r.type),m=b(r.internalFormat,p,f,r.encoding),g=o&&!0!==r.isVideoTexture,M=void 0===e.__version;let T,S=_(r,u,d);if(R(34067,r,d),a){g&&M&&n.texStorage2D(34067,S,m,u.width,u.height);for(let t=0;t<6;t++){T=h[t].mipmaps;for(let e=0;e<T.length;e++){const i=T[e];r.format!==Gt&&r.format!==Ht?null!==p?g?n.compressedTexSubImage2D(34069+t,e,0,0,i.width,i.height,p,i.data):n.compressedTexImage2D(34069+t,e,m,i.width,i.height,0,i.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()"):g?n.texSubImage2D(34069+t,e,0,0,i.width,i.height,p,f,i.data):n.texImage2D(34069+t,e,m,i.width,i.height,0,p,f,i.data)}}}else{T=r.mipmaps,g&&M&&(T.length>0&&S++,n.texStorage2D(34067,S,m,h[0].width,h[0].height));for(let t=0;t<6;t++)if(l){g?n.texSubImage2D(34069+t,0,0,0,h[t].width,h[t].height,p,f,h[t].data):n.texImage2D(34069+t,0,m,h[t].width,h[t].height,0,p,f,h[t].data);for(let e=0;e<T.length;e++){const r=T[e].image[t].image;g?n.texSubImage2D(34069+t,e+1,0,0,r.width,r.height,p,f,r.data):n.texImage2D(34069+t,e+1,m,r.width,r.height,0,p,f,r.data)}}else{g?n.texSubImage2D(34069+t,0,0,0,p,f,h[t]):n.texImage2D(34069+t,0,m,p,f,h[t]);for(let e=0;e<T.length;e++){const r=T[e];g?n.texSubImage2D(34069+t,e+1,0,0,p,f,r.image[t]):n.texImage2D(34069+t,e+1,m,p,f,r.image[t])}}}y(r,d)&&w(34067),e.__version=r.version,r.onUpdate&&r.onUpdate(r)}(a,e,i):(n.activeTexture(33984+i),n.bindTexture(34067,a.__webglTexture))}const P={[mt]:10497,[gt]:33071,[vt]:33648},L={[xt]:9728,[yt]:9984,[bt]:9986,[Mt]:9729,[Tt]:9985,[At]:9987};function R(n,s,a){if(a?(t.texParameteri(n,10242,P[s.wrapS]),t.texParameteri(n,10243,P[s.wrapT]),32879!==n&&35866!==n||t.texParameteri(n,32882,P[s.wrapR]),t.texParameteri(n,10240,L[s.magFilter]),t.texParameteri(n,10241,L[s.minFilter])):(t.texParameteri(n,10242,33071),t.texParameteri(n,10243,33071),32879!==n&&35866!==n||t.texParameteri(n,32882,33071),s.wrapS===gt&&s.wrapT===gt||console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."),t.texParameteri(n,10240,M(s.magFilter)),t.texParameteri(n,10241,M(s.minFilter)),s.minFilter!==xt&&s.minFilter!==Mt&&console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")),!0===e.has("EXT_texture_filter_anisotropic")){const a=e.get("EXT_texture_filter_anisotropic");if(s.type===It&&!1===e.has("OES_texture_float_linear"))return;if(!1===o&&s.type===Ut&&!1===e.has("OES_texture_half_float_linear"))return;(s.anisotropy>1||r.get(s).__currentAnisotropy)&&(t.texParameterf(n,a.TEXTURE_MAX_ANISOTROPY_EXT,Math.min(s.anisotropy,i.getMaxAnisotropy())),r.get(s).__currentAnisotropy=s.anisotropy)}}function F(e,n){void 0===e.__webglInit&&(e.__webglInit=!0,n.addEventListener("dispose",T),e.__webglTexture=t.createTexture(),a.memory.textures++)}function D(e,r,i){let a=3553;r.isDataTexture2DArray&&(a=35866),r.isDataTexture3D&&(a=32879),F(e,r),n.activeTexture(33984+i),n.bindTexture(a,e.__webglTexture),t.pixelStorei(37440,r.flipY),t.pixelStorei(37441,r.premultiplyAlpha),t.pixelStorei(3317,r.unpackAlignment),t.pixelStorei(37443,0);const l=function(t){return!o&&(t.wrapS!==gt||t.wrapT!==gt||t.minFilter!==xt&&t.minFilter!==Mt)}(r)&&!1===x(r.image),c=v(r.image,l,!1,h),u=x(c)||o,d=s.convert(r.format);let p,f=s.convert(r.type),m=b(r.internalFormat,d,f,r.encoding);R(a,r,u);const g=r.mipmaps,M=o&&!0!==r.isVideoTexture,T=void 0===e.__version,S=_(r,c,u);if(r.isDepthTexture)m=6402,o?m=r.type===It?36012:r.type===Dt?33190:r.type===zt?35056:33189:r.type===It&&console.error("WebGLRenderer: Floating point depth texture requires WebGL2."),r.format===Xt&&6402===m&&r.type!==Rt&&r.type!==Dt&&(console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."),r.type=Rt,f=s.convert(r.type)),r.format===jt&&6402===m&&(m=34041,r.type!==zt&&(console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."),r.type=zt,f=s.convert(r.type))),M&&T?n.texStorage2D(3553,1,m,c.width,c.height):n.texImage2D(3553,0,m,c.width,c.height,0,d,f,null);else if(r.isDataTexture)if(g.length>0&&u){M&&T&&n.texStorage2D(3553,S,m,g[0].width,g[0].height);for(let t=0,e=g.length;t<e;t++)p=g[t],M?n.texSubImage2D(3553,0,0,0,p.width,p.height,d,f,p.data):n.texImage2D(3553,t,m,p.width,p.height,0,d,f,p.data);r.generateMipmaps=!1}else M?(T&&n.texStorage2D(3553,S,m,c.width,c.height),n.texSubImage2D(3553,0,0,0,c.width,c.height,d,f,c.data)):n.texImage2D(3553,0,m,c.width,c.height,0,d,f,c.data);else if(r.isCompressedTexture){M&&T&&n.texStorage2D(3553,S,m,g[0].width,g[0].height);for(let t=0,e=g.length;t<e;t++)p=g[t],r.format!==Gt&&r.format!==Ht?null!==d?M?n.compressedTexSubImage2D(3553,t,0,0,p.width,p.height,d,p.data):n.compressedTexImage2D(3553,t,m,p.width,p.height,0,p.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"):M?n.texSubImage2D(3553,t,0,0,p.width,p.height,d,f,p.data):n.texImage2D(3553,t,m,p.width,p.height,0,d,f,p.data)}else if(r.isDataTexture2DArray)M?(T&&n.texStorage3D(35866,S,m,c.width,c.height,c.depth),n.texSubImage3D(35866,0,0,0,0,c.width,c.height,c.depth,d,f,c.data)):n.texImage3D(35866,0,m,c.width,c.height,c.depth,0,d,f,c.data);else if(r.isDataTexture3D)M?(T&&n.texStorage3D(32879,S,m,c.width,c.height,c.depth),n.texSubImage3D(32879,0,0,0,0,c.width,c.height,c.depth,d,f,c.data)):n.texImage3D(32879,0,m,c.width,c.height,c.depth,0,d,f,c.data);else if(r.isFramebufferTexture)M&&T?n.texStorage2D(3553,S,m,c.width,c.height):n.texImage2D(3553,0,m,c.width,c.height,0,d,f,null);else if(g.length>0&&u){M&&T&&n.texStorage2D(3553,S,m,g[0].width,g[0].height);for(let t=0,e=g.length;t<e;t++)p=g[t],M?n.texSubImage2D(3553,t,0,0,d,f,p):n.texImage2D(3553,t,m,d,f,p);r.generateMipmaps=!1}else M?(T&&n.texStorage2D(3553,S,m,c.width,c.height),n.texSubImage2D(3553,0,0,0,d,f,c)):n.texImage2D(3553,0,m,d,f,c);y(r,u)&&w(a),e.__version=r.version,r.onUpdate&&r.onUpdate(r)}function I(e,i,a,o,l){const c=s.convert(a.format),h=s.convert(a.type),u=b(a.internalFormat,c,h,a.encoding);r.get(i).__hasExternalTextures||(32879===l||35866===l?n.texImage3D(l,0,u,i.width,i.height,i.depth,0,c,h,null):n.texImage2D(l,0,u,i.width,i.height,0,c,h,null)),n.bindFramebuffer(36160,e),i.useRenderToTexture?d.framebufferTexture2DMultisampleEXT(36160,o,l,r.get(a).__webglTexture,0,O(i)):t.framebufferTexture2D(36160,o,l,r.get(a).__webglTexture,0),n.bindFramebuffer(36160,null)}function U(e,n,r){if(t.bindRenderbuffer(36161,e),n.depthBuffer&&!n.stencilBuffer){let i=33189;if(r||n.useRenderToTexture){const e=n.depthTexture;e&&e.isDepthTexture&&(e.type===It?i=36012:e.type===Dt&&(i=33190));const r=O(n);n.useRenderToTexture?d.renderbufferStorageMultisampleEXT(36161,r,i,n.width,n.height):t.renderbufferStorageMultisample(36161,r,i,n.width,n.height)}else t.renderbufferStorage(36161,i,n.width,n.height);t.framebufferRenderbuffer(36160,36096,36161,e)}else if(n.depthBuffer&&n.stencilBuffer){const i=O(n);r&&n.useRenderbuffer?t.renderbufferStorageMultisample(36161,i,35056,n.width,n.height):n.useRenderToTexture?d.renderbufferStorageMultisampleEXT(36161,i,35056,n.width,n.height):t.renderbufferStorage(36161,34041,n.width,n.height),t.framebufferRenderbuffer(36160,33306,36161,e)}else{const e=!0===n.isWebGLMultipleRenderTargets?n.texture[0]:n.texture,i=s.convert(e.format),a=s.convert(e.type),o=b(e.internalFormat,i,a,e.encoding),l=O(n);r&&n.useRenderbuffer?t.renderbufferStorageMultisample(36161,l,o,n.width,n.height):n.useRenderToTexture?d.renderbufferStorageMultisampleEXT(36161,l,o,n.width,n.height):t.renderbufferStorage(36161,o,n.width,n.height)}t.bindRenderbuffer(36161,null)}function N(e){const i=r.get(e),s=!0===e.isWebGLCubeRenderTarget;if(e.depthTexture&&!i.__autoAllocateDepthBuffer){if(s)throw new Error("target.depthTexture not supported in Cube render targets");!function(e,i){if(i&&i.isWebGLCubeRenderTarget)throw new Error("Depth Texture with cube render targets is not supported");if(n.bindFramebuffer(36160,e),!i.depthTexture||!i.depthTexture.isDepthTexture)throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");r.get(i.depthTexture).__webglTexture&&i.depthTexture.image.width===i.width&&i.depthTexture.image.height===i.height||(i.depthTexture.image.width=i.width,i.depthTexture.image.height=i.height,i.depthTexture.needsUpdate=!0),E(i.depthTexture,0);const s=r.get(i.depthTexture).__webglTexture,a=O(i);if(i.depthTexture.format===Xt)i.useRenderToTexture?d.framebufferTexture2DMultisampleEXT(36160,36096,3553,s,0,a):t.framebufferTexture2D(36160,36096,3553,s,0);else{if(i.depthTexture.format!==jt)throw new Error("Unknown depthTexture format");i.useRenderToTexture?d.framebufferTexture2DMultisampleEXT(36160,33306,3553,s,0,a):t.framebufferTexture2D(36160,33306,3553,s,0)}}(i.__webglFramebuffer,e)}else if(s){i.__webglDepthbuffer=[];for(let r=0;r<6;r++)n.bindFramebuffer(36160,i.__webglFramebuffer[r]),i.__webglDepthbuffer[r]=t.createRenderbuffer(),U(i.__webglDepthbuffer[r],e,!1)}else n.bindFramebuffer(36160,i.__webglFramebuffer),i.__webglDepthbuffer=t.createRenderbuffer(),U(i.__webglDepthbuffer,e,!1);n.bindFramebuffer(36160,null)}function O(t){return o&&(t.useRenderbuffer||t.useRenderToTexture)?Math.min(u,t.samples):0}let B=!1,z=!1;this.allocateTextureUnit=function(){const t=A;return t>=l&&console.warn("THREE.WebGLTextures: Trying to use "+t+" texture units while this GPU supports only "+l),A+=1,t},this.resetTextureUnits=function(){A=0},this.setTexture2D=E,this.setTexture2DArray=function(t,e){const i=r.get(t);t.version>0&&i.__version!==t.version?D(i,t,e):(n.activeTexture(33984+e),n.bindTexture(35866,i.__webglTexture))},this.setTexture3D=function(t,e){const i=r.get(t);t.version>0&&i.__version!==t.version?D(i,t,e):(n.activeTexture(33984+e),n.bindTexture(32879,i.__webglTexture))},this.setTextureCube=C,this.rebindTextures=function(t,e,n){const i=r.get(t);void 0!==e&&I(i.__webglFramebuffer,t,t.texture,36064,3553),void 0!==n&&N(t)},this.setupRenderTarget=function(e){const l=e.texture,c=r.get(e),h=r.get(l);e.addEventListener("dispose",S),!0!==e.isWebGLMultipleRenderTargets&&(void 0===h.__webglTexture&&(h.__webglTexture=t.createTexture()),h.__version=l.version,a.memory.textures++);const u=!0===e.isWebGLCubeRenderTarget,d=!0===e.isWebGLMultipleRenderTargets,p=l.isDataTexture3D||l.isDataTexture2DArray,f=x(e)||o;if(!o||l.format!==Ht||l.type!==It&&l.type!==Ut||(l.format=Gt,console.warn("THREE.WebGLRenderer: Rendering to textures with RGB format is not supported. Using RGBA format instead.")),u){c.__webglFramebuffer=[];for(let e=0;e<6;e++)c.__webglFramebuffer[e]=t.createFramebuffer()}else if(c.__webglFramebuffer=t.createFramebuffer(),d)if(i.drawBuffers){const n=e.texture;for(let e=0,i=n.length;e<i;e++){const i=r.get(n[e]);void 0===i.__webglTexture&&(i.__webglTexture=t.createTexture(),a.memory.textures++)}}else console.warn("THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.");else if(e.useRenderbuffer)if(o){c.__webglMultisampledFramebuffer=t.createFramebuffer(),c.__webglColorRenderbuffer=t.createRenderbuffer(),t.bindRenderbuffer(36161,c.__webglColorRenderbuffer);const r=s.convert(l.format),i=s.convert(l.type),a=b(l.internalFormat,r,i,l.encoding),o=O(e);t.renderbufferStorageMultisample(36161,o,a,e.width,e.height),n.bindFramebuffer(36160,c.__webglMultisampledFramebuffer),t.framebufferRenderbuffer(36160,36064,36161,c.__webglColorRenderbuffer),t.bindRenderbuffer(36161,null),e.depthBuffer&&(c.__webglDepthRenderbuffer=t.createRenderbuffer(),U(c.__webglDepthRenderbuffer,e,!0)),n.bindFramebuffer(36160,null)}else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.");if(u){n.bindTexture(34067,h.__webglTexture),R(34067,l,f);for(let t=0;t<6;t++)I(c.__webglFramebuffer[t],e,l,36064,34069+t);y(l,f)&&w(34067),n.unbindTexture()}else if(d){const t=e.texture;for(let i=0,s=t.length;i<s;i++){const s=t[i],a=r.get(s);n.bindTexture(3553,a.__webglTexture),R(3553,s,f),I(c.__webglFramebuffer,e,s,36064+i,3553),y(s,f)&&w(3553)}n.unbindTexture()}else{let t=3553;p&&(o?t=l.isDataTexture3D?32879:35866:console.warn("THREE.DataTexture3D and THREE.DataTexture2DArray only supported with WebGL2.")),n.bindTexture(t,h.__webglTexture),R(t,l,f),I(c.__webglFramebuffer,e,l,36064,t),y(l,f)&&w(t),n.unbindTexture()}e.depthBuffer&&N(e)},this.updateRenderTargetMipmap=function(t){const e=x(t)||o,i=!0===t.isWebGLMultipleRenderTargets?t.texture:[t.texture];for(let s=0,a=i.length;s<a;s++){const a=i[s];if(y(a,e)){const e=t.isWebGLCubeRenderTarget?34067:3553,i=r.get(a).__webglTexture;n.bindTexture(e,i),w(e),n.unbindTexture()}}},this.updateMultisampleRenderTarget=function(e){if(e.useRenderbuffer)if(o){const i=e.width,s=e.height;let a=16384;const o=[36064],l=e.stencilBuffer?33306:36096;e.depthBuffer&&o.push(l),e.ignoreDepthForMultisampleCopy||(e.depthBuffer&&(a|=256),e.stencilBuffer&&(a|=1024));const c=r.get(e);n.bindFramebuffer(36008,c.__webglMultisampledFramebuffer),n.bindFramebuffer(36009,c.__webglFramebuffer),e.ignoreDepthForMultisampleCopy&&(t.invalidateFramebuffer(36008,[l]),t.invalidateFramebuffer(36009,[l])),t.blitFramebuffer(0,0,i,s,0,0,i,s,a,9728),t.invalidateFramebuffer(36008,o),n.bindFramebuffer(36008,null),n.bindFramebuffer(36009,c.__webglMultisampledFramebuffer)}else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.")},this.setupDepthRenderbuffer=N,this.setupFrameBufferTexture=I,this.safeSetTexture2D=function(t,e){t&&t.isWebGLRenderTarget&&(!1===B&&(console.warn("THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead."),B=!0),t=t.texture),E(t,e)},this.safeSetTextureCube=function(t,e){t&&t.isWebGLCubeRenderTarget&&(!1===z&&(console.warn("THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead."),z=!0),t=t.texture),C(t,e)}}function xl(t,e,n){const r=n.isWebGL2;return{convert:function(t){let n;if(t===Ct)return 5121;if(t===Nt)return 32819;if(t===Ot)return 32820;if(t===Bt)return 33635;if(t===Pt)return 5120;if(t===Lt)return 5122;if(t===Rt)return 5123;if(t===Ft)return 5124;if(t===Dt)return 5125;if(t===It)return 5126;if(t===Ut)return r?5131:(n=e.get("OES_texture_half_float"),null!==n?n.HALF_FLOAT_OES:null);if(t===kt)return 6406;if(t===Ht)return 6407;if(t===Gt)return 6408;if(t===Vt)return 6409;if(t===Wt)return 6410;if(t===Xt)return 6402;if(t===jt)return 34041;if(t===Yt)return 6403;if(t===qt)return 36244;if(t===Qt)return 33319;if(t===Zt)return 33320;if(t===Jt)return 36248;if(t===Kt)return 36249;if(t===$t||t===te||t===ee||t===ne){if(n=e.get("WEBGL_compressed_texture_s3tc"),null===n)return null;if(t===$t)return n.COMPRESSED_RGB_S3TC_DXT1_EXT;if(t===te)return n.COMPRESSED_RGBA_S3TC_DXT1_EXT;if(t===ee)return n.COMPRESSED_RGBA_S3TC_DXT3_EXT;if(t===ne)return n.COMPRESSED_RGBA_S3TC_DXT5_EXT}if(t===re||t===ie||t===se||t===ae){if(n=e.get("WEBGL_compressed_texture_pvrtc"),null===n)return null;if(t===re)return n.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;if(t===ie)return n.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;if(t===se)return n.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;if(t===ae)return n.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG}if(t===oe)return n=e.get("WEBGL_compressed_texture_etc1"),null!==n?n.COMPRESSED_RGB_ETC1_WEBGL:null;if((t===le||t===ce)&&(n=e.get("WEBGL_compressed_texture_etc"),null!==n)){if(t===le)return n.COMPRESSED_RGB8_ETC2;if(t===ce)return n.COMPRESSED_RGBA8_ETC2_EAC}return t===he||t===ue||t===de||t===pe||t===fe||t===me||t===ge||t===ve||t===xe||t===ye||t===we||t===be||t===_e||t===Me||t===Se||t===Ae||t===Ee||t===Ce||t===Pe||t===Le||t===Re||t===Fe||t===De||t===Ie||t===Ue||t===Ne||t===Oe||t===Be?(n=e.get("WEBGL_compressed_texture_astc"),null!==n?t:null):t===Te?(n=e.get("EXT_texture_compression_bptc"),null!==n?t:null):t===zt?r?34042:(n=e.get("WEBGL_depth_texture"),null!==n?n.UNSIGNED_INT_24_8_WEBGL:null):void 0}}}fl.prototype.isMeshDistanceMaterial=!0;class yl extends Ts{constructor(t=[]){super(),this.cameras=t}}yl.prototype.isArrayCamera=!0;class wl extends hi{constructor(){super(),this.type="Group"}}wl.prototype.isGroup=!0;const bl={type:"move"};class _l{constructor(){this._targetRay=null,this._grip=null,this._hand=null}getHandSpace(){return null===this._hand&&(this._hand=new wl,this._hand.matrixAutoUpdate=!1,this._hand.visible=!1,this._hand.joints={},this._hand.inputState={pinching:!1}),this._hand}getTargetRaySpace(){return null===this._targetRay&&(this._targetRay=new wl,this._targetRay.matrixAutoUpdate=!1,this._targetRay.visible=!1,this._targetRay.hasLinearVelocity=!1,this._targetRay.linearVelocity=new lr,this._targetRay.hasAngularVelocity=!1,this._targetRay.angularVelocity=new lr),this._targetRay}getGripSpace(){return null===this._grip&&(this._grip=new wl,this._grip.matrixAutoUpdate=!1,this._grip.visible=!1,this._grip.hasLinearVelocity=!1,this._grip.linearVelocity=new lr,this._grip.hasAngularVelocity=!1,this._grip.angularVelocity=new lr),this._grip}dispatchEvent(t){return null!==this._targetRay&&this._targetRay.dispatchEvent(t),null!==this._grip&&this._grip.dispatchEvent(t),null!==this._hand&&this._hand.dispatchEvent(t),this}disconnect(t){return this.dispatchEvent({type:"disconnected",data:t}),null!==this._targetRay&&(this._targetRay.visible=!1),null!==this._grip&&(this._grip.visible=!1),null!==this._hand&&(this._hand.visible=!1),this}update(t,e,n){let r=null,i=null,s=null;const a=this._targetRay,o=this._grip,l=this._hand;if(t&&"visible-blurred"!==e.session.visibilityState)if(null!==a&&(r=e.getPose(t.targetRaySpace,n),null!==r&&(a.matrix.fromArray(r.transform.matrix),a.matrix.decompose(a.position,a.rotation,a.scale),r.linearVelocity?(a.hasLinearVelocity=!0,a.linearVelocity.copy(r.linearVelocity)):a.hasLinearVelocity=!1,r.angularVelocity?(a.hasAngularVelocity=!0,a.angularVelocity.copy(r.angularVelocity)):a.hasAngularVelocity=!1,this.dispatchEvent(bl))),l&&t.hand){s=!0;for(const r of t.hand.values()){const t=e.getJointPose(r,n);if(void 0===l.joints[r.jointName]){const t=new wl;t.matrixAutoUpdate=!1,t.visible=!1,l.joints[r.jointName]=t,l.add(t)}const i=l.joints[r.jointName];null!==t&&(i.matrix.fromArray(t.transform.matrix),i.matrix.decompose(i.position,i.rotation,i.scale),i.jointRadius=t.radius),i.visible=null!==t}const r=l.joints["index-finger-tip"],i=l.joints["thumb-tip"],a=r.position.distanceTo(i.position),o=.02,c=.005;l.inputState.pinching&&a>o+c?(l.inputState.pinching=!1,this.dispatchEvent({type:"pinchend",handedness:t.handedness,target:this})):!l.inputState.pinching&&a<=o-c&&(l.inputState.pinching=!0,this.dispatchEvent({type:"pinchstart",handedness:t.handedness,target:this}))}else null!==o&&t.gripSpace&&(i=e.getPose(t.gripSpace,n),null!==i&&(o.matrix.fromArray(i.transform.matrix),o.matrix.decompose(o.position,o.rotation,o.scale),i.linearVelocity?(o.hasLinearVelocity=!0,o.linearVelocity.copy(i.linearVelocity)):o.hasLinearVelocity=!1,i.angularVelocity?(o.hasAngularVelocity=!0,o.angularVelocity.copy(i.angularVelocity)):o.hasAngularVelocity=!1));return null!==a&&(a.visible=null!==r),null!==o&&(o.visible=null!==i),null!==l&&(l.visible=null!==s),this}}class Ml extends er{constructor(t,e,n,r,i,s,a,o,l,c){if((c=void 0!==c?c:Xt)!==Xt&&c!==jt)throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");void 0===n&&c===Xt&&(n=Rt),void 0===n&&c===jt&&(n=zt),super(null,r,i,s,a,o,c,n,l),this.image={width:t,height:e},this.magFilter=void 0!==a?a:xt,this.minFilter=void 0!==o?o:xt,this.flipY=!1,this.generateMipmaps=!1}}Ml.prototype.isDepthTexture=!0;class Tl extends Dn{constructor(t,e){super();const n=this;let r=null,i=1,s=null,a="local-floor";const o=t.extensions.has("WEBGL_multisampled_render_to_texture");let l=null,c=null,h=null,u=null,d=!1,p=null;const f=e.getContextAttributes();let m=null,g=null;const v=[],x=new Map,y=new Ts;y.layers.enable(1),y.viewport=new rr;const w=new Ts;w.layers.enable(2),w.viewport=new rr;const b=[y,w],_=new yl;_.layers.enable(1),_.layers.enable(2);let M=null,T=null;function S(t){const e=x.get(t.inputSource);e&&e.dispatchEvent({type:t.type,data:t.inputSource})}function A(){x.forEach((function(t,e){t.disconnect(e)})),x.clear(),M=null,T=null,t.setRenderTarget(m),u=null,h=null,c=null,r=null,g=null,F.stop(),n.isPresenting=!1,n.dispatchEvent({type:"sessionend"})}function E(t){const e=r.inputSources;for(let t=0;t<v.length;t++)x.set(e[t],v[t]);for(let e=0;e<t.removed.length;e++){const n=t.removed[e],r=x.get(n);r&&(r.dispatchEvent({type:"disconnected",data:n}),x.delete(n))}for(let e=0;e<t.added.length;e++){const n=t.added[e],r=x.get(n);r&&r.dispatchEvent({type:"connected",data:n})}}this.cameraAutoUpdate=!0,this.enabled=!1,this.isPresenting=!1,this.getController=function(t){let e=v[t];return void 0===e&&(e=new _l,v[t]=e),e.getTargetRaySpace()},this.getControllerGrip=function(t){let e=v[t];return void 0===e&&(e=new _l,v[t]=e),e.getGripSpace()},this.getHand=function(t){let e=v[t];return void 0===e&&(e=new _l,v[t]=e),e.getHandSpace()},this.setFramebufferScaleFactor=function(t){i=t,!0===n.isPresenting&&console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.")},this.setReferenceSpaceType=function(t){a=t,!0===n.isPresenting&&console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.")},this.getReferenceSpace=function(){return s},this.getBaseLayer=function(){return null!==h?h:u},this.getBinding=function(){return c},this.getFrame=function(){return p},this.getSession=function(){return r},this.setSession=async function(l){if(r=l,null!==r){if(m=t.getRenderTarget(),r.addEventListener("select",S),r.addEventListener("selectstart",S),r.addEventListener("selectend",S),r.addEventListener("squeeze",S),r.addEventListener("squeezestart",S),r.addEventListener("squeezeend",S),r.addEventListener("end",A),r.addEventListener("inputsourceschange",E),!0!==f.xrCompatible&&await e.makeXRCompatible(),void 0===r.renderState.layers||!1===t.capabilities.isWebGL2){const n={antialias:void 0!==r.renderState.layers||f.antialias,alpha:f.alpha,depth:f.depth,stencil:f.stencil,framebufferScaleFactor:i};u=new XRWebGLLayer(r,e,n),r.updateRenderState({baseLayer:u}),g=new ir(u.framebufferWidth,u.framebufferHeight,{format:Gt,type:Ct,encoding:t.outputEncoding})}else{d=f.antialias;let n=null,s=null,a=null;f.depth&&(a=f.stencil?35056:33190,n=f.stencil?jt:Xt,s=f.stencil?zt:Rt);const l={colorFormat:f.alpha||d?32856:32849,depthFormat:a,scaleFactor:i};c=new XRWebGLBinding(r,e),h=c.createProjectionLayer(l),r.updateRenderState({layers:[h]}),g=d?new ar(h.textureWidth,h.textureHeight,{format:Gt,type:Ct,depthTexture:new Ml(h.textureWidth,h.textureHeight,s,void 0,void 0,void 0,void 0,void 0,void 0,n),stencilBuffer:f.stencil,ignoreDepth:h.ignoreDepthValues,useRenderToTexture:o,encoding:t.outputEncoding}):new ir(h.textureWidth,h.textureHeight,{format:f.alpha?Gt:Ht,type:Ct,depthTexture:new Ml(h.textureWidth,h.textureHeight,s,void 0,void 0,void 0,void 0,void 0,void 0,n),stencilBuffer:f.stencil,ignoreDepth:h.ignoreDepthValues,encoding:t.outputEncoding})}this.setFoveation(1),s=await r.requestReferenceSpace(a),F.setContext(r),F.start(),n.isPresenting=!0,n.dispatchEvent({type:"sessionstart"})}};const C=new lr,P=new lr;function L(t,e){null===e?t.matrixWorld.copy(t.matrix):t.matrixWorld.multiplyMatrices(e.matrixWorld,t.matrix),t.matrixWorldInverse.copy(t.matrixWorld).invert()}this.updateCamera=function(t){if(null===r)return;_.near=w.near=y.near=t.near,_.far=w.far=y.far=t.far,M===_.near&&T===_.far||(r.updateRenderState({depthNear:_.near,depthFar:_.far}),M=_.near,T=_.far);const e=t.parent,n=_.cameras;L(_,e);for(let t=0;t<n.length;t++)L(n[t],e);_.matrixWorld.decompose(_.position,_.quaternion,_.scale),t.position.copy(_.position),t.quaternion.copy(_.quaternion),t.scale.copy(_.scale),t.matrix.copy(_.matrix),t.matrixWorld.copy(_.matrixWorld);const i=t.children;for(let t=0,e=i.length;t<e;t++)i[t].updateMatrixWorld(!0);2===n.length?function(t,e,n){C.setFromMatrixPosition(e.matrixWorld),P.setFromMatrixPosition(n.matrixWorld);const r=C.distanceTo(P),i=e.projectionMatrix.elements,s=n.projectionMatrix.elements,a=i[14]/(i[10]-1),o=i[14]/(i[10]+1),l=(i[9]+1)/i[5],c=(i[9]-1)/i[5],h=(i[8]-1)/i[0],u=(s[8]+1)/s[0],d=a*h,p=a*u,f=r/(-h+u),m=f*-h;e.matrixWorld.decompose(t.position,t.quaternion,t.scale),t.translateX(m),t.translateZ(f),t.matrixWorld.compose(t.position,t.quaternion,t.scale),t.matrixWorldInverse.copy(t.matrixWorld).invert();const g=a+f,v=o+f,x=d-m,y=p+(r-m),w=l*o/v*g,b=c*o/v*g;t.projectionMatrix.makePerspective(x,y,w,b,g,v)}(_,y,w):_.projectionMatrix.copy(y.projectionMatrix)},this.getCamera=function(){return _},this.getFoveation=function(){return null!==h?h.fixedFoveation:null!==u?u.fixedFoveation:void 0},this.setFoveation=function(t){null!==h&&(h.fixedFoveation=t),null!==u&&void 0!==u.fixedFoveation&&(u.fixedFoveation=t)};let R=null;const F=new Ns;F.setAnimationLoop((function(e,n){if(l=n.getViewerPose(s),p=n,null!==l){const e=l.views;null!==u&&(t.setRenderTargetFramebuffer(g,u.framebuffer),t.setRenderTarget(g));let n=!1;e.length!==_.cameras.length&&(_.cameras.length=0,n=!0);for(let r=0;r<e.length;r++){const i=e[r];let s=null;if(null!==u)s=u.getViewport(i);else{const e=c.getViewSubImage(h,i);s=e.viewport,0===r&&(t.setRenderTargetTextures(g,e.colorTexture,h.ignoreDepthValues?void 0:e.depthStencilTexture),t.setRenderTarget(g))}const a=b[r];a.matrix.fromArray(i.transform.matrix),a.projectionMatrix.fromArray(i.projectionMatrix),a.viewport.set(s.x,s.y,s.width,s.height),0===r&&_.matrix.copy(a.matrix),!0===n&&_.cameras.push(a)}}const i=r.inputSources;for(let t=0;t<v.length;t++){const e=v[t],r=i[t];e.update(r,n,s)}R&&R(e,n),p=null})),this.setAnimationLoop=function(t){R=t},this.dispose=function(){}}}function Sl(t){function e(e,n){e.opacity.value=n.opacity,n.color&&e.diffuse.value.copy(n.color),n.emissive&&e.emissive.value.copy(n.emissive).multiplyScalar(n.emissiveIntensity),n.map&&(e.map.value=n.map),n.alphaMap&&(e.alphaMap.value=n.alphaMap),n.specularMap&&(e.specularMap.value=n.specularMap),n.alphaTest>0&&(e.alphaTest.value=n.alphaTest);const r=t.get(n).envMap;let i,s;r&&(e.envMap.value=r,e.flipEnvMap.value=r.isCubeTexture&&!1===r.isRenderTargetTexture?-1:1,e.reflectivity.value=n.reflectivity,e.ior.value=n.ior,e.refractionRatio.value=n.refractionRatio),n.lightMap&&(e.lightMap.value=n.lightMap,e.lightMapIntensity.value=n.lightMapIntensity),n.aoMap&&(e.aoMap.value=n.aoMap,e.aoMapIntensity.value=n.aoMapIntensity),n.map?i=n.map:n.specularMap?i=n.specularMap:n.displacementMap?i=n.displacementMap:n.normalMap?i=n.normalMap:n.bumpMap?i=n.bumpMap:n.roughnessMap?i=n.roughnessMap:n.metalnessMap?i=n.metalnessMap:n.alphaMap?i=n.alphaMap:n.emissiveMap?i=n.emissiveMap:n.clearcoatMap?i=n.clearcoatMap:n.clearcoatNormalMap?i=n.clearcoatNormalMap:n.clearcoatRoughnessMap?i=n.clearcoatRoughnessMap:n.specularIntensityMap?i=n.specularIntensityMap:n.specularColorMap?i=n.specularColorMap:n.transmissionMap?i=n.transmissionMap:n.thicknessMap?i=n.thicknessMap:n.sheenColorMap?i=n.sheenColorMap:n.sheenRoughnessMap&&(i=n.sheenRoughnessMap),void 0!==i&&(i.isWebGLRenderTarget&&(i=i.texture),!0===i.matrixAutoUpdate&&i.updateMatrix(),e.uvTransform.value.copy(i.matrix)),n.aoMap?s=n.aoMap:n.lightMap&&(s=n.lightMap),void 0!==s&&(s.isWebGLRenderTarget&&(s=s.texture),!0===s.matrixAutoUpdate&&s.updateMatrix(),e.uv2Transform.value.copy(s.matrix))}function n(e,n){e.roughness.value=n.roughness,e.metalness.value=n.metalness,n.roughnessMap&&(e.roughnessMap.value=n.roughnessMap),n.metalnessMap&&(e.metalnessMap.value=n.metalnessMap),n.emissiveMap&&(e.emissiveMap.value=n.emissiveMap),n.bumpMap&&(e.bumpMap.value=n.bumpMap,e.bumpScale.value=n.bumpScale,n.side===y&&(e.bumpScale.value*=-1)),n.normalMap&&(e.normalMap.value=n.normalMap,e.normalScale.value.copy(n.normalScale),n.side===y&&e.normalScale.value.negate()),n.displacementMap&&(e.displacementMap.value=n.displacementMap,e.displacementScale.value=n.displacementScale,e.displacementBias.value=n.displacementBias),t.get(n).envMap&&(e.envMapIntensity.value=n.envMapIntensity)}return{refreshFogUniforms:function(t,e){t.fogColor.value.copy(e.color),e.isFog?(t.fogNear.value=e.near,t.fogFar.value=e.far):e.isFogExp2&&(t.fogDensity.value=e.density)},refreshMaterialUniforms:function(t,r,i,s,a){r.isMeshBasicMaterial?e(t,r):r.isMeshLambertMaterial?(e(t,r),function(t,e){e.emissiveMap&&(t.emissiveMap.value=e.emissiveMap)}(t,r)):r.isMeshToonMaterial?(e(t,r),function(t,e){e.gradientMap&&(t.gradientMap.value=e.gradientMap),e.emissiveMap&&(t.emissiveMap.value=e.emissiveMap),e.bumpMap&&(t.bumpMap.value=e.bumpMap,t.bumpScale.value=e.bumpScale,e.side===y&&(t.bumpScale.value*=-1)),e.normalMap&&(t.normalMap.value=e.normalMap,t.normalScale.value.copy(e.normalScale),e.side===y&&t.normalScale.value.negate()),e.displacementMap&&(t.displacementMap.value=e.displacementMap,t.displacementScale.value=e.displacementScale,t.displacementBias.value=e.displacementBias)}(t,r)):r.isMeshPhongMaterial?(e(t,r),function(t,e){t.specular.value.copy(e.specular),t.shininess.value=Math.max(e.shininess,1e-4),e.emissiveMap&&(t.emissiveMap.value=e.emissiveMap),e.bumpMap&&(t.bumpMap.value=e.bumpMap,t.bumpScale.value=e.bumpScale,e.side===y&&(t.bumpScale.value*=-1)),e.normalMap&&(t.normalMap.value=e.normalMap,t.normalScale.value.copy(e.normalScale),e.side===y&&t.normalScale.value.negate()),e.displacementMap&&(t.displacementMap.value=e.displacementMap,t.displacementScale.value=e.displacementScale,t.displacementBias.value=e.displacementBias)}(t,r)):r.isMeshStandardMaterial?(e(t,r),r.isMeshPhysicalMaterial?function(t,e,r){n(t,e),t.ior.value=e.ior,e.sheen>0&&(t.sheenColor.value.copy(e.sheenColor).multiplyScalar(e.sheen),t.sheenRoughness.value=e.sheenRoughness,e.sheenColorMap&&(t.sheenColorMap.value=e.sheenColorMap),e.sheenRoughnessMap&&(t.sheenRoughnessMap.value=e.sheenRoughnessMap)),e.clearcoat>0&&(t.clearcoat.value=e.clearcoat,t.clearcoatRoughness.value=e.clearcoatRoughness,e.clearcoatMap&&(t.clearcoatMap.value=e.clearcoatMap),e.clearcoatRoughnessMap&&(t.clearcoatRoughnessMap.value=e.clearcoatRoughnessMap),e.clearcoatNormalMap&&(t.clearcoatNormalScale.value.copy(e.clearcoatNormalScale),t.clearcoatNormalMap.value=e.clearcoatNormalMap,e.side===y&&t.clearcoatNormalScale.value.negate())),e.transmission>0&&(t.transmission.value=e.transmission,t.transmissionSamplerMap.value=r.texture,t.transmissionSamplerSize.value.set(r.width,r.height),e.transmissionMap&&(t.transmissionMap.value=e.transmissionMap),t.thickness.value=e.thickness,e.thicknessMap&&(t.thicknessMap.value=e.thicknessMap),t.attenuationDistance.value=e.attenuationDistance,t.attenuationColor.value.copy(e.attenuationColor)),t.specularIntensity.value=e.specularIntensity,t.specularColor.value.copy(e.specularColor),e.specularIntensityMap&&(t.specularIntensityMap.value=e.specularIntensityMap),e.specularColorMap&&(t.specularColorMap.value=e.specularColorMap)}(t,r,a):n(t,r)):r.isMeshMatcapMaterial?(e(t,r),function(t,e){e.matcap&&(t.matcap.value=e.matcap),e.bumpMap&&(t.bumpMap.value=e.bumpMap,t.bumpScale.value=e.bumpScale,e.side===y&&(t.bumpScale.value*=-1)),e.normalMap&&(t.normalMap.value=e.normalMap,t.normalScale.value.copy(e.normalScale),e.side===y&&t.normalScale.value.negate()),e.displacementMap&&(t.displacementMap.value=e.displacementMap,t.displacementScale.value=e.displacementScale,t.displacementBias.value=e.displacementBias)}(t,r)):r.isMeshDepthMaterial?(e(t,r),function(t,e){e.displacementMap&&(t.displacementMap.value=e.displacementMap,t.displacementScale.value=e.displacementScale,t.displacementBias.value=e.displacementBias)}(t,r)):r.isMeshDistanceMaterial?(e(t,r),function(t,e){e.displacementMap&&(t.displacementMap.value=e.displacementMap,t.displacementScale.value=e.displacementScale,t.displacementBias.value=e.displacementBias),t.referencePosition.value.copy(e.referencePosition),t.nearDistance.value=e.nearDistance,t.farDistance.value=e.farDistance}(t,r)):r.isMeshNormalMaterial?(e(t,r),function(t,e){e.bumpMap&&(t.bumpMap.value=e.bumpMap,t.bumpScale.value=e.bumpScale,e.side===y&&(t.bumpScale.value*=-1)),e.normalMap&&(t.normalMap.value=e.normalMap,t.normalScale.value.copy(e.normalScale),e.side===y&&t.normalScale.value.negate()),e.displacementMap&&(t.displacementMap.value=e.displacementMap,t.displacementScale.value=e.displacementScale,t.displacementBias.value=e.displacementBias)}(t,r)):r.isLineBasicMaterial?(function(t,e){t.diffuse.value.copy(e.color),t.opacity.value=e.opacity}(t,r),r.isLineDashedMaterial&&function(t,e){t.dashSize.value=e.dashSize,t.totalSize.value=e.dashSize+e.gapSize,t.scale.value=e.scale}(t,r)):r.isPointsMaterial?function(t,e,n,r){let i;t.diffuse.value.copy(e.color),t.opacity.value=e.opacity,t.size.value=e.size*n,t.scale.value=.5*r,e.map&&(t.map.value=e.map),e.alphaMap&&(t.alphaMap.value=e.alphaMap),e.alphaTest>0&&(t.alphaTest.value=e.alphaTest),e.map?i=e.map:e.alphaMap&&(i=e.alphaMap),void 0!==i&&(!0===i.matrixAutoUpdate&&i.updateMatrix(),t.uvTransform.value.copy(i.matrix))}(t,r,i,s):r.isSpriteMaterial?function(t,e){let n;t.diffuse.value.copy(e.color),t.opacity.value=e.opacity,t.rotation.value=e.rotation,e.map&&(t.map.value=e.map),e.alphaMap&&(t.alphaMap.value=e.alphaMap),e.alphaTest>0&&(t.alphaTest.value=e.alphaTest),e.map?n=e.map:e.alphaMap&&(n=e.alphaMap),void 0!==n&&(!0===n.matrixAutoUpdate&&n.updateMatrix(),t.uvTransform.value.copy(n.matrix))}(t,r):r.isShadowMaterial?(t.color.value.copy(r.color),t.opacity.value=r.opacity):r.isShaderMaterial&&(r.uniformsNeedUpdate=!1)}}}function Al(t={}){const e=void 0!==t.canvas?t.canvas:function(){const t=Jn("canvas");return t.style.display="block",t}(),n=void 0!==t.context?t.context:null,r=void 0!==t.alpha&&t.alpha,i=void 0===t.depth||t.depth,s=void 0===t.stencil||t.stencil,a=void 0!==t.antialias&&t.antialias,l=void 0===t.premultipliedAlpha||t.premultipliedAlpha,c=void 0!==t.preserveDrawingBuffer&&t.preserveDrawingBuffer,h=void 0!==t.powerPreference?t.powerPreference:"default",u=void 0!==t.failIfMajorPerformanceCaveat&&t.failIfMajorPerformanceCaveat;let d=null,p=null;const f=[],m=[];this.domElement=e,this.debug={checkShaderErrors:!0},this.autoClear=!0,this.autoClearColor=!0,this.autoClearDepth=!0,this.autoClearStencil=!0,this.sortObjects=!0,this.clippingPlanes=[],this.localClippingEnabled=!1,this.outputEncoding=$e,this.physicallyCorrectLights=!1,this.toneMapping=nt,this.toneMappingExposure=1;const g=this;let v=!1,b=0,_=0,M=null,T=-1,S=null;const A=new rr,E=new rr;let C=null,P=e.width,L=e.height,R=1,F=null,D=null;const I=new rr(0,0,P,L),U=new rr(0,0,P,L);let N=!1;const O=[],B=new Us;let z=!1,k=!1,H=null;const G=new zr,V=new lr,W={background:null,fog:null,environment:null,overrideMaterial:null,isScene:!0};function X(){return null===M?R:1}let j,Y,q,Q,Z,J,K,$,tt,et,rt,it,st,at,ot,lt,ct,ht,ut,dt,pt,ft,mt,vt=n;function yt(t,n){for(let r=0;r<t.length;r++){const i=t[r],s=e.getContext(i,n);if(null!==s)return s}return null}try{const t={alpha:r,depth:i,stencil:s,antialias:a,premultipliedAlpha:l,preserveDrawingBuffer:c,powerPreference:h,failIfMajorPerformanceCaveat:u};if("setAttribute"in e&&e.setAttribute("data-engine",`three.js r${o}`),e.addEventListener("webglcontextlost",_t,!1),e.addEventListener("webglcontextrestored",Mt,!1),null===vt){const e=["webgl2","webgl","experimental-webgl"];if(!0===g.isWebGL1Renderer&&e.shift(),vt=yt(e,t),null===vt)throw yt(e)?new Error("Error creating WebGL context with your selected attributes."):new Error("Error creating WebGL context.")}void 0===vt.getShaderPrecisionFormat&&(vt.getShaderPrecisionFormat=function(){return{rangeMin:1,rangeMax:1,precision:1}})}catch(t){throw console.error("THREE.WebGLRenderer: "+t.message),t}function wt(){j=new ga(vt),Y=new Xs(vt,j,t),j.init(Y),ft=new xl(vt,j,Y),q=new gl(vt,j,Y),O[0]=1029,Q=new ya(vt),Z=new nl,J=new vl(vt,j,q,Z,Y,ft,Q),K=new Ys(g),$=new ma(g),tt=new Os(vt,Y),mt=new Vs(vt,j,tt,Y),et=new va(vt,tt,Q,mt),rt=new Sa(vt,et,tt,Q),ut=new Ta(vt,Y,J),lt=new js(Z),it=new el(g,K,$,j,Y,mt,lt),st=new Sl(Z),at=new al,ot=new dl(j,Y),ht=new Gs(g,K,q,rt,l),ct=new ml(g,rt,Y),dt=new Ws(vt,j,Q,Y),pt=new xa(vt,j,Q,Y),Q.programs=it.programs,g.capabilities=Y,g.extensions=j,g.properties=Z,g.renderLists=at,g.shadowMap=ct,g.state=q,g.info=Q}wt();const bt=new Tl(g,vt);function _t(t){t.preventDefault(),console.log("THREE.WebGLRenderer: Context Lost."),v=!0}function Mt(){console.log("THREE.WebGLRenderer: Context Restored."),v=!1;const t=Q.autoReset,e=ct.enabled,n=ct.autoUpdate,r=ct.needsUpdate,i=ct.type;wt(),Q.autoReset=t,ct.enabled=e,ct.autoUpdate=n,ct.needsUpdate=r,ct.type=i}function Tt(t){const e=t.target;e.removeEventListener("dispose",Tt),function(t){(function(t){const e=Z.get(t).programs;void 0!==e&&(e.forEach((function(t){it.releaseProgram(t)})),t.isShaderMaterial&&it.releaseShaderCache(t))})(t),Z.remove(t)}(e)}this.xr=bt,this.getContext=function(){return vt},this.getContextAttributes=function(){return vt.getContextAttributes()},this.forceContextLoss=function(){const t=j.get("WEBGL_lose_context");t&&t.loseContext()},this.forceContextRestore=function(){const t=j.get("WEBGL_lose_context");t&&t.restoreContext()},this.getPixelRatio=function(){return R},this.setPixelRatio=function(t){void 0!==t&&(R=t,this.setSize(P,L,!1))},this.getSize=function(t){return t.set(P,L)},this.setSize=function(t,n,r){bt.isPresenting?console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting."):(P=t,L=n,e.width=Math.floor(t*R),e.height=Math.floor(n*R),!1!==r&&(e.style.width=t+"px",e.style.height=n+"px"),this.setViewport(0,0,t,n))},this.getDrawingBufferSize=function(t){return t.set(P*R,L*R).floor()},this.setDrawingBufferSize=function(t,n,r){P=t,L=n,R=r,e.width=Math.floor(t*r),e.height=Math.floor(n*r),this.setViewport(0,0,t,n)},this.getCurrentViewport=function(t){return t.copy(A)},this.getViewport=function(t){return t.copy(I)},this.setViewport=function(t,e,n,r){t.isVector4?I.set(t.x,t.y,t.z,t.w):I.set(t,e,n,r),q.viewport(A.copy(I).multiplyScalar(R).floor())},this.getScissor=function(t){return t.copy(U)},this.setScissor=function(t,e,n,r){t.isVector4?U.set(t.x,t.y,t.z,t.w):U.set(t,e,n,r),q.scissor(E.copy(U).multiplyScalar(R).floor())},this.getScissorTest=function(){return N},this.setScissorTest=function(t){q.setScissorTest(N=t)},this.setOpaqueSort=function(t){F=t},this.setTransparentSort=function(t){D=t},this.getClearColor=function(t){return t.copy(ht.getClearColor())},this.setClearColor=function(){ht.setClearColor.apply(ht,arguments)},this.getClearAlpha=function(){return ht.getClearAlpha()},this.setClearAlpha=function(){ht.setClearAlpha.apply(ht,arguments)},this.clear=function(t,e,n){let r=0;(void 0===t||t)&&(r|=16384),(void 0===e||e)&&(r|=256),(void 0===n||n)&&(r|=1024),vt.clear(r)},this.clearColor=function(){this.clear(!0,!1,!1)},this.clearDepth=function(){this.clear(!1,!0,!1)},this.clearStencil=function(){this.clear(!1,!1,!0)},this.dispose=function(){e.removeEventListener("webglcontextlost",_t,!1),e.removeEventListener("webglcontextrestored",Mt,!1),at.dispose(),ot.dispose(),Z.dispose(),K.dispose(),$.dispose(),rt.dispose(),mt.dispose(),it.dispose(),bt.dispose(),bt.removeEventListener("sessionstart",Et),bt.removeEventListener("sessionend",Pt),H&&(H.dispose(),H=null),Lt.stop()},this.renderBufferDirect=function(t,e,n,r,i,s){null===e&&(e=W);const a=i.isMesh&&i.matrixWorld.determinant()<0,o=function(t,e,n,r,i){!0!==e.isScene&&(e=W),J.resetTextureUnits();const s=e.fog,a=r.isMeshStandardMaterial?e.environment:null,o=null===M?g.outputEncoding:M.texture.encoding,l=(r.isMeshStandardMaterial?$:K).get(r.envMap||a),c=!0===r.vertexColors&&!!n.attributes.color&&4===n.attributes.color.itemSize,h=!!r.normalMap&&!!n.attributes.tangent,u=!!n.morphAttributes.position,d=!!n.morphAttributes.normal,f=n.morphAttributes.position?n.morphAttributes.position.length:0,m=r.toneMapped?g.toneMapping:nt,v=Z.get(r),x=p.state.lights;if(!0===z&&(!0===k||t!==S)){const e=t===S&&r.id===T;lt.setState(r,t,e)}let y=!1;r.version===v.__version?v.needsLights&&v.lightsStateVersion!==x.state.version||v.outputEncoding!==o||i.isInstancedMesh&&!1===v.instancing?y=!0:i.isInstancedMesh||!0!==v.instancing?i.isSkinnedMesh&&!1===v.skinning?y=!0:i.isSkinnedMesh||!0!==v.skinning?v.envMap!==l||r.fog&&v.fog!==s?y=!0:void 0===v.numClippingPlanes||v.numClippingPlanes===lt.numPlanes&&v.numIntersection===lt.numIntersection?(v.vertexAlphas!==c||v.vertexTangents!==h||v.morphTargets!==u||v.morphNormals!==d||v.toneMapping!==m||!0===Y.isWebGL2&&v.morphTargetsCount!==f)&&(y=!0):y=!0:y=!0:y=!0:(y=!0,v.__version=r.version);let w=v.currentProgram;!0===y&&(w=Ot(r,e,i));let b=!1,_=!1,A=!1;const E=w.getUniforms(),C=v.uniforms;if(q.useProgram(w.program)&&(b=!0,_=!0,A=!0),r.id!==T&&(T=r.id,_=!0),b||S!==t){if(E.setValue(vt,"projectionMatrix",t.projectionMatrix),Y.logarithmicDepthBuffer&&E.setValue(vt,"logDepthBufFC",2/(Math.log(t.far+1)/Math.LN2)),S!==t&&(S=t,_=!0,A=!0),r.isShaderMaterial||r.isMeshPhongMaterial||r.isMeshToonMaterial||r.isMeshStandardMaterial||r.envMap){const e=E.map.cameraPosition;void 0!==e&&e.setValue(vt,V.setFromMatrixPosition(t.matrixWorld))}(r.isMeshPhongMaterial||r.isMeshToonMaterial||r.isMeshLambertMaterial||r.isMeshBasicMaterial||r.isMeshStandardMaterial||r.isShaderMaterial)&&E.setValue(vt,"isOrthographic",!0===t.isOrthographicCamera),(r.isMeshPhongMaterial||r.isMeshToonMaterial||r.isMeshLambertMaterial||r.isMeshBasicMaterial||r.isMeshStandardMaterial||r.isShaderMaterial||r.isShadowMaterial||i.isSkinnedMesh)&&E.setValue(vt,"viewMatrix",t.matrixWorldInverse)}if(i.isSkinnedMesh){E.setOptional(vt,i,"bindMatrix"),E.setOptional(vt,i,"bindMatrixInverse");const t=i.skeleton;t&&(Y.floatVertexTextures?(null===t.boneTexture&&t.computeBoneTexture(),E.setValue(vt,"boneTexture",t.boneTexture,J),E.setValue(vt,"boneTextureSize",t.boneTextureSize)):E.setOptional(vt,t,"boneMatrices"))}var P,F;return!n||void 0===n.morphAttributes.position&&void 0===n.morphAttributes.normal||ut.update(i,n,r,w),(_||v.receiveShadow!==i.receiveShadow)&&(v.receiveShadow=i.receiveShadow,E.setValue(vt,"receiveShadow",i.receiveShadow)),_&&(E.setValue(vt,"toneMappingExposure",g.toneMappingExposure),v.needsLights&&(F=A,(P=C).ambientLightColor.needsUpdate=F,P.lightProbe.needsUpdate=F,P.directionalLights.needsUpdate=F,P.directionalLightShadows.needsUpdate=F,P.pointLights.needsUpdate=F,P.pointLightShadows.needsUpdate=F,P.spotLights.needsUpdate=F,P.spotLightShadows.needsUpdate=F,P.rectAreaLights.needsUpdate=F,P.hemisphereLights.needsUpdate=F),s&&r.fog&&st.refreshFogUniforms(C,s),st.refreshMaterialUniforms(C,r,R,L,H),Ro.upload(vt,v.uniformsList,C,J)),r.isShaderMaterial&&!0===r.uniformsNeedUpdate&&(Ro.upload(vt,v.uniformsList,C,J),r.uniformsNeedUpdate=!1),r.isSpriteMaterial&&E.setValue(vt,"center",i.center),E.setValue(vt,"modelViewMatrix",i.modelViewMatrix),E.setValue(vt,"normalMatrix",i.normalMatrix),E.setValue(vt,"modelMatrix",i.matrixWorld),w}(t,e,n,r,i);q.setMaterial(r,a);let l=n.index;const c=n.attributes.position;if(null===l){if(void 0===c||0===c.count)return}else if(0===l.count)return;let h,u=1;!0===r.wireframe&&(l=et.getWireframeAttribute(n),u=2),mt.setup(i,r,o,n,l);let d=dt;null!==l&&(h=tt.get(l),d=pt,d.setIndex(h));const f=null!==l?l.count:c.count,m=n.drawRange.start*u,v=n.drawRange.count*u,x=null!==s?s.start*u:0,y=null!==s?s.count*u:1/0,w=Math.max(m,x),b=Math.min(f,m+v,x+y)-1,_=Math.max(0,b-w+1);if(0!==_){if(i.isMesh)!0===r.wireframe?(q.setLineWidth(r.wireframeLinewidth*X()),d.setMode(1)):d.setMode(4);else if(i.isLine){let t=r.linewidth;void 0===t&&(t=1),q.setLineWidth(t*X()),i.isLineSegments?d.setMode(1):i.isLineLoop?d.setMode(2):d.setMode(3)}else i.isPoints?d.setMode(0):i.isSprite&&d.setMode(4);if(i.isInstancedMesh)d.renderInstances(w,_,i.count);else if(n.isInstancedBufferGeometry){const t=Math.min(n.instanceCount,n._maxInstanceCount);d.renderInstances(w,_,t)}else d.render(w,_)}},this.compile=function(t,e){p=ot.get(t),p.init(),m.push(p),t.traverseVisible((function(t){t.isLight&&t.layers.test(e.layers)&&(p.pushLight(t),t.castShadow&&p.pushShadow(t))})),p.setupLights(g.physicallyCorrectLights),t.traverse((function(e){const n=e.material;if(n)if(Array.isArray(n))for(let r=0;r<n.length;r++)Ot(n[r],t,e);else Ot(n,t,e)})),m.pop(),p=null};let St=null;function Et(){Lt.stop()}function Pt(){Lt.start()}const Lt=new Ns;function Rt(t,e,n,r){if(!1===t.visible)return;if(t.layers.test(e.layers))if(t.isGroup)n=t.renderOrder;else if(t.isLOD)!0===t.autoUpdate&&t.update(e);else if(t.isLight)p.pushLight(t),t.castShadow&&p.pushShadow(t);else if(t.isSprite){if(!t.frustumCulled||B.intersectsSprite(t)){r&&V.setFromMatrixPosition(t.matrixWorld).applyMatrix4(G);const e=rt.update(t),i=t.material;i.visible&&d.push(t,e,i,n,V.z,null)}}else if((t.isMesh||t.isLine||t.isPoints)&&(t.isSkinnedMesh&&t.skeleton.frame!==Q.render.frame&&(t.skeleton.update(),t.skeleton.frame=Q.render.frame),!t.frustumCulled||B.intersectsObject(t))){r&&V.setFromMatrixPosition(t.matrixWorld).applyMatrix4(G);const e=rt.update(t),i=t.material;if(Array.isArray(i)){const r=e.groups;for(let s=0,a=r.length;s<a;s++){const a=r[s],o=i[a.materialIndex];o&&o.visible&&d.push(t,e,o,n,V.z,a)}}else i.visible&&d.push(t,e,i,n,V.z,null)}const i=t.children;for(let t=0,s=i.length;t<s;t++)Rt(i[t],e,n,r)}function Ft(t,e,n,r){const i=t.opaque,s=t.transmissive,o=t.transparent;p.setupLightsView(n),s.length>0&&function(t,e,n){if(null===H){const t=!0===a&&!0===Y.isWebGL2;H=new(t?ar:ir)(1024,1024,{generateMipmaps:!0,type:null!==ft.convert(Ut)?Ut:Ct,minFilter:At,magFilter:xt,wrapS:gt,wrapT:gt,useRenderToTexture:j.has("WEBGL_multisampled_render_to_texture")})}const r=g.getRenderTarget();g.setRenderTarget(H),g.clear();const i=g.toneMapping;g.toneMapping=nt,Dt(t,e,n),g.toneMapping=i,J.updateMultisampleRenderTarget(H),J.updateRenderTargetMipmap(H),g.setRenderTarget(r)}(i,e,n),r&&q.viewport(A.copy(r)),i.length>0&&Dt(i,e,n),s.length>0&&Dt(s,e,n),o.length>0&&Dt(o,e,n)}function Dt(t,e,n){const r=!0===e.isScene?e.overrideMaterial:null;for(let i=0,s=t.length;i<s;i++){const s=t[i],a=s.object,o=s.geometry,l=null===r?s.material:r,c=s.group;a.layers.test(n.layers)&&Nt(a,e,n,o,l,c)}}function Nt(t,e,n,r,i,s){t.onBeforeRender(g,e,n,r,i,s),t.modelViewMatrix.multiplyMatrices(n.matrixWorldInverse,t.matrixWorld),t.normalMatrix.getNormalMatrix(t.modelViewMatrix),i.onBeforeRender(g,e,n,r,t,s),!0===i.transparent&&i.side===w?(i.side=y,i.needsUpdate=!0,g.renderBufferDirect(n,e,r,i,t,s),i.side=x,i.needsUpdate=!0,g.renderBufferDirect(n,e,r,i,t,s),i.side=w):g.renderBufferDirect(n,e,r,i,t,s),t.onAfterRender(g,e,n,r,i,s)}function Ot(t,e,n){!0!==e.isScene&&(e=W);const r=Z.get(t),i=p.state.lights,s=p.state.shadowsArray,a=i.state.version,o=it.getParameters(t,i.state,s,e,n),l=it.getProgramCacheKey(o);let c=r.programs;r.environment=t.isMeshStandardMaterial?e.environment:null,r.fog=e.fog,r.envMap=(t.isMeshStandardMaterial?$:K).get(t.envMap||r.environment),void 0===c&&(t.addEventListener("dispose",Tt),c=new Map,r.programs=c);let h=c.get(l);if(void 0!==h){if(r.currentProgram===h&&r.lightsStateVersion===a)return Bt(t,o),h}else o.uniforms=it.getUniforms(t),t.onBuild(n,o,g),t.onBeforeCompile(o,g),h=it.acquireProgram(o,l),c.set(l,h),r.uniforms=o.uniforms;const u=r.uniforms;(t.isShaderMaterial||t.isRawShaderMaterial)&&!0!==t.clipping||(u.clippingPlanes=lt.uniform),Bt(t,o),r.needsLights=function(t){return t.isMeshLambertMaterial||t.isMeshToonMaterial||t.isMeshPhongMaterial||t.isMeshStandardMaterial||t.isShadowMaterial||t.isShaderMaterial&&!0===t.lights}(t),r.lightsStateVersion=a,r.needsLights&&(u.ambientLightColor.value=i.state.ambient,u.lightProbe.value=i.state.probe,u.directionalLights.value=i.state.directional,u.directionalLightShadows.value=i.state.directionalShadow,u.spotLights.value=i.state.spot,u.spotLightShadows.value=i.state.spotShadow,u.rectAreaLights.value=i.state.rectArea,u.ltc_1.value=i.state.rectAreaLTC1,u.ltc_2.value=i.state.rectAreaLTC2,u.pointLights.value=i.state.point,u.pointLightShadows.value=i.state.pointShadow,u.hemisphereLights.value=i.state.hemi,u.directionalShadowMap.value=i.state.directionalShadowMap,u.directionalShadowMatrix.value=i.state.directionalShadowMatrix,u.spotShadowMap.value=i.state.spotShadowMap,u.spotShadowMatrix.value=i.state.spotShadowMatrix,u.pointShadowMap.value=i.state.pointShadowMap,u.pointShadowMatrix.value=i.state.pointShadowMatrix);const d=h.getUniforms(),f=Ro.seqWithValue(d.seq,u);return r.currentProgram=h,r.uniformsList=f,h}function Bt(t,e){const n=Z.get(t);n.outputEncoding=e.outputEncoding,n.instancing=e.instancing,n.skinning=e.skinning,n.morphTargets=e.morphTargets,n.morphNormals=e.morphNormals,n.morphTargetsCount=e.morphTargetsCount,n.numClippingPlanes=e.numClippingPlanes,n.numIntersection=e.numClipIntersection,n.vertexAlphas=e.vertexAlphas,n.vertexTangents=e.vertexTangents,n.toneMapping=e.toneMapping}Lt.setAnimationLoop((function(t){St&&St(t)})),"undefined"!=typeof window&&Lt.setContext(window),this.setAnimationLoop=function(t){St=t,bt.setAnimationLoop(t),null===t?Lt.stop():Lt.start()},bt.addEventListener("sessionstart",Et),bt.addEventListener("sessionend",Pt),this.render=function(t,e){if(void 0!==e&&!0!==e.isCamera)return void console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");if(!0===v)return;!0===t.autoUpdate&&t.updateMatrixWorld(),null===e.parent&&e.updateMatrixWorld(),!0===bt.enabled&&!0===bt.isPresenting&&(!0===bt.cameraAutoUpdate&&bt.updateCamera(e),e=bt.getCamera()),!0===t.isScene&&t.onBeforeRender(g,t,e,M),p=ot.get(t,m.length),p.init(),m.push(p),G.multiplyMatrices(e.projectionMatrix,e.matrixWorldInverse),B.setFromProjectionMatrix(G),k=this.localClippingEnabled,z=lt.init(this.clippingPlanes,k,e),d=at.get(t,f.length),d.init(),f.push(d),Rt(t,e,0,g.sortObjects),d.finish(),!0===g.sortObjects&&d.sort(F,D),!0===z&&lt.beginShadows();const n=p.state.shadowsArray;if(ct.render(n,t,e),!0===z&&lt.endShadows(),!0===this.info.autoReset&&this.info.reset(),ht.render(d,t),p.setupLights(g.physicallyCorrectLights),e.isArrayCamera){const n=e.cameras;for(let e=0,r=n.length;e<r;e++){const r=n[e];Ft(d,t,r,r.viewport)}}else Ft(d,t,e);null!==M&&(J.updateMultisampleRenderTarget(M),J.updateRenderTargetMipmap(M)),!0===t.isScene&&t.onAfterRender(g,t,e),q.buffers.depth.setTest(!0),q.buffers.depth.setMask(!0),q.buffers.color.setMask(!0),q.setPolygonOffset(!1),mt.resetDefaultState(),T=-1,S=null,m.pop(),p=m.length>0?m[m.length-1]:null,f.pop(),d=f.length>0?f[f.length-1]:null},this.getActiveCubeFace=function(){return b},this.getActiveMipmapLevel=function(){return _},this.getRenderTarget=function(){return M},this.setRenderTargetTextures=function(t,e,n){Z.get(t.texture).__webglTexture=e,Z.get(t.depthTexture).__webglTexture=n;const r=Z.get(t);r.__hasExternalTextures=!0,r.__hasExternalTextures&&(r.__autoAllocateDepthBuffer=void 0===n,r.__autoAllocateDepthBuffer||t.useRenderToTexture&&(console.warn("render-to-texture extension was disabled because an external texture was provided"),t.useRenderToTexture=!1,t.useRenderbuffer=!0))},this.setRenderTargetFramebuffer=function(t,e){const n=Z.get(t);n.__webglFramebuffer=e,n.__useDefaultFramebuffer=void 0===e},this.setRenderTarget=function(t,e=0,n=0){M=t,b=e,_=n;let r=!0;if(t){const e=Z.get(t);void 0!==e.__useDefaultFramebuffer?(q.bindFramebuffer(36160,null),r=!1):void 0===e.__webglFramebuffer?J.setupRenderTarget(t):e.__hasExternalTextures&&J.rebindTextures(t,Z.get(t.texture).__webglTexture,Z.get(t.depthTexture).__webglTexture)}let i=null,s=!1,a=!1;if(t){const n=t.texture;(n.isDataTexture3D||n.isDataTexture2DArray)&&(a=!0);const r=Z.get(t).__webglFramebuffer;t.isWebGLCubeRenderTarget?(i=r[e],s=!0):i=t.useRenderbuffer?Z.get(t).__webglMultisampledFramebuffer:r,A.copy(t.viewport),E.copy(t.scissor),C=t.scissorTest}else A.copy(I).multiplyScalar(R).floor(),E.copy(U).multiplyScalar(R).floor(),C=N;if(q.bindFramebuffer(36160,i)&&Y.drawBuffers&&r){let e=!1;if(t)if(t.isWebGLMultipleRenderTargets){const n=t.texture;if(O.length!==n.length||36064!==O[0]){for(let t=0,e=n.length;t<e;t++)O[t]=36064+t;O.length=n.length,e=!0}}else 1===O.length&&36064===O[0]||(O[0]=36064,O.length=1,e=!0);else 1===O.length&&1029===O[0]||(O[0]=1029,O.length=1,e=!0);e&&(Y.isWebGL2?vt.drawBuffers(O):j.get("WEBGL_draw_buffers").drawBuffersWEBGL(O))}if(q.viewport(A),q.scissor(E),q.setScissorTest(C),s){const r=Z.get(t.texture);vt.framebufferTexture2D(36160,36064,34069+e,r.__webglTexture,n)}else if(a){const r=Z.get(t.texture),i=e||0;vt.framebufferTextureLayer(36160,36064,r.__webglTexture,n||0,i)}T=-1},this.readRenderTargetPixels=function(t,e,n,r,i,s,a){if(!t||!t.isWebGLRenderTarget)return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");let o=Z.get(t).__webglFramebuffer;if(t.isWebGLCubeRenderTarget&&void 0!==a&&(o=o[a]),o){q.bindFramebuffer(36160,o);try{const a=t.texture,o=a.format,l=a.type;if(o!==Gt&&ft.convert(o)!==vt.getParameter(35739))return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");const c=l===Ut&&(j.has("EXT_color_buffer_half_float")||Y.isWebGL2&&j.has("EXT_color_buffer_float"));if(!(l===Ct||ft.convert(l)===vt.getParameter(35738)||l===It&&(Y.isWebGL2||j.has("OES_texture_float")||j.has("WEBGL_color_buffer_float"))||c))return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");36053===vt.checkFramebufferStatus(36160)?e>=0&&e<=t.width-r&&n>=0&&n<=t.height-i&&vt.readPixels(e,n,r,i,ft.convert(o),ft.convert(l),s):console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.")}finally{const t=null!==M?Z.get(M).__webglFramebuffer:null;q.bindFramebuffer(36160,t)}}},this.copyFramebufferToTexture=function(t,e,n=0){if(!0!==e.isFramebufferTexture)return void console.error("THREE.WebGLRenderer: copyFramebufferToTexture() can only be used with FramebufferTexture.");const r=Math.pow(2,-n),i=Math.floor(e.image.width*r),s=Math.floor(e.image.height*r);J.setTexture2D(e,0),vt.copyTexSubImage2D(3553,n,0,0,t.x,t.y,i,s),q.unbindTexture()},this.copyTextureToTexture=function(t,e,n,r=0){const i=e.image.width,s=e.image.height,a=ft.convert(n.format),o=ft.convert(n.type);J.setTexture2D(n,0),vt.pixelStorei(37440,n.flipY),vt.pixelStorei(37441,n.premultiplyAlpha),vt.pixelStorei(3317,n.unpackAlignment),e.isDataTexture?vt.texSubImage2D(3553,r,t.x,t.y,i,s,a,o,e.image.data):e.isCompressedTexture?vt.compressedTexSubImage2D(3553,r,t.x,t.y,e.mipmaps[0].width,e.mipmaps[0].height,a,e.mipmaps[0].data):vt.texSubImage2D(3553,r,t.x,t.y,a,o,e.image),0===r&&n.generateMipmaps&&vt.generateMipmap(3553),q.unbindTexture()},this.copyTextureToTexture3D=function(t,e,n,r,i=0){if(g.isWebGL1Renderer)return void console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");const s=t.max.x-t.min.x+1,a=t.max.y-t.min.y+1,o=t.max.z-t.min.z+1,l=ft.convert(r.format),c=ft.convert(r.type);let h;if(r.isDataTexture3D)J.setTexture3D(r,0),h=32879;else{if(!r.isDataTexture2DArray)return void console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");J.setTexture2DArray(r,0),h=35866}vt.pixelStorei(37440,r.flipY),vt.pixelStorei(37441,r.premultiplyAlpha),vt.pixelStorei(3317,r.unpackAlignment);const u=vt.getParameter(3314),d=vt.getParameter(32878),p=vt.getParameter(3316),f=vt.getParameter(3315),m=vt.getParameter(32877),v=n.isCompressedTexture?n.mipmaps[0]:n.image;vt.pixelStorei(3314,v.width),vt.pixelStorei(32878,v.height),vt.pixelStorei(3316,t.min.x),vt.pixelStorei(3315,t.min.y),vt.pixelStorei(32877,t.min.z),n.isDataTexture||n.isDataTexture3D?vt.texSubImage3D(h,i,e.x,e.y,e.z,s,a,o,l,c,v.data):n.isCompressedTexture?(console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture."),vt.compressedTexSubImage3D(h,i,e.x,e.y,e.z,s,a,o,l,v.data)):vt.texSubImage3D(h,i,e.x,e.y,e.z,s,a,o,l,c,v),vt.pixelStorei(3314,u),vt.pixelStorei(32878,d),vt.pixelStorei(3316,p),vt.pixelStorei(3315,f),vt.pixelStorei(32877,m),0===i&&r.generateMipmaps&&vt.generateMipmap(h),q.unbindTexture()},this.initTexture=function(t){J.setTexture2D(t,0),q.unbindTexture()},this.resetState=function(){b=0,_=0,M=null,q.reset(),mt.reset()},"undefined"!=typeof __THREE_DEVTOOLS__&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}Al.prototype.isWebGLRenderer=!0;class El extends Al{}El.prototype.isWebGL1Renderer=!0;class Cl{constructor(t,e=25e-5){this.name="",this.color=new Li(t),this.density=e}clone(){return new Cl(this.color,this.density)}toJSON(){return{type:"FogExp2",color:this.color.getHex(),density:this.density}}}Cl.prototype.isFogExp2=!0;class Pl{constructor(t,e=1,n=1e3){this.name="",this.color=new Li(t),this.near=e,this.far=n}clone(){return new Pl(this.color,this.near,this.far)}toJSON(){return{type:"Fog",color:this.color.getHex(),near:this.near,far:this.far}}}Pl.prototype.isFog=!0;class Ll extends hi{constructor(){super(),this.type="Scene",this.background=null,this.environment=null,this.fog=null,this.overrideMaterial=null,this.autoUpdate=!0,"undefined"!=typeof __THREE_DEVTOOLS__&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}copy(t,e){return super.copy(t,e),null!==t.background&&(this.background=t.background.clone()),null!==t.environment&&(this.environment=t.environment.clone()),null!==t.fog&&(this.fog=t.fog.clone()),null!==t.overrideMaterial&&(this.overrideMaterial=t.overrideMaterial.clone()),this.autoUpdate=t.autoUpdate,this.matrixAutoUpdate=t.matrixAutoUpdate,this}toJSON(t){const e=super.toJSON(t);return null!==this.fog&&(e.object.fog=this.fog.toJSON()),e}}Ll.prototype.isScene=!0;class Rl{constructor(t,e){this.array=t,this.stride=e,this.count=void 0!==t?t.length/e:0,this.usage=_n,this.updateRange={offset:0,count:-1},this.version=0,this.uuid=Bn()}onUploadCallback(){}set needsUpdate(t){!0===t&&this.version++}setUsage(t){return this.usage=t,this}copy(t){return this.array=new t.array.constructor(t.array),this.count=t.count,this.stride=t.stride,this.usage=t.usage,this}copyAt(t,e,n){t*=this.stride,n*=e.stride;for(let r=0,i=this.stride;r<i;r++)this.array[t+r]=e.array[n+r];return this}set(t,e=0){return this.array.set(t,e),this}clone(t){void 0===t.arrayBuffers&&(t.arrayBuffers={}),void 0===this.array.buffer._uuid&&(this.array.buffer._uuid=Bn()),void 0===t.arrayBuffers[this.array.buffer._uuid]&&(t.arrayBuffers[this.array.buffer._uuid]=this.array.slice(0).buffer);const e=new this.array.constructor(t.arrayBuffers[this.array.buffer._uuid]),n=new this.constructor(e,this.stride);return n.setUsage(this.usage),n}onUpload(t){return this.onUploadCallback=t,this}toJSON(t){return void 0===t.arrayBuffers&&(t.arrayBuffers={}),void 0===this.array.buffer._uuid&&(this.array.buffer._uuid=Bn()),void 0===t.arrayBuffers[this.array.buffer._uuid]&&(t.arrayBuffers[this.array.buffer._uuid]=Array.prototype.slice.call(new Uint32Array(this.array.buffer))),{uuid:this.uuid,buffer:this.array.buffer._uuid,type:this.array.constructor.name,stride:this.stride}}}Rl.prototype.isInterleavedBuffer=!0;const Fl=new lr;class Dl{constructor(t,e,n,r=!1){this.name="",this.data=t,this.itemSize=e,this.offset=n,this.normalized=!0===r}get count(){return this.data.count}get array(){return this.data.array}set needsUpdate(t){this.data.needsUpdate=t}applyMatrix4(t){for(let e=0,n=this.data.count;e<n;e++)Fl.x=this.getX(e),Fl.y=this.getY(e),Fl.z=this.getZ(e),Fl.applyMatrix4(t),this.setXYZ(e,Fl.x,Fl.y,Fl.z);return this}applyNormalMatrix(t){for(let e=0,n=this.count;e<n;e++)Fl.x=this.getX(e),Fl.y=this.getY(e),Fl.z=this.getZ(e),Fl.applyNormalMatrix(t),this.setXYZ(e,Fl.x,Fl.y,Fl.z);return this}transformDirection(t){for(let e=0,n=this.count;e<n;e++)Fl.x=this.getX(e),Fl.y=this.getY(e),Fl.z=this.getZ(e),Fl.transformDirection(t),this.setXYZ(e,Fl.x,Fl.y,Fl.z);return this}setX(t,e){return this.data.array[t*this.data.stride+this.offset]=e,this}setY(t,e){return this.data.array[t*this.data.stride+this.offset+1]=e,this}setZ(t,e){return this.data.array[t*this.data.stride+this.offset+2]=e,this}setW(t,e){return this.data.array[t*this.data.stride+this.offset+3]=e,this}getX(t){return this.data.array[t*this.data.stride+this.offset]}getY(t){return this.data.array[t*this.data.stride+this.offset+1]}getZ(t){return this.data.array[t*this.data.stride+this.offset+2]}getW(t){return this.data.array[t*this.data.stride+this.offset+3]}setXY(t,e,n){return t=t*this.data.stride+this.offset,this.data.array[t+0]=e,this.data.array[t+1]=n,this}setXYZ(t,e,n,r){return t=t*this.data.stride+this.offset,this.data.array[t+0]=e,this.data.array[t+1]=n,this.data.array[t+2]=r,this}setXYZW(t,e,n,r,i){return t=t*this.data.stride+this.offset,this.data.array[t+0]=e,this.data.array[t+1]=n,this.data.array[t+2]=r,this.data.array[t+3]=i,this}clone(t){if(void 0===t){console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data.");const t=[];for(let e=0;e<this.count;e++){const n=e*this.data.stride+this.offset;for(let e=0;e<this.itemSize;e++)t.push(this.data.array[n+e])}return new Ii(new this.array.constructor(t),this.itemSize,this.normalized)}return void 0===t.interleavedBuffers&&(t.interleavedBuffers={}),void 0===t.interleavedBuffers[this.data.uuid]&&(t.interleavedBuffers[this.data.uuid]=this.data.clone(t)),new Dl(t.interleavedBuffers[this.data.uuid],this.itemSize,this.offset,this.normalized)}toJSON(t){if(void 0===t){console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data.");const t=[];for(let e=0;e<this.count;e++){const n=e*this.data.stride+this.offset;for(let e=0;e<this.itemSize;e++)t.push(this.data.array[n+e])}return{itemSize:this.itemSize,type:this.array.constructor.name,array:t,normalized:this.normalized}}return void 0===t.interleavedBuffers&&(t.interleavedBuffers={}),void 0===t.interleavedBuffers[this.data.uuid]&&(t.interleavedBuffers[this.data.uuid]=this.data.toJSON(t)),{isInterleavedBufferAttribute:!0,itemSize:this.itemSize,data:this.data.uuid,offset:this.offset,normalized:this.normalized}}}Dl.prototype.isInterleavedBufferAttribute=!0;class Il extends Mi{constructor(t){super(),this.type="SpriteMaterial",this.color=new Li(16777215),this.map=null,this.alphaMap=null,this.rotation=0,this.sizeAttenuation=!0,this.transparent=!0,this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.map=t.map,this.alphaMap=t.alphaMap,this.rotation=t.rotation,this.sizeAttenuation=t.sizeAttenuation,this}}let Ul;Il.prototype.isSpriteMaterial=!0;const Nl=new lr,Ol=new lr,Bl=new lr,zl=new jn,kl=new jn,Hl=new zr,Gl=new lr,Vl=new lr,Wl=new lr,Xl=new jn,jl=new jn,Yl=new jn;class ql extends hi{constructor(t){if(super(),this.type="Sprite",void 0===Ul){Ul=new Ki;const t=new Float32Array([-.5,-.5,0,0,0,.5,-.5,0,1,0,.5,.5,0,1,1,-.5,.5,0,0,1]),e=new Rl(t,5);Ul.setIndex([0,1,2,0,2,3]),Ul.setAttribute("position",new Dl(e,3,0,!1)),Ul.setAttribute("uv",new Dl(e,2,3,!1))}this.geometry=Ul,this.material=void 0!==t?t:new Il,this.center=new jn(.5,.5)}raycast(t,e){null===t.camera&&console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'),Ol.setFromMatrixScale(this.matrixWorld),Hl.copy(t.camera.matrixWorld),this.modelViewMatrix.multiplyMatrices(t.camera.matrixWorldInverse,this.matrixWorld),Bl.setFromMatrixPosition(this.modelViewMatrix),t.camera.isPerspectiveCamera&&!1===this.material.sizeAttenuation&&Ol.multiplyScalar(-Bl.z);const n=this.material.rotation;let r,i;0!==n&&(i=Math.cos(n),r=Math.sin(n));const s=this.center;Ql(Gl.set(-.5,-.5,0),Bl,s,Ol,r,i),Ql(Vl.set(.5,-.5,0),Bl,s,Ol,r,i),Ql(Wl.set(.5,.5,0),Bl,s,Ol,r,i),Xl.set(0,0),jl.set(1,0),Yl.set(1,1);let a=t.ray.intersectTriangle(Gl,Vl,Wl,!1,Nl);if(null===a&&(Ql(Vl.set(-.5,.5,0),Bl,s,Ol,r,i),jl.set(0,1),a=t.ray.intersectTriangle(Gl,Wl,Vl,!1,Nl),null===a))return;const o=t.ray.origin.distanceTo(Nl);o<t.near||o>t.far||e.push({distance:o,point:Nl.clone(),uv:bi.getUV(Nl,Gl,Vl,Wl,Xl,jl,Yl,new jn),face:null,object:this})}copy(t){return super.copy(t),void 0!==t.center&&this.center.copy(t.center),this.material=t.material,this}}function Ql(t,e,n,r,i,s){zl.subVectors(t,n).addScalar(.5).multiply(r),void 0!==i?(kl.x=s*zl.x-i*zl.y,kl.y=i*zl.x+s*zl.y):kl.copy(zl),t.copy(e),t.x+=kl.x,t.y+=kl.y,t.applyMatrix4(Hl)}ql.prototype.isSprite=!0;const Zl=new lr,Jl=new lr;class Kl extends hi{constructor(){super(),this._currentLevel=0,this.type="LOD",Object.defineProperties(this,{levels:{enumerable:!0,value:[]},isLOD:{value:!0}}),this.autoUpdate=!0}copy(t){super.copy(t,!1);const e=t.levels;for(let t=0,n=e.length;t<n;t++){const n=e[t];this.addLevel(n.object.clone(),n.distance)}return this.autoUpdate=t.autoUpdate,this}addLevel(t,e=0){e=Math.abs(e);const n=this.levels;let r;for(r=0;r<n.length&&!(e<n[r].distance);r++);return n.splice(r,0,{distance:e,object:t}),this.add(t),this}getCurrentLevel(){return this._currentLevel}getObjectForDistance(t){const e=this.levels;if(e.length>0){let n,r;for(n=1,r=e.length;n<r&&!(t<e[n].distance);n++);return e[n-1].object}return null}raycast(t,e){if(this.levels.length>0){Zl.setFromMatrixPosition(this.matrixWorld);const n=t.ray.origin.distanceTo(Zl);this.getObjectForDistance(n).raycast(t,e)}}update(t){const e=this.levels;if(e.length>1){Zl.setFromMatrixPosition(t.matrixWorld),Jl.setFromMatrixPosition(this.matrixWorld);const n=Zl.distanceTo(Jl)/t.zoom;let r,i;for(e[0].object.visible=!0,r=1,i=e.length;r<i&&n>=e[r].distance;r++)e[r-1].object.visible=!1,e[r].object.visible=!0;for(this._currentLevel=r-1;r<i;r++)e[r].object.visible=!1}}toJSON(t){const e=super.toJSON(t);!1===this.autoUpdate&&(e.object.autoUpdate=!1),e.object.levels=[];const n=this.levels;for(let t=0,r=n.length;t<r;t++){const r=n[t];e.object.levels.push({object:r.object.uuid,distance:r.distance})}return e}}const $l=new lr,tc=new rr,ec=new rr,nc=new lr,rc=new zr;class ic extends gs{constructor(t,e){super(t,e),this.type="SkinnedMesh",this.bindMode="attached",this.bindMatrix=new zr,this.bindMatrixInverse=new zr}copy(t){return super.copy(t),this.bindMode=t.bindMode,this.bindMatrix.copy(t.bindMatrix),this.bindMatrixInverse.copy(t.bindMatrixInverse),this.skeleton=t.skeleton,this}bind(t,e){this.skeleton=t,void 0===e&&(this.updateMatrixWorld(!0),this.skeleton.calculateInverses(),e=this.matrixWorld),this.bindMatrix.copy(e),this.bindMatrixInverse.copy(e).invert()}pose(){this.skeleton.pose()}normalizeSkinWeights(){const t=new rr,e=this.geometry.attributes.skinWeight;for(let n=0,r=e.count;n<r;n++){t.x=e.getX(n),t.y=e.getY(n),t.z=e.getZ(n),t.w=e.getW(n);const r=1/t.manhattanLength();r!==1/0?t.multiplyScalar(r):t.set(1,0,0,0),e.setXYZW(n,t.x,t.y,t.z,t.w)}}updateMatrixWorld(t){super.updateMatrixWorld(t),"attached"===this.bindMode?this.bindMatrixInverse.copy(this.matrixWorld).invert():"detached"===this.bindMode?this.bindMatrixInverse.copy(this.bindMatrix).invert():console.warn("THREE.SkinnedMesh: Unrecognized bindMode: "+this.bindMode)}boneTransform(t,e){const n=this.skeleton,r=this.geometry;tc.fromBufferAttribute(r.attributes.skinIndex,t),ec.fromBufferAttribute(r.attributes.skinWeight,t),$l.copy(e).applyMatrix4(this.bindMatrix),e.set(0,0,0);for(let t=0;t<4;t++){const r=ec.getComponent(t);if(0!==r){const i=tc.getComponent(t);rc.multiplyMatrices(n.bones[i].matrixWorld,n.boneInverses[i]),e.addScaledVector(nc.copy($l).applyMatrix4(rc),r)}}return e.applyMatrix4(this.bindMatrixInverse)}}ic.prototype.isSkinnedMesh=!0;class sc extends hi{constructor(){super(),this.type="Bone"}}sc.prototype.isBone=!0;class ac extends er{constructor(t=null,e=1,n=1,r,i,s,a,o,l=xt,c=xt,h,u){super(null,s,a,o,l,c,r,i,h,u),this.image={data:t,width:e,height:n},this.magFilter=l,this.minFilter=c,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1}}ac.prototype.isDataTexture=!0;const oc=new zr,lc=new zr;class cc{constructor(t=[],e=[]){this.uuid=Bn(),this.bones=t.slice(0),this.boneInverses=e,this.boneMatrices=null,this.boneTexture=null,this.boneTextureSize=0,this.frame=-1,this.init()}init(){const t=this.bones,e=this.boneInverses;if(this.boneMatrices=new Float32Array(16*t.length),0===e.length)this.calculateInverses();else if(t.length!==e.length){console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."),this.boneInverses=[];for(let t=0,e=this.bones.length;t<e;t++)this.boneInverses.push(new zr)}}calculateInverses(){this.boneInverses.length=0;for(let t=0,e=this.bones.length;t<e;t++){const e=new zr;this.bones[t]&&e.copy(this.bones[t].matrixWorld).invert(),this.boneInverses.push(e)}}pose(){for(let t=0,e=this.bones.length;t<e;t++){const e=this.bones[t];e&&e.matrixWorld.copy(this.boneInverses[t]).invert()}for(let t=0,e=this.bones.length;t<e;t++){const e=this.bones[t];e&&(e.parent&&e.parent.isBone?(e.matrix.copy(e.parent.matrixWorld).invert(),e.matrix.multiply(e.matrixWorld)):e.matrix.copy(e.matrixWorld),e.matrix.decompose(e.position,e.quaternion,e.scale))}}update(){const t=this.bones,e=this.boneInverses,n=this.boneMatrices,r=this.boneTexture;for(let r=0,i=t.length;r<i;r++){const i=t[r]?t[r].matrixWorld:lc;oc.multiplyMatrices(i,e[r]),oc.toArray(n,16*r)}null!==r&&(r.needsUpdate=!0)}clone(){return new cc(this.bones,this.boneInverses)}computeBoneTexture(){let t=Math.sqrt(4*this.bones.length);t=Vn(t),t=Math.max(t,4);const e=new Float32Array(t*t*4);e.set(this.boneMatrices);const n=new ac(e,t,t,Gt,It);return n.needsUpdate=!0,this.boneMatrices=e,this.boneTexture=n,this.boneTextureSize=t,this}getBoneByName(t){for(let e=0,n=this.bones.length;e<n;e++){const n=this.bones[e];if(n.name===t)return n}}dispose(){null!==this.boneTexture&&(this.boneTexture.dispose(),this.boneTexture=null)}fromJSON(t,e){this.uuid=t.uuid;for(let n=0,r=t.bones.length;n<r;n++){const r=t.bones[n];let i=e[r];void 0===i&&(console.warn("THREE.Skeleton: No bone found with UUID:",r),i=new sc),this.bones.push(i),this.boneInverses.push((new zr).fromArray(t.boneInverses[n]))}return this.init(),this}toJSON(){const t={metadata:{version:4.5,type:"Skeleton",generator:"Skeleton.toJSON"},bones:[],boneInverses:[]};t.uuid=this.uuid;const e=this.bones,n=this.boneInverses;for(let r=0,i=e.length;r<i;r++){const i=e[r];t.bones.push(i.uuid);const s=n[r];t.boneInverses.push(s.toArray())}return t}}class hc extends Ii{constructor(t,e,n,r=1){"number"==typeof n&&(r=n,n=!1,console.error("THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.")),super(t,e,n),this.meshPerAttribute=r}copy(t){return super.copy(t),this.meshPerAttribute=t.meshPerAttribute,this}toJSON(){const t=super.toJSON();return t.meshPerAttribute=this.meshPerAttribute,t.isInstancedBufferAttribute=!0,t}}hc.prototype.isInstancedBufferAttribute=!0;const uc=new zr,dc=new zr,pc=[],fc=new gs;class mc extends gs{constructor(t,e,n){super(t,e),this.instanceMatrix=new hc(new Float32Array(16*n),16),this.instanceColor=null,this.count=n,this.frustumCulled=!1}copy(t){return super.copy(t),this.instanceMatrix.copy(t.instanceMatrix),null!==t.instanceColor&&(this.instanceColor=t.instanceColor.clone()),this.count=t.count,this}getColorAt(t,e){e.fromArray(this.instanceColor.array,3*t)}getMatrixAt(t,e){e.fromArray(this.instanceMatrix.array,16*t)}raycast(t,e){const n=this.matrixWorld,r=this.count;if(fc.geometry=this.geometry,fc.material=this.material,void 0!==fc.material)for(let i=0;i<r;i++){this.getMatrixAt(i,uc),dc.multiplyMatrices(n,uc),fc.matrixWorld=dc,fc.raycast(t,pc);for(let t=0,n=pc.length;t<n;t++){const n=pc[t];n.instanceId=i,n.object=this,e.push(n)}pc.length=0}}setColorAt(t,e){null===this.instanceColor&&(this.instanceColor=new hc(new Float32Array(3*this.instanceMatrix.count),3)),e.toArray(this.instanceColor.array,3*t)}setMatrixAt(t,e){e.toArray(this.instanceMatrix.array,16*t)}updateMorphTargets(){}dispose(){this.dispatchEvent({type:"dispose"})}}mc.prototype.isInstancedMesh=!0;class gc extends Mi{constructor(t){super(),this.type="LineBasicMaterial",this.color=new Li(16777215),this.linewidth=1,this.linecap="round",this.linejoin="round",this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.linewidth=t.linewidth,this.linecap=t.linecap,this.linejoin=t.linejoin,this}}gc.prototype.isLineBasicMaterial=!0;const vc=new lr,xc=new lr,yc=new zr,wc=new Br,bc=new Lr;class _c extends hi{constructor(t=new Ki,e=new gc){super(),this.type="Line",this.geometry=t,this.material=e,this.updateMorphTargets()}copy(t){return super.copy(t),this.material=t.material,this.geometry=t.geometry,this}computeLineDistances(){const t=this.geometry;if(t.isBufferGeometry)if(null===t.index){const e=t.attributes.position,n=[0];for(let t=1,r=e.count;t<r;t++)vc.fromBufferAttribute(e,t-1),xc.fromBufferAttribute(e,t),n[t]=n[t-1],n[t]+=vc.distanceTo(xc);t.setAttribute("lineDistance",new Vi(n,1))}else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");else t.isGeometry&&console.error("THREE.Line.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");return this}raycast(t,e){const n=this.geometry,r=this.matrixWorld,i=t.params.Line.threshold,s=n.drawRange;if(null===n.boundingSphere&&n.computeBoundingSphere(),bc.copy(n.boundingSphere),bc.applyMatrix4(r),bc.radius+=i,!1===t.ray.intersectsSphere(bc))return;yc.copy(r).invert(),wc.copy(t.ray).applyMatrix4(yc);const a=i/((this.scale.x+this.scale.y+this.scale.z)/3),o=a*a,l=new lr,c=new lr,h=new lr,u=new lr,d=this.isLineSegments?2:1;if(n.isBufferGeometry){const r=n.index,i=n.attributes.position;if(null!==r)for(let n=Math.max(0,s.start),a=Math.min(r.count,s.start+s.count)-1;n<a;n+=d){const s=r.getX(n),a=r.getX(n+1);if(l.fromBufferAttribute(i,s),c.fromBufferAttribute(i,a),wc.distanceSqToSegment(l,c,u,h)>o)continue;u.applyMatrix4(this.matrixWorld);const d=t.ray.origin.distanceTo(u);d<t.near||d>t.far||e.push({distance:d,point:h.clone().applyMatrix4(this.matrixWorld),index:n,face:null,faceIndex:null,object:this})}else for(let n=Math.max(0,s.start),r=Math.min(i.count,s.start+s.count)-1;n<r;n+=d){if(l.fromBufferAttribute(i,n),c.fromBufferAttribute(i,n+1),wc.distanceSqToSegment(l,c,u,h)>o)continue;u.applyMatrix4(this.matrixWorld);const r=t.ray.origin.distanceTo(u);r<t.near||r>t.far||e.push({distance:r,point:h.clone().applyMatrix4(this.matrixWorld),index:n,face:null,faceIndex:null,object:this})}}else n.isGeometry&&console.error("THREE.Line.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")}updateMorphTargets(){const t=this.geometry;if(t.isBufferGeometry){const e=t.morphAttributes,n=Object.keys(e);if(n.length>0){const t=e[n[0]];if(void 0!==t){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let e=0,n=t.length;e<n;e++){const n=t[e].name||String(e);this.morphTargetInfluences.push(0),this.morphTargetDictionary[n]=e}}}}else{const e=t.morphTargets;void 0!==e&&e.length>0&&console.error("THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.")}}}_c.prototype.isLine=!0;const Mc=new lr,Tc=new lr;class Sc extends _c{constructor(t,e){super(t,e),this.type="LineSegments"}computeLineDistances(){const t=this.geometry;if(t.isBufferGeometry)if(null===t.index){const e=t.attributes.position,n=[];for(let t=0,r=e.count;t<r;t+=2)Mc.fromBufferAttribute(e,t),Tc.fromBufferAttribute(e,t+1),n[t]=0===t?0:n[t-1],n[t+1]=n[t]+Mc.distanceTo(Tc);t.setAttribute("lineDistance",new Vi(n,1))}else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");else t.isGeometry&&console.error("THREE.LineSegments.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");return this}}Sc.prototype.isLineSegments=!0;class Ac extends _c{constructor(t,e){super(t,e),this.type="LineLoop"}}Ac.prototype.isLineLoop=!0;class Ec extends Mi{constructor(t){super(),this.type="PointsMaterial",this.color=new Li(16777215),this.map=null,this.alphaMap=null,this.size=1,this.sizeAttenuation=!0,this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.map=t.map,this.alphaMap=t.alphaMap,this.size=t.size,this.sizeAttenuation=t.sizeAttenuation,this}}Ec.prototype.isPointsMaterial=!0;const Cc=new zr,Pc=new Br,Lc=new Lr,Rc=new lr;class Fc extends hi{constructor(t=new Ki,e=new Ec){super(),this.type="Points",this.geometry=t,this.material=e,this.updateMorphTargets()}copy(t){return super.copy(t),this.material=t.material,this.geometry=t.geometry,this}raycast(t,e){const n=this.geometry,r=this.matrixWorld,i=t.params.Points.threshold,s=n.drawRange;if(null===n.boundingSphere&&n.computeBoundingSphere(),Lc.copy(n.boundingSphere),Lc.applyMatrix4(r),Lc.radius+=i,!1===t.ray.intersectsSphere(Lc))return;Cc.copy(r).invert(),Pc.copy(t.ray).applyMatrix4(Cc);const a=i/((this.scale.x+this.scale.y+this.scale.z)/3),o=a*a;if(n.isBufferGeometry){const i=n.index,a=n.attributes.position;if(null!==i)for(let n=Math.max(0,s.start),l=Math.min(i.count,s.start+s.count);n<l;n++){const s=i.getX(n);Rc.fromBufferAttribute(a,s),Dc(Rc,s,o,r,t,e,this)}else for(let n=Math.max(0,s.start),i=Math.min(a.count,s.start+s.count);n<i;n++)Rc.fromBufferAttribute(a,n),Dc(Rc,n,o,r,t,e,this)}else console.error("THREE.Points.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")}updateMorphTargets(){const t=this.geometry;if(t.isBufferGeometry){const e=t.morphAttributes,n=Object.keys(e);if(n.length>0){const t=e[n[0]];if(void 0!==t){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let e=0,n=t.length;e<n;e++){const n=t[e].name||String(e);this.morphTargetInfluences.push(0),this.morphTargetDictionary[n]=e}}}}else{const e=t.morphTargets;void 0!==e&&e.length>0&&console.error("THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.")}}}function Dc(t,e,n,r,i,s,a){const o=Pc.distanceSqToPoint(t);if(o<n){const n=new lr;Pc.closestPointToPoint(t,n),n.applyMatrix4(r);const l=i.ray.origin.distanceTo(n);if(l<i.near||l>i.far)return;s.push({distance:l,distanceToRay:Math.sqrt(o),point:n,index:e,face:null,object:a})}}Fc.prototype.isPoints=!0;class Ic extends er{constructor(t,e,n,r,i,s,a,o,l){super(t,e,n,r,i,s,a,o,l),this.format=void 0!==a?a:Ht,this.minFilter=void 0!==s?s:Mt,this.magFilter=void 0!==i?i:Mt,this.generateMipmaps=!1;const c=this;"requestVideoFrameCallback"in t&&t.requestVideoFrameCallback((function e(){c.needsUpdate=!0,t.requestVideoFrameCallback(e)}))}clone(){return new this.constructor(this.image).copy(this)}update(){const t=this.image;!1=="requestVideoFrameCallback"in t&&t.readyState>=t.HAVE_CURRENT_DATA&&(this.needsUpdate=!0)}}Ic.prototype.isVideoTexture=!0;class Uc extends er{constructor(t,e,n){super({width:t,height:e}),this.format=n,this.magFilter=xt,this.minFilter=xt,this.generateMipmaps=!1,this.needsUpdate=!0}}Uc.prototype.isFramebufferTexture=!0;class Nc extends er{constructor(t,e,n,r,i,s,a,o,l,c,h,u){super(null,s,a,o,l,c,r,i,h,u),this.image={width:e,height:n},this.mipmaps=t,this.flipY=!1,this.generateMipmaps=!1}}Nc.prototype.isCompressedTexture=!0;class Oc extends er{constructor(t,e,n,r,i,s,a,o,l){super(t,e,n,r,i,s,a,o,l),this.needsUpdate=!0}}Oc.prototype.isCanvasTexture=!0;class Bc extends Ki{constructor(t=1,e=8,n=0,r=2*Math.PI){super(),this.type="CircleGeometry",this.parameters={radius:t,segments:e,thetaStart:n,thetaLength:r},e=Math.max(3,e);const i=[],s=[],a=[],o=[],l=new lr,c=new jn;s.push(0,0,0),a.push(0,0,1),o.push(.5,.5);for(let i=0,h=3;i<=e;i++,h+=3){const u=n+i/e*r;l.x=t*Math.cos(u),l.y=t*Math.sin(u),s.push(l.x,l.y,l.z),a.push(0,0,1),c.x=(s[h]/t+1)/2,c.y=(s[h+1]/t+1)/2,o.push(c.x,c.y)}for(let t=1;t<=e;t++)i.push(t,t+1,0);this.setIndex(i),this.setAttribute("position",new Vi(s,3)),this.setAttribute("normal",new Vi(a,3)),this.setAttribute("uv",new Vi(o,2))}static fromJSON(t){return new Bc(t.radius,t.segments,t.thetaStart,t.thetaLength)}}class zc extends Ki{constructor(t=1,e=1,n=1,r=8,i=1,s=!1,a=0,o=2*Math.PI){super(),this.type="CylinderGeometry",this.parameters={radiusTop:t,radiusBottom:e,height:n,radialSegments:r,heightSegments:i,openEnded:s,thetaStart:a,thetaLength:o};const l=this;r=Math.floor(r),i=Math.floor(i);const c=[],h=[],u=[],d=[];let p=0;const f=[],m=n/2;let g=0;function v(n){const i=p,s=new jn,f=new lr;let v=0;const x=!0===n?t:e,y=!0===n?1:-1;for(let t=1;t<=r;t++)h.push(0,m*y,0),u.push(0,y,0),d.push(.5,.5),p++;const w=p;for(let t=0;t<=r;t++){const e=t/r*o+a,n=Math.cos(e),i=Math.sin(e);f.x=x*i,f.y=m*y,f.z=x*n,h.push(f.x,f.y,f.z),u.push(0,y,0),s.x=.5*n+.5,s.y=.5*i*y+.5,d.push(s.x,s.y),p++}for(let t=0;t<r;t++){const e=i+t,r=w+t;!0===n?c.push(r,r+1,e):c.push(r+1,r,e),v+=3}l.addGroup(g,v,!0===n?1:2),g+=v}!function(){const s=new lr,v=new lr;let x=0;const y=(e-t)/n;for(let l=0;l<=i;l++){const c=[],g=l/i,x=g*(e-t)+t;for(let t=0;t<=r;t++){const e=t/r,i=e*o+a,l=Math.sin(i),f=Math.cos(i);v.x=x*l,v.y=-g*n+m,v.z=x*f,h.push(v.x,v.y,v.z),s.set(l,y,f).normalize(),u.push(s.x,s.y,s.z),d.push(e,1-g),c.push(p++)}f.push(c)}for(let t=0;t<r;t++)for(let e=0;e<i;e++){const n=f[e][t],r=f[e+1][t],i=f[e+1][t+1],s=f[e][t+1];c.push(n,r,s),c.push(r,i,s),x+=6}l.addGroup(g,x,0),g+=x}(),!1===s&&(t>0&&v(!0),e>0&&v(!1)),this.setIndex(c),this.setAttribute("position",new Vi(h,3)),this.setAttribute("normal",new Vi(u,3)),this.setAttribute("uv",new Vi(d,2))}static fromJSON(t){return new zc(t.radiusTop,t.radiusBottom,t.height,t.radialSegments,t.heightSegments,t.openEnded,t.thetaStart,t.thetaLength)}}class kc extends zc{constructor(t=1,e=1,n=8,r=1,i=!1,s=0,a=2*Math.PI){super(0,t,e,n,r,i,s,a),this.type="ConeGeometry",this.parameters={radius:t,height:e,radialSegments:n,heightSegments:r,openEnded:i,thetaStart:s,thetaLength:a}}static fromJSON(t){return new kc(t.radius,t.height,t.radialSegments,t.heightSegments,t.openEnded,t.thetaStart,t.thetaLength)}}class Hc extends Ki{constructor(t=[],e=[],n=1,r=0){super(),this.type="PolyhedronGeometry",this.parameters={vertices:t,indices:e,radius:n,detail:r};const i=[],s=[];function a(t,e,n,r){const i=r+1,s=[];for(let r=0;r<=i;r++){s[r]=[];const a=t.clone().lerp(n,r/i),o=e.clone().lerp(n,r/i),l=i-r;for(let t=0;t<=l;t++)s[r][t]=0===t&&r===i?a:a.clone().lerp(o,t/l)}for(let t=0;t<i;t++)for(let e=0;e<2*(i-t)-1;e++){const n=Math.floor(e/2);e%2==0?(o(s[t][n+1]),o(s[t+1][n]),o(s[t][n])):(o(s[t][n+1]),o(s[t+1][n+1]),o(s[t+1][n]))}}function o(t){i.push(t.x,t.y,t.z)}function l(e,n){const r=3*e;n.x=t[r+0],n.y=t[r+1],n.z=t[r+2]}function c(t,e,n,r){r<0&&1===t.x&&(s[e]=t.x-1),0===n.x&&0===n.z&&(s[e]=r/2/Math.PI+.5)}function h(t){return Math.atan2(t.z,-t.x)}!function(t){const n=new lr,r=new lr,i=new lr;for(let s=0;s<e.length;s+=3)l(e[s+0],n),l(e[s+1],r),l(e[s+2],i),a(n,r,i,t)}(r),function(t){const e=new lr;for(let n=0;n<i.length;n+=3)e.x=i[n+0],e.y=i[n+1],e.z=i[n+2],e.normalize().multiplyScalar(t),i[n+0]=e.x,i[n+1]=e.y,i[n+2]=e.z}(n),function(){const t=new lr;for(let n=0;n<i.length;n+=3){t.x=i[n+0],t.y=i[n+1],t.z=i[n+2];const r=h(t)/2/Math.PI+.5,a=(e=t,Math.atan2(-e.y,Math.sqrt(e.x*e.x+e.z*e.z))/Math.PI+.5);s.push(r,1-a)}var e;(function(){const t=new lr,e=new lr,n=new lr,r=new lr,a=new jn,o=new jn,l=new jn;for(let u=0,d=0;u<i.length;u+=9,d+=6){t.set(i[u+0],i[u+1],i[u+2]),e.set(i[u+3],i[u+4],i[u+5]),n.set(i[u+6],i[u+7],i[u+8]),a.set(s[d+0],s[d+1]),o.set(s[d+2],s[d+3]),l.set(s[d+4],s[d+5]),r.copy(t).add(e).add(n).divideScalar(3);const p=h(r);c(a,d+0,t,p),c(o,d+2,e,p),c(l,d+4,n,p)}})(),function(){for(let t=0;t<s.length;t+=6){const e=s[t+0],n=s[t+2],r=s[t+4],i=Math.max(e,n,r),a=Math.min(e,n,r);i>.9&&a<.1&&(e<.2&&(s[t+0]+=1),n<.2&&(s[t+2]+=1),r<.2&&(s[t+4]+=1))}}()}(),this.setAttribute("position",new Vi(i,3)),this.setAttribute("normal",new Vi(i.slice(),3)),this.setAttribute("uv",new Vi(s,2)),0===r?this.computeVertexNormals():this.normalizeNormals()}static fromJSON(t){return new Hc(t.vertices,t.indices,t.radius,t.details)}}class Gc extends Hc{constructor(t=1,e=0){const n=(1+Math.sqrt(5))/2,r=1/n;super([-1,-1,-1,-1,-1,1,-1,1,-1,-1,1,1,1,-1,-1,1,-1,1,1,1,-1,1,1,1,0,-r,-n,0,-r,n,0,r,-n,0,r,n,-r,-n,0,-r,n,0,r,-n,0,r,n,0,-n,0,-r,n,0,-r,-n,0,r,n,0,r],[3,11,7,3,7,15,3,15,13,7,19,17,7,17,6,7,6,15,17,4,8,17,8,10,17,10,6,8,0,16,8,16,2,8,2,10,0,12,1,0,1,18,0,18,16,6,10,2,6,2,13,6,13,15,2,16,18,2,18,3,2,3,13,18,1,9,18,9,11,18,11,3,4,14,12,4,12,0,4,0,8,11,9,5,11,5,19,11,19,7,19,5,14,19,14,4,19,4,17,1,12,14,1,14,5,1,5,9],t,e),this.type="DodecahedronGeometry",this.parameters={radius:t,detail:e}}static fromJSON(t){return new Gc(t.radius,t.detail)}}const Vc=new lr,Wc=new lr,Xc=new lr,jc=new bi;class Yc extends Ki{constructor(t=null,e=1){if(super(),this.type="EdgesGeometry",this.parameters={geometry:t,thresholdAngle:e},null!==t){const n=4,r=Math.pow(10,n),i=Math.cos(Nn*e),s=t.getIndex(),a=t.getAttribute("position"),o=s?s.count:a.count,l=[0,0,0],c=["a","b","c"],h=new Array(3),u={},d=[];for(let t=0;t<o;t+=3){s?(l[0]=s.getX(t),l[1]=s.getX(t+1),l[2]=s.getX(t+2)):(l[0]=t,l[1]=t+1,l[2]=t+2);const{a:e,b:n,c:o}=jc;if(e.fromBufferAttribute(a,l[0]),n.fromBufferAttribute(a,l[1]),o.fromBufferAttribute(a,l[2]),jc.getNormal(Xc),h[0]=`${Math.round(e.x*r)},${Math.round(e.y*r)},${Math.round(e.z*r)}`,h[1]=`${Math.round(n.x*r)},${Math.round(n.y*r)},${Math.round(n.z*r)}`,h[2]=`${Math.round(o.x*r)},${Math.round(o.y*r)},${Math.round(o.z*r)}`,h[0]!==h[1]&&h[1]!==h[2]&&h[2]!==h[0])for(let t=0;t<3;t++){const e=(t+1)%3,n=h[t],r=h[e],s=jc[c[t]],a=jc[c[e]],o=`${n}_${r}`,p=`${r}_${n}`;p in u&&u[p]?(Xc.dot(u[p].normal)<=i&&(d.push(s.x,s.y,s.z),d.push(a.x,a.y,a.z)),u[p]=null):o in u||(u[o]={index0:l[t],index1:l[e],normal:Xc.clone()})}}for(const t in u)if(u[t]){const{index0:e,index1:n}=u[t];Vc.fromBufferAttribute(a,e),Wc.fromBufferAttribute(a,n),d.push(Vc.x,Vc.y,Vc.z),d.push(Wc.x,Wc.y,Wc.z)}this.setAttribute("position",new Vi(d,3))}}}class qc{constructor(){this.type="Curve",this.arcLengthDivisions=200}getPoint(){return console.warn("THREE.Curve: .getPoint() not implemented."),null}getPointAt(t,e){const n=this.getUtoTmapping(t);return this.getPoint(n,e)}getPoints(t=5){const e=[];for(let n=0;n<=t;n++)e.push(this.getPoint(n/t));return e}getSpacedPoints(t=5){const e=[];for(let n=0;n<=t;n++)e.push(this.getPointAt(n/t));return e}getLength(){const t=this.getLengths();return t[t.length-1]}getLengths(t=this.arcLengthDivisions){if(this.cacheArcLengths&&this.cacheArcLengths.length===t+1&&!this.needsUpdate)return this.cacheArcLengths;this.needsUpdate=!1;const e=[];let n,r=this.getPoint(0),i=0;e.push(0);for(let s=1;s<=t;s++)n=this.getPoint(s/t),i+=n.distanceTo(r),e.push(i),r=n;return this.cacheArcLengths=e,e}updateArcLengths(){this.needsUpdate=!0,this.getLengths()}getUtoTmapping(t,e){const n=this.getLengths();let r=0;const i=n.length;let s;s=e||t*n[i-1];let a,o=0,l=i-1;for(;o<=l;)if(r=Math.floor(o+(l-o)/2),a=n[r]-s,a<0)o=r+1;else{if(!(a>0)){l=r;break}l=r-1}if(r=l,n[r]===s)return r/(i-1);const c=n[r];return(r+(s-c)/(n[r+1]-c))/(i-1)}getTangent(t,e){const n=1e-4;let r=t-n,i=t+n;r<0&&(r=0),i>1&&(i=1);const s=this.getPoint(r),a=this.getPoint(i),o=e||(s.isVector2?new jn:new lr);return o.copy(a).sub(s).normalize(),o}getTangentAt(t,e){const n=this.getUtoTmapping(t);return this.getTangent(n,e)}computeFrenetFrames(t,e){const n=new lr,r=[],i=[],s=[],a=new lr,o=new zr;for(let e=0;e<=t;e++){const n=e/t;r[e]=this.getTangentAt(n,new lr)}i[0]=new lr,s[0]=new lr;let l=Number.MAX_VALUE;const c=Math.abs(r[0].x),h=Math.abs(r[0].y),u=Math.abs(r[0].z);c<=l&&(l=c,n.set(1,0,0)),h<=l&&(l=h,n.set(0,1,0)),u<=l&&n.set(0,0,1),a.crossVectors(r[0],n).normalize(),i[0].crossVectors(r[0],a),s[0].crossVectors(r[0],i[0]);for(let e=1;e<=t;e++){if(i[e]=i[e-1].clone(),s[e]=s[e-1].clone(),a.crossVectors(r[e-1],r[e]),a.length()>Number.EPSILON){a.normalize();const t=Math.acos(zn(r[e-1].dot(r[e]),-1,1));i[e].applyMatrix4(o.makeRotationAxis(a,t))}s[e].crossVectors(r[e],i[e])}if(!0===e){let e=Math.acos(zn(i[0].dot(i[t]),-1,1));e/=t,r[0].dot(a.crossVectors(i[0],i[t]))>0&&(e=-e);for(let n=1;n<=t;n++)i[n].applyMatrix4(o.makeRotationAxis(r[n],e*n)),s[n].crossVectors(r[n],i[n])}return{tangents:r,normals:i,binormals:s}}clone(){return(new this.constructor).copy(this)}copy(t){return this.arcLengthDivisions=t.arcLengthDivisions,this}toJSON(){const t={metadata:{version:4.5,type:"Curve",generator:"Curve.toJSON"}};return t.arcLengthDivisions=this.arcLengthDivisions,t.type=this.type,t}fromJSON(t){return this.arcLengthDivisions=t.arcLengthDivisions,this}}class Qc extends qc{constructor(t=0,e=0,n=1,r=1,i=0,s=2*Math.PI,a=!1,o=0){super(),this.type="EllipseCurve",this.aX=t,this.aY=e,this.xRadius=n,this.yRadius=r,this.aStartAngle=i,this.aEndAngle=s,this.aClockwise=a,this.aRotation=o}getPoint(t,e){const n=e||new jn,r=2*Math.PI;let i=this.aEndAngle-this.aStartAngle;const s=Math.abs(i)<Number.EPSILON;for(;i<0;)i+=r;for(;i>r;)i-=r;i<Number.EPSILON&&(i=s?0:r),!0!==this.aClockwise||s||(i===r?i=-r:i-=r);const a=this.aStartAngle+t*i;let o=this.aX+this.xRadius*Math.cos(a),l=this.aY+this.yRadius*Math.sin(a);if(0!==this.aRotation){const t=Math.cos(this.aRotation),e=Math.sin(this.aRotation),n=o-this.aX,r=l-this.aY;o=n*t-r*e+this.aX,l=n*e+r*t+this.aY}return n.set(o,l)}copy(t){return super.copy(t),this.aX=t.aX,this.aY=t.aY,this.xRadius=t.xRadius,this.yRadius=t.yRadius,this.aStartAngle=t.aStartAngle,this.aEndAngle=t.aEndAngle,this.aClockwise=t.aClockwise,this.aRotation=t.aRotation,this}toJSON(){const t=super.toJSON();return t.aX=this.aX,t.aY=this.aY,t.xRadius=this.xRadius,t.yRadius=this.yRadius,t.aStartAngle=this.aStartAngle,t.aEndAngle=this.aEndAngle,t.aClockwise=this.aClockwise,t.aRotation=this.aRotation,t}fromJSON(t){return super.fromJSON(t),this.aX=t.aX,this.aY=t.aY,this.xRadius=t.xRadius,this.yRadius=t.yRadius,this.aStartAngle=t.aStartAngle,this.aEndAngle=t.aEndAngle,this.aClockwise=t.aClockwise,this.aRotation=t.aRotation,this}}Qc.prototype.isEllipseCurve=!0;class Zc extends Qc{constructor(t,e,n,r,i,s){super(t,e,n,n,r,i,s),this.type="ArcCurve"}}function Jc(){let t=0,e=0,n=0,r=0;function i(i,s,a,o){t=i,e=a,n=-3*i+3*s-2*a-o,r=2*i-2*s+a+o}return{initCatmullRom:function(t,e,n,r,s){i(e,n,s*(n-t),s*(r-e))},initNonuniformCatmullRom:function(t,e,n,r,s,a,o){let l=(e-t)/s-(n-t)/(s+a)+(n-e)/a,c=(n-e)/a-(r-e)/(a+o)+(r-n)/o;l*=a,c*=a,i(e,n,l,c)},calc:function(i){const s=i*i;return t+e*i+n*s+r*(s*i)}}}Zc.prototype.isArcCurve=!0;const Kc=new lr,$c=new Jc,th=new Jc,eh=new Jc;class nh extends qc{constructor(t=[],e=!1,n="centripetal",r=.5){super(),this.type="CatmullRomCurve3",this.points=t,this.closed=e,this.curveType=n,this.tension=r}getPoint(t,e=new lr){const n=e,r=this.points,i=r.length,s=(i-(this.closed?0:1))*t;let a,o,l=Math.floor(s),c=s-l;this.closed?l+=l>0?0:(Math.floor(Math.abs(l)/i)+1)*i:0===c&&l===i-1&&(l=i-2,c=1),this.closed||l>0?a=r[(l-1)%i]:(Kc.subVectors(r[0],r[1]).add(r[0]),a=Kc);const h=r[l%i],u=r[(l+1)%i];if(this.closed||l+2<i?o=r[(l+2)%i]:(Kc.subVectors(r[i-1],r[i-2]).add(r[i-1]),o=Kc),"centripetal"===this.curveType||"chordal"===this.curveType){const t="chordal"===this.curveType?.5:.25;let e=Math.pow(a.distanceToSquared(h),t),n=Math.pow(h.distanceToSquared(u),t),r=Math.pow(u.distanceToSquared(o),t);n<1e-4&&(n=1),e<1e-4&&(e=n),r<1e-4&&(r=n),$c.initNonuniformCatmullRom(a.x,h.x,u.x,o.x,e,n,r),th.initNonuniformCatmullRom(a.y,h.y,u.y,o.y,e,n,r),eh.initNonuniformCatmullRom(a.z,h.z,u.z,o.z,e,n,r)}else"catmullrom"===this.curveType&&($c.initCatmullRom(a.x,h.x,u.x,o.x,this.tension),th.initCatmullRom(a.y,h.y,u.y,o.y,this.tension),eh.initCatmullRom(a.z,h.z,u.z,o.z,this.tension));return n.set($c.calc(c),th.calc(c),eh.calc(c)),n}copy(t){super.copy(t),this.points=[];for(let e=0,n=t.points.length;e<n;e++){const n=t.points[e];this.points.push(n.clone())}return this.closed=t.closed,this.curveType=t.curveType,this.tension=t.tension,this}toJSON(){const t=super.toJSON();t.points=[];for(let e=0,n=this.points.length;e<n;e++){const n=this.points[e];t.points.push(n.toArray())}return t.closed=this.closed,t.curveType=this.curveType,t.tension=this.tension,t}fromJSON(t){super.fromJSON(t),this.points=[];for(let e=0,n=t.points.length;e<n;e++){const n=t.points[e];this.points.push((new lr).fromArray(n))}return this.closed=t.closed,this.curveType=t.curveType,this.tension=t.tension,this}}function rh(t,e,n,r,i){const s=.5*(r-e),a=.5*(i-n),o=t*t;return(2*n-2*r+s+a)*(t*o)+(-3*n+3*r-2*s-a)*o+s*t+n}function ih(t,e,n,r){return function(t,e){const n=1-t;return n*n*e}(t,e)+function(t,e){return 2*(1-t)*t*e}(t,n)+function(t,e){return t*t*e}(t,r)}function sh(t,e,n,r,i){return function(t,e){const n=1-t;return n*n*n*e}(t,e)+function(t,e){const n=1-t;return 3*n*n*t*e}(t,n)+function(t,e){return 3*(1-t)*t*t*e}(t,r)+function(t,e){return t*t*t*e}(t,i)}nh.prototype.isCatmullRomCurve3=!0;class ah extends qc{constructor(t=new jn,e=new jn,n=new jn,r=new jn){super(),this.type="CubicBezierCurve",this.v0=t,this.v1=e,this.v2=n,this.v3=r}getPoint(t,e=new jn){const n=e,r=this.v0,i=this.v1,s=this.v2,a=this.v3;return n.set(sh(t,r.x,i.x,s.x,a.x),sh(t,r.y,i.y,s.y,a.y)),n}copy(t){return super.copy(t),this.v0.copy(t.v0),this.v1.copy(t.v1),this.v2.copy(t.v2),this.v3.copy(t.v3),this}toJSON(){const t=super.toJSON();return t.v0=this.v0.toArray(),t.v1=this.v1.toArray(),t.v2=this.v2.toArray(),t.v3=this.v3.toArray(),t}fromJSON(t){return super.fromJSON(t),this.v0.fromArray(t.v0),this.v1.fromArray(t.v1),this.v2.fromArray(t.v2),this.v3.fromArray(t.v3),this}}ah.prototype.isCubicBezierCurve=!0;class oh extends qc{constructor(t=new lr,e=new lr,n=new lr,r=new lr){super(),this.type="CubicBezierCurve3",this.v0=t,this.v1=e,this.v2=n,this.v3=r}getPoint(t,e=new lr){const n=e,r=this.v0,i=this.v1,s=this.v2,a=this.v3;return n.set(sh(t,r.x,i.x,s.x,a.x),sh(t,r.y,i.y,s.y,a.y),sh(t,r.z,i.z,s.z,a.z)),n}copy(t){return super.copy(t),this.v0.copy(t.v0),this.v1.copy(t.v1),this.v2.copy(t.v2),this.v3.copy(t.v3),this}toJSON(){const t=super.toJSON();return t.v0=this.v0.toArray(),t.v1=this.v1.toArray(),t.v2=this.v2.toArray(),t.v3=this.v3.toArray(),t}fromJSON(t){return super.fromJSON(t),this.v0.fromArray(t.v0),this.v1.fromArray(t.v1),this.v2.fromArray(t.v2),this.v3.fromArray(t.v3),this}}oh.prototype.isCubicBezierCurve3=!0;class lh extends qc{constructor(t=new jn,e=new jn){super(),this.type="LineCurve",this.v1=t,this.v2=e}getPoint(t,e=new jn){const n=e;return 1===t?n.copy(this.v2):(n.copy(this.v2).sub(this.v1),n.multiplyScalar(t).add(this.v1)),n}getPointAt(t,e){return this.getPoint(t,e)}getTangent(t,e){const n=e||new jn;return n.copy(this.v2).sub(this.v1).normalize(),n}copy(t){return super.copy(t),this.v1.copy(t.v1),this.v2.copy(t.v2),this}toJSON(){const t=super.toJSON();return t.v1=this.v1.toArray(),t.v2=this.v2.toArray(),t}fromJSON(t){return super.fromJSON(t),this.v1.fromArray(t.v1),this.v2.fromArray(t.v2),this}}lh.prototype.isLineCurve=!0;class ch extends qc{constructor(t=new lr,e=new lr){super(),this.type="LineCurve3",this.isLineCurve3=!0,this.v1=t,this.v2=e}getPoint(t,e=new lr){const n=e;return 1===t?n.copy(this.v2):(n.copy(this.v2).sub(this.v1),n.multiplyScalar(t).add(this.v1)),n}getPointAt(t,e){return this.getPoint(t,e)}copy(t){return super.copy(t),this.v1.copy(t.v1),this.v2.copy(t.v2),this}toJSON(){const t=super.toJSON();return t.v1=this.v1.toArray(),t.v2=this.v2.toArray(),t}fromJSON(t){return super.fromJSON(t),this.v1.fromArray(t.v1),this.v2.fromArray(t.v2),this}}class hh extends qc{constructor(t=new jn,e=new jn,n=new jn){super(),this.type="QuadraticBezierCurve",this.v0=t,this.v1=e,this.v2=n}getPoint(t,e=new jn){const n=e,r=this.v0,i=this.v1,s=this.v2;return n.set(ih(t,r.x,i.x,s.x),ih(t,r.y,i.y,s.y)),n}copy(t){return super.copy(t),this.v0.copy(t.v0),this.v1.copy(t.v1),this.v2.copy(t.v2),this}toJSON(){const t=super.toJSON();return t.v0=this.v0.toArray(),t.v1=this.v1.toArray(),t.v2=this.v2.toArray(),t}fromJSON(t){return super.fromJSON(t),this.v0.fromArray(t.v0),this.v1.fromArray(t.v1),this.v2.fromArray(t.v2),this}}hh.prototype.isQuadraticBezierCurve=!0;class uh extends qc{constructor(t=new lr,e=new lr,n=new lr){super(),this.type="QuadraticBezierCurve3",this.v0=t,this.v1=e,this.v2=n}getPoint(t,e=new lr){const n=e,r=this.v0,i=this.v1,s=this.v2;return n.set(ih(t,r.x,i.x,s.x),ih(t,r.y,i.y,s.y),ih(t,r.z,i.z,s.z)),n}copy(t){return super.copy(t),this.v0.copy(t.v0),this.v1.copy(t.v1),this.v2.copy(t.v2),this}toJSON(){const t=super.toJSON();return t.v0=this.v0.toArray(),t.v1=this.v1.toArray(),t.v2=this.v2.toArray(),t}fromJSON(t){return super.fromJSON(t),this.v0.fromArray(t.v0),this.v1.fromArray(t.v1),this.v2.fromArray(t.v2),this}}uh.prototype.isQuadraticBezierCurve3=!0;class dh extends qc{constructor(t=[]){super(),this.type="SplineCurve",this.points=t}getPoint(t,e=new jn){const n=e,r=this.points,i=(r.length-1)*t,s=Math.floor(i),a=i-s,o=r[0===s?s:s-1],l=r[s],c=r[s>r.length-2?r.length-1:s+1],h=r[s>r.length-3?r.length-1:s+2];return n.set(rh(a,o.x,l.x,c.x,h.x),rh(a,o.y,l.y,c.y,h.y)),n}copy(t){super.copy(t),this.points=[];for(let e=0,n=t.points.length;e<n;e++){const n=t.points[e];this.points.push(n.clone())}return this}toJSON(){const t=super.toJSON();t.points=[];for(let e=0,n=this.points.length;e<n;e++){const n=this.points[e];t.points.push(n.toArray())}return t}fromJSON(t){super.fromJSON(t),this.points=[];for(let e=0,n=t.points.length;e<n;e++){const n=t.points[e];this.points.push((new jn).fromArray(n))}return this}}dh.prototype.isSplineCurve=!0;var ph=Object.freeze({__proto__:null,ArcCurve:Zc,CatmullRomCurve3:nh,CubicBezierCurve:ah,CubicBezierCurve3:oh,EllipseCurve:Qc,LineCurve:lh,LineCurve3:ch,QuadraticBezierCurve:hh,QuadraticBezierCurve3:uh,SplineCurve:dh});class fh extends qc{constructor(){super(),this.type="CurvePath",this.curves=[],this.autoClose=!1}add(t){this.curves.push(t)}closePath(){const t=this.curves[0].getPoint(0),e=this.curves[this.curves.length-1].getPoint(1);t.equals(e)||this.curves.push(new lh(e,t))}getPoint(t,e){const n=t*this.getLength(),r=this.getCurveLengths();let i=0;for(;i<r.length;){if(r[i]>=n){const t=r[i]-n,s=this.curves[i],a=s.getLength(),o=0===a?0:1-t/a;return s.getPointAt(o,e)}i++}return null}getLength(){const t=this.getCurveLengths();return t[t.length-1]}updateArcLengths(){this.needsUpdate=!0,this.cacheLengths=null,this.getCurveLengths()}getCurveLengths(){if(this.cacheLengths&&this.cacheLengths.length===this.curves.length)return this.cacheLengths;const t=[];let e=0;for(let n=0,r=this.curves.length;n<r;n++)e+=this.curves[n].getLength(),t.push(e);return this.cacheLengths=t,t}getSpacedPoints(t=40){const e=[];for(let n=0;n<=t;n++)e.push(this.getPoint(n/t));return this.autoClose&&e.push(e[0]),e}getPoints(t=12){const e=[];let n;for(let r=0,i=this.curves;r<i.length;r++){const s=i[r],a=s&&s.isEllipseCurve?2*t:s&&(s.isLineCurve||s.isLineCurve3)?1:s&&s.isSplineCurve?t*s.points.length:t,o=s.getPoints(a);for(let t=0;t<o.length;t++){const r=o[t];n&&n.equals(r)||(e.push(r),n=r)}}return this.autoClose&&e.length>1&&!e[e.length-1].equals(e[0])&&e.push(e[0]),e}copy(t){super.copy(t),this.curves=[];for(let e=0,n=t.curves.length;e<n;e++){const n=t.curves[e];this.curves.push(n.clone())}return this.autoClose=t.autoClose,this}toJSON(){const t=super.toJSON();t.autoClose=this.autoClose,t.curves=[];for(let e=0,n=this.curves.length;e<n;e++){const n=this.curves[e];t.curves.push(n.toJSON())}return t}fromJSON(t){super.fromJSON(t),this.autoClose=t.autoClose,this.curves=[];for(let e=0,n=t.curves.length;e<n;e++){const n=t.curves[e];this.curves.push((new ph[n.type]).fromJSON(n))}return this}}class mh extends fh{constructor(t){super(),this.type="Path",this.currentPoint=new jn,t&&this.setFromPoints(t)}setFromPoints(t){this.moveTo(t[0].x,t[0].y);for(let e=1,n=t.length;e<n;e++)this.lineTo(t[e].x,t[e].y);return this}moveTo(t,e){return this.currentPoint.set(t,e),this}lineTo(t,e){const n=new lh(this.currentPoint.clone(),new jn(t,e));return this.curves.push(n),this.currentPoint.set(t,e),this}quadraticCurveTo(t,e,n,r){const i=new hh(this.currentPoint.clone(),new jn(t,e),new jn(n,r));return this.curves.push(i),this.currentPoint.set(n,r),this}bezierCurveTo(t,e,n,r,i,s){const a=new ah(this.currentPoint.clone(),new jn(t,e),new jn(n,r),new jn(i,s));return this.curves.push(a),this.currentPoint.set(i,s),this}splineThru(t){const e=[this.currentPoint.clone()].concat(t),n=new dh(e);return this.curves.push(n),this.currentPoint.copy(t[t.length-1]),this}arc(t,e,n,r,i,s){const a=this.currentPoint.x,o=this.currentPoint.y;return this.absarc(t+a,e+o,n,r,i,s),this}absarc(t,e,n,r,i,s){return this.absellipse(t,e,n,n,r,i,s),this}ellipse(t,e,n,r,i,s,a,o){const l=this.currentPoint.x,c=this.currentPoint.y;return this.absellipse(t+l,e+c,n,r,i,s,a,o),this}absellipse(t,e,n,r,i,s,a,o){const l=new Qc(t,e,n,r,i,s,a,o);if(this.curves.length>0){const t=l.getPoint(0);t.equals(this.currentPoint)||this.lineTo(t.x,t.y)}this.curves.push(l);const c=l.getPoint(1);return this.currentPoint.copy(c),this}copy(t){return super.copy(t),this.currentPoint.copy(t.currentPoint),this}toJSON(){const t=super.toJSON();return t.currentPoint=this.currentPoint.toArray(),t}fromJSON(t){return super.fromJSON(t),this.currentPoint.fromArray(t.currentPoint),this}}class gh extends mh{constructor(t){super(t),this.uuid=Bn(),this.type="Shape",this.holes=[]}getPointsHoles(t){const e=[];for(let n=0,r=this.holes.length;n<r;n++)e[n]=this.holes[n].getPoints(t);return e}extractPoints(t){return{shape:this.getPoints(t),holes:this.getPointsHoles(t)}}copy(t){super.copy(t),this.holes=[];for(let e=0,n=t.holes.length;e<n;e++){const n=t.holes[e];this.holes.push(n.clone())}return this}toJSON(){const t=super.toJSON();t.uuid=this.uuid,t.holes=[];for(let e=0,n=this.holes.length;e<n;e++){const n=this.holes[e];t.holes.push(n.toJSON())}return t}fromJSON(t){super.fromJSON(t),this.uuid=t.uuid,this.holes=[];for(let e=0,n=t.holes.length;e<n;e++){const n=t.holes[e];this.holes.push((new mh).fromJSON(n))}return this}}function vh(t,e,n,r,i){let s,a;if(i===function(t,e,n,r){let i=0;for(let s=e,a=n-r;s<n;s+=r)i+=(t[a]-t[s])*(t[s+1]+t[a+1]),a=s;return i}(t,e,n,r)>0)for(s=e;s<n;s+=r)a=Bh(s,t[s],t[s+1],a);else for(s=n-r;s>=e;s-=r)a=Bh(s,t[s],t[s+1],a);return a&&Fh(a,a.next)&&(zh(a),a=a.next),a}function xh(t,e){if(!t)return t;e||(e=t);let n,r=t;do{if(n=!1,r.steiner||!Fh(r,r.next)&&0!==Rh(r.prev,r,r.next))r=r.next;else{if(zh(r),r=e=r.prev,r===r.next)break;n=!0}}while(n||r!==e);return e}function yh(t,e,n,r,i,s,a){if(!t)return;!a&&s&&function(t,e,n,r){let i=t;do{null===i.z&&(i.z=Eh(i.x,i.y,e,n,r)),i.prevZ=i.prev,i.nextZ=i.next,i=i.next}while(i!==t);i.prevZ.nextZ=null,i.prevZ=null,function(t){let e,n,r,i,s,a,o,l,c=1;do{for(n=t,t=null,s=null,a=0;n;){for(a++,r=n,o=0,e=0;e<c&&(o++,r=r.nextZ,r);e++);for(l=c;o>0||l>0&&r;)0!==o&&(0===l||!r||n.z<=r.z)?(i=n,n=n.nextZ,o--):(i=r,r=r.nextZ,l--),s?s.nextZ=i:t=i,i.prevZ=s,s=i;n=r}s.nextZ=null,c*=2}while(a>1)}(i)}(t,r,i,s);let o,l,c=t;for(;t.prev!==t.next;)if(o=t.prev,l=t.next,s?bh(t,r,i,s):wh(t))e.push(o.i/n),e.push(t.i/n),e.push(l.i/n),zh(t),t=l.next,c=l.next;else if((t=l)===c){a?1===a?yh(t=_h(xh(t),e,n),e,n,r,i,s,2):2===a&&Mh(t,e,n,r,i,s):yh(xh(t),e,n,r,i,s,1);break}}function wh(t){const e=t.prev,n=t,r=t.next;if(Rh(e,n,r)>=0)return!1;let i=t.next.next;for(;i!==t.prev;){if(Ph(e.x,e.y,n.x,n.y,r.x,r.y,i.x,i.y)&&Rh(i.prev,i,i.next)>=0)return!1;i=i.next}return!0}function bh(t,e,n,r){const i=t.prev,s=t,a=t.next;if(Rh(i,s,a)>=0)return!1;const o=i.x<s.x?i.x<a.x?i.x:a.x:s.x<a.x?s.x:a.x,l=i.y<s.y?i.y<a.y?i.y:a.y:s.y<a.y?s.y:a.y,c=i.x>s.x?i.x>a.x?i.x:a.x:s.x>a.x?s.x:a.x,h=i.y>s.y?i.y>a.y?i.y:a.y:s.y>a.y?s.y:a.y,u=Eh(o,l,e,n,r),d=Eh(c,h,e,n,r);let p=t.prevZ,f=t.nextZ;for(;p&&p.z>=u&&f&&f.z<=d;){if(p!==t.prev&&p!==t.next&&Ph(i.x,i.y,s.x,s.y,a.x,a.y,p.x,p.y)&&Rh(p.prev,p,p.next)>=0)return!1;if(p=p.prevZ,f!==t.prev&&f!==t.next&&Ph(i.x,i.y,s.x,s.y,a.x,a.y,f.x,f.y)&&Rh(f.prev,f,f.next)>=0)return!1;f=f.nextZ}for(;p&&p.z>=u;){if(p!==t.prev&&p!==t.next&&Ph(i.x,i.y,s.x,s.y,a.x,a.y,p.x,p.y)&&Rh(p.prev,p,p.next)>=0)return!1;p=p.prevZ}for(;f&&f.z<=d;){if(f!==t.prev&&f!==t.next&&Ph(i.x,i.y,s.x,s.y,a.x,a.y,f.x,f.y)&&Rh(f.prev,f,f.next)>=0)return!1;f=f.nextZ}return!0}function _h(t,e,n){let r=t;do{const i=r.prev,s=r.next.next;!Fh(i,s)&&Dh(i,r,r.next,s)&&Nh(i,s)&&Nh(s,i)&&(e.push(i.i/n),e.push(r.i/n),e.push(s.i/n),zh(r),zh(r.next),r=t=s),r=r.next}while(r!==t);return xh(r)}function Mh(t,e,n,r,i,s){let a=t;do{let t=a.next.next;for(;t!==a.prev;){if(a.i!==t.i&&Lh(a,t)){let o=Oh(a,t);return a=xh(a,a.next),o=xh(o,o.next),yh(a,e,n,r,i,s),void yh(o,e,n,r,i,s)}t=t.next}a=a.next}while(a!==t)}function Th(t,e){return t.x-e.x}function Sh(t,e){if(e=function(t,e){let n=e;const r=t.x,i=t.y;let s,a=-1/0;do{if(i<=n.y&&i>=n.next.y&&n.next.y!==n.y){const t=n.x+(i-n.y)*(n.next.x-n.x)/(n.next.y-n.y);if(t<=r&&t>a){if(a=t,t===r){if(i===n.y)return n;if(i===n.next.y)return n.next}s=n.x<n.next.x?n:n.next}}n=n.next}while(n!==e);if(!s)return null;if(r===a)return s;const o=s,l=s.x,c=s.y;let h,u=1/0;n=s;do{r>=n.x&&n.x>=l&&r!==n.x&&Ph(i<c?r:a,i,l,c,i<c?a:r,i,n.x,n.y)&&(h=Math.abs(i-n.y)/(r-n.x),Nh(n,t)&&(h<u||h===u&&(n.x>s.x||n.x===s.x&&Ah(s,n)))&&(s=n,u=h)),n=n.next}while(n!==o);return s}(t,e),e){const n=Oh(e,t);xh(e,e.next),xh(n,n.next)}}function Ah(t,e){return Rh(t.prev,t,e.prev)<0&&Rh(e.next,t,t.next)<0}function Eh(t,e,n,r,i){return(t=1431655765&((t=858993459&((t=252645135&((t=16711935&((t=32767*(t-n)*i)|t<<8))|t<<4))|t<<2))|t<<1))|(e=1431655765&((e=858993459&((e=252645135&((e=16711935&((e=32767*(e-r)*i)|e<<8))|e<<4))|e<<2))|e<<1))<<1}function Ch(t){let e=t,n=t;do{(e.x<n.x||e.x===n.x&&e.y<n.y)&&(n=e),e=e.next}while(e!==t);return n}function Ph(t,e,n,r,i,s,a,o){return(i-a)*(e-o)-(t-a)*(s-o)>=0&&(t-a)*(r-o)-(n-a)*(e-o)>=0&&(n-a)*(s-o)-(i-a)*(r-o)>=0}function Lh(t,e){return t.next.i!==e.i&&t.prev.i!==e.i&&!function(t,e){let n=t;do{if(n.i!==t.i&&n.next.i!==t.i&&n.i!==e.i&&n.next.i!==e.i&&Dh(n,n.next,t,e))return!0;n=n.next}while(n!==t);return!1}(t,e)&&(Nh(t,e)&&Nh(e,t)&&function(t,e){let n=t,r=!1;const i=(t.x+e.x)/2,s=(t.y+e.y)/2;do{n.y>s!=n.next.y>s&&n.next.y!==n.y&&i<(n.next.x-n.x)*(s-n.y)/(n.next.y-n.y)+n.x&&(r=!r),n=n.next}while(n!==t);return r}(t,e)&&(Rh(t.prev,t,e.prev)||Rh(t,e.prev,e))||Fh(t,e)&&Rh(t.prev,t,t.next)>0&&Rh(e.prev,e,e.next)>0)}function Rh(t,e,n){return(e.y-t.y)*(n.x-e.x)-(e.x-t.x)*(n.y-e.y)}function Fh(t,e){return t.x===e.x&&t.y===e.y}function Dh(t,e,n,r){const i=Uh(Rh(t,e,n)),s=Uh(Rh(t,e,r)),a=Uh(Rh(n,r,t)),o=Uh(Rh(n,r,e));return i!==s&&a!==o||!(0!==i||!Ih(t,n,e))||!(0!==s||!Ih(t,r,e))||!(0!==a||!Ih(n,t,r))||!(0!==o||!Ih(n,e,r))}function Ih(t,e,n){return e.x<=Math.max(t.x,n.x)&&e.x>=Math.min(t.x,n.x)&&e.y<=Math.max(t.y,n.y)&&e.y>=Math.min(t.y,n.y)}function Uh(t){return t>0?1:t<0?-1:0}function Nh(t,e){return Rh(t.prev,t,t.next)<0?Rh(t,e,t.next)>=0&&Rh(t,t.prev,e)>=0:Rh(t,e,t.prev)<0||Rh(t,t.next,e)<0}function Oh(t,e){const n=new kh(t.i,t.x,t.y),r=new kh(e.i,e.x,e.y),i=t.next,s=e.prev;return t.next=e,e.prev=t,n.next=i,i.prev=n,r.next=n,n.prev=r,s.next=r,r.prev=s,r}function Bh(t,e,n,r){const i=new kh(t,e,n);return r?(i.next=r.next,i.prev=r,r.next.prev=i,r.next=i):(i.prev=i,i.next=i),i}function zh(t){t.next.prev=t.prev,t.prev.next=t.next,t.prevZ&&(t.prevZ.nextZ=t.nextZ),t.nextZ&&(t.nextZ.prevZ=t.prevZ)}function kh(t,e,n){this.i=t,this.x=e,this.y=n,this.prev=null,this.next=null,this.z=null,this.prevZ=null,this.nextZ=null,this.steiner=!1}class Hh{static area(t){const e=t.length;let n=0;for(let r=e-1,i=0;i<e;r=i++)n+=t[r].x*t[i].y-t[i].x*t[r].y;return.5*n}static isClockWise(t){return Hh.area(t)<0}static triangulateShape(t,e){const n=[],r=[],i=[];Gh(t),Vh(n,t);let s=t.length;e.forEach(Gh);for(let t=0;t<e.length;t++)r.push(s),s+=e[t].length,Vh(n,e[t]);const a=function(t,e,n=2){const r=e&&e.length,i=r?e[0]*n:t.length;let s=vh(t,0,i,n,!0);const a=[];if(!s||s.next===s.prev)return a;let o,l,c,h,u,d,p;if(r&&(s=function(t,e,n,r){const i=[];let s,a,o,l,c;for(s=0,a=e.length;s<a;s++)o=e[s]*r,l=s<a-1?e[s+1]*r:t.length,c=vh(t,o,l,r,!1),c===c.next&&(c.steiner=!0),i.push(Ch(c));for(i.sort(Th),s=0;s<i.length;s++)Sh(i[s],n),n=xh(n,n.next);return n}(t,e,s,n)),t.length>80*n){o=c=t[0],l=h=t[1];for(let e=n;e<i;e+=n)u=t[e],d=t[e+1],u<o&&(o=u),d<l&&(l=d),u>c&&(c=u),d>h&&(h=d);p=Math.max(c-o,h-l),p=0!==p?1/p:0}return yh(s,a,n,o,l,p),a}(n,r);for(let t=0;t<a.length;t+=3)i.push(a.slice(t,t+3));return i}}function Gh(t){const e=t.length;e>2&&t[e-1].equals(t[0])&&t.pop()}function Vh(t,e){for(let n=0;n<e.length;n++)t.push(e[n].x),t.push(e[n].y)}class Wh extends Ki{constructor(t=new gh([new jn(.5,.5),new jn(-.5,.5),new jn(-.5,-.5),new jn(.5,-.5)]),e={}){super(),this.type="ExtrudeGeometry",this.parameters={shapes:t,options:e},t=Array.isArray(t)?t:[t];const n=this,r=[],i=[];for(let e=0,n=t.length;e<n;e++)s(t[e]);function s(t){const s=[],a=void 0!==e.curveSegments?e.curveSegments:12,o=void 0!==e.steps?e.steps:1;let l=void 0!==e.depth?e.depth:1,c=void 0===e.bevelEnabled||e.bevelEnabled,h=void 0!==e.bevelThickness?e.bevelThickness:.2,u=void 0!==e.bevelSize?e.bevelSize:h-.1,d=void 0!==e.bevelOffset?e.bevelOffset:0,p=void 0!==e.bevelSegments?e.bevelSegments:3;const f=e.extrudePath,m=void 0!==e.UVGenerator?e.UVGenerator:Xh;void 0!==e.amount&&(console.warn("THREE.ExtrudeBufferGeometry: amount has been renamed to depth."),l=e.amount);let g,v,x,y,w,b=!1;f&&(g=f.getSpacedPoints(o),b=!0,c=!1,v=f.computeFrenetFrames(o,!1),x=new lr,y=new lr,w=new lr),c||(p=0,h=0,u=0,d=0);const _=t.extractPoints(a);let M=_.shape;const T=_.holes;if(!Hh.isClockWise(M)){M=M.reverse();for(let t=0,e=T.length;t<e;t++){const e=T[t];Hh.isClockWise(e)&&(T[t]=e.reverse())}}const S=Hh.triangulateShape(M,T),A=M;for(let t=0,e=T.length;t<e;t++){const e=T[t];M=M.concat(e)}function E(t,e,n){return e||console.error("THREE.ExtrudeGeometry: vec does not exist"),e.clone().multiplyScalar(n).add(t)}const C=M.length,P=S.length;function L(t,e,n){let r,i,s;const a=t.x-e.x,o=t.y-e.y,l=n.x-t.x,c=n.y-t.y,h=a*a+o*o,u=a*c-o*l;if(Math.abs(u)>Number.EPSILON){const u=Math.sqrt(h),d=Math.sqrt(l*l+c*c),p=e.x-o/u,f=e.y+a/u,m=((n.x-c/d-p)*c-(n.y+l/d-f)*l)/(a*c-o*l);r=p+a*m-t.x,i=f+o*m-t.y;const g=r*r+i*i;if(g<=2)return new jn(r,i);s=Math.sqrt(g/2)}else{let t=!1;a>Number.EPSILON?l>Number.EPSILON&&(t=!0):a<-Number.EPSILON?l<-Number.EPSILON&&(t=!0):Math.sign(o)===Math.sign(c)&&(t=!0),t?(r=-o,i=a,s=Math.sqrt(h)):(r=a,i=o,s=Math.sqrt(h/2))}return new jn(r/s,i/s)}const R=[];for(let t=0,e=A.length,n=e-1,r=t+1;t<e;t++,n++,r++)n===e&&(n=0),r===e&&(r=0),R[t]=L(A[t],A[n],A[r]);const F=[];let D,I=R.concat();for(let t=0,e=T.length;t<e;t++){const e=T[t];D=[];for(let t=0,n=e.length,r=n-1,i=t+1;t<n;t++,r++,i++)r===n&&(r=0),i===n&&(i=0),D[t]=L(e[t],e[r],e[i]);F.push(D),I=I.concat(D)}for(let t=0;t<p;t++){const e=t/p,n=h*Math.cos(e*Math.PI/2),r=u*Math.sin(e*Math.PI/2)+d;for(let t=0,e=A.length;t<e;t++){const e=E(A[t],R[t],r);O(e.x,e.y,-n)}for(let t=0,e=T.length;t<e;t++){const e=T[t];D=F[t];for(let t=0,i=e.length;t<i;t++){const i=E(e[t],D[t],r);O(i.x,i.y,-n)}}}const U=u+d;for(let t=0;t<C;t++){const e=c?E(M[t],I[t],U):M[t];b?(y.copy(v.normals[0]).multiplyScalar(e.x),x.copy(v.binormals[0]).multiplyScalar(e.y),w.copy(g[0]).add(y).add(x),O(w.x,w.y,w.z)):O(e.x,e.y,0)}for(let t=1;t<=o;t++)for(let e=0;e<C;e++){const n=c?E(M[e],I[e],U):M[e];b?(y.copy(v.normals[t]).multiplyScalar(n.x),x.copy(v.binormals[t]).multiplyScalar(n.y),w.copy(g[t]).add(y).add(x),O(w.x,w.y,w.z)):O(n.x,n.y,l/o*t)}for(let t=p-1;t>=0;t--){const e=t/p,n=h*Math.cos(e*Math.PI/2),r=u*Math.sin(e*Math.PI/2)+d;for(let t=0,e=A.length;t<e;t++){const e=E(A[t],R[t],r);O(e.x,e.y,l+n)}for(let t=0,e=T.length;t<e;t++){const e=T[t];D=F[t];for(let t=0,i=e.length;t<i;t++){const i=E(e[t],D[t],r);b?O(i.x,i.y+g[o-1].y,g[o-1].x+n):O(i.x,i.y,l+n)}}}function N(t,e){let n=t.length;for(;--n>=0;){const r=n;let i=n-1;i<0&&(i=t.length-1);for(let t=0,n=o+2*p;t<n;t++){const n=C*t,s=C*(t+1);z(e+r+n,e+i+n,e+i+s,e+r+s)}}}function O(t,e,n){s.push(t),s.push(e),s.push(n)}function B(t,e,i){k(t),k(e),k(i);const s=r.length/3,a=m.generateTopUV(n,r,s-3,s-2,s-1);H(a[0]),H(a[1]),H(a[2])}function z(t,e,i,s){k(t),k(e),k(s),k(e),k(i),k(s);const a=r.length/3,o=m.generateSideWallUV(n,r,a-6,a-3,a-2,a-1);H(o[0]),H(o[1]),H(o[3]),H(o[1]),H(o[2]),H(o[3])}function k(t){r.push(s[3*t+0]),r.push(s[3*t+1]),r.push(s[3*t+2])}function H(t){i.push(t.x),i.push(t.y)}!function(){const t=r.length/3;if(c){let t=0,e=C*t;for(let t=0;t<P;t++){const n=S[t];B(n[2]+e,n[1]+e,n[0]+e)}t=o+2*p,e=C*t;for(let t=0;t<P;t++){const n=S[t];B(n[0]+e,n[1]+e,n[2]+e)}}else{for(let t=0;t<P;t++){const e=S[t];B(e[2],e[1],e[0])}for(let t=0;t<P;t++){const e=S[t];B(e[0]+C*o,e[1]+C*o,e[2]+C*o)}}n.addGroup(t,r.length/3-t,0)}(),function(){const t=r.length/3;let e=0;N(A,e),e+=A.length;for(let t=0,n=T.length;t<n;t++){const n=T[t];N(n,e),e+=n.length}n.addGroup(t,r.length/3-t,1)}()}this.setAttribute("position",new Vi(r,3)),this.setAttribute("uv",new Vi(i,2)),this.computeVertexNormals()}toJSON(){const t=super.toJSON();return function(t,e,n){if(n.shapes=[],Array.isArray(t))for(let e=0,r=t.length;e<r;e++){const r=t[e];n.shapes.push(r.uuid)}else n.shapes.push(t.uuid);return void 0!==e.extrudePath&&(n.options.extrudePath=e.extrudePath.toJSON()),n}(this.parameters.shapes,this.parameters.options,t)}static fromJSON(t,e){const n=[];for(let r=0,i=t.shapes.length;r<i;r++){const i=e[t.shapes[r]];n.push(i)}const r=t.options.extrudePath;return void 0!==r&&(t.options.extrudePath=(new ph[r.type]).fromJSON(r)),new Wh(n,t.options)}}const Xh={generateTopUV:function(t,e,n,r,i){const s=e[3*n],a=e[3*n+1],o=e[3*r],l=e[3*r+1],c=e[3*i],h=e[3*i+1];return[new jn(s,a),new jn(o,l),new jn(c,h)]},generateSideWallUV:function(t,e,n,r,i,s){const a=e[3*n],o=e[3*n+1],l=e[3*n+2],c=e[3*r],h=e[3*r+1],u=e[3*r+2],d=e[3*i],p=e[3*i+1],f=e[3*i+2],m=e[3*s],g=e[3*s+1],v=e[3*s+2];return Math.abs(o-h)<Math.abs(a-c)?[new jn(a,1-l),new jn(c,1-u),new jn(d,1-f),new jn(m,1-v)]:[new jn(o,1-l),new jn(h,1-u),new jn(p,1-f),new jn(g,1-v)]}};class jh extends Hc{constructor(t=1,e=0){const n=(1+Math.sqrt(5))/2;super([-1,n,0,1,n,0,-1,-n,0,1,-n,0,0,-1,n,0,1,n,0,-1,-n,0,1,-n,n,0,-1,n,0,1,-n,0,-1,-n,0,1],[0,11,5,0,5,1,0,1,7,0,7,10,0,10,11,1,5,9,5,11,4,11,10,2,10,7,6,7,1,8,3,9,4,3,4,2,3,2,6,3,6,8,3,8,9,4,9,5,2,4,11,6,2,10,8,6,7,9,8,1],t,e),this.type="IcosahedronGeometry",this.parameters={radius:t,detail:e}}static fromJSON(t){return new jh(t.radius,t.detail)}}class Yh extends Ki{constructor(t=[new jn(0,.5),new jn(.5,0),new jn(0,-.5)],e=12,n=0,r=2*Math.PI){super(),this.type="LatheGeometry",this.parameters={points:t,segments:e,phiStart:n,phiLength:r},e=Math.floor(e),r=zn(r,0,2*Math.PI);const i=[],s=[],a=[],o=[],l=[],c=1/e,h=new lr,u=new jn,d=new lr,p=new lr,f=new lr;let m=0,g=0;for(let e=0;e<=t.length-1;e++)switch(e){case 0:m=t[e+1].x-t[e].x,g=t[e+1].y-t[e].y,d.x=1*g,d.y=-m,d.z=0*g,f.copy(d),d.normalize(),o.push(d.x,d.y,d.z);break;case t.length-1:o.push(f.x,f.y,f.z);break;default:m=t[e+1].x-t[e].x,g=t[e+1].y-t[e].y,d.x=1*g,d.y=-m,d.z=0*g,p.copy(d),d.x+=f.x,d.y+=f.y,d.z+=f.z,d.normalize(),o.push(d.x,d.y,d.z),f.copy(p)}for(let i=0;i<=e;i++){const d=n+i*c*r,p=Math.sin(d),f=Math.cos(d);for(let n=0;n<=t.length-1;n++){h.x=t[n].x*p,h.y=t[n].y,h.z=t[n].x*f,s.push(h.x,h.y,h.z),u.x=i/e,u.y=n/(t.length-1),a.push(u.x,u.y);const r=o[3*n+0]*p,c=o[3*n+1],d=o[3*n+0]*f;l.push(r,c,d)}}for(let n=0;n<e;n++)for(let e=0;e<t.length-1;e++){const r=e+n*t.length,s=r,a=r+t.length,o=r+t.length+1,l=r+1;i.push(s,a,l),i.push(a,o,l)}this.setIndex(i),this.setAttribute("position",new Vi(s,3)),this.setAttribute("uv",new Vi(a,2)),this.setAttribute("normal",new Vi(l,3))}static fromJSON(t){return new Yh(t.points,t.segments,t.phiStart,t.phiLength)}}class qh extends Hc{constructor(t=1,e=0){super([1,0,0,-1,0,0,0,1,0,0,-1,0,0,0,1,0,0,-1],[0,2,4,0,4,3,0,3,5,0,5,2,1,2,5,1,5,3,1,3,4,1,4,2],t,e),this.type="OctahedronGeometry",this.parameters={radius:t,detail:e}}static fromJSON(t){return new qh(t.radius,t.detail)}}class Qh extends Ki{constructor(t=.5,e=1,n=8,r=1,i=0,s=2*Math.PI){super(),this.type="RingGeometry",this.parameters={innerRadius:t,outerRadius:e,thetaSegments:n,phiSegments:r,thetaStart:i,thetaLength:s},n=Math.max(3,n);const a=[],o=[],l=[],c=[];let h=t;const u=(e-t)/(r=Math.max(1,r)),d=new lr,p=new jn;for(let t=0;t<=r;t++){for(let t=0;t<=n;t++){const r=i+t/n*s;d.x=h*Math.cos(r),d.y=h*Math.sin(r),o.push(d.x,d.y,d.z),l.push(0,0,1),p.x=(d.x/e+1)/2,p.y=(d.y/e+1)/2,c.push(p.x,p.y)}h+=u}for(let t=0;t<r;t++){const e=t*(n+1);for(let t=0;t<n;t++){const r=t+e,i=r,s=r+n+1,o=r+n+2,l=r+1;a.push(i,s,l),a.push(s,o,l)}}this.setIndex(a),this.setAttribute("position",new Vi(o,3)),this.setAttribute("normal",new Vi(l,3)),this.setAttribute("uv",new Vi(c,2))}static fromJSON(t){return new Qh(t.innerRadius,t.outerRadius,t.thetaSegments,t.phiSegments,t.thetaStart,t.thetaLength)}}class Zh extends Ki{constructor(t=new gh([new jn(0,.5),new jn(-.5,-.5),new jn(.5,-.5)]),e=12){super(),this.type="ShapeGeometry",this.parameters={shapes:t,curveSegments:e};const n=[],r=[],i=[],s=[];let a=0,o=0;if(!1===Array.isArray(t))l(t);else for(let e=0;e<t.length;e++)l(t[e]),this.addGroup(a,o,e),a+=o,o=0;function l(t){const a=r.length/3,l=t.extractPoints(e);let c=l.shape;const h=l.holes;!1===Hh.isClockWise(c)&&(c=c.reverse());for(let t=0,e=h.length;t<e;t++){const e=h[t];!0===Hh.isClockWise(e)&&(h[t]=e.reverse())}const u=Hh.triangulateShape(c,h);for(let t=0,e=h.length;t<e;t++){const e=h[t];c=c.concat(e)}for(let t=0,e=c.length;t<e;t++){const e=c[t];r.push(e.x,e.y,0),i.push(0,0,1),s.push(e.x,e.y)}for(let t=0,e=u.length;t<e;t++){const e=u[t],r=e[0]+a,i=e[1]+a,s=e[2]+a;n.push(r,i,s),o+=3}}this.setIndex(n),this.setAttribute("position",new Vi(r,3)),this.setAttribute("normal",new Vi(i,3)),this.setAttribute("uv",new Vi(s,2))}toJSON(){const t=super.toJSON();return function(t,e){if(e.shapes=[],Array.isArray(t))for(let n=0,r=t.length;n<r;n++){const r=t[n];e.shapes.push(r.uuid)}else e.shapes.push(t.uuid);return e}(this.parameters.shapes,t)}static fromJSON(t,e){const n=[];for(let r=0,i=t.shapes.length;r<i;r++){const i=e[t.shapes[r]];n.push(i)}return new Zh(n,t.curveSegments)}}class Jh extends Ki{constructor(t=1,e=32,n=16,r=0,i=2*Math.PI,s=0,a=Math.PI){super(),this.type="SphereGeometry",this.parameters={radius:t,widthSegments:e,heightSegments:n,phiStart:r,phiLength:i,thetaStart:s,thetaLength:a},e=Math.max(3,Math.floor(e)),n=Math.max(2,Math.floor(n));const o=Math.min(s+a,Math.PI);let l=0;const c=[],h=new lr,u=new lr,d=[],p=[],f=[],m=[];for(let d=0;d<=n;d++){const g=[],v=d/n;let x=0;0==d&&0==s?x=.5/e:d==n&&o==Math.PI&&(x=-.5/e);for(let n=0;n<=e;n++){const o=n/e;h.x=-t*Math.cos(r+o*i)*Math.sin(s+v*a),h.y=t*Math.cos(s+v*a),h.z=t*Math.sin(r+o*i)*Math.sin(s+v*a),p.push(h.x,h.y,h.z),u.copy(h).normalize(),f.push(u.x,u.y,u.z),m.push(o+x,1-v),g.push(l++)}c.push(g)}for(let t=0;t<n;t++)for(let r=0;r<e;r++){const e=c[t][r+1],i=c[t][r],a=c[t+1][r],l=c[t+1][r+1];(0!==t||s>0)&&d.push(e,i,l),(t!==n-1||o<Math.PI)&&d.push(i,a,l)}this.setIndex(d),this.setAttribute("position",new Vi(p,3)),this.setAttribute("normal",new Vi(f,3)),this.setAttribute("uv",new Vi(m,2))}static fromJSON(t){return new Jh(t.radius,t.widthSegments,t.heightSegments,t.phiStart,t.phiLength,t.thetaStart,t.thetaLength)}}class Kh extends Hc{constructor(t=1,e=0){super([1,1,1,-1,-1,1,-1,1,-1,1,-1,-1],[2,1,0,0,3,2,1,3,0,2,3,1],t,e),this.type="TetrahedronGeometry",this.parameters={radius:t,detail:e}}static fromJSON(t){return new Kh(t.radius,t.detail)}}class $h extends Ki{constructor(t=1,e=.4,n=8,r=6,i=2*Math.PI){super(),this.type="TorusGeometry",this.parameters={radius:t,tube:e,radialSegments:n,tubularSegments:r,arc:i},n=Math.floor(n),r=Math.floor(r);const s=[],a=[],o=[],l=[],c=new lr,h=new lr,u=new lr;for(let s=0;s<=n;s++)for(let d=0;d<=r;d++){const p=d/r*i,f=s/n*Math.PI*2;h.x=(t+e*Math.cos(f))*Math.cos(p),h.y=(t+e*Math.cos(f))*Math.sin(p),h.z=e*Math.sin(f),a.push(h.x,h.y,h.z),c.x=t*Math.cos(p),c.y=t*Math.sin(p),u.subVectors(h,c).normalize(),o.push(u.x,u.y,u.z),l.push(d/r),l.push(s/n)}for(let t=1;t<=n;t++)for(let e=1;e<=r;e++){const n=(r+1)*t+e-1,i=(r+1)*(t-1)+e-1,a=(r+1)*(t-1)+e,o=(r+1)*t+e;s.push(n,i,o),s.push(i,a,o)}this.setIndex(s),this.setAttribute("position",new Vi(a,3)),this.setAttribute("normal",new Vi(o,3)),this.setAttribute("uv",new Vi(l,2))}static fromJSON(t){return new $h(t.radius,t.tube,t.radialSegments,t.tubularSegments,t.arc)}}class tu extends Ki{constructor(t=1,e=.4,n=64,r=8,i=2,s=3){super(),this.type="TorusKnotGeometry",this.parameters={radius:t,tube:e,tubularSegments:n,radialSegments:r,p:i,q:s},n=Math.floor(n),r=Math.floor(r);const a=[],o=[],l=[],c=[],h=new lr,u=new lr,d=new lr,p=new lr,f=new lr,m=new lr,g=new lr;for(let a=0;a<=n;++a){const x=a/n*i*Math.PI*2;v(x,i,s,t,d),v(x+.01,i,s,t,p),m.subVectors(p,d),g.addVectors(p,d),f.crossVectors(m,g),g.crossVectors(f,m),f.normalize(),g.normalize();for(let t=0;t<=r;++t){const i=t/r*Math.PI*2,s=-e*Math.cos(i),p=e*Math.sin(i);h.x=d.x+(s*g.x+p*f.x),h.y=d.y+(s*g.y+p*f.y),h.z=d.z+(s*g.z+p*f.z),o.push(h.x,h.y,h.z),u.subVectors(h,d).normalize(),l.push(u.x,u.y,u.z),c.push(a/n),c.push(t/r)}}for(let t=1;t<=n;t++)for(let e=1;e<=r;e++){const n=(r+1)*(t-1)+(e-1),i=(r+1)*t+(e-1),s=(r+1)*t+e,o=(r+1)*(t-1)+e;a.push(n,i,o),a.push(i,s,o)}function v(t,e,n,r,i){const s=Math.cos(t),a=Math.sin(t),o=n/e*t,l=Math.cos(o);i.x=r*(2+l)*.5*s,i.y=r*(2+l)*a*.5,i.z=r*Math.sin(o)*.5}this.setIndex(a),this.setAttribute("position",new Vi(o,3)),this.setAttribute("normal",new Vi(l,3)),this.setAttribute("uv",new Vi(c,2))}static fromJSON(t){return new tu(t.radius,t.tube,t.tubularSegments,t.radialSegments,t.p,t.q)}}class eu extends Ki{constructor(t=new uh(new lr(-1,-1,0),new lr(-1,1,0),new lr(1,1,0)),e=64,n=1,r=8,i=!1){super(),this.type="TubeGeometry",this.parameters={path:t,tubularSegments:e,radius:n,radialSegments:r,closed:i};const s=t.computeFrenetFrames(e,i);this.tangents=s.tangents,this.normals=s.normals,this.binormals=s.binormals;const a=new lr,o=new lr,l=new jn;let c=new lr;const h=[],u=[],d=[],p=[];function f(i){c=t.getPointAt(i/e,c);const l=s.normals[i],d=s.binormals[i];for(let t=0;t<=r;t++){const e=t/r*Math.PI*2,i=Math.sin(e),s=-Math.cos(e);o.x=s*l.x+i*d.x,o.y=s*l.y+i*d.y,o.z=s*l.z+i*d.z,o.normalize(),u.push(o.x,o.y,o.z),a.x=c.x+n*o.x,a.y=c.y+n*o.y,a.z=c.z+n*o.z,h.push(a.x,a.y,a.z)}}!function(){for(let t=0;t<e;t++)f(t);f(!1===i?e:0),function(){for(let t=0;t<=e;t++)for(let n=0;n<=r;n++)l.x=t/e,l.y=n/r,d.push(l.x,l.y)}(),function(){for(let t=1;t<=e;t++)for(let e=1;e<=r;e++){const n=(r+1)*(t-1)+(e-1),i=(r+1)*t+(e-1),s=(r+1)*t+e,a=(r+1)*(t-1)+e;p.push(n,i,a),p.push(i,s,a)}}()}(),this.setIndex(p),this.setAttribute("position",new Vi(h,3)),this.setAttribute("normal",new Vi(u,3)),this.setAttribute("uv",new Vi(d,2))}toJSON(){const t=super.toJSON();return t.path=this.parameters.path.toJSON(),t}static fromJSON(t){return new eu((new ph[t.path.type]).fromJSON(t.path),t.tubularSegments,t.radius,t.radialSegments,t.closed)}}class nu extends Ki{constructor(t=null){if(super(),this.type="WireframeGeometry",this.parameters={geometry:t},null!==t){const e=[],n=new Set,r=new lr,i=new lr;if(null!==t.index){const s=t.attributes.position,a=t.index;let o=t.groups;0===o.length&&(o=[{start:0,count:a.count,materialIndex:0}]);for(let t=0,l=o.length;t<l;++t){const l=o[t],c=l.start;for(let t=c,o=c+l.count;t<o;t+=3)for(let o=0;o<3;o++){const l=a.getX(t+o),c=a.getX(t+(o+1)%3);r.fromBufferAttribute(s,l),i.fromBufferAttribute(s,c),!0===ru(r,i,n)&&(e.push(r.x,r.y,r.z),e.push(i.x,i.y,i.z))}}}else{const s=t.attributes.position;for(let t=0,a=s.count/3;t<a;t++)for(let a=0;a<3;a++){const o=3*t+a,l=3*t+(a+1)%3;r.fromBufferAttribute(s,o),i.fromBufferAttribute(s,l),!0===ru(r,i,n)&&(e.push(r.x,r.y,r.z),e.push(i.x,i.y,i.z))}}this.setAttribute("position",new Vi(e,3))}}}function ru(t,e,n){const r=`${t.x},${t.y},${t.z}-${e.x},${e.y},${e.z}`,i=`${e.x},${e.y},${e.z}-${t.x},${t.y},${t.z}`;return!0!==n.has(r)&&!0!==n.has(i)&&(n.add(r,i),!0)}var iu=Object.freeze({__proto__:null,BoxGeometry:xs,BoxBufferGeometry:xs,CircleGeometry:Bc,CircleBufferGeometry:Bc,ConeGeometry:kc,ConeBufferGeometry:kc,CylinderGeometry:zc,CylinderBufferGeometry:zc,DodecahedronGeometry:Gc,DodecahedronBufferGeometry:Gc,EdgesGeometry:Yc,ExtrudeGeometry:Wh,ExtrudeBufferGeometry:Wh,IcosahedronGeometry:jh,IcosahedronBufferGeometry:jh,LatheGeometry:Yh,LatheBufferGeometry:Yh,OctahedronGeometry:qh,OctahedronBufferGeometry:qh,PlaneGeometry:Bs,PlaneBufferGeometry:Bs,PolyhedronGeometry:Hc,PolyhedronBufferGeometry:Hc,RingGeometry:Qh,RingBufferGeometry:Qh,ShapeGeometry:Zh,ShapeBufferGeometry:Zh,SphereGeometry:Jh,SphereBufferGeometry:Jh,TetrahedronGeometry:Kh,TetrahedronBufferGeometry:Kh,TorusGeometry:$h,TorusBufferGeometry:$h,TorusKnotGeometry:tu,TorusKnotBufferGeometry:tu,TubeGeometry:eu,TubeBufferGeometry:eu,WireframeGeometry:nu});class su extends Mi{constructor(t){super(),this.type="ShadowMaterial",this.color=new Li(0),this.transparent=!0,this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this}}su.prototype.isShadowMaterial=!0;class au extends Mi{constructor(t){super(),this.defines={STANDARD:""},this.type="MeshStandardMaterial",this.color=new Li(16777215),this.roughness=1,this.metalness=0,this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new Li(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=rn,this.normalScale=new jn(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.roughnessMap=null,this.metalnessMap=null,this.alphaMap=null,this.envMap=null,this.envMapIntensity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.flatShading=!1,this.setValues(t)}copy(t){return super.copy(t),this.defines={STANDARD:""},this.color.copy(t.color),this.roughness=t.roughness,this.metalness=t.metalness,this.map=t.map,this.lightMap=t.lightMap,this.lightMapIntensity=t.lightMapIntensity,this.aoMap=t.aoMap,this.aoMapIntensity=t.aoMapIntensity,this.emissive.copy(t.emissive),this.emissiveMap=t.emissiveMap,this.emissiveIntensity=t.emissiveIntensity,this.bumpMap=t.bumpMap,this.bumpScale=t.bumpScale,this.normalMap=t.normalMap,this.normalMapType=t.normalMapType,this.normalScale.copy(t.normalScale),this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this.roughnessMap=t.roughnessMap,this.metalnessMap=t.metalnessMap,this.alphaMap=t.alphaMap,this.envMap=t.envMap,this.envMapIntensity=t.envMapIntensity,this.refractionRatio=t.refractionRatio,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.wireframeLinecap=t.wireframeLinecap,this.wireframeLinejoin=t.wireframeLinejoin,this.flatShading=t.flatShading,this}}au.prototype.isMeshStandardMaterial=!0;class ou extends au{constructor(t){super(),this.defines={STANDARD:"",PHYSICAL:""},this.type="MeshPhysicalMaterial",this.clearcoatMap=null,this.clearcoatRoughness=0,this.clearcoatRoughnessMap=null,this.clearcoatNormalScale=new jn(1,1),this.clearcoatNormalMap=null,this.ior=1.5,Object.defineProperty(this,"reflectivity",{get:function(){return zn(2.5*(this.ior-1)/(this.ior+1),0,1)},set:function(t){this.ior=(1+.4*t)/(1-.4*t)}}),this.sheenColor=new Li(0),this.sheenColorMap=null,this.sheenRoughness=1,this.sheenRoughnessMap=null,this.transmissionMap=null,this.thickness=0,this.thicknessMap=null,this.attenuationDistance=0,this.attenuationColor=new Li(1,1,1),this.specularIntensity=1,this.specularIntensityMap=null,this.specularColor=new Li(1,1,1),this.specularColorMap=null,this._sheen=0,this._clearcoat=0,this._transmission=0,this.setValues(t)}get sheen(){return this._sheen}set sheen(t){this._sheen>0!=t>0&&this.version++,this._sheen=t}get clearcoat(){return this._clearcoat}set clearcoat(t){this._clearcoat>0!=t>0&&this.version++,this._clearcoat=t}get transmission(){return this._transmission}set transmission(t){this._transmission>0!=t>0&&this.version++,this._transmission=t}copy(t){return super.copy(t),this.defines={STANDARD:"",PHYSICAL:""},this.clearcoat=t.clearcoat,this.clearcoatMap=t.clearcoatMap,this.clearcoatRoughness=t.clearcoatRoughness,this.clearcoatRoughnessMap=t.clearcoatRoughnessMap,this.clearcoatNormalMap=t.clearcoatNormalMap,this.clearcoatNormalScale.copy(t.clearcoatNormalScale),this.ior=t.ior,this.sheen=t.sheen,this.sheenColor.copy(t.sheenColor),this.sheenColorMap=t.sheenColorMap,this.sheenRoughness=t.sheenRoughness,this.sheenRoughnessMap=t.sheenRoughnessMap,this.transmission=t.transmission,this.transmissionMap=t.transmissionMap,this.thickness=t.thickness,this.thicknessMap=t.thicknessMap,this.attenuationDistance=t.attenuationDistance,this.attenuationColor.copy(t.attenuationColor),this.specularIntensity=t.specularIntensity,this.specularIntensityMap=t.specularIntensityMap,this.specularColor.copy(t.specularColor),this.specularColorMap=t.specularColorMap,this}}ou.prototype.isMeshPhysicalMaterial=!0;class lu extends Mi{constructor(t){super(),this.type="MeshPhongMaterial",this.color=new Li(16777215),this.specular=new Li(1118481),this.shininess=30,this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new Li(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=rn,this.normalScale=new jn(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=$,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.flatShading=!1,this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.specular.copy(t.specular),this.shininess=t.shininess,this.map=t.map,this.lightMap=t.lightMap,this.lightMapIntensity=t.lightMapIntensity,this.aoMap=t.aoMap,this.aoMapIntensity=t.aoMapIntensity,this.emissive.copy(t.emissive),this.emissiveMap=t.emissiveMap,this.emissiveIntensity=t.emissiveIntensity,this.bumpMap=t.bumpMap,this.bumpScale=t.bumpScale,this.normalMap=t.normalMap,this.normalMapType=t.normalMapType,this.normalScale.copy(t.normalScale),this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this.specularMap=t.specularMap,this.alphaMap=t.alphaMap,this.envMap=t.envMap,this.combine=t.combine,this.reflectivity=t.reflectivity,this.refractionRatio=t.refractionRatio,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.wireframeLinecap=t.wireframeLinecap,this.wireframeLinejoin=t.wireframeLinejoin,this.flatShading=t.flatShading,this}}lu.prototype.isMeshPhongMaterial=!0;class cu extends Mi{constructor(t){super(),this.defines={TOON:""},this.type="MeshToonMaterial",this.color=new Li(16777215),this.map=null,this.gradientMap=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new Li(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=rn,this.normalScale=new jn(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.alphaMap=null,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.map=t.map,this.gradientMap=t.gradientMap,this.lightMap=t.lightMap,this.lightMapIntensity=t.lightMapIntensity,this.aoMap=t.aoMap,this.aoMapIntensity=t.aoMapIntensity,this.emissive.copy(t.emissive),this.emissiveMap=t.emissiveMap,this.emissiveIntensity=t.emissiveIntensity,this.bumpMap=t.bumpMap,this.bumpScale=t.bumpScale,this.normalMap=t.normalMap,this.normalMapType=t.normalMapType,this.normalScale.copy(t.normalScale),this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this.alphaMap=t.alphaMap,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.wireframeLinecap=t.wireframeLinecap,this.wireframeLinejoin=t.wireframeLinejoin,this}}cu.prototype.isMeshToonMaterial=!0;class hu extends Mi{constructor(t){super(),this.type="MeshNormalMaterial",this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=rn,this.normalScale=new jn(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.wireframe=!1,this.wireframeLinewidth=1,this.fog=!1,this.flatShading=!1,this.setValues(t)}copy(t){return super.copy(t),this.bumpMap=t.bumpMap,this.bumpScale=t.bumpScale,this.normalMap=t.normalMap,this.normalMapType=t.normalMapType,this.normalScale.copy(t.normalScale),this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.flatShading=t.flatShading,this}}hu.prototype.isMeshNormalMaterial=!0;class uu extends Mi{constructor(t){super(),this.type="MeshLambertMaterial",this.color=new Li(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new Li(0),this.emissiveIntensity=1,this.emissiveMap=null,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=$,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.map=t.map,this.lightMap=t.lightMap,this.lightMapIntensity=t.lightMapIntensity,this.aoMap=t.aoMap,this.aoMapIntensity=t.aoMapIntensity,this.emissive.copy(t.emissive),this.emissiveMap=t.emissiveMap,this.emissiveIntensity=t.emissiveIntensity,this.specularMap=t.specularMap,this.alphaMap=t.alphaMap,this.envMap=t.envMap,this.combine=t.combine,this.reflectivity=t.reflectivity,this.refractionRatio=t.refractionRatio,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.wireframeLinecap=t.wireframeLinecap,this.wireframeLinejoin=t.wireframeLinejoin,this}}uu.prototype.isMeshLambertMaterial=!0;class du extends Mi{constructor(t){super(),this.defines={MATCAP:""},this.type="MeshMatcapMaterial",this.color=new Li(16777215),this.matcap=null,this.map=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=rn,this.normalScale=new jn(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.alphaMap=null,this.flatShading=!1,this.setValues(t)}copy(t){return super.copy(t),this.defines={MATCAP:""},this.color.copy(t.color),this.matcap=t.matcap,this.map=t.map,this.bumpMap=t.bumpMap,this.bumpScale=t.bumpScale,this.normalMap=t.normalMap,this.normalMapType=t.normalMapType,this.normalScale.copy(t.normalScale),this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this.alphaMap=t.alphaMap,this.flatShading=t.flatShading,this}}du.prototype.isMeshMatcapMaterial=!0;class pu extends gc{constructor(t){super(),this.type="LineDashedMaterial",this.scale=1,this.dashSize=3,this.gapSize=1,this.setValues(t)}copy(t){return super.copy(t),this.scale=t.scale,this.dashSize=t.dashSize,this.gapSize=t.gapSize,this}}pu.prototype.isLineDashedMaterial=!0;var fu=Object.freeze({__proto__:null,ShadowMaterial:su,SpriteMaterial:Il,RawShaderMaterial:Qs,ShaderMaterial:_s,PointsMaterial:Ec,MeshPhysicalMaterial:ou,MeshStandardMaterial:au,MeshPhongMaterial:lu,MeshToonMaterial:cu,MeshNormalMaterial:hu,MeshLambertMaterial:uu,MeshDepthMaterial:pl,MeshDistanceMaterial:fl,MeshBasicMaterial:Ri,MeshMatcapMaterial:du,LineDashedMaterial:pu,LineBasicMaterial:gc,Material:Mi});const mu={arraySlice:function(t,e,n){return mu.isTypedArray(t)?new t.constructor(t.subarray(e,void 0!==n?n:t.length)):t.slice(e,n)},convertArray:function(t,e,n){return!t||!n&&t.constructor===e?t:"number"==typeof e.BYTES_PER_ELEMENT?new e(t):Array.prototype.slice.call(t)},isTypedArray:function(t){return ArrayBuffer.isView(t)&&!(t instanceof DataView)},getKeyframeOrder:function(t){const e=t.length,n=new Array(e);for(let t=0;t!==e;++t)n[t]=t;return n.sort((function(e,n){return t[e]-t[n]})),n},sortedArray:function(t,e,n){const r=t.length,i=new t.constructor(r);for(let s=0,a=0;a!==r;++s){const r=n[s]*e;for(let n=0;n!==e;++n)i[a++]=t[r+n]}return i},flattenJSON:function(t,e,n,r){let i=1,s=t[0];for(;void 0!==s&&void 0===s[r];)s=t[i++];if(void 0===s)return;let a=s[r];if(void 0!==a)if(Array.isArray(a))do{a=s[r],void 0!==a&&(e.push(s.time),n.push.apply(n,a)),s=t[i++]}while(void 0!==s);else if(void 0!==a.toArray)do{a=s[r],void 0!==a&&(e.push(s.time),a.toArray(n,n.length)),s=t[i++]}while(void 0!==s);else do{a=s[r],void 0!==a&&(e.push(s.time),n.push(a)),s=t[i++]}while(void 0!==s)},subclip:function(t,e,n,r,i=30){const s=t.clone();s.name=e;const a=[];for(let t=0;t<s.tracks.length;++t){const e=s.tracks[t],o=e.getValueSize(),l=[],c=[];for(let t=0;t<e.times.length;++t){const s=e.times[t]*i;if(!(s<n||s>=r)){l.push(e.times[t]);for(let n=0;n<o;++n)c.push(e.values[t*o+n])}}0!==l.length&&(e.times=mu.convertArray(l,e.times.constructor),e.values=mu.convertArray(c,e.values.constructor),a.push(e))}s.tracks=a;let o=1/0;for(let t=0;t<s.tracks.length;++t)o>s.tracks[t].times[0]&&(o=s.tracks[t].times[0]);for(let t=0;t<s.tracks.length;++t)s.tracks[t].shift(-1*o);return s.resetDuration(),s},makeClipAdditive:function(t,e=0,n=t,r=30){r<=0&&(r=30);const i=n.tracks.length,s=e/r;for(let e=0;e<i;++e){const r=n.tracks[e],i=r.ValueTypeName;if("bool"===i||"string"===i)continue;const a=t.tracks.find((function(t){return t.name===r.name&&t.ValueTypeName===i}));if(void 0===a)continue;let o=0;const l=r.getValueSize();r.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline&&(o=l/3);let c=0;const h=a.getValueSize();a.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline&&(c=h/3);const u=r.times.length-1;let d;if(s<=r.times[0]){const t=o,e=l-o;d=mu.arraySlice(r.values,t,e)}else if(s>=r.times[u]){const t=u*l+o,e=t+l-o;d=mu.arraySlice(r.values,t,e)}else{const t=r.createInterpolant(),e=o,n=l-o;t.evaluate(s),d=mu.arraySlice(t.resultBuffer,e,n)}"quaternion"===i&&(new or).fromArray(d).normalize().conjugate().toArray(d);const p=a.times.length;for(let t=0;t<p;++t){const e=t*h+c;if("quaternion"===i)or.multiplyQuaternionsFlat(a.values,e,d,0,a.values,e);else{const t=h-2*c;for(let n=0;n<t;++n)a.values[e+n]-=d[n]}}}return t.blendMode=Qe,t}};class gu{constructor(t,e,n,r){this.parameterPositions=t,this._cachedIndex=0,this.resultBuffer=void 0!==r?r:new e.constructor(n),this.sampleValues=e,this.valueSize=n,this.settings=null,this.DefaultSettings_={}}evaluate(t){const e=this.parameterPositions;let n=this._cachedIndex,r=e[n],i=e[n-1];t:{e:{let s;n:{r:if(!(t<r)){for(let s=n+2;;){if(void 0===r){if(t<i)break r;return n=e.length,this._cachedIndex=n,this.afterEnd_(n-1,t,i)}if(n===s)break;if(i=r,r=e[++n],t<r)break e}s=e.length;break n}if(t>=i)break t;{const a=e[1];t<a&&(n=2,i=a);for(let s=n-2;;){if(void 0===i)return this._cachedIndex=0,this.beforeStart_(0,t,r);if(n===s)break;if(r=i,i=e[--n-1],t>=i)break e}s=n,n=0}}for(;n<s;){const r=n+s>>>1;t<e[r]?s=r:n=r+1}if(r=e[n],i=e[n-1],void 0===i)return this._cachedIndex=0,this.beforeStart_(0,t,r);if(void 0===r)return n=e.length,this._cachedIndex=n,this.afterEnd_(n-1,i,t)}this._cachedIndex=n,this.intervalChanged_(n,i,r)}return this.interpolate_(n,i,t,r)}getSettings_(){return this.settings||this.DefaultSettings_}copySampleValue_(t){const e=this.resultBuffer,n=this.sampleValues,r=this.valueSize,i=t*r;for(let t=0;t!==r;++t)e[t]=n[i+t];return e}interpolate_(){throw new Error("call to abstract method")}intervalChanged_(){}}gu.prototype.beforeStart_=gu.prototype.copySampleValue_,gu.prototype.afterEnd_=gu.prototype.copySampleValue_;class vu extends gu{constructor(t,e,n,r){super(t,e,n,r),this._weightPrev=-0,this._offsetPrev=-0,this._weightNext=-0,this._offsetNext=-0,this.DefaultSettings_={endingStart:Xe,endingEnd:Xe}}intervalChanged_(t,e,n){const r=this.parameterPositions;let i=t-2,s=t+1,a=r[i],o=r[s];if(void 0===a)switch(this.getSettings_().endingStart){case je:i=t,a=2*e-n;break;case Ye:i=r.length-2,a=e+r[i]-r[i+1];break;default:i=t,a=n}if(void 0===o)switch(this.getSettings_().endingEnd){case je:s=t,o=2*n-e;break;case Ye:s=1,o=n+r[1]-r[0];break;default:s=t-1,o=e}const l=.5*(n-e),c=this.valueSize;this._weightPrev=l/(e-a),this._weightNext=l/(o-n),this._offsetPrev=i*c,this._offsetNext=s*c}interpolate_(t,e,n,r){const i=this.resultBuffer,s=this.sampleValues,a=this.valueSize,o=t*a,l=o-a,c=this._offsetPrev,h=this._offsetNext,u=this._weightPrev,d=this._weightNext,p=(n-e)/(r-e),f=p*p,m=f*p,g=-u*m+2*u*f-u*p,v=(1+u)*m+(-1.5-2*u)*f+(-.5+u)*p+1,x=(-1-d)*m+(1.5+d)*f+.5*p,y=d*m-d*f;for(let t=0;t!==a;++t)i[t]=g*s[c+t]+v*s[l+t]+x*s[o+t]+y*s[h+t];return i}}class xu extends gu{constructor(t,e,n,r){super(t,e,n,r)}interpolate_(t,e,n,r){const i=this.resultBuffer,s=this.sampleValues,a=this.valueSize,o=t*a,l=o-a,c=(n-e)/(r-e),h=1-c;for(let t=0;t!==a;++t)i[t]=s[l+t]*h+s[o+t]*c;return i}}class yu extends gu{constructor(t,e,n,r){super(t,e,n,r)}interpolate_(t){return this.copySampleValue_(t-1)}}class wu{constructor(t,e,n,r){if(void 0===t)throw new Error("THREE.KeyframeTrack: track name is undefined");if(void 0===e||0===e.length)throw new Error("THREE.KeyframeTrack: no keyframes in track named "+t);this.name=t,this.times=mu.convertArray(e,this.TimeBufferType),this.values=mu.convertArray(n,this.ValueBufferType),this.setInterpolation(r||this.DefaultInterpolation)}static toJSON(t){const e=t.constructor;let n;if(e.toJSON!==this.toJSON)n=e.toJSON(t);else{n={name:t.name,times:mu.convertArray(t.times,Array),values:mu.convertArray(t.values,Array)};const e=t.getInterpolation();e!==t.DefaultInterpolation&&(n.interpolation=e)}return n.type=t.ValueTypeName,n}InterpolantFactoryMethodDiscrete(t){return new yu(this.times,this.values,this.getValueSize(),t)}InterpolantFactoryMethodLinear(t){return new xu(this.times,this.values,this.getValueSize(),t)}InterpolantFactoryMethodSmooth(t){return new vu(this.times,this.values,this.getValueSize(),t)}setInterpolation(t){let e;switch(t){case Ge:e=this.InterpolantFactoryMethodDiscrete;break;case Ve:e=this.InterpolantFactoryMethodLinear;break;case We:e=this.InterpolantFactoryMethodSmooth}if(void 0===e){const e="unsupported interpolation for "+this.ValueTypeName+" keyframe track named "+this.name;if(void 0===this.createInterpolant){if(t===this.DefaultInterpolation)throw new Error(e);this.setInterpolation(this.DefaultInterpolation)}return console.warn("THREE.KeyframeTrack:",e),this}return this.createInterpolant=e,this}getInterpolation(){switch(this.createInterpolant){case this.InterpolantFactoryMethodDiscrete:return Ge;case this.InterpolantFactoryMethodLinear:return Ve;case this.InterpolantFactoryMethodSmooth:return We}}getValueSize(){return this.values.length/this.times.length}shift(t){if(0!==t){const e=this.times;for(let n=0,r=e.length;n!==r;++n)e[n]+=t}return this}scale(t){if(1!==t){const e=this.times;for(let n=0,r=e.length;n!==r;++n)e[n]*=t}return this}trim(t,e){const n=this.times,r=n.length;let i=0,s=r-1;for(;i!==r&&n[i]<t;)++i;for(;-1!==s&&n[s]>e;)--s;if(++s,0!==i||s!==r){i>=s&&(s=Math.max(s,1),i=s-1);const t=this.getValueSize();this.times=mu.arraySlice(n,i,s),this.values=mu.arraySlice(this.values,i*t,s*t)}return this}validate(){let t=!0;const e=this.getValueSize();e-Math.floor(e)!=0&&(console.error("THREE.KeyframeTrack: Invalid value size in track.",this),t=!1);const n=this.times,r=this.values,i=n.length;0===i&&(console.error("THREE.KeyframeTrack: Track is empty.",this),t=!1);let s=null;for(let e=0;e!==i;e++){const r=n[e];if("number"==typeof r&&isNaN(r)){console.error("THREE.KeyframeTrack: Time is not a valid number.",this,e,r),t=!1;break}if(null!==s&&s>r){console.error("THREE.KeyframeTrack: Out of order keys.",this,e,r,s),t=!1;break}s=r}if(void 0!==r&&mu.isTypedArray(r))for(let e=0,n=r.length;e!==n;++e){const n=r[e];if(isNaN(n)){console.error("THREE.KeyframeTrack: Value is not a valid number.",this,e,n),t=!1;break}}return t}optimize(){const t=mu.arraySlice(this.times),e=mu.arraySlice(this.values),n=this.getValueSize(),r=this.getInterpolation()===We,i=t.length-1;let s=1;for(let a=1;a<i;++a){let i=!1;const o=t[a];if(o!==t[a+1]&&(1!==a||o!==t[0]))if(r)i=!0;else{const t=a*n,r=t-n,s=t+n;for(let a=0;a!==n;++a){const n=e[t+a];if(n!==e[r+a]||n!==e[s+a]){i=!0;break}}}if(i){if(a!==s){t[s]=t[a];const r=a*n,i=s*n;for(let t=0;t!==n;++t)e[i+t]=e[r+t]}++s}}if(i>0){t[s]=t[i];for(let t=i*n,r=s*n,a=0;a!==n;++a)e[r+a]=e[t+a];++s}return s!==t.length?(this.times=mu.arraySlice(t,0,s),this.values=mu.arraySlice(e,0,s*n)):(this.times=t,this.values=e),this}clone(){const t=mu.arraySlice(this.times,0),e=mu.arraySlice(this.values,0),n=new(0,this.constructor)(this.name,t,e);return n.createInterpolant=this.createInterpolant,n}}wu.prototype.TimeBufferType=Float32Array,wu.prototype.ValueBufferType=Float32Array,wu.prototype.DefaultInterpolation=Ve;class bu extends wu{}bu.prototype.ValueTypeName="bool",bu.prototype.ValueBufferType=Array,bu.prototype.DefaultInterpolation=Ge,bu.prototype.InterpolantFactoryMethodLinear=void 0,bu.prototype.InterpolantFactoryMethodSmooth=void 0;class _u extends wu{}_u.prototype.ValueTypeName="color";class Mu extends wu{}Mu.prototype.ValueTypeName="number";class Tu extends gu{constructor(t,e,n,r){super(t,e,n,r)}interpolate_(t,e,n,r){const i=this.resultBuffer,s=this.sampleValues,a=this.valueSize,o=(n-e)/(r-e);let l=t*a;for(let t=l+a;l!==t;l+=4)or.slerpFlat(i,0,s,l-a,s,l,o);return i}}class Su extends wu{InterpolantFactoryMethodLinear(t){return new Tu(this.times,this.values,this.getValueSize(),t)}}Su.prototype.ValueTypeName="quaternion",Su.prototype.DefaultInterpolation=Ve,Su.prototype.InterpolantFactoryMethodSmooth=void 0;class Au extends wu{}Au.prototype.ValueTypeName="string",Au.prototype.ValueBufferType=Array,Au.prototype.DefaultInterpolation=Ge,Au.prototype.InterpolantFactoryMethodLinear=void 0,Au.prototype.InterpolantFactoryMethodSmooth=void 0;class Eu extends wu{}Eu.prototype.ValueTypeName="vector";class Cu{constructor(t,e=-1,n,r=qe){this.name=t,this.tracks=n,this.duration=e,this.blendMode=r,this.uuid=Bn(),this.duration<0&&this.resetDuration()}static parse(t){const e=[],n=t.tracks,r=1/(t.fps||1);for(let t=0,i=n.length;t!==i;++t)e.push(Pu(n[t]).scale(r));const i=new this(t.name,t.duration,e,t.blendMode);return i.uuid=t.uuid,i}static toJSON(t){const e=[],n=t.tracks,r={name:t.name,duration:t.duration,tracks:e,uuid:t.uuid,blendMode:t.blendMode};for(let t=0,r=n.length;t!==r;++t)e.push(wu.toJSON(n[t]));return r}static CreateFromMorphTargetSequence(t,e,n,r){const i=e.length,s=[];for(let t=0;t<i;t++){let a=[],o=[];a.push((t+i-1)%i,t,(t+1)%i),o.push(0,1,0);const l=mu.getKeyframeOrder(a);a=mu.sortedArray(a,1,l),o=mu.sortedArray(o,1,l),r||0!==a[0]||(a.push(i),o.push(o[0])),s.push(new Mu(".morphTargetInfluences["+e[t].name+"]",a,o).scale(1/n))}return new this(t,-1,s)}static findByName(t,e){let n=t;if(!Array.isArray(t)){const e=t;n=e.geometry&&e.geometry.animations||e.animations}for(let t=0;t<n.length;t++)if(n[t].name===e)return n[t];return null}static CreateClipsFromMorphTargetSequences(t,e,n){const r={},i=/^([\w-]*?)([\d]+)$/;for(let e=0,n=t.length;e<n;e++){const n=t[e],s=n.name.match(i);if(s&&s.length>1){const t=s[1];let e=r[t];e||(r[t]=e=[]),e.push(n)}}const s=[];for(const t in r)s.push(this.CreateFromMorphTargetSequence(t,r[t],e,n));return s}static parseAnimation(t,e){if(!t)return console.error("THREE.AnimationClip: No animation in JSONLoader data."),null;const n=function(t,e,n,r,i){if(0!==n.length){const s=[],a=[];mu.flattenJSON(n,s,a,r),0!==s.length&&i.push(new t(e,s,a))}},r=[],i=t.name||"default",s=t.fps||30,a=t.blendMode;let o=t.length||-1;const l=t.hierarchy||[];for(let t=0;t<l.length;t++){const i=l[t].keys;if(i&&0!==i.length)if(i[0].morphTargets){const t={};let e;for(e=0;e<i.length;e++)if(i[e].morphTargets)for(let n=0;n<i[e].morphTargets.length;n++)t[i[e].morphTargets[n]]=-1;for(const n in t){const t=[],s=[];for(let r=0;r!==i[e].morphTargets.length;++r){const r=i[e];t.push(r.time),s.push(r.morphTarget===n?1:0)}r.push(new Mu(".morphTargetInfluence["+n+"]",t,s))}o=t.length*(s||1)}else{const s=".bones["+e[t].name+"]";n(Eu,s+".position",i,"pos",r),n(Su,s+".quaternion",i,"rot",r),n(Eu,s+".scale",i,"scl",r)}}return 0===r.length?null:new this(i,o,r,a)}resetDuration(){let t=0;for(let e=0,n=this.tracks.length;e!==n;++e){const n=this.tracks[e];t=Math.max(t,n.times[n.times.length-1])}return this.duration=t,this}trim(){for(let t=0;t<this.tracks.length;t++)this.tracks[t].trim(0,this.duration);return this}validate(){let t=!0;for(let e=0;e<this.tracks.length;e++)t=t&&this.tracks[e].validate();return t}optimize(){for(let t=0;t<this.tracks.length;t++)this.tracks[t].optimize();return this}clone(){const t=[];for(let e=0;e<this.tracks.length;e++)t.push(this.tracks[e].clone());return new this.constructor(this.name,this.duration,t,this.blendMode)}toJSON(){return this.constructor.toJSON(this)}}function Pu(t){if(void 0===t.type)throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");const e=function(t){switch(t.toLowerCase()){case"scalar":case"double":case"float":case"number":case"integer":return Mu;case"vector":case"vector2":case"vector3":case"vector4":return Eu;case"color":return _u;case"quaternion":return Su;case"bool":case"boolean":return bu;case"string":return Au}throw new Error("THREE.KeyframeTrack: Unsupported typeName: "+t)}(t.type);if(void 0===t.times){const e=[],n=[];mu.flattenJSON(t.keys,e,n,"value"),t.times=e,t.values=n}return void 0!==e.parse?e.parse(t):new e(t.name,t.times,t.values,t.interpolation)}const Lu={enabled:!1,files:{},add:function(t,e){!1!==this.enabled&&(this.files[t]=e)},get:function(t){if(!1!==this.enabled)return this.files[t]},remove:function(t){delete this.files[t]},clear:function(){this.files={}}};class Ru{constructor(t,e,n){const r=this;let i,s=!1,a=0,o=0;const l=[];this.onStart=void 0,this.onLoad=t,this.onProgress=e,this.onError=n,this.itemStart=function(t){o++,!1===s&&void 0!==r.onStart&&r.onStart(t,a,o),s=!0},this.itemEnd=function(t){a++,void 0!==r.onProgress&&r.onProgress(t,a,o),a===o&&(s=!1,void 0!==r.onLoad&&r.onLoad())},this.itemError=function(t){void 0!==r.onError&&r.onError(t)},this.resolveURL=function(t){return i?i(t):t},this.setURLModifier=function(t){return i=t,this},this.addHandler=function(t,e){return l.push(t,e),this},this.removeHandler=function(t){const e=l.indexOf(t);return-1!==e&&l.splice(e,2),this},this.getHandler=function(t){for(let e=0,n=l.length;e<n;e+=2){const n=l[e],r=l[e+1];if(n.global&&(n.lastIndex=0),n.test(t))return r}return null}}}const Fu=new Ru;class Du{constructor(t){this.manager=void 0!==t?t:Fu,this.crossOrigin="anonymous",this.withCredentials=!1,this.path="",this.resourcePath="",this.requestHeader={}}load(){}loadAsync(t,e){const n=this;return new Promise((function(r,i){n.load(t,r,e,i)}))}parse(){}setCrossOrigin(t){return this.crossOrigin=t,this}setWithCredentials(t){return this.withCredentials=t,this}setPath(t){return this.path=t,this}setResourcePath(t){return this.resourcePath=t,this}setRequestHeader(t){return this.requestHeader=t,this}}const Iu={};class Uu extends Du{constructor(t){super(t)}load(t,e,n,r){void 0===t&&(t=""),void 0!==this.path&&(t=this.path+t),t=this.manager.resolveURL(t);const i=Lu.get(t);if(void 0!==i)return this.manager.itemStart(t),setTimeout((()=>{e&&e(i),this.manager.itemEnd(t)}),0),i;if(void 0!==Iu[t])return void Iu[t].push({onLoad:e,onProgress:n,onError:r});Iu[t]=[],Iu[t].push({onLoad:e,onProgress:n,onError:r});const s=new Request(t,{headers:new Headers(this.requestHeader),credentials:this.withCredentials?"include":"same-origin"});fetch(s).then((e=>{if(200===e.status||0===e.status){if(0===e.status&&console.warn("THREE.FileLoader: HTTP Status 0 received."),"undefined"==typeof ReadableStream||void 0===e.body.getReader)return e;const n=Iu[t],r=e.body.getReader(),i=e.headers.get("Content-Length"),s=i?parseInt(i):0,a=0!==s;let o=0;const l=new ReadableStream({start(t){!function e(){r.read().then((({done:r,value:i})=>{if(r)t.close();else{o+=i.byteLength;const r=new ProgressEvent("progress",{lengthComputable:a,loaded:o,total:s});for(let t=0,e=n.length;t<e;t++){const e=n[t];e.onProgress&&e.onProgress(r)}t.enqueue(i),e()}}))}()}});return new Response(l)}throw Error(`fetch for "${e.url}" responded with ${e.status}: ${e.statusText}`)})).then((t=>{switch(this.responseType){case"arraybuffer":return t.arrayBuffer();case"blob":return t.blob();case"document":return t.text().then((t=>(new DOMParser).parseFromString(t,this.mimeType)));case"json":return t.json();default:return t.text()}})).then((e=>{Lu.add(t,e);const n=Iu[t];delete Iu[t];for(let t=0,r=n.length;t<r;t++){const r=n[t];r.onLoad&&r.onLoad(e)}})).catch((e=>{const n=Iu[t];if(void 0===n)throw this.manager.itemError(t),e;delete Iu[t];for(let t=0,r=n.length;t<r;t++){const r=n[t];r.onError&&r.onError(e)}this.manager.itemError(t)})).finally((()=>{this.manager.itemEnd(t)})),this.manager.itemStart(t)}setResponseType(t){return this.responseType=t,this}setMimeType(t){return this.mimeType=t,this}}class Nu extends Du{constructor(t){super(t)}load(t,e,n,r){const i=this,s=new Uu(this.manager);s.setPath(this.path),s.setRequestHeader(this.requestHeader),s.setWithCredentials(this.withCredentials),s.load(t,(function(n){try{e(i.parse(JSON.parse(n)))}catch(e){r?r(e):console.error(e),i.manager.itemError(t)}}),n,r)}parse(t){const e=[];for(let n=0;n<t.length;n++){const r=Cu.parse(t[n]);e.push(r)}return e}}class Ou extends Du{constructor(t){super(t)}load(t,e,n,r){const i=this,s=[],a=new Nc,o=new Uu(this.manager);o.setPath(this.path),o.setResponseType("arraybuffer"),o.setRequestHeader(this.requestHeader),o.setWithCredentials(i.withCredentials);let l=0;function c(c){o.load(t[c],(function(t){const n=i.parse(t,!0);s[c]={width:n.width,height:n.height,format:n.format,mipmaps:n.mipmaps},l+=1,6===l&&(1===n.mipmapCount&&(a.minFilter=Mt),a.image=s,a.format=n.format,a.needsUpdate=!0,e&&e(a))}),n,r)}if(Array.isArray(t))for(let e=0,n=t.length;e<n;++e)c(e);else o.load(t,(function(t){const n=i.parse(t,!0);if(n.isCubemap){const t=n.mipmaps.length/n.mipmapCount;for(let e=0;e<t;e++){s[e]={mipmaps:[]};for(let t=0;t<n.mipmapCount;t++)s[e].mipmaps.push(n.mipmaps[e*n.mipmapCount+t]),s[e].format=n.format,s[e].width=n.width,s[e].height=n.height}a.image=s}else a.image.width=n.width,a.image.height=n.height,a.mipmaps=n.mipmaps;1===n.mipmapCount&&(a.minFilter=Mt),a.format=n.format,a.needsUpdate=!0,e&&e(a)}),n,r);return a}}class Bu extends Du{constructor(t){super(t)}load(t,e,n,r){void 0!==this.path&&(t=this.path+t),t=this.manager.resolveURL(t);const i=this,s=Lu.get(t);if(void 0!==s)return i.manager.itemStart(t),setTimeout((function(){e&&e(s),i.manager.itemEnd(t)}),0),s;const a=Jn("img");function o(){c(),Lu.add(t,this),e&&e(this),i.manager.itemEnd(t)}function l(e){c(),r&&r(e),i.manager.itemError(t),i.manager.itemEnd(t)}function c(){a.removeEventListener("load",o,!1),a.removeEventListener("error",l,!1)}return a.addEventListener("load",o,!1),a.addEventListener("error",l,!1),"data:"!==t.substr(0,5)&&void 0!==this.crossOrigin&&(a.crossOrigin=this.crossOrigin),i.manager.itemStart(t),a.src=t,a}}class zu extends Du{constructor(t){super(t)}load(t,e,n,r){const i=new Es,s=new Bu(this.manager);s.setCrossOrigin(this.crossOrigin),s.setPath(this.path);let a=0;function o(n){s.load(t[n],(function(t){i.images[n]=t,a++,6===a&&(i.needsUpdate=!0,e&&e(i))}),void 0,r)}for(let e=0;e<t.length;++e)o(e);return i}}class ku extends Du{constructor(t){super(t)}load(t,e,n,r){const i=this,s=new ac,a=new Uu(this.manager);return a.setResponseType("arraybuffer"),a.setRequestHeader(this.requestHeader),a.setPath(this.path),a.setWithCredentials(i.withCredentials),a.load(t,(function(t){const n=i.parse(t);n&&(void 0!==n.image?s.image=n.image:void 0!==n.data&&(s.image.width=n.width,s.image.height=n.height,s.image.data=n.data),s.wrapS=void 0!==n.wrapS?n.wrapS:gt,s.wrapT=void 0!==n.wrapT?n.wrapT:gt,s.magFilter=void 0!==n.magFilter?n.magFilter:Mt,s.minFilter=void 0!==n.minFilter?n.minFilter:Mt,s.anisotropy=void 0!==n.anisotropy?n.anisotropy:1,void 0!==n.encoding&&(s.encoding=n.encoding),void 0!==n.flipY&&(s.flipY=n.flipY),void 0!==n.format&&(s.format=n.format),void 0!==n.type&&(s.type=n.type),void 0!==n.mipmaps&&(s.mipmaps=n.mipmaps,s.minFilter=At),1===n.mipmapCount&&(s.minFilter=Mt),void 0!==n.generateMipmaps&&(s.generateMipmaps=n.generateMipmaps),s.needsUpdate=!0,e&&e(s,n))}),n,r),s}}class Hu extends Du{constructor(t){super(t)}load(t,e,n,r){const i=new er,s=new Bu(this.manager);return s.setCrossOrigin(this.crossOrigin),s.setPath(this.path),s.load(t,(function(t){i.image=t,i.needsUpdate=!0,void 0!==e&&e(i)}),n,r),i}}class Gu extends hi{constructor(t,e=1){super(),this.type="Light",this.color=new Li(t),this.intensity=e}dispose(){}copy(t){return super.copy(t),this.color.copy(t.color),this.intensity=t.intensity,this}toJSON(t){const e=super.toJSON(t);return e.object.color=this.color.getHex(),e.object.intensity=this.intensity,void 0!==this.groundColor&&(e.object.groundColor=this.groundColor.getHex()),void 0!==this.distance&&(e.object.distance=this.distance),void 0!==this.angle&&(e.object.angle=this.angle),void 0!==this.decay&&(e.object.decay=this.decay),void 0!==this.penumbra&&(e.object.penumbra=this.penumbra),void 0!==this.shadow&&(e.object.shadow=this.shadow.toJSON()),e}}Gu.prototype.isLight=!0;class Vu extends Gu{constructor(t,e,n){super(t,n),this.type="HemisphereLight",this.position.copy(hi.DefaultUp),this.updateMatrix(),this.groundColor=new Li(e)}copy(t){return Gu.prototype.copy.call(this,t),this.groundColor.copy(t.groundColor),this}}Vu.prototype.isHemisphereLight=!0;const Wu=new zr,Xu=new lr,ju=new lr;class Yu{constructor(t){this.camera=t,this.bias=0,this.normalBias=0,this.radius=1,this.blurSamples=8,this.mapSize=new jn(512,512),this.map=null,this.mapPass=null,this.matrix=new zr,this.autoUpdate=!0,this.needsUpdate=!1,this._frustum=new Us,this._frameExtents=new jn(1,1),this._viewportCount=1,this._viewports=[new rr(0,0,1,1)]}getViewportCount(){return this._viewportCount}getFrustum(){return this._frustum}updateMatrices(t){const e=this.camera,n=this.matrix;Xu.setFromMatrixPosition(t.matrixWorld),e.position.copy(Xu),ju.setFromMatrixPosition(t.target.matrixWorld),e.lookAt(ju),e.updateMatrixWorld(),Wu.multiplyMatrices(e.projectionMatrix,e.matrixWorldInverse),this._frustum.setFromProjectionMatrix(Wu),n.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),n.multiply(e.projectionMatrix),n.multiply(e.matrixWorldInverse)}getViewport(t){return this._viewports[t]}getFrameExtents(){return this._frameExtents}dispose(){this.map&&this.map.dispose(),this.mapPass&&this.mapPass.dispose()}copy(t){return this.camera=t.camera.clone(),this.bias=t.bias,this.radius=t.radius,this.mapSize.copy(t.mapSize),this}clone(){return(new this.constructor).copy(this)}toJSON(){const t={};return 0!==this.bias&&(t.bias=this.bias),0!==this.normalBias&&(t.normalBias=this.normalBias),1!==this.radius&&(t.radius=this.radius),512===this.mapSize.x&&512===this.mapSize.y||(t.mapSize=this.mapSize.toArray()),t.camera=this.camera.toJSON(!1).object,delete t.camera.matrix,t}}class qu extends Yu{constructor(){super(new Ts(50,1,.5,500)),this.focus=1}updateMatrices(t){const e=this.camera,n=2*On*t.angle*this.focus,r=this.mapSize.width/this.mapSize.height,i=t.distance||e.far;n===e.fov&&r===e.aspect&&i===e.far||(e.fov=n,e.aspect=r,e.far=i,e.updateProjectionMatrix()),super.updateMatrices(t)}copy(t){return super.copy(t),this.focus=t.focus,this}}qu.prototype.isSpotLightShadow=!0;class Qu extends Gu{constructor(t,e,n=0,r=Math.PI/3,i=0,s=1){super(t,e),this.type="SpotLight",this.position.copy(hi.DefaultUp),this.updateMatrix(),this.target=new hi,this.distance=n,this.angle=r,this.penumbra=i,this.decay=s,this.shadow=new qu}get power(){return this.intensity*Math.PI}set power(t){this.intensity=t/Math.PI}dispose(){this.shadow.dispose()}copy(t){return super.copy(t),this.distance=t.distance,this.angle=t.angle,this.penumbra=t.penumbra,this.decay=t.decay,this.target=t.target.clone(),this.shadow=t.shadow.clone(),this}}Qu.prototype.isSpotLight=!0;const Zu=new zr,Ju=new lr,Ku=new lr;class $u extends Yu{constructor(){super(new Ts(90,1,.5,500)),this._frameExtents=new jn(4,2),this._viewportCount=6,this._viewports=[new rr(2,1,1,1),new rr(0,1,1,1),new rr(3,1,1,1),new rr(1,1,1,1),new rr(3,0,1,1),new rr(1,0,1,1)],this._cubeDirections=[new lr(1,0,0),new lr(-1,0,0),new lr(0,0,1),new lr(0,0,-1),new lr(0,1,0),new lr(0,-1,0)],this._cubeUps=[new lr(0,1,0),new lr(0,1,0),new lr(0,1,0),new lr(0,1,0),new lr(0,0,1),new lr(0,0,-1)]}updateMatrices(t,e=0){const n=this.camera,r=this.matrix,i=t.distance||n.far;i!==n.far&&(n.far=i,n.updateProjectionMatrix()),Ju.setFromMatrixPosition(t.matrixWorld),n.position.copy(Ju),Ku.copy(n.position),Ku.add(this._cubeDirections[e]),n.up.copy(this._cubeUps[e]),n.lookAt(Ku),n.updateMatrixWorld(),r.makeTranslation(-Ju.x,-Ju.y,-Ju.z),Zu.multiplyMatrices(n.projectionMatrix,n.matrixWorldInverse),this._frustum.setFromProjectionMatrix(Zu)}}$u.prototype.isPointLightShadow=!0;class td extends Gu{constructor(t,e,n=0,r=1){super(t,e),this.type="PointLight",this.distance=n,this.decay=r,this.shadow=new $u}get power(){return 4*this.intensity*Math.PI}set power(t){this.intensity=t/(4*Math.PI)}dispose(){this.shadow.dispose()}copy(t){return super.copy(t),this.distance=t.distance,this.decay=t.decay,this.shadow=t.shadow.clone(),this}}td.prototype.isPointLight=!0;class ed extends Yu{constructor(){super(new qs(-5,5,5,-5,.5,500))}}ed.prototype.isDirectionalLightShadow=!0;class nd extends Gu{constructor(t,e){super(t,e),this.type="DirectionalLight",this.position.copy(hi.DefaultUp),this.updateMatrix(),this.target=new hi,this.shadow=new ed}dispose(){this.shadow.dispose()}copy(t){return super.copy(t),this.target=t.target.clone(),this.shadow=t.shadow.clone(),this}}nd.prototype.isDirectionalLight=!0;class rd extends Gu{constructor(t,e){super(t,e),this.type="AmbientLight"}}rd.prototype.isAmbientLight=!0;class id extends Gu{constructor(t,e,n=10,r=10){super(t,e),this.type="RectAreaLight",this.width=n,this.height=r}get power(){return this.intensity*this.width*this.height*Math.PI}set power(t){this.intensity=t/(this.width*this.height*Math.PI)}copy(t){return super.copy(t),this.width=t.width,this.height=t.height,this}toJSON(t){const e=super.toJSON(t);return e.object.width=this.width,e.object.height=this.height,e}}id.prototype.isRectAreaLight=!0;class sd{constructor(){this.coefficients=[];for(let t=0;t<9;t++)this.coefficients.push(new lr)}set(t){for(let e=0;e<9;e++)this.coefficients[e].copy(t[e]);return this}zero(){for(let t=0;t<9;t++)this.coefficients[t].set(0,0,0);return this}getAt(t,e){const n=t.x,r=t.y,i=t.z,s=this.coefficients;return e.copy(s[0]).multiplyScalar(.282095),e.addScaledVector(s[1],.488603*r),e.addScaledVector(s[2],.488603*i),e.addScaledVector(s[3],.488603*n),e.addScaledVector(s[4],n*r*1.092548),e.addScaledVector(s[5],r*i*1.092548),e.addScaledVector(s[6],.315392*(3*i*i-1)),e.addScaledVector(s[7],n*i*1.092548),e.addScaledVector(s[8],.546274*(n*n-r*r)),e}getIrradianceAt(t,e){const n=t.x,r=t.y,i=t.z,s=this.coefficients;return e.copy(s[0]).multiplyScalar(.886227),e.addScaledVector(s[1],1.023328*r),e.addScaledVector(s[2],1.023328*i),e.addScaledVector(s[3],1.023328*n),e.addScaledVector(s[4],.858086*n*r),e.addScaledVector(s[5],.858086*r*i),e.addScaledVector(s[6],.743125*i*i-.247708),e.addScaledVector(s[7],.858086*n*i),e.addScaledVector(s[8],.429043*(n*n-r*r)),e}add(t){for(let e=0;e<9;e++)this.coefficients[e].add(t.coefficients[e]);return this}addScaledSH(t,e){for(let n=0;n<9;n++)this.coefficients[n].addScaledVector(t.coefficients[n],e);return this}scale(t){for(let e=0;e<9;e++)this.coefficients[e].multiplyScalar(t);return this}lerp(t,e){for(let n=0;n<9;n++)this.coefficients[n].lerp(t.coefficients[n],e);return this}equals(t){for(let e=0;e<9;e++)if(!this.coefficients[e].equals(t.coefficients[e]))return!1;return!0}copy(t){return this.set(t.coefficients)}clone(){return(new this.constructor).copy(this)}fromArray(t,e=0){const n=this.coefficients;for(let r=0;r<9;r++)n[r].fromArray(t,e+3*r);return this}toArray(t=[],e=0){const n=this.coefficients;for(let r=0;r<9;r++)n[r].toArray(t,e+3*r);return t}static getBasisAt(t,e){const n=t.x,r=t.y,i=t.z;e[0]=.282095,e[1]=.488603*r,e[2]=.488603*i,e[3]=.488603*n,e[4]=1.092548*n*r,e[5]=1.092548*r*i,e[6]=.315392*(3*i*i-1),e[7]=1.092548*n*i,e[8]=.546274*(n*n-r*r)}}sd.prototype.isSphericalHarmonics3=!0;class ad extends Gu{constructor(t=new sd,e=1){super(void 0,e),this.sh=t}copy(t){return super.copy(t),this.sh.copy(t.sh),this}fromJSON(t){return this.intensity=t.intensity,this.sh.fromArray(t.sh),this}toJSON(t){const e=super.toJSON(t);return e.object.sh=this.sh.toArray(),e}}ad.prototype.isLightProbe=!0;class od extends Du{constructor(t){super(t),this.textures={}}load(t,e,n,r){const i=this,s=new Uu(i.manager);s.setPath(i.path),s.setRequestHeader(i.requestHeader),s.setWithCredentials(i.withCredentials),s.load(t,(function(n){try{e(i.parse(JSON.parse(n)))}catch(e){r?r(e):console.error(e),i.manager.itemError(t)}}),n,r)}parse(t){const e=this.textures;function n(t){return void 0===e[t]&&console.warn("THREE.MaterialLoader: Undefined texture",t),e[t]}const r=new fu[t.type];if(void 0!==t.uuid&&(r.uuid=t.uuid),void 0!==t.name&&(r.name=t.name),void 0!==t.color&&void 0!==r.color&&r.color.setHex(t.color),void 0!==t.roughness&&(r.roughness=t.roughness),void 0!==t.metalness&&(r.metalness=t.metalness),void 0!==t.sheen&&(r.sheen=t.sheen),void 0!==t.sheenColor&&(r.sheenColor=(new Li).setHex(t.sheenColor)),void 0!==t.sheenRoughness&&(r.sheenRoughness=t.sheenRoughness),void 0!==t.emissive&&void 0!==r.emissive&&r.emissive.setHex(t.emissive),void 0!==t.specular&&void 0!==r.specular&&r.specular.setHex(t.specular),void 0!==t.specularIntensity&&(r.specularIntensity=t.specularIntensity),void 0!==t.specularColor&&void 0!==r.specularColor&&r.specularColor.setHex(t.specularColor),void 0!==t.shininess&&(r.shininess=t.shininess),void 0!==t.clearcoat&&(r.clearcoat=t.clearcoat),void 0!==t.clearcoatRoughness&&(r.clearcoatRoughness=t.clearcoatRoughness),void 0!==t.transmission&&(r.transmission=t.transmission),void 0!==t.thickness&&(r.thickness=t.thickness),void 0!==t.attenuationDistance&&(r.attenuationDistance=t.attenuationDistance),void 0!==t.attenuationColor&&void 0!==r.attenuationColor&&r.attenuationColor.setHex(t.attenuationColor),void 0!==t.fog&&(r.fog=t.fog),void 0!==t.flatShading&&(r.flatShading=t.flatShading),void 0!==t.blending&&(r.blending=t.blending),void 0!==t.combine&&(r.combine=t.combine),void 0!==t.side&&(r.side=t.side),void 0!==t.shadowSide&&(r.shadowSide=t.shadowSide),void 0!==t.opacity&&(r.opacity=t.opacity),void 0!==t.format&&(r.format=t.format),void 0!==t.transparent&&(r.transparent=t.transparent),void 0!==t.alphaTest&&(r.alphaTest=t.alphaTest),void 0!==t.depthTest&&(r.depthTest=t.depthTest),void 0!==t.depthWrite&&(r.depthWrite=t.depthWrite),void 0!==t.colorWrite&&(r.colorWrite=t.colorWrite),void 0!==t.stencilWrite&&(r.stencilWrite=t.stencilWrite),void 0!==t.stencilWriteMask&&(r.stencilWriteMask=t.stencilWriteMask),void 0!==t.stencilFunc&&(r.stencilFunc=t.stencilFunc),void 0!==t.stencilRef&&(r.stencilRef=t.stencilRef),void 0!==t.stencilFuncMask&&(r.stencilFuncMask=t.stencilFuncMask),void 0!==t.stencilFail&&(r.stencilFail=t.stencilFail),void 0!==t.stencilZFail&&(r.stencilZFail=t.stencilZFail),void 0!==t.stencilZPass&&(r.stencilZPass=t.stencilZPass),void 0!==t.wireframe&&(r.wireframe=t.wireframe),void 0!==t.wireframeLinewidth&&(r.wireframeLinewidth=t.wireframeLinewidth),void 0!==t.wireframeLinecap&&(r.wireframeLinecap=t.wireframeLinecap),void 0!==t.wireframeLinejoin&&(r.wireframeLinejoin=t.wireframeLinejoin),void 0!==t.rotation&&(r.rotation=t.rotation),1!==t.linewidth&&(r.linewidth=t.linewidth),void 0!==t.dashSize&&(r.dashSize=t.dashSize),void 0!==t.gapSize&&(r.gapSize=t.gapSize),void 0!==t.scale&&(r.scale=t.scale),void 0!==t.polygonOffset&&(r.polygonOffset=t.polygonOffset),void 0!==t.polygonOffsetFactor&&(r.polygonOffsetFactor=t.polygonOffsetFactor),void 0!==t.polygonOffsetUnits&&(r.polygonOffsetUnits=t.polygonOffsetUnits),void 0!==t.dithering&&(r.dithering=t.dithering),void 0!==t.alphaToCoverage&&(r.alphaToCoverage=t.alphaToCoverage),void 0!==t.premultipliedAlpha&&(r.premultipliedAlpha=t.premultipliedAlpha),void 0!==t.visible&&(r.visible=t.visible),void 0!==t.toneMapped&&(r.toneMapped=t.toneMapped),void 0!==t.userData&&(r.userData=t.userData),void 0!==t.vertexColors&&("number"==typeof t.vertexColors?r.vertexColors=t.vertexColors>0:r.vertexColors=t.vertexColors),void 0!==t.uniforms)for(const e in t.uniforms){const i=t.uniforms[e];switch(r.uniforms[e]={},i.type){case"t":r.uniforms[e].value=n(i.value);break;case"c":r.uniforms[e].value=(new Li).setHex(i.value);break;case"v2":r.uniforms[e].value=(new jn).fromArray(i.value);break;case"v3":r.uniforms[e].value=(new lr).fromArray(i.value);break;case"v4":r.uniforms[e].value=(new rr).fromArray(i.value);break;case"m3":r.uniforms[e].value=(new Yn).fromArray(i.value);break;case"m4":r.uniforms[e].value=(new zr).fromArray(i.value);break;default:r.uniforms[e].value=i.value}}if(void 0!==t.defines&&(r.defines=t.defines),void 0!==t.vertexShader&&(r.vertexShader=t.vertexShader),void 0!==t.fragmentShader&&(r.fragmentShader=t.fragmentShader),void 0!==t.extensions)for(const e in t.extensions)r.extensions[e]=t.extensions[e];if(void 0!==t.shading&&(r.flatShading=1===t.shading),void 0!==t.size&&(r.size=t.size),void 0!==t.sizeAttenuation&&(r.sizeAttenuation=t.sizeAttenuation),void 0!==t.map&&(r.map=n(t.map)),void 0!==t.matcap&&(r.matcap=n(t.matcap)),void 0!==t.alphaMap&&(r.alphaMap=n(t.alphaMap)),void 0!==t.bumpMap&&(r.bumpMap=n(t.bumpMap)),void 0!==t.bumpScale&&(r.bumpScale=t.bumpScale),void 0!==t.normalMap&&(r.normalMap=n(t.normalMap)),void 0!==t.normalMapType&&(r.normalMapType=t.normalMapType),void 0!==t.normalScale){let e=t.normalScale;!1===Array.isArray(e)&&(e=[e,e]),r.normalScale=(new jn).fromArray(e)}return void 0!==t.displacementMap&&(r.displacementMap=n(t.displacementMap)),void 0!==t.displacementScale&&(r.displacementScale=t.displacementScale),void 0!==t.displacementBias&&(r.displacementBias=t.displacementBias),void 0!==t.roughnessMap&&(r.roughnessMap=n(t.roughnessMap)),void 0!==t.metalnessMap&&(r.metalnessMap=n(t.metalnessMap)),void 0!==t.emissiveMap&&(r.emissiveMap=n(t.emissiveMap)),void 0!==t.emissiveIntensity&&(r.emissiveIntensity=t.emissiveIntensity),void 0!==t.specularMap&&(r.specularMap=n(t.specularMap)),void 0!==t.specularIntensityMap&&(r.specularIntensityMap=n(t.specularIntensityMap)),void 0!==t.specularColorMap&&(r.specularColorMap=n(t.specularColorMap)),void 0!==t.envMap&&(r.envMap=n(t.envMap)),void 0!==t.envMapIntensity&&(r.envMapIntensity=t.envMapIntensity),void 0!==t.reflectivity&&(r.reflectivity=t.reflectivity),void 0!==t.refractionRatio&&(r.refractionRatio=t.refractionRatio),void 0!==t.lightMap&&(r.lightMap=n(t.lightMap)),void 0!==t.lightMapIntensity&&(r.lightMapIntensity=t.lightMapIntensity),void 0!==t.aoMap&&(r.aoMap=n(t.aoMap)),void 0!==t.aoMapIntensity&&(r.aoMapIntensity=t.aoMapIntensity),void 0!==t.gradientMap&&(r.gradientMap=n(t.gradientMap)),void 0!==t.clearcoatMap&&(r.clearcoatMap=n(t.clearcoatMap)),void 0!==t.clearcoatRoughnessMap&&(r.clearcoatRoughnessMap=n(t.clearcoatRoughnessMap)),void 0!==t.clearcoatNormalMap&&(r.clearcoatNormalMap=n(t.clearcoatNormalMap)),void 0!==t.clearcoatNormalScale&&(r.clearcoatNormalScale=(new jn).fromArray(t.clearcoatNormalScale)),void 0!==t.transmissionMap&&(r.transmissionMap=n(t.transmissionMap)),void 0!==t.thicknessMap&&(r.thicknessMap=n(t.thicknessMap)),void 0!==t.sheenColorMap&&(r.sheenColorMap=n(t.sheenColorMap)),void 0!==t.sheenRoughnessMap&&(r.sheenRoughnessMap=n(t.sheenRoughnessMap)),r}setTextures(t){return this.textures=t,this}}class ld{static decodeText(t){if("undefined"!=typeof TextDecoder)return(new TextDecoder).decode(t);let e="";for(let n=0,r=t.length;n<r;n++)e+=String.fromCharCode(t[n]);try{return decodeURIComponent(escape(e))}catch(t){return e}}static extractUrlBase(t){const e=t.lastIndexOf("/");return-1===e?"./":t.substr(0,e+1)}static resolveURL(t,e){return"string"!=typeof t||""===t?"":(/^https?:\/\//i.test(e)&&/^\//.test(t)&&(e=e.replace(/(^https?:\/\/[^\/]+).*/i,"$1")),/^(https?:)?\/\//i.test(t)||/^data:.*,.*$/i.test(t)||/^blob:.*$/i.test(t)?t:e+t)}}class cd extends Ki{constructor(){super(),this.type="InstancedBufferGeometry",this.instanceCount=1/0}copy(t){return super.copy(t),this.instanceCount=t.instanceCount,this}clone(){return(new this.constructor).copy(this)}toJSON(){const t=super.toJSON(this);return t.instanceCount=this.instanceCount,t.isInstancedBufferGeometry=!0,t}}cd.prototype.isInstancedBufferGeometry=!0;class hd extends Du{constructor(t){super(t)}load(t,e,n,r){const i=this,s=new Uu(i.manager);s.setPath(i.path),s.setRequestHeader(i.requestHeader),s.setWithCredentials(i.withCredentials),s.load(t,(function(n){try{e(i.parse(JSON.parse(n)))}catch(e){r?r(e):console.error(e),i.manager.itemError(t)}}),n,r)}parse(t){const e={},n={};function r(t,r){if(void 0!==e[r])return e[r];const i=t.interleavedBuffers[r],s=function(t,e){if(void 0!==n[e])return n[e];const r=t.arrayBuffers[e],i=new Uint32Array(r).buffer;return n[e]=i,i}(t,i.buffer),a=Zn(i.type,s),o=new Rl(a,i.stride);return o.uuid=i.uuid,e[r]=o,o}const i=t.isInstancedBufferGeometry?new cd:new Ki,s=t.data.index;if(void 0!==s){const t=Zn(s.type,s.array);i.setIndex(new Ii(t,1))}const a=t.data.attributes;for(const e in a){const n=a[e];let s;if(n.isInterleavedBufferAttribute){const e=r(t.data,n.data);s=new Dl(e,n.itemSize,n.offset,n.normalized)}else{const t=Zn(n.type,n.array);s=new(n.isInstancedBufferAttribute?hc:Ii)(t,n.itemSize,n.normalized)}void 0!==n.name&&(s.name=n.name),void 0!==n.usage&&s.setUsage(n.usage),void 0!==n.updateRange&&(s.updateRange.offset=n.updateRange.offset,s.updateRange.count=n.updateRange.count),i.setAttribute(e,s)}const o=t.data.morphAttributes;if(o)for(const e in o){const n=o[e],s=[];for(let e=0,i=n.length;e<i;e++){const i=n[e];let a;if(i.isInterleavedBufferAttribute){const e=r(t.data,i.data);a=new Dl(e,i.itemSize,i.offset,i.normalized)}else{const t=Zn(i.type,i.array);a=new Ii(t,i.itemSize,i.normalized)}void 0!==i.name&&(a.name=i.name),s.push(a)}i.morphAttributes[e]=s}t.data.morphTargetsRelative&&(i.morphTargetsRelative=!0);const l=t.data.groups||t.data.drawcalls||t.data.offsets;if(void 0!==l)for(let t=0,e=l.length;t!==e;++t){const e=l[t];i.addGroup(e.start,e.count,e.materialIndex)}const c=t.data.boundingSphere;if(void 0!==c){const t=new lr;void 0!==c.center&&t.fromArray(c.center),i.boundingSphere=new Lr(t,c.radius)}return t.name&&(i.name=t.name),t.userData&&(i.userData=t.userData),i}}class ud extends Du{constructor(t){super(t)}load(t,e,n,r){const i=this,s=""===this.path?ld.extractUrlBase(t):this.path;this.resourcePath=this.resourcePath||s;const a=new Uu(this.manager);a.setPath(this.path),a.setRequestHeader(this.requestHeader),a.setWithCredentials(this.withCredentials),a.load(t,(function(n){let s=null;try{s=JSON.parse(n)}catch(e){return void 0!==r&&r(e),void console.error("THREE:ObjectLoader: Can't parse "+t+".",e.message)}const a=s.metadata;void 0!==a&&void 0!==a.type&&"geometry"!==a.type.toLowerCase()?i.parse(s,e):console.error("THREE.ObjectLoader: Can't load "+t)}),n,r)}async loadAsync(t,e){const n=""===this.path?ld.extractUrlBase(t):this.path;this.resourcePath=this.resourcePath||n;const r=new Uu(this.manager);r.setPath(this.path),r.setRequestHeader(this.requestHeader),r.setWithCredentials(this.withCredentials);const i=await r.loadAsync(t,e),s=JSON.parse(i),a=s.metadata;if(void 0===a||void 0===a.type||"geometry"===a.type.toLowerCase())throw new Error("THREE.ObjectLoader: Can't load "+t);return await this.parseAsync(s)}parse(t,e){const n=this.parseAnimations(t.animations),r=this.parseShapes(t.shapes),i=this.parseGeometries(t.geometries,r),s=this.parseImages(t.images,(function(){void 0!==e&&e(l)})),a=this.parseTextures(t.textures,s),o=this.parseMaterials(t.materials,a),l=this.parseObject(t.object,i,o,a,n),c=this.parseSkeletons(t.skeletons,l);if(this.bindSkeletons(l,c),void 0!==e){let t=!1;for(const e in s)if(s[e]instanceof HTMLImageElement){t=!0;break}!1===t&&e(l)}return l}async parseAsync(t){const e=this.parseAnimations(t.animations),n=this.parseShapes(t.shapes),r=this.parseGeometries(t.geometries,n),i=await this.parseImagesAsync(t.images),s=this.parseTextures(t.textures,i),a=this.parseMaterials(t.materials,s),o=this.parseObject(t.object,r,a,s,e),l=this.parseSkeletons(t.skeletons,o);return this.bindSkeletons(o,l),o}parseShapes(t){const e={};if(void 0!==t)for(let n=0,r=t.length;n<r;n++){const r=(new gh).fromJSON(t[n]);e[r.uuid]=r}return e}parseSkeletons(t,e){const n={},r={};if(e.traverse((function(t){t.isBone&&(r[t.uuid]=t)})),void 0!==t)for(let e=0,i=t.length;e<i;e++){const i=(new cc).fromJSON(t[e],r);n[i.uuid]=i}return n}parseGeometries(t,e){const n={};if(void 0!==t){const r=new hd;for(let i=0,s=t.length;i<s;i++){let s;const a=t[i];switch(a.type){case"BufferGeometry":case"InstancedBufferGeometry":s=r.parse(a);break;case"Geometry":console.error("THREE.ObjectLoader: The legacy Geometry type is no longer supported.");break;default:a.type in iu?s=iu[a.type].fromJSON(a,e):console.warn(`THREE.ObjectLoader: Unsupported geometry type "${a.type}"`)}s.uuid=a.uuid,void 0!==a.name&&(s.name=a.name),!0===s.isBufferGeometry&&void 0!==a.userData&&(s.userData=a.userData),n[a.uuid]=s}}return n}parseMaterials(t,e){const n={},r={};if(void 0!==t){const i=new od;i.setTextures(e);for(let e=0,s=t.length;e<s;e++){const s=t[e];if("MultiMaterial"===s.type){const t=[];for(let e=0;e<s.materials.length;e++){const r=s.materials[e];void 0===n[r.uuid]&&(n[r.uuid]=i.parse(r)),t.push(n[r.uuid])}r[s.uuid]=t}else void 0===n[s.uuid]&&(n[s.uuid]=i.parse(s)),r[s.uuid]=n[s.uuid]}}return r}parseAnimations(t){const e={};if(void 0!==t)for(let n=0;n<t.length;n++){const r=t[n],i=Cu.parse(r);e[i.uuid]=i}return e}parseImages(t,e){const n=this,r={};let i;function s(t){if("string"==typeof t){const e=t;return function(t){return n.manager.itemStart(t),i.load(t,(function(){n.manager.itemEnd(t)}),void 0,(function(){n.manager.itemError(t),n.manager.itemEnd(t)}))}(/^(\/\/)|([a-z]+:(\/\/)?)/i.test(e)?e:n.resourcePath+e)}return t.data?{data:Zn(t.type,t.data),width:t.width,height:t.height}:null}if(void 0!==t&&t.length>0){const n=new Ru(e);i=new Bu(n),i.setCrossOrigin(this.crossOrigin);for(let e=0,n=t.length;e<n;e++){const n=t[e],i=n.url;if(Array.isArray(i)){r[n.uuid]=[];for(let t=0,e=i.length;t<e;t++){const e=s(i[t]);null!==e&&(e instanceof HTMLImageElement?r[n.uuid].push(e):r[n.uuid].push(new ac(e.data,e.width,e.height)))}}else{const t=s(n.url);null!==t&&(r[n.uuid]=t)}}}return r}async parseImagesAsync(t){const e=this,n={};let r;async function i(t){if("string"==typeof t){const n=t,i=/^(\/\/)|([a-z]+:(\/\/)?)/i.test(n)?n:e.resourcePath+n;return await r.loadAsync(i)}return t.data?{data:Zn(t.type,t.data),width:t.width,height:t.height}:null}if(void 0!==t&&t.length>0){r=new Bu(this.manager),r.setCrossOrigin(this.crossOrigin);for(let e=0,r=t.length;e<r;e++){const r=t[e],s=r.url;if(Array.isArray(s)){n[r.uuid]=[];for(let t=0,e=s.length;t<e;t++){const e=s[t],a=await i(e);null!==a&&(a instanceof HTMLImageElement?n[r.uuid].push(a):n[r.uuid].push(new ac(a.data,a.width,a.height)))}}else{const t=await i(r.url);null!==t&&(n[r.uuid]=t)}}}return n}parseTextures(t,e){function n(t,e){return"number"==typeof t?t:(console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.",t),e[t])}const r={};if(void 0!==t)for(let i=0,s=t.length;i<s;i++){const s=t[i];let a;void 0===s.image&&console.warn('THREE.ObjectLoader: No "image" specified for',s.uuid),void 0===e[s.image]&&console.warn("THREE.ObjectLoader: Undefined image",s.image);const o=e[s.image];Array.isArray(o)?(a=new Es(o),6===o.length&&(a.needsUpdate=!0)):(a=o&&o.data?new ac(o.data,o.width,o.height):new er(o),o&&(a.needsUpdate=!0)),a.uuid=s.uuid,void 0!==s.name&&(a.name=s.name),void 0!==s.mapping&&(a.mapping=n(s.mapping,dd)),void 0!==s.offset&&a.offset.fromArray(s.offset),void 0!==s.repeat&&a.repeat.fromArray(s.repeat),void 0!==s.center&&a.center.fromArray(s.center),void 0!==s.rotation&&(a.rotation=s.rotation),void 0!==s.wrap&&(a.wrapS=n(s.wrap[0],pd),a.wrapT=n(s.wrap[1],pd)),void 0!==s.format&&(a.format=s.format),void 0!==s.type&&(a.type=s.type),void 0!==s.encoding&&(a.encoding=s.encoding),void 0!==s.minFilter&&(a.minFilter=n(s.minFilter,fd)),void 0!==s.magFilter&&(a.magFilter=n(s.magFilter,fd)),void 0!==s.anisotropy&&(a.anisotropy=s.anisotropy),void 0!==s.flipY&&(a.flipY=s.flipY),void 0!==s.premultiplyAlpha&&(a.premultiplyAlpha=s.premultiplyAlpha),void 0!==s.unpackAlignment&&(a.unpackAlignment=s.unpackAlignment),void 0!==s.userData&&(a.userData=s.userData),r[s.uuid]=a}return r}parseObject(t,e,n,r,i){let s,a,o;function l(t){return void 0===e[t]&&console.warn("THREE.ObjectLoader: Undefined geometry",t),e[t]}function c(t){if(void 0!==t){if(Array.isArray(t)){const e=[];for(let r=0,i=t.length;r<i;r++){const i=t[r];void 0===n[i]&&console.warn("THREE.ObjectLoader: Undefined material",i),e.push(n[i])}return e}return void 0===n[t]&&console.warn("THREE.ObjectLoader: Undefined material",t),n[t]}}function h(t){return void 0===r[t]&&console.warn("THREE.ObjectLoader: Undefined texture",t),r[t]}switch(t.type){case"Scene":s=new Ll,void 0!==t.background&&(Number.isInteger(t.background)?s.background=new Li(t.background):s.background=h(t.background)),void 0!==t.environment&&(s.environment=h(t.environment)),void 0!==t.fog&&("Fog"===t.fog.type?s.fog=new Pl(t.fog.color,t.fog.near,t.fog.far):"FogExp2"===t.fog.type&&(s.fog=new Cl(t.fog.color,t.fog.density)));break;case"PerspectiveCamera":s=new Ts(t.fov,t.aspect,t.near,t.far),void 0!==t.focus&&(s.focus=t.focus),void 0!==t.zoom&&(s.zoom=t.zoom),void 0!==t.filmGauge&&(s.filmGauge=t.filmGauge),void 0!==t.filmOffset&&(s.filmOffset=t.filmOffset),void 0!==t.view&&(s.view=Object.assign({},t.view));break;case"OrthographicCamera":s=new qs(t.left,t.right,t.top,t.bottom,t.near,t.far),void 0!==t.zoom&&(s.zoom=t.zoom),void 0!==t.view&&(s.view=Object.assign({},t.view));break;case"AmbientLight":s=new rd(t.color,t.intensity);break;case"DirectionalLight":s=new nd(t.color,t.intensity);break;case"PointLight":s=new td(t.color,t.intensity,t.distance,t.decay);break;case"RectAreaLight":s=new id(t.color,t.intensity,t.width,t.height);break;case"SpotLight":s=new Qu(t.color,t.intensity,t.distance,t.angle,t.penumbra,t.decay);break;case"HemisphereLight":s=new Vu(t.color,t.groundColor,t.intensity);break;case"LightProbe":s=(new ad).fromJSON(t);break;case"SkinnedMesh":a=l(t.geometry),o=c(t.material),s=new ic(a,o),void 0!==t.bindMode&&(s.bindMode=t.bindMode),void 0!==t.bindMatrix&&s.bindMatrix.fromArray(t.bindMatrix),void 0!==t.skeleton&&(s.skeleton=t.skeleton);break;case"Mesh":a=l(t.geometry),o=c(t.material),s=new gs(a,o);break;case"InstancedMesh":a=l(t.geometry),o=c(t.material);const e=t.count,n=t.instanceMatrix,r=t.instanceColor;s=new mc(a,o,e),s.instanceMatrix=new hc(new Float32Array(n.array),16),void 0!==r&&(s.instanceColor=new hc(new Float32Array(r.array),r.itemSize));break;case"LOD":s=new Kl;break;case"Line":s=new _c(l(t.geometry),c(t.material));break;case"LineLoop":s=new Ac(l(t.geometry),c(t.material));break;case"LineSegments":s=new Sc(l(t.geometry),c(t.material));break;case"PointCloud":case"Points":s=new Fc(l(t.geometry),c(t.material));break;case"Sprite":s=new ql(c(t.material));break;case"Group":s=new wl;break;case"Bone":s=new sc;break;default:s=new hi}if(s.uuid=t.uuid,void 0!==t.name&&(s.name=t.name),void 0!==t.matrix?(s.matrix.fromArray(t.matrix),void 0!==t.matrixAutoUpdate&&(s.matrixAutoUpdate=t.matrixAutoUpdate),s.matrixAutoUpdate&&s.matrix.decompose(s.position,s.quaternion,s.scale)):(void 0!==t.position&&s.position.fromArray(t.position),void 0!==t.rotation&&s.rotation.fromArray(t.rotation),void 0!==t.quaternion&&s.quaternion.fromArray(t.quaternion),void 0!==t.scale&&s.scale.fromArray(t.scale)),void 0!==t.castShadow&&(s.castShadow=t.castShadow),void 0!==t.receiveShadow&&(s.receiveShadow=t.receiveShadow),t.shadow&&(void 0!==t.shadow.bias&&(s.shadow.bias=t.shadow.bias),void 0!==t.shadow.normalBias&&(s.shadow.normalBias=t.shadow.normalBias),void 0!==t.shadow.radius&&(s.shadow.radius=t.shadow.radius),void 0!==t.shadow.mapSize&&s.shadow.mapSize.fromArray(t.shadow.mapSize),void 0!==t.shadow.camera&&(s.shadow.camera=this.parseObject(t.shadow.camera))),void 0!==t.visible&&(s.visible=t.visible),void 0!==t.frustumCulled&&(s.frustumCulled=t.frustumCulled),void 0!==t.renderOrder&&(s.renderOrder=t.renderOrder),void 0!==t.userData&&(s.userData=t.userData),void 0!==t.layers&&(s.layers.mask=t.layers),void 0!==t.children){const a=t.children;for(let t=0;t<a.length;t++)s.add(this.parseObject(a[t],e,n,r,i))}if(void 0!==t.animations){const e=t.animations;for(let t=0;t<e.length;t++){const n=e[t];s.animations.push(i[n])}}if("LOD"===t.type){void 0!==t.autoUpdate&&(s.autoUpdate=t.autoUpdate);const e=t.levels;for(let t=0;t<e.length;t++){const n=e[t],r=s.getObjectByProperty("uuid",n.object);void 0!==r&&s.addLevel(r,n.distance)}}return s}bindSkeletons(t,e){0!==Object.keys(e).length&&t.traverse((function(t){if(!0===t.isSkinnedMesh&&void 0!==t.skeleton){const n=e[t.skeleton];void 0===n?console.warn("THREE.ObjectLoader: No skeleton found with UUID:",t.skeleton):t.bind(n,t.bindMatrix)}}))}setTexturePath(t){return console.warn("THREE.ObjectLoader: .setTexturePath() has been renamed to .setResourcePath()."),this.setResourcePath(t)}}const dd={UVMapping:lt,CubeReflectionMapping:ct,CubeRefractionMapping:ht,EquirectangularReflectionMapping:ut,EquirectangularRefractionMapping:dt,CubeUVReflectionMapping:pt,CubeUVRefractionMapping:ft},pd={RepeatWrapping:mt,ClampToEdgeWrapping:gt,MirroredRepeatWrapping:vt},fd={NearestFilter:xt,NearestMipmapNearestFilter:yt,NearestMipmapLinearFilter:bt,LinearFilter:Mt,LinearMipmapNearestFilter:Tt,LinearMipmapLinearFilter:At};class md extends Du{constructor(t){super(t),"undefined"==typeof createImageBitmap&&console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."),"undefined"==typeof fetch&&console.warn("THREE.ImageBitmapLoader: fetch() not supported."),this.options={premultiplyAlpha:"none"}}setOptions(t){return this.options=t,this}load(t,e,n,r){void 0===t&&(t=""),void 0!==this.path&&(t=this.path+t),t=this.manager.resolveURL(t);const i=this,s=Lu.get(t);if(void 0!==s)return i.manager.itemStart(t),setTimeout((function(){e&&e(s),i.manager.itemEnd(t)}),0),s;const a={};a.credentials="anonymous"===this.crossOrigin?"same-origin":"include",a.headers=this.requestHeader,fetch(t,a).then((function(t){return t.blob()})).then((function(t){return createImageBitmap(t,Object.assign(i.options,{colorSpaceConversion:"none"}))})).then((function(n){Lu.add(t,n),e&&e(n),i.manager.itemEnd(t)})).catch((function(e){r&&r(e),i.manager.itemError(t),i.manager.itemEnd(t)})),i.manager.itemStart(t)}}let gd;md.prototype.isImageBitmapLoader=!0;const vd={getContext:function(){return void 0===gd&&(gd=new(window.AudioContext||window.webkitAudioContext)),gd},setContext:function(t){gd=t}};class xd extends Du{constructor(t){super(t)}load(t,e,n,r){const i=this,s=new Uu(this.manager);s.setResponseType("arraybuffer"),s.setPath(this.path),s.setRequestHeader(this.requestHeader),s.setWithCredentials(this.withCredentials),s.load(t,(function(n){try{const t=n.slice(0);vd.getContext().decodeAudioData(t,(function(t){e(t)}))}catch(e){r?r(e):console.error(e),i.manager.itemError(t)}}),n,r)}}class yd extends ad{constructor(t,e,n=1){super(void 0,n);const r=(new Li).set(t),i=(new Li).set(e),s=new lr(r.r,r.g,r.b),a=new lr(i.r,i.g,i.b),o=Math.sqrt(Math.PI),l=o*Math.sqrt(.75);this.sh.coefficients[0].copy(s).add(a).multiplyScalar(o),this.sh.coefficients[1].copy(s).sub(a).multiplyScalar(l)}}yd.prototype.isHemisphereLightProbe=!0;class wd extends ad{constructor(t,e=1){super(void 0,e);const n=(new Li).set(t);this.sh.coefficients[0].set(n.r,n.g,n.b).multiplyScalar(2*Math.sqrt(Math.PI))}}wd.prototype.isAmbientLightProbe=!0;const bd=new zr,_d=new zr,Md=new zr;class Td{constructor(){this.type="StereoCamera",this.aspect=1,this.eyeSep=.064,this.cameraL=new Ts,this.cameraL.layers.enable(1),this.cameraL.matrixAutoUpdate=!1,this.cameraR=new Ts,this.cameraR.layers.enable(2),this.cameraR.matrixAutoUpdate=!1,this._cache={focus:null,fov:null,aspect:null,near:null,far:null,zoom:null,eyeSep:null}}update(t){const e=this._cache;if(e.focus!==t.focus||e.fov!==t.fov||e.aspect!==t.aspect*this.aspect||e.near!==t.near||e.far!==t.far||e.zoom!==t.zoom||e.eyeSep!==this.eyeSep){e.focus=t.focus,e.fov=t.fov,e.aspect=t.aspect*this.aspect,e.near=t.near,e.far=t.far,e.zoom=t.zoom,e.eyeSep=this.eyeSep,Md.copy(t.projectionMatrix);const n=e.eyeSep/2,r=n*e.near/e.focus,i=e.near*Math.tan(Nn*e.fov*.5)/e.zoom;let s,a;_d.elements[12]=-n,bd.elements[12]=n,s=-i*e.aspect+r,a=i*e.aspect+r,Md.elements[0]=2*e.near/(a-s),Md.elements[8]=(a+s)/(a-s),this.cameraL.projectionMatrix.copy(Md),s=-i*e.aspect-r,a=i*e.aspect-r,Md.elements[0]=2*e.near/(a-s),Md.elements[8]=(a+s)/(a-s),this.cameraR.projectionMatrix.copy(Md)}this.cameraL.matrixWorld.copy(t.matrixWorld).multiply(_d),this.cameraR.matrixWorld.copy(t.matrixWorld).multiply(bd)}}class Sd{constructor(t=!0){this.autoStart=t,this.startTime=0,this.oldTime=0,this.elapsedTime=0,this.running=!1}start(){this.startTime=Ad(),this.oldTime=this.startTime,this.elapsedTime=0,this.running=!0}stop(){this.getElapsedTime(),this.running=!1,this.autoStart=!1}getElapsedTime(){return this.getDelta(),this.elapsedTime}getDelta(){let t=0;if(this.autoStart&&!this.running)return this.start(),0;if(this.running){const e=Ad();t=(e-this.oldTime)/1e3,this.oldTime=e,this.elapsedTime+=t}return t}}function Ad(){return("undefined"==typeof performance?Date:performance).now()}const Ed=new lr,Cd=new or,Pd=new lr,Ld=new lr;class Rd extends hi{constructor(){super(),this.type="AudioListener",this.context=vd.getContext(),this.gain=this.context.createGain(),this.gain.connect(this.context.destination),this.filter=null,this.timeDelta=0,this._clock=new Sd}getInput(){return this.gain}removeFilter(){return null!==this.filter&&(this.gain.disconnect(this.filter),this.filter.disconnect(this.context.destination),this.gain.connect(this.context.destination),this.filter=null),this}getFilter(){return this.filter}setFilter(t){return null!==this.filter?(this.gain.disconnect(this.filter),this.filter.disconnect(this.context.destination)):this.gain.disconnect(this.context.destination),this.filter=t,this.gain.connect(this.filter),this.filter.connect(this.context.destination),this}getMasterVolume(){return this.gain.gain.value}setMasterVolume(t){return this.gain.gain.setTargetAtTime(t,this.context.currentTime,.01),this}updateMatrixWorld(t){super.updateMatrixWorld(t);const e=this.context.listener,n=this.up;if(this.timeDelta=this._clock.getDelta(),this.matrixWorld.decompose(Ed,Cd,Pd),Ld.set(0,0,-1).applyQuaternion(Cd),e.positionX){const t=this.context.currentTime+this.timeDelta;e.positionX.linearRampToValueAtTime(Ed.x,t),e.positionY.linearRampToValueAtTime(Ed.y,t),e.positionZ.linearRampToValueAtTime(Ed.z,t),e.forwardX.linearRampToValueAtTime(Ld.x,t),e.forwardY.linearRampToValueAtTime(Ld.y,t),e.forwardZ.linearRampToValueAtTime(Ld.z,t),e.upX.linearRampToValueAtTime(n.x,t),e.upY.linearRampToValueAtTime(n.y,t),e.upZ.linearRampToValueAtTime(n.z,t)}else e.setPosition(Ed.x,Ed.y,Ed.z),e.setOrientation(Ld.x,Ld.y,Ld.z,n.x,n.y,n.z)}}class Fd extends hi{constructor(t){super(),this.type="Audio",this.listener=t,this.context=t.context,this.gain=this.context.createGain(),this.gain.connect(t.getInput()),this.autoplay=!1,this.buffer=null,this.detune=0,this.loop=!1,this.loopStart=0,this.loopEnd=0,this.offset=0,this.duration=void 0,this.playbackRate=1,this.isPlaying=!1,this.hasPlaybackControl=!0,this.source=null,this.sourceType="empty",this._startedAt=0,this._progress=0,this._connected=!1,this.filters=[]}getOutput(){return this.gain}setNodeSource(t){return this.hasPlaybackControl=!1,this.sourceType="audioNode",this.source=t,this.connect(),this}setMediaElementSource(t){return this.hasPlaybackControl=!1,this.sourceType="mediaNode",this.source=this.context.createMediaElementSource(t),this.connect(),this}setMediaStreamSource(t){return this.hasPlaybackControl=!1,this.sourceType="mediaStreamNode",this.source=this.context.createMediaStreamSource(t),this.connect(),this}setBuffer(t){return this.buffer=t,this.sourceType="buffer",this.autoplay&&this.play(),this}play(t=0){if(!0===this.isPlaying)return void console.warn("THREE.Audio: Audio is already playing.");if(!1===this.hasPlaybackControl)return void console.warn("THREE.Audio: this Audio has no playback control.");this._startedAt=this.context.currentTime+t;const e=this.context.createBufferSource();return e.buffer=this.buffer,e.loop=this.loop,e.loopStart=this.loopStart,e.loopEnd=this.loopEnd,e.onended=this.onEnded.bind(this),e.start(this._startedAt,this._progress+this.offset,this.duration),this.isPlaying=!0,this.source=e,this.setDetune(this.detune),this.setPlaybackRate(this.playbackRate),this.connect()}pause(){if(!1!==this.hasPlaybackControl)return!0===this.isPlaying&&(this._progress+=Math.max(this.context.currentTime-this._startedAt,0)*this.playbackRate,!0===this.loop&&(this._progress=this._progress%(this.duration||this.buffer.duration)),this.source.stop(),this.source.onended=null,this.isPlaying=!1),this;console.warn("THREE.Audio: this Audio has no playback control.")}stop(){if(!1!==this.hasPlaybackControl)return this._progress=0,this.source.stop(),this.source.onended=null,this.isPlaying=!1,this;console.warn("THREE.Audio: this Audio has no playback control.")}connect(){if(this.filters.length>0){this.source.connect(this.filters[0]);for(let t=1,e=this.filters.length;t<e;t++)this.filters[t-1].connect(this.filters[t]);this.filters[this.filters.length-1].connect(this.getOutput())}else this.source.connect(this.getOutput());return this._connected=!0,this}disconnect(){if(this.filters.length>0){this.source.disconnect(this.filters[0]);for(let t=1,e=this.filters.length;t<e;t++)this.filters[t-1].disconnect(this.filters[t]);this.filters[this.filters.length-1].disconnect(this.getOutput())}else this.source.disconnect(this.getOutput());return this._connected=!1,this}getFilters(){return this.filters}setFilters(t){return t||(t=[]),!0===this._connected?(this.disconnect(),this.filters=t.slice(),this.connect()):this.filters=t.slice(),this}setDetune(t){if(this.detune=t,void 0!==this.source.detune)return!0===this.isPlaying&&this.source.detune.setTargetAtTime(this.detune,this.context.currentTime,.01),this}getDetune(){return this.detune}getFilter(){return this.getFilters()[0]}setFilter(t){return this.setFilters(t?[t]:[])}setPlaybackRate(t){if(!1!==this.hasPlaybackControl)return this.playbackRate=t,!0===this.isPlaying&&this.source.playbackRate.setTargetAtTime(this.playbackRate,this.context.currentTime,.01),this;console.warn("THREE.Audio: this Audio has no playback control.")}getPlaybackRate(){return this.playbackRate}onEnded(){this.isPlaying=!1}getLoop(){return!1===this.hasPlaybackControl?(console.warn("THREE.Audio: this Audio has no playback control."),!1):this.loop}setLoop(t){if(!1!==this.hasPlaybackControl)return this.loop=t,!0===this.isPlaying&&(this.source.loop=this.loop),this;console.warn("THREE.Audio: this Audio has no playback control.")}setLoopStart(t){return this.loopStart=t,this}setLoopEnd(t){return this.loopEnd=t,this}getVolume(){return this.gain.gain.value}setVolume(t){return this.gain.gain.setTargetAtTime(t,this.context.currentTime,.01),this}}const Dd=new lr,Id=new or,Ud=new lr,Nd=new lr;class Od extends Fd{constructor(t){super(t),this.panner=this.context.createPanner(),this.panner.panningModel="HRTF",this.panner.connect(this.gain)}getOutput(){return this.panner}getRefDistance(){return this.panner.refDistance}setRefDistance(t){return this.panner.refDistance=t,this}getRolloffFactor(){return this.panner.rolloffFactor}setRolloffFactor(t){return this.panner.rolloffFactor=t,this}getDistanceModel(){return this.panner.distanceModel}setDistanceModel(t){return this.panner.distanceModel=t,this}getMaxDistance(){return this.panner.maxDistance}setMaxDistance(t){return this.panner.maxDistance=t,this}setDirectionalCone(t,e,n){return this.panner.coneInnerAngle=t,this.panner.coneOuterAngle=e,this.panner.coneOuterGain=n,this}updateMatrixWorld(t){if(super.updateMatrixWorld(t),!0===this.hasPlaybackControl&&!1===this.isPlaying)return;this.matrixWorld.decompose(Dd,Id,Ud),Nd.set(0,0,1).applyQuaternion(Id);const e=this.panner;if(e.positionX){const t=this.context.currentTime+this.listener.timeDelta;e.positionX.linearRampToValueAtTime(Dd.x,t),e.positionY.linearRampToValueAtTime(Dd.y,t),e.positionZ.linearRampToValueAtTime(Dd.z,t),e.orientationX.linearRampToValueAtTime(Nd.x,t),e.orientationY.linearRampToValueAtTime(Nd.y,t),e.orientationZ.linearRampToValueAtTime(Nd.z,t)}else e.setPosition(Dd.x,Dd.y,Dd.z),e.setOrientation(Nd.x,Nd.y,Nd.z)}}class Bd{constructor(t,e=2048){this.analyser=t.context.createAnalyser(),this.analyser.fftSize=e,this.data=new Uint8Array(this.analyser.frequencyBinCount),t.getOutput().connect(this.analyser)}getFrequencyData(){return this.analyser.getByteFrequencyData(this.data),this.data}getAverageFrequency(){let t=0;const e=this.getFrequencyData();for(let n=0;n<e.length;n++)t+=e[n];return t/e.length}}class zd{constructor(t,e,n){let r,i,s;switch(this.binding=t,this.valueSize=n,e){case"quaternion":r=this._slerp,i=this._slerpAdditive,s=this._setAdditiveIdentityQuaternion,this.buffer=new Float64Array(6*n),this._workIndex=5;break;case"string":case"bool":r=this._select,i=this._select,s=this._setAdditiveIdentityOther,this.buffer=new Array(5*n);break;default:r=this._lerp,i=this._lerpAdditive,s=this._setAdditiveIdentityNumeric,this.buffer=new Float64Array(5*n)}this._mixBufferRegion=r,this._mixBufferRegionAdditive=i,this._setIdentity=s,this._origIndex=3,this._addIndex=4,this.cumulativeWeight=0,this.cumulativeWeightAdditive=0,this.useCount=0,this.referenceCount=0}accumulate(t,e){const n=this.buffer,r=this.valueSize,i=t*r+r;let s=this.cumulativeWeight;if(0===s){for(let t=0;t!==r;++t)n[i+t]=n[t];s=e}else{s+=e;const t=e/s;this._mixBufferRegion(n,i,0,t,r)}this.cumulativeWeight=s}accumulateAdditive(t){const e=this.buffer,n=this.valueSize,r=n*this._addIndex;0===this.cumulativeWeightAdditive&&this._setIdentity(),this._mixBufferRegionAdditive(e,r,0,t,n),this.cumulativeWeightAdditive+=t}apply(t){const e=this.valueSize,n=this.buffer,r=t*e+e,i=this.cumulativeWeight,s=this.cumulativeWeightAdditive,a=this.binding;if(this.cumulativeWeight=0,this.cumulativeWeightAdditive=0,i<1){const t=e*this._origIndex;this._mixBufferRegion(n,r,t,1-i,e)}s>0&&this._mixBufferRegionAdditive(n,r,this._addIndex*e,1,e);for(let t=e,i=e+e;t!==i;++t)if(n[t]!==n[t+e]){a.setValue(n,r);break}}saveOriginalState(){const t=this.binding,e=this.buffer,n=this.valueSize,r=n*this._origIndex;t.getValue(e,r);for(let t=n,i=r;t!==i;++t)e[t]=e[r+t%n];this._setIdentity(),this.cumulativeWeight=0,this.cumulativeWeightAdditive=0}restoreOriginalState(){const t=3*this.valueSize;this.binding.setValue(this.buffer,t)}_setAdditiveIdentityNumeric(){const t=this._addIndex*this.valueSize,e=t+this.valueSize;for(let n=t;n<e;n++)this.buffer[n]=0}_setAdditiveIdentityQuaternion(){this._setAdditiveIdentityNumeric(),this.buffer[this._addIndex*this.valueSize+3]=1}_setAdditiveIdentityOther(){const t=this._origIndex*this.valueSize,e=this._addIndex*this.valueSize;for(let n=0;n<this.valueSize;n++)this.buffer[e+n]=this.buffer[t+n]}_select(t,e,n,r,i){if(r>=.5)for(let r=0;r!==i;++r)t[e+r]=t[n+r]}_slerp(t,e,n,r){or.slerpFlat(t,e,t,e,t,n,r)}_slerpAdditive(t,e,n,r,i){const s=this._workIndex*i;or.multiplyQuaternionsFlat(t,s,t,e,t,n),or.slerpFlat(t,e,t,e,t,s,r)}_lerp(t,e,n,r,i){const s=1-r;for(let a=0;a!==i;++a){const i=e+a;t[i]=t[i]*s+t[n+a]*r}}_lerpAdditive(t,e,n,r,i){for(let s=0;s!==i;++s){const i=e+s;t[i]=t[i]+t[n+s]*r}}}const kd=new RegExp("[\\[\\]\\.:\\/]","g"),Hd="[^\\[\\]\\.:\\/]",Gd="[^"+"\\[\\]\\.:\\/".replace("\\.","")+"]",Vd=/((?:WC+[\/:])*)/.source.replace("WC",Hd),Wd=/(WCOD+)?/.source.replace("WCOD",Gd),Xd=/(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC",Hd),jd=/\.(WC+)(?:\[(.+)\])?/.source.replace("WC",Hd),Yd=new RegExp("^"+Vd+Wd+Xd+jd+"$"),qd=["material","materials","bones"];class Qd{constructor(t,e,n){this.path=e,this.parsedPath=n||Qd.parseTrackName(e),this.node=Qd.findNode(t,this.parsedPath.nodeName)||t,this.rootNode=t,this.getValue=this._getValue_unbound,this.setValue=this._setValue_unbound}static create(t,e,n){return t&&t.isAnimationObjectGroup?new Qd.Composite(t,e,n):new Qd(t,e,n)}static sanitizeNodeName(t){return t.replace(/\s/g,"_").replace(kd,"")}static parseTrackName(t){const e=Yd.exec(t);if(!e)throw new Error("PropertyBinding: Cannot parse trackName: "+t);const n={nodeName:e[2],objectName:e[3],objectIndex:e[4],propertyName:e[5],propertyIndex:e[6]},r=n.nodeName&&n.nodeName.lastIndexOf(".");if(void 0!==r&&-1!==r){const t=n.nodeName.substring(r+1);-1!==qd.indexOf(t)&&(n.nodeName=n.nodeName.substring(0,r),n.objectName=t)}if(null===n.propertyName||0===n.propertyName.length)throw new Error("PropertyBinding: can not parse propertyName from trackName: "+t);return n}static findNode(t,e){if(!e||""===e||"."===e||-1===e||e===t.name||e===t.uuid)return t;if(t.skeleton){const n=t.skeleton.getBoneByName(e);if(void 0!==n)return n}if(t.children){const n=function(t){for(let r=0;r<t.length;r++){const i=t[r];if(i.name===e||i.uuid===e)return i;const s=n(i.children);if(s)return s}return null},r=n(t.children);if(r)return r}return null}_getValue_unavailable(){}_setValue_unavailable(){}_getValue_direct(t,e){t[e]=this.targetObject[this.propertyName]}_getValue_array(t,e){const n=this.resolvedProperty;for(let r=0,i=n.length;r!==i;++r)t[e++]=n[r]}_getValue_arrayElement(t,e){t[e]=this.resolvedProperty[this.propertyIndex]}_getValue_toArray(t,e){this.resolvedProperty.toArray(t,e)}_setValue_direct(t,e){this.targetObject[this.propertyName]=t[e]}_setValue_direct_setNeedsUpdate(t,e){this.targetObject[this.propertyName]=t[e],this.targetObject.needsUpdate=!0}_setValue_direct_setMatrixWorldNeedsUpdate(t,e){this.targetObject[this.propertyName]=t[e],this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_array(t,e){const n=this.resolvedProperty;for(let r=0,i=n.length;r!==i;++r)n[r]=t[e++]}_setValue_array_setNeedsUpdate(t,e){const n=this.resolvedProperty;for(let r=0,i=n.length;r!==i;++r)n[r]=t[e++];this.targetObject.needsUpdate=!0}_setValue_array_setMatrixWorldNeedsUpdate(t,e){const n=this.resolvedProperty;for(let r=0,i=n.length;r!==i;++r)n[r]=t[e++];this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_arrayElement(t,e){this.resolvedProperty[this.propertyIndex]=t[e]}_setValue_arrayElement_setNeedsUpdate(t,e){this.resolvedProperty[this.propertyIndex]=t[e],this.targetObject.needsUpdate=!0}_setValue_arrayElement_setMatrixWorldNeedsUpdate(t,e){this.resolvedProperty[this.propertyIndex]=t[e],this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_fromArray(t,e){this.resolvedProperty.fromArray(t,e)}_setValue_fromArray_setNeedsUpdate(t,e){this.resolvedProperty.fromArray(t,e),this.targetObject.needsUpdate=!0}_setValue_fromArray_setMatrixWorldNeedsUpdate(t,e){this.resolvedProperty.fromArray(t,e),this.targetObject.matrixWorldNeedsUpdate=!0}_getValue_unbound(t,e){this.bind(),this.getValue(t,e)}_setValue_unbound(t,e){this.bind(),this.setValue(t,e)}bind(){let t=this.node;const e=this.parsedPath,n=e.objectName,r=e.propertyName;let i=e.propertyIndex;if(t||(t=Qd.findNode(this.rootNode,e.nodeName)||this.rootNode,this.node=t),this.getValue=this._getValue_unavailable,this.setValue=this._setValue_unavailable,!t)return void console.error("THREE.PropertyBinding: Trying to update node for track: "+this.path+" but it wasn't found.");if(n){let r=e.objectIndex;switch(n){case"materials":if(!t.material)return void console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.",this);if(!t.material.materials)return void console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.",this);t=t.material.materials;break;case"bones":if(!t.skeleton)return void console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.",this);t=t.skeleton.bones;for(let e=0;e<t.length;e++)if(t[e].name===r){r=e;break}break;default:if(void 0===t[n])return void console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.",this);t=t[n]}if(void 0!==r){if(void 0===t[r])return void console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.",this,t);t=t[r]}}const s=t[r];if(void 0===s){const n=e.nodeName;return void console.error("THREE.PropertyBinding: Trying to update property for track: "+n+"."+r+" but it wasn't found.",t)}let a=this.Versioning.None;this.targetObject=t,void 0!==t.needsUpdate?a=this.Versioning.NeedsUpdate:void 0!==t.matrixWorldNeedsUpdate&&(a=this.Versioning.MatrixWorldNeedsUpdate);let o=this.BindingType.Direct;if(void 0!==i){if("morphTargetInfluences"===r){if(!t.geometry)return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.",this);if(!t.geometry.isBufferGeometry)return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.",this);if(!t.geometry.morphAttributes)return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.",this);void 0!==t.morphTargetDictionary[i]&&(i=t.morphTargetDictionary[i])}o=this.BindingType.ArrayElement,this.resolvedProperty=s,this.propertyIndex=i}else void 0!==s.fromArray&&void 0!==s.toArray?(o=this.BindingType.HasFromToArray,this.resolvedProperty=s):Array.isArray(s)?(o=this.BindingType.EntireArray,this.resolvedProperty=s):this.propertyName=r;this.getValue=this.GetterByBindingType[o],this.setValue=this.SetterByBindingTypeAndVersioning[o][a]}unbind(){this.node=null,this.getValue=this._getValue_unbound,this.setValue=this._setValue_unbound}}Qd.Composite=class{constructor(t,e,n){const r=n||Qd.parseTrackName(e);this._targetGroup=t,this._bindings=t.subscribe_(e,r)}getValue(t,e){this.bind();const n=this._targetGroup.nCachedObjects_,r=this._bindings[n];void 0!==r&&r.getValue(t,e)}setValue(t,e){const n=this._bindings;for(let r=this._targetGroup.nCachedObjects_,i=n.length;r!==i;++r)n[r].setValue(t,e)}bind(){const t=this._bindings;for(let e=this._targetGroup.nCachedObjects_,n=t.length;e!==n;++e)t[e].bind()}unbind(){const t=this._bindings;for(let e=this._targetGroup.nCachedObjects_,n=t.length;e!==n;++e)t[e].unbind()}},Qd.prototype.BindingType={Direct:0,EntireArray:1,ArrayElement:2,HasFromToArray:3},Qd.prototype.Versioning={None:0,NeedsUpdate:1,MatrixWorldNeedsUpdate:2},Qd.prototype.GetterByBindingType=[Qd.prototype._getValue_direct,Qd.prototype._getValue_array,Qd.prototype._getValue_arrayElement,Qd.prototype._getValue_toArray],Qd.prototype.SetterByBindingTypeAndVersioning=[[Qd.prototype._setValue_direct,Qd.prototype._setValue_direct_setNeedsUpdate,Qd.prototype._setValue_direct_setMatrixWorldNeedsUpdate],[Qd.prototype._setValue_array,Qd.prototype._setValue_array_setNeedsUpdate,Qd.prototype._setValue_array_setMatrixWorldNeedsUpdate],[Qd.prototype._setValue_arrayElement,Qd.prototype._setValue_arrayElement_setNeedsUpdate,Qd.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate],[Qd.prototype._setValue_fromArray,Qd.prototype._setValue_fromArray_setNeedsUpdate,Qd.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]];class Zd{constructor(){this.uuid=Bn(),this._objects=Array.prototype.slice.call(arguments),this.nCachedObjects_=0;const t={};this._indicesByUUID=t;for(let e=0,n=arguments.length;e!==n;++e)t[arguments[e].uuid]=e;this._paths=[],this._parsedPaths=[],this._bindings=[],this._bindingsIndicesByPath={};const e=this;this.stats={objects:{get total(){return e._objects.length},get inUse(){return this.total-e.nCachedObjects_}},get bindingsPerObject(){return e._bindings.length}}}add(){const t=this._objects,e=this._indicesByUUID,n=this._paths,r=this._parsedPaths,i=this._bindings,s=i.length;let a,o=t.length,l=this.nCachedObjects_;for(let c=0,h=arguments.length;c!==h;++c){const h=arguments[c],u=h.uuid;let d=e[u];if(void 0===d){d=o++,e[u]=d,t.push(h);for(let t=0,e=s;t!==e;++t)i[t].push(new Qd(h,n[t],r[t]))}else if(d<l){a=t[d];const o=--l,c=t[o];e[c.uuid]=d,t[d]=c,e[u]=o,t[o]=h;for(let t=0,e=s;t!==e;++t){const e=i[t],s=e[o];let a=e[d];e[d]=s,void 0===a&&(a=new Qd(h,n[t],r[t])),e[o]=a}}else t[d]!==a&&console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.")}this.nCachedObjects_=l}remove(){const t=this._objects,e=this._indicesByUUID,n=this._bindings,r=n.length;let i=this.nCachedObjects_;for(let s=0,a=arguments.length;s!==a;++s){const a=arguments[s],o=a.uuid,l=e[o];if(void 0!==l&&l>=i){const s=i++,c=t[s];e[c.uuid]=l,t[l]=c,e[o]=s,t[s]=a;for(let t=0,e=r;t!==e;++t){const e=n[t],r=e[s],i=e[l];e[l]=r,e[s]=i}}}this.nCachedObjects_=i}uncache(){const t=this._objects,e=this._indicesByUUID,n=this._bindings,r=n.length;let i=this.nCachedObjects_,s=t.length;for(let a=0,o=arguments.length;a!==o;++a){const o=arguments[a].uuid,l=e[o];if(void 0!==l)if(delete e[o],l<i){const a=--i,o=t[a],c=--s,h=t[c];e[o.uuid]=l,t[l]=o,e[h.uuid]=a,t[a]=h,t.pop();for(let t=0,e=r;t!==e;++t){const e=n[t],r=e[a],i=e[c];e[l]=r,e[a]=i,e.pop()}}else{const i=--s,a=t[i];i>0&&(e[a.uuid]=l),t[l]=a,t.pop();for(let t=0,e=r;t!==e;++t){const e=n[t];e[l]=e[i],e.pop()}}}this.nCachedObjects_=i}subscribe_(t,e){const n=this._bindingsIndicesByPath;let r=n[t];const i=this._bindings;if(void 0!==r)return i[r];const s=this._paths,a=this._parsedPaths,o=this._objects,l=o.length,c=this.nCachedObjects_,h=new Array(l);r=i.length,n[t]=r,s.push(t),a.push(e),i.push(h);for(let n=c,r=o.length;n!==r;++n){const r=o[n];h[n]=new Qd(r,t,e)}return h}unsubscribe_(t){const e=this._bindingsIndicesByPath,n=e[t];if(void 0!==n){const r=this._paths,i=this._parsedPaths,s=this._bindings,a=s.length-1,o=s[a];e[t[a]]=n,s[n]=o,s.pop(),i[n]=i[a],i.pop(),r[n]=r[a],r.pop()}}}Zd.prototype.isAnimationObjectGroup=!0;class Jd{constructor(t,e,n=null,r=e.blendMode){this._mixer=t,this._clip=e,this._localRoot=n,this.blendMode=r;const i=e.tracks,s=i.length,a=new Array(s),o={endingStart:Xe,endingEnd:Xe};for(let t=0;t!==s;++t){const e=i[t].createInterpolant(null);a[t]=e,e.settings=o}this._interpolantSettings=o,this._interpolants=a,this._propertyBindings=new Array(s),this._cacheIndex=null,this._byClipCacheIndex=null,this._timeScaleInterpolant=null,this._weightInterpolant=null,this.loop=ke,this._loopCount=-1,this._startTime=null,this.time=0,this.timeScale=1,this._effectiveTimeScale=1,this.weight=1,this._effectiveWeight=1,this.repetitions=1/0,this.paused=!1,this.enabled=!0,this.clampWhenFinished=!1,this.zeroSlopeAtStart=!0,this.zeroSlopeAtEnd=!0}play(){return this._mixer._activateAction(this),this}stop(){return this._mixer._deactivateAction(this),this.reset()}reset(){return this.paused=!1,this.enabled=!0,this.time=0,this._loopCount=-1,this._startTime=null,this.stopFading().stopWarping()}isRunning(){return this.enabled&&!this.paused&&0!==this.timeScale&&null===this._startTime&&this._mixer._isActiveAction(this)}isScheduled(){return this._mixer._isActiveAction(this)}startAt(t){return this._startTime=t,this}setLoop(t,e){return this.loop=t,this.repetitions=e,this}setEffectiveWeight(t){return this.weight=t,this._effectiveWeight=this.enabled?t:0,this.stopFading()}getEffectiveWeight(){return this._effectiveWeight}fadeIn(t){return this._scheduleFading(t,0,1)}fadeOut(t){return this._scheduleFading(t,1,0)}crossFadeFrom(t,e,n){if(t.fadeOut(e),this.fadeIn(e),n){const n=this._clip.duration,r=t._clip.duration,i=r/n,s=n/r;t.warp(1,i,e),this.warp(s,1,e)}return this}crossFadeTo(t,e,n){return t.crossFadeFrom(this,e,n)}stopFading(){const t=this._weightInterpolant;return null!==t&&(this._weightInterpolant=null,this._mixer._takeBackControlInterpolant(t)),this}setEffectiveTimeScale(t){return this.timeScale=t,this._effectiveTimeScale=this.paused?0:t,this.stopWarping()}getEffectiveTimeScale(){return this._effectiveTimeScale}setDuration(t){return this.timeScale=this._clip.duration/t,this.stopWarping()}syncWith(t){return this.time=t.time,this.timeScale=t.timeScale,this.stopWarping()}halt(t){return this.warp(this._effectiveTimeScale,0,t)}warp(t,e,n){const r=this._mixer,i=r.time,s=this.timeScale;let a=this._timeScaleInterpolant;null===a&&(a=r._lendControlInterpolant(),this._timeScaleInterpolant=a);const o=a.parameterPositions,l=a.sampleValues;return o[0]=i,o[1]=i+n,l[0]=t/s,l[1]=e/s,this}stopWarping(){const t=this._timeScaleInterpolant;return null!==t&&(this._timeScaleInterpolant=null,this._mixer._takeBackControlInterpolant(t)),this}getMixer(){return this._mixer}getClip(){return this._clip}getRoot(){return this._localRoot||this._mixer._root}_update(t,e,n,r){if(!this.enabled)return void this._updateWeight(t);const i=this._startTime;if(null!==i){const r=(t-i)*n;if(r<0||0===n)return;this._startTime=null,e=n*r}e*=this._updateTimeScale(t);const s=this._updateTime(e),a=this._updateWeight(t);if(a>0){const t=this._interpolants,e=this._propertyBindings;if(this.blendMode===Qe)for(let n=0,r=t.length;n!==r;++n)t[n].evaluate(s),e[n].accumulateAdditive(a);else for(let n=0,i=t.length;n!==i;++n)t[n].evaluate(s),e[n].accumulate(r,a)}}_updateWeight(t){let e=0;if(this.enabled){e=this.weight;const n=this._weightInterpolant;if(null!==n){const r=n.evaluate(t)[0];e*=r,t>n.parameterPositions[1]&&(this.stopFading(),0===r&&(this.enabled=!1))}}return this._effectiveWeight=e,e}_updateTimeScale(t){let e=0;if(!this.paused){e=this.timeScale;const n=this._timeScaleInterpolant;null!==n&&(e*=n.evaluate(t)[0],t>n.parameterPositions[1]&&(this.stopWarping(),0===e?this.paused=!0:this.timeScale=e))}return this._effectiveTimeScale=e,e}_updateTime(t){const e=this._clip.duration,n=this.loop;let r=this.time+t,i=this._loopCount;const s=n===He;if(0===t)return-1===i?r:s&&1==(1&i)?e-r:r;if(n===ze){-1===i&&(this._loopCount=0,this._setEndings(!0,!0,!1));t:{if(r>=e)r=e;else{if(!(r<0)){this.time=r;break t}r=0}this.clampWhenFinished?this.paused=!0:this.enabled=!1,this.time=r,this._mixer.dispatchEvent({type:"finished",action:this,direction:t<0?-1:1})}}else{if(-1===i&&(t>=0?(i=0,this._setEndings(!0,0===this.repetitions,s)):this._setEndings(0===this.repetitions,!0,s)),r>=e||r<0){const n=Math.floor(r/e);r-=e*n,i+=Math.abs(n);const a=this.repetitions-i;if(a<=0)this.clampWhenFinished?this.paused=!0:this.enabled=!1,r=t>0?e:0,this.time=r,this._mixer.dispatchEvent({type:"finished",action:this,direction:t>0?1:-1});else{if(1===a){const e=t<0;this._setEndings(e,!e,s)}else this._setEndings(!1,!1,s);this._loopCount=i,this.time=r,this._mixer.dispatchEvent({type:"loop",action:this,loopDelta:n})}}else this.time=r;if(s&&1==(1&i))return e-r}return r}_setEndings(t,e,n){const r=this._interpolantSettings;n?(r.endingStart=je,r.endingEnd=je):(r.endingStart=t?this.zeroSlopeAtStart?je:Xe:Ye,r.endingEnd=e?this.zeroSlopeAtEnd?je:Xe:Ye)}_scheduleFading(t,e,n){const r=this._mixer,i=r.time;let s=this._weightInterpolant;null===s&&(s=r._lendControlInterpolant(),this._weightInterpolant=s);const a=s.parameterPositions,o=s.sampleValues;return a[0]=i,o[0]=e,a[1]=i+t,o[1]=n,this}}class Kd extends Dn{constructor(t){super(),this._root=t,this._initMemoryManager(),this._accuIndex=0,this.time=0,this.timeScale=1}_bindAction(t,e){const n=t._localRoot||this._root,r=t._clip.tracks,i=r.length,s=t._propertyBindings,a=t._interpolants,o=n.uuid,l=this._bindingsByRootAndName;let c=l[o];void 0===c&&(c={},l[o]=c);for(let t=0;t!==i;++t){const i=r[t],l=i.name;let h=c[l];if(void 0!==h)s[t]=h;else{if(h=s[t],void 0!==h){null===h._cacheIndex&&(++h.referenceCount,this._addInactiveBinding(h,o,l));continue}const r=e&&e._propertyBindings[t].binding.parsedPath;h=new zd(Qd.create(n,l,r),i.ValueTypeName,i.getValueSize()),++h.referenceCount,this._addInactiveBinding(h,o,l),s[t]=h}a[t].resultBuffer=h.buffer}}_activateAction(t){if(!this._isActiveAction(t)){if(null===t._cacheIndex){const e=(t._localRoot||this._root).uuid,n=t._clip.uuid,r=this._actionsByClip[n];this._bindAction(t,r&&r.knownActions[0]),this._addInactiveAction(t,n,e)}const e=t._propertyBindings;for(let t=0,n=e.length;t!==n;++t){const n=e[t];0==n.useCount++&&(this._lendBinding(n),n.saveOriginalState())}this._lendAction(t)}}_deactivateAction(t){if(this._isActiveAction(t)){const e=t._propertyBindings;for(let t=0,n=e.length;t!==n;++t){const n=e[t];0==--n.useCount&&(n.restoreOriginalState(),this._takeBackBinding(n))}this._takeBackAction(t)}}_initMemoryManager(){this._actions=[],this._nActiveActions=0,this._actionsByClip={},this._bindings=[],this._nActiveBindings=0,this._bindingsByRootAndName={},this._controlInterpolants=[],this._nActiveControlInterpolants=0;const t=this;this.stats={actions:{get total(){return t._actions.length},get inUse(){return t._nActiveActions}},bindings:{get total(){return t._bindings.length},get inUse(){return t._nActiveBindings}},controlInterpolants:{get total(){return t._controlInterpolants.length},get inUse(){return t._nActiveControlInterpolants}}}}_isActiveAction(t){const e=t._cacheIndex;return null!==e&&e<this._nActiveActions}_addInactiveAction(t,e,n){const r=this._actions,i=this._actionsByClip;let s=i[e];if(void 0===s)s={knownActions:[t],actionByRoot:{}},t._byClipCacheIndex=0,i[e]=s;else{const e=s.knownActions;t._byClipCacheIndex=e.length,e.push(t)}t._cacheIndex=r.length,r.push(t),s.actionByRoot[n]=t}_removeInactiveAction(t){const e=this._actions,n=e[e.length-1],r=t._cacheIndex;n._cacheIndex=r,e[r]=n,e.pop(),t._cacheIndex=null;const i=t._clip.uuid,s=this._actionsByClip,a=s[i],o=a.knownActions,l=o[o.length-1],c=t._byClipCacheIndex;l._byClipCacheIndex=c,o[c]=l,o.pop(),t._byClipCacheIndex=null,delete a.actionByRoot[(t._localRoot||this._root).uuid],0===o.length&&delete s[i],this._removeInactiveBindingsForAction(t)}_removeInactiveBindingsForAction(t){const e=t._propertyBindings;for(let t=0,n=e.length;t!==n;++t){const n=e[t];0==--n.referenceCount&&this._removeInactiveBinding(n)}}_lendAction(t){const e=this._actions,n=t._cacheIndex,r=this._nActiveActions++,i=e[r];t._cacheIndex=r,e[r]=t,i._cacheIndex=n,e[n]=i}_takeBackAction(t){const e=this._actions,n=t._cacheIndex,r=--this._nActiveActions,i=e[r];t._cacheIndex=r,e[r]=t,i._cacheIndex=n,e[n]=i}_addInactiveBinding(t,e,n){const r=this._bindingsByRootAndName,i=this._bindings;let s=r[e];void 0===s&&(s={},r[e]=s),s[n]=t,t._cacheIndex=i.length,i.push(t)}_removeInactiveBinding(t){const e=this._bindings,n=t.binding,r=n.rootNode.uuid,i=n.path,s=this._bindingsByRootAndName,a=s[r],o=e[e.length-1],l=t._cacheIndex;o._cacheIndex=l,e[l]=o,e.pop(),delete a[i],0===Object.keys(a).length&&delete s[r]}_lendBinding(t){const e=this._bindings,n=t._cacheIndex,r=this._nActiveBindings++,i=e[r];t._cacheIndex=r,e[r]=t,i._cacheIndex=n,e[n]=i}_takeBackBinding(t){const e=this._bindings,n=t._cacheIndex,r=--this._nActiveBindings,i=e[r];t._cacheIndex=r,e[r]=t,i._cacheIndex=n,e[n]=i}_lendControlInterpolant(){const t=this._controlInterpolants,e=this._nActiveControlInterpolants++;let n=t[e];return void 0===n&&(n=new xu(new Float32Array(2),new Float32Array(2),1,this._controlInterpolantsResultBuffer),n.__cacheIndex=e,t[e]=n),n}_takeBackControlInterpolant(t){const e=this._controlInterpolants,n=t.__cacheIndex,r=--this._nActiveControlInterpolants,i=e[r];t.__cacheIndex=r,e[r]=t,i.__cacheIndex=n,e[n]=i}clipAction(t,e,n){const r=e||this._root,i=r.uuid;let s="string"==typeof t?Cu.findByName(r,t):t;const a=null!==s?s.uuid:t,o=this._actionsByClip[a];let l=null;if(void 0===n&&(n=null!==s?s.blendMode:qe),void 0!==o){const t=o.actionByRoot[i];if(void 0!==t&&t.blendMode===n)return t;l=o.knownActions[0],null===s&&(s=l._clip)}if(null===s)return null;const c=new Jd(this,s,e,n);return this._bindAction(c,l),this._addInactiveAction(c,a,i),c}existingAction(t,e){const n=e||this._root,r=n.uuid,i="string"==typeof t?Cu.findByName(n,t):t,s=i?i.uuid:t,a=this._actionsByClip[s];return void 0!==a&&a.actionByRoot[r]||null}stopAllAction(){const t=this._actions;for(let e=this._nActiveActions-1;e>=0;--e)t[e].stop();return this}update(t){t*=this.timeScale;const e=this._actions,n=this._nActiveActions,r=this.time+=t,i=Math.sign(t),s=this._accuIndex^=1;for(let a=0;a!==n;++a)e[a]._update(r,t,i,s);const a=this._bindings,o=this._nActiveBindings;for(let t=0;t!==o;++t)a[t].apply(s);return this}setTime(t){this.time=0;for(let t=0;t<this._actions.length;t++)this._actions[t].time=0;return this.update(t)}getRoot(){return this._root}uncacheClip(t){const e=this._actions,n=t.uuid,r=this._actionsByClip,i=r[n];if(void 0!==i){const t=i.knownActions;for(let n=0,r=t.length;n!==r;++n){const r=t[n];this._deactivateAction(r);const i=r._cacheIndex,s=e[e.length-1];r._cacheIndex=null,r._byClipCacheIndex=null,s._cacheIndex=i,e[i]=s,e.pop(),this._removeInactiveBindingsForAction(r)}delete r[n]}}uncacheRoot(t){const e=t.uuid,n=this._actionsByClip;for(const t in n){const r=n[t].actionByRoot[e];void 0!==r&&(this._deactivateAction(r),this._removeInactiveAction(r))}const r=this._bindingsByRootAndName[e];if(void 0!==r)for(const t in r){const e=r[t];e.restoreOriginalState(),this._removeInactiveBinding(e)}}uncacheAction(t,e){const n=this.existingAction(t,e);null!==n&&(this._deactivateAction(n),this._removeInactiveAction(n))}}Kd.prototype._controlInterpolantsResultBuffer=new Float32Array(1);class $d{constructor(t){"string"==typeof t&&(console.warn("THREE.Uniform: Type parameter is no longer needed."),t=arguments[1]),this.value=t}clone(){return new $d(void 0===this.value.clone?this.value:this.value.clone())}}class tp extends Rl{constructor(t,e,n=1){super(t,e),this.meshPerAttribute=n}copy(t){return super.copy(t),this.meshPerAttribute=t.meshPerAttribute,this}clone(t){const e=super.clone(t);return e.meshPerAttribute=this.meshPerAttribute,e}toJSON(t){const e=super.toJSON(t);return e.isInstancedInterleavedBuffer=!0,e.meshPerAttribute=this.meshPerAttribute,e}}tp.prototype.isInstancedInterleavedBuffer=!0;class ep{constructor(t,e,n,r,i){this.buffer=t,this.type=e,this.itemSize=n,this.elementSize=r,this.count=i,this.version=0}set needsUpdate(t){!0===t&&this.version++}setBuffer(t){return this.buffer=t,this}setType(t,e){return this.type=t,this.elementSize=e,this}setItemSize(t){return this.itemSize=t,this}setCount(t){return this.count=t,this}}ep.prototype.isGLBufferAttribute=!0;class np{constructor(t,e,n=0,r=1/0){this.ray=new Br(t,e),this.near=n,this.far=r,this.camera=null,this.layers=new Zr,this.params={Mesh:{},Line:{threshold:1},LOD:{},Points:{threshold:1},Sprite:{}}}set(t,e){this.ray.set(t,e)}setFromCamera(t,e){e&&e.isPerspectiveCamera?(this.ray.origin.setFromMatrixPosition(e.matrixWorld),this.ray.direction.set(t.x,t.y,.5).unproject(e).sub(this.ray.origin).normalize(),this.camera=e):e&&e.isOrthographicCamera?(this.ray.origin.set(t.x,t.y,(e.near+e.far)/(e.near-e.far)).unproject(e),this.ray.direction.set(0,0,-1).transformDirection(e.matrixWorld),this.camera=e):console.error("THREE.Raycaster: Unsupported camera type: "+e.type)}intersectObject(t,e=!0,n=[]){return ip(t,this,n,e),n.sort(rp),n}intersectObjects(t,e=!0,n=[]){for(let r=0,i=t.length;r<i;r++)ip(t[r],this,n,e);return n.sort(rp),n}}function rp(t,e){return t.distance-e.distance}function ip(t,e,n,r){if(t.layers.test(e.layers)&&t.raycast(e,n),!0===r){const r=t.children;for(let t=0,i=r.length;t<i;t++)ip(r[t],e,n,!0)}}class sp{constructor(t=1,e=0,n=0){return this.radius=t,this.phi=e,this.theta=n,this}set(t,e,n){return this.radius=t,this.phi=e,this.theta=n,this}copy(t){return this.radius=t.radius,this.phi=t.phi,this.theta=t.theta,this}makeSafe(){const t=1e-6;return this.phi=Math.max(t,Math.min(Math.PI-t,this.phi)),this}setFromVector3(t){return this.setFromCartesianCoords(t.x,t.y,t.z)}setFromCartesianCoords(t,e,n){return this.radius=Math.sqrt(t*t+e*e+n*n),0===this.radius?(this.theta=0,this.phi=0):(this.theta=Math.atan2(t,n),this.phi=Math.acos(zn(e/this.radius,-1,1))),this}clone(){return(new this.constructor).copy(this)}}class ap{constructor(t=1,e=0,n=0){return this.radius=t,this.theta=e,this.y=n,this}set(t,e,n){return this.radius=t,this.theta=e,this.y=n,this}copy(t){return this.radius=t.radius,this.theta=t.theta,this.y=t.y,this}setFromVector3(t){return this.setFromCartesianCoords(t.x,t.y,t.z)}setFromCartesianCoords(t,e,n){return this.radius=Math.sqrt(t*t+n*n),this.theta=Math.atan2(t,n),this.y=e,this}clone(){return(new this.constructor).copy(this)}}const op=new jn;class lp{constructor(t=new jn(1/0,1/0),e=new jn(-1/0,-1/0)){this.min=t,this.max=e}set(t,e){return this.min.copy(t),this.max.copy(e),this}setFromPoints(t){this.makeEmpty();for(let e=0,n=t.length;e<n;e++)this.expandByPoint(t[e]);return this}setFromCenterAndSize(t,e){const n=op.copy(e).multiplyScalar(.5);return this.min.copy(t).sub(n),this.max.copy(t).add(n),this}clone(){return(new this.constructor).copy(this)}copy(t){return this.min.copy(t.min),this.max.copy(t.max),this}makeEmpty(){return this.min.x=this.min.y=1/0,this.max.x=this.max.y=-1/0,this}isEmpty(){return this.max.x<this.min.x||this.max.y<this.min.y}getCenter(t){return this.isEmpty()?t.set(0,0):t.addVectors(this.min,this.max).multiplyScalar(.5)}getSize(t){return this.isEmpty()?t.set(0,0):t.subVectors(this.max,this.min)}expandByPoint(t){return this.min.min(t),this.max.max(t),this}expandByVector(t){return this.min.sub(t),this.max.add(t),this}expandByScalar(t){return this.min.addScalar(-t),this.max.addScalar(t),this}containsPoint(t){return!(t.x<this.min.x||t.x>this.max.x||t.y<this.min.y||t.y>this.max.y)}containsBox(t){return this.min.x<=t.min.x&&t.max.x<=this.max.x&&this.min.y<=t.min.y&&t.max.y<=this.max.y}getParameter(t,e){return e.set((t.x-this.min.x)/(this.max.x-this.min.x),(t.y-this.min.y)/(this.max.y-this.min.y))}intersectsBox(t){return!(t.max.x<this.min.x||t.min.x>this.max.x||t.max.y<this.min.y||t.min.y>this.max.y)}clampPoint(t,e){return e.copy(t).clamp(this.min,this.max)}distanceToPoint(t){return op.copy(t).clamp(this.min,this.max).sub(t).length()}intersect(t){return this.min.max(t.min),this.max.min(t.max),this}union(t){return this.min.min(t.min),this.max.max(t.max),this}translate(t){return this.min.add(t),this.max.add(t),this}equals(t){return t.min.equals(this.min)&&t.max.equals(this.max)}}lp.prototype.isBox2=!0;const cp=new lr,hp=new lr;class up{constructor(t=new lr,e=new lr){this.start=t,this.end=e}set(t,e){return this.start.copy(t),this.end.copy(e),this}copy(t){return this.start.copy(t.start),this.end.copy(t.end),this}getCenter(t){return t.addVectors(this.start,this.end).multiplyScalar(.5)}delta(t){return t.subVectors(this.end,this.start)}distanceSq(){return this.start.distanceToSquared(this.end)}distance(){return this.start.distanceTo(this.end)}at(t,e){return this.delta(e).multiplyScalar(t).add(this.start)}closestPointToPointParameter(t,e){cp.subVectors(t,this.start),hp.subVectors(this.end,this.start);const n=hp.dot(hp);let r=hp.dot(cp)/n;return e&&(r=zn(r,0,1)),r}closestPointToPoint(t,e,n){const r=this.closestPointToPointParameter(t,e);return this.delta(n).multiplyScalar(r).add(this.start)}applyMatrix4(t){return this.start.applyMatrix4(t),this.end.applyMatrix4(t),this}equals(t){return t.start.equals(this.start)&&t.end.equals(this.end)}clone(){return(new this.constructor).copy(this)}}const dp=new lr;class pp extends hi{constructor(t,e){super(),this.light=t,this.light.updateMatrixWorld(),this.matrix=t.matrixWorld,this.matrixAutoUpdate=!1,this.color=e;const n=new Ki,r=[0,0,0,0,0,1,0,0,0,1,0,1,0,0,0,-1,0,1,0,0,0,0,1,1,0,0,0,0,-1,1];for(let t=0,e=1,n=32;t<n;t++,e++){const i=t/n*Math.PI*2,s=e/n*Math.PI*2;r.push(Math.cos(i),Math.sin(i),1,Math.cos(s),Math.sin(s),1)}n.setAttribute("position",new Vi(r,3));const i=new gc({fog:!1,toneMapped:!1});this.cone=new Sc(n,i),this.add(this.cone),this.update()}dispose(){this.cone.geometry.dispose(),this.cone.material.dispose()}update(){this.light.updateMatrixWorld();const t=this.light.distance?this.light.distance:1e3,e=t*Math.tan(this.light.angle);this.cone.scale.set(e,e,t),dp.setFromMatrixPosition(this.light.target.matrixWorld),this.cone.lookAt(dp),void 0!==this.color?this.cone.material.color.set(this.color):this.cone.material.color.copy(this.light.color)}}const fp=new lr,mp=new zr,gp=new zr;class vp extends Sc{constructor(t){const e=xp(t),n=new Ki,r=[],i=[],s=new Li(0,0,1),a=new Li(0,1,0);for(let t=0;t<e.length;t++){const n=e[t];n.parent&&n.parent.isBone&&(r.push(0,0,0),r.push(0,0,0),i.push(s.r,s.g,s.b),i.push(a.r,a.g,a.b))}n.setAttribute("position",new Vi(r,3)),n.setAttribute("color",new Vi(i,3)),super(n,new gc({vertexColors:!0,depthTest:!1,depthWrite:!1,toneMapped:!1,transparent:!0})),this.type="SkeletonHelper",this.isSkeletonHelper=!0,this.root=t,this.bones=e,this.matrix=t.matrixWorld,this.matrixAutoUpdate=!1}updateMatrixWorld(t){const e=this.bones,n=this.geometry,r=n.getAttribute("position");gp.copy(this.root.matrixWorld).invert();for(let t=0,n=0;t<e.length;t++){const i=e[t];i.parent&&i.parent.isBone&&(mp.multiplyMatrices(gp,i.matrixWorld),fp.setFromMatrixPosition(mp),r.setXYZ(n,fp.x,fp.y,fp.z),mp.multiplyMatrices(gp,i.parent.matrixWorld),fp.setFromMatrixPosition(mp),r.setXYZ(n+1,fp.x,fp.y,fp.z),n+=2)}n.getAttribute("position").needsUpdate=!0,super.updateMatrixWorld(t)}}function xp(t){const e=[];t&&t.isBone&&e.push(t);for(let n=0;n<t.children.length;n++)e.push.apply(e,xp(t.children[n]));return e}class yp extends gs{constructor(t,e,n){super(new Jh(e,4,2),new Ri({wireframe:!0,fog:!1,toneMapped:!1})),this.light=t,this.light.updateMatrixWorld(),this.color=n,this.type="PointLightHelper",this.matrix=this.light.matrixWorld,this.matrixAutoUpdate=!1,this.update()}dispose(){this.geometry.dispose(),this.material.dispose()}update(){void 0!==this.color?this.material.color.set(this.color):this.material.color.copy(this.light.color)}}const wp=new lr,bp=new Li,_p=new Li;class Mp extends hi{constructor(t,e,n){super(),this.light=t,this.light.updateMatrixWorld(),this.matrix=t.matrixWorld,this.matrixAutoUpdate=!1,this.color=n;const r=new qh(e);r.rotateY(.5*Math.PI),this.material=new Ri({wireframe:!0,fog:!1,toneMapped:!1}),void 0===this.color&&(this.material.vertexColors=!0);const i=r.getAttribute("position"),s=new Float32Array(3*i.count);r.setAttribute("color",new Ii(s,3)),this.add(new gs(r,this.material)),this.update()}dispose(){this.children[0].geometry.dispose(),this.children[0].material.dispose()}update(){const t=this.children[0];if(void 0!==this.color)this.material.color.set(this.color);else{const e=t.geometry.getAttribute("color");bp.copy(this.light.color),_p.copy(this.light.groundColor);for(let t=0,n=e.count;t<n;t++){const r=t<n/2?bp:_p;e.setXYZ(t,r.r,r.g,r.b)}e.needsUpdate=!0}t.lookAt(wp.setFromMatrixPosition(this.light.matrixWorld).negate())}}class Tp extends Sc{constructor(t=10,e=10,n=4473924,r=8947848){n=new Li(n),r=new Li(r);const i=e/2,s=t/e,a=t/2,o=[],l=[];for(let t=0,c=0,h=-a;t<=e;t++,h+=s){o.push(-a,0,h,a,0,h),o.push(h,0,-a,h,0,a);const e=t===i?n:r;e.toArray(l,c),c+=3,e.toArray(l,c),c+=3,e.toArray(l,c),c+=3,e.toArray(l,c),c+=3}const c=new Ki;c.setAttribute("position",new Vi(o,3)),c.setAttribute("color",new Vi(l,3)),super(c,new gc({vertexColors:!0,toneMapped:!1})),this.type="GridHelper"}}class Sp extends Sc{constructor(t=10,e=16,n=8,r=64,i=4473924,s=8947848){i=new Li(i),s=new Li(s);const a=[],o=[];for(let n=0;n<=e;n++){const r=n/e*(2*Math.PI),l=Math.sin(r)*t,c=Math.cos(r)*t;a.push(0,0,0),a.push(l,0,c);const h=1&n?i:s;o.push(h.r,h.g,h.b),o.push(h.r,h.g,h.b)}for(let e=0;e<=n;e++){const l=1&e?i:s,c=t-t/n*e;for(let t=0;t<r;t++){let e=t/r*(2*Math.PI),n=Math.sin(e)*c,i=Math.cos(e)*c;a.push(n,0,i),o.push(l.r,l.g,l.b),e=(t+1)/r*(2*Math.PI),n=Math.sin(e)*c,i=Math.cos(e)*c,a.push(n,0,i),o.push(l.r,l.g,l.b)}}const l=new Ki;l.setAttribute("position",new Vi(a,3)),l.setAttribute("color",new Vi(o,3)),super(l,new gc({vertexColors:!0,toneMapped:!1})),this.type="PolarGridHelper"}}const Ap=new lr,Ep=new lr,Cp=new lr;class Pp extends hi{constructor(t,e,n){super(),this.light=t,this.light.updateMatrixWorld(),this.matrix=t.matrixWorld,this.matrixAutoUpdate=!1,this.color=n,void 0===e&&(e=1);let r=new Ki;r.setAttribute("position",new Vi([-e,e,0,e,e,0,e,-e,0,-e,-e,0,-e,e,0],3));const i=new gc({fog:!1,toneMapped:!1});this.lightPlane=new _c(r,i),this.add(this.lightPlane),r=new Ki,r.setAttribute("position",new Vi([0,0,0,0,0,1],3)),this.targetLine=new _c(r,i),this.add(this.targetLine),this.update()}dispose(){this.lightPlane.geometry.dispose(),this.lightPlane.material.dispose(),this.targetLine.geometry.dispose(),this.targetLine.material.dispose()}update(){Ap.setFromMatrixPosition(this.light.matrixWorld),Ep.setFromMatrixPosition(this.light.target.matrixWorld),Cp.subVectors(Ep,Ap),this.lightPlane.lookAt(Ep),void 0!==this.color?(this.lightPlane.material.color.set(this.color),this.targetLine.material.color.set(this.color)):(this.lightPlane.material.color.copy(this.light.color),this.targetLine.material.color.copy(this.light.color)),this.targetLine.lookAt(Ep),this.targetLine.scale.z=Cp.length()}}const Lp=new lr,Rp=new Ms;class Fp extends Sc{constructor(t){const e=new Ki,n=new gc({color:16777215,vertexColors:!0,toneMapped:!1}),r=[],i=[],s={},a=new Li(16755200),o=new Li(16711680),l=new Li(43775),c=new Li(16777215),h=new Li(3355443);function u(t,e,n){d(t,n),d(e,n)}function d(t,e){r.push(0,0,0),i.push(e.r,e.g,e.b),void 0===s[t]&&(s[t]=[]),s[t].push(r.length/3-1)}u("n1","n2",a),u("n2","n4",a),u("n4","n3",a),u("n3","n1",a),u("f1","f2",a),u("f2","f4",a),u("f4","f3",a),u("f3","f1",a),u("n1","f1",a),u("n2","f2",a),u("n3","f3",a),u("n4","f4",a),u("p","n1",o),u("p","n2",o),u("p","n3",o),u("p","n4",o),u("u1","u2",l),u("u2","u3",l),u("u3","u1",l),u("c","t",c),u("p","c",h),u("cn1","cn2",h),u("cn3","cn4",h),u("cf1","cf2",h),u("cf3","cf4",h),e.setAttribute("position",new Vi(r,3)),e.setAttribute("color",new Vi(i,3)),super(e,n),this.type="CameraHelper",this.camera=t,this.camera.updateProjectionMatrix&&this.camera.updateProjectionMatrix(),this.matrix=t.matrixWorld,this.matrixAutoUpdate=!1,this.pointMap=s,this.update()}update(){const t=this.geometry,e=this.pointMap;Rp.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse),Dp("c",e,t,Rp,0,0,-1),Dp("t",e,t,Rp,0,0,1),Dp("n1",e,t,Rp,-1,-1,-1),Dp("n2",e,t,Rp,1,-1,-1),Dp("n3",e,t,Rp,-1,1,-1),Dp("n4",e,t,Rp,1,1,-1),Dp("f1",e,t,Rp,-1,-1,1),Dp("f2",e,t,Rp,1,-1,1),Dp("f3",e,t,Rp,-1,1,1),Dp("f4",e,t,Rp,1,1,1),Dp("u1",e,t,Rp,.7,1.1,-1),Dp("u2",e,t,Rp,-.7,1.1,-1),Dp("u3",e,t,Rp,0,2,-1),Dp("cf1",e,t,Rp,-1,0,1),Dp("cf2",e,t,Rp,1,0,1),Dp("cf3",e,t,Rp,0,-1,1),Dp("cf4",e,t,Rp,0,1,1),Dp("cn1",e,t,Rp,-1,0,-1),Dp("cn2",e,t,Rp,1,0,-1),Dp("cn3",e,t,Rp,0,-1,-1),Dp("cn4",e,t,Rp,0,1,-1),t.getAttribute("position").needsUpdate=!0}dispose(){this.geometry.dispose(),this.material.dispose()}}function Dp(t,e,n,r,i,s,a){Lp.set(i,s,a).unproject(r);const o=e[t];if(void 0!==o){const t=n.getAttribute("position");for(let e=0,n=o.length;e<n;e++)t.setXYZ(o[e],Lp.x,Lp.y,Lp.z)}}const Ip=new ur;class Up extends Sc{constructor(t,e=16776960){const n=new Uint16Array([0,1,1,2,2,3,3,0,4,5,5,6,6,7,7,4,0,4,1,5,2,6,3,7]),r=new Float32Array(24),i=new Ki;i.setIndex(new Ii(n,1)),i.setAttribute("position",new Ii(r,3)),super(i,new gc({color:e,toneMapped:!1})),this.object=t,this.type="BoxHelper",this.matrixAutoUpdate=!1,this.update()}update(t){if(void 0!==t&&console.warn("THREE.BoxHelper: .update() has no longer arguments."),void 0!==this.object&&Ip.setFromObject(this.object),Ip.isEmpty())return;const e=Ip.min,n=Ip.max,r=this.geometry.attributes.position,i=r.array;i[0]=n.x,i[1]=n.y,i[2]=n.z,i[3]=e.x,i[4]=n.y,i[5]=n.z,i[6]=e.x,i[7]=e.y,i[8]=n.z,i[9]=n.x,i[10]=e.y,i[11]=n.z,i[12]=n.x,i[13]=n.y,i[14]=e.z,i[15]=e.x,i[16]=n.y,i[17]=e.z,i[18]=e.x,i[19]=e.y,i[20]=e.z,i[21]=n.x,i[22]=e.y,i[23]=e.z,r.needsUpdate=!0,this.geometry.computeBoundingSphere()}setFromObject(t){return this.object=t,this.update(),this}copy(t){return Sc.prototype.copy.call(this,t),this.object=t.object,this}}class Np extends Sc{constructor(t,e=16776960){const n=new Uint16Array([0,1,1,2,2,3,3,0,4,5,5,6,6,7,7,4,0,4,1,5,2,6,3,7]),r=new Ki;r.setIndex(new Ii(n,1)),r.setAttribute("position",new Vi([1,1,1,-1,1,1,-1,-1,1,1,-1,1,1,1,-1,-1,1,-1,-1,-1,-1,1,-1,-1],3)),super(r,new gc({color:e,toneMapped:!1})),this.box=t,this.type="Box3Helper",this.geometry.computeBoundingSphere()}updateMatrixWorld(t){const e=this.box;e.isEmpty()||(e.getCenter(this.position),e.getSize(this.scale),this.scale.multiplyScalar(.5),super.updateMatrixWorld(t))}}class Op extends _c{constructor(t,e=1,n=16776960){const r=n,i=new Ki;i.setAttribute("position",new Vi([1,-1,1,-1,1,1,-1,-1,1,1,1,1,-1,1,1,-1,-1,1,1,-1,1,1,1,1,0,0,1,0,0,0],3)),i.computeBoundingSphere(),super(i,new gc({color:r,toneMapped:!1})),this.type="PlaneHelper",this.plane=t,this.size=e;const s=new Ki;s.setAttribute("position",new Vi([1,1,1,-1,1,1,-1,-1,1,1,1,1,-1,-1,1,1,-1,1],3)),s.computeBoundingSphere(),this.add(new gs(s,new Ri({color:r,opacity:.2,transparent:!0,depthWrite:!1,toneMapped:!1})))}updateMatrixWorld(t){let e=-this.plane.constant;Math.abs(e)<1e-8&&(e=1e-8),this.scale.set(.5*this.size,.5*this.size,e),this.children[0].material.side=e<0?y:x,this.lookAt(this.plane.normal),super.updateMatrixWorld(t)}}const Bp=new lr;let zp,kp;class Hp extends hi{constructor(t=new lr(0,0,1),e=new lr(0,0,0),n=1,r=16776960,i=.2*n,s=.2*i){super(),this.type="ArrowHelper",void 0===zp&&(zp=new Ki,zp.setAttribute("position",new Vi([0,0,0,0,1,0],3)),kp=new zc(0,.5,1,5,1),kp.translate(0,-.5,0)),this.position.copy(e),this.line=new _c(zp,new gc({color:r,toneMapped:!1})),this.line.matrixAutoUpdate=!1,this.add(this.line),this.cone=new gs(kp,new Ri({color:r,toneMapped:!1})),this.cone.matrixAutoUpdate=!1,this.add(this.cone),this.setDirection(t),this.setLength(n,i,s)}setDirection(t){if(t.y>.99999)this.quaternion.set(0,0,0,1);else if(t.y<-.99999)this.quaternion.set(1,0,0,0);else{Bp.set(t.z,0,-t.x).normalize();const e=Math.acos(t.y);this.quaternion.setFromAxisAngle(Bp,e)}}setLength(t,e=.2*t,n=.2*e){this.line.scale.set(1,Math.max(1e-4,t-e),1),this.line.updateMatrix(),this.cone.scale.set(n,e,n),this.cone.position.y=t,this.cone.updateMatrix()}setColor(t){this.line.material.color.set(t),this.cone.material.color.set(t)}copy(t){return super.copy(t,!1),this.line.copy(t.line),this.cone.copy(t.cone),this}}class Gp extends Sc{constructor(t=1){const e=[0,0,0,t,0,0,0,0,0,0,t,0,0,0,0,0,0,t],n=new Ki;n.setAttribute("position",new Vi(e,3)),n.setAttribute("color",new Vi([1,0,0,1,.6,0,0,1,0,.6,1,0,0,0,1,0,.6,1],3)),super(n,new gc({vertexColors:!0,toneMapped:!1})),this.type="AxesHelper"}setColors(t,e,n){const r=new Li,i=this.geometry.attributes.color.array;return r.set(t),r.toArray(i,0),r.toArray(i,3),r.set(e),r.toArray(i,6),r.toArray(i,9),r.set(n),r.toArray(i,12),r.toArray(i,15),this.geometry.attributes.color.needsUpdate=!0,this}dispose(){this.geometry.dispose(),this.material.dispose()}}class Vp{constructor(){this.type="ShapePath",this.color=new Li,this.subPaths=[],this.currentPath=null}moveTo(t,e){return this.currentPath=new mh,this.subPaths.push(this.currentPath),this.currentPath.moveTo(t,e),this}lineTo(t,e){return this.currentPath.lineTo(t,e),this}quadraticCurveTo(t,e,n,r){return this.currentPath.quadraticCurveTo(t,e,n,r),this}bezierCurveTo(t,e,n,r,i,s){return this.currentPath.bezierCurveTo(t,e,n,r,i,s),this}splineThru(t){return this.currentPath.splineThru(t),this}toShapes(t,e){function n(t){const e=[];for(let n=0,r=t.length;n<r;n++){const r=t[n],i=new gh;i.curves=r.curves,e.push(i)}return e}function r(t,e){const n=e.length;let r=!1;for(let i=n-1,s=0;s<n;i=s++){let n=e[i],a=e[s],o=a.x-n.x,l=a.y-n.y;if(Math.abs(l)>Number.EPSILON){if(l<0&&(n=e[s],o=-o,a=e[i],l=-l),t.y<n.y||t.y>a.y)continue;if(t.y===n.y){if(t.x===n.x)return!0}else{const e=l*(t.x-n.x)-o*(t.y-n.y);if(0===e)return!0;if(e<0)continue;r=!r}}else{if(t.y!==n.y)continue;if(a.x<=t.x&&t.x<=n.x||n.x<=t.x&&t.x<=a.x)return!0}}return r}const i=Hh.isClockWise,s=this.subPaths;if(0===s.length)return[];if(!0===e)return n(s);let a,o,l;const c=[];if(1===s.length)return o=s[0],l=new gh,l.curves=o.curves,c.push(l),c;let h=!i(s[0].getPoints());h=t?!h:h;const u=[],d=[];let p,f,m=[],g=0;d[g]=void 0,m[g]=[];for(let e=0,n=s.length;e<n;e++)o=s[e],p=o.getPoints(),a=i(p),a=t?!a:a,a?(!h&&d[g]&&g++,d[g]={s:new gh,p},d[g].s.curves=o.curves,h&&g++,m[g]=[]):m[g].push({h:o,p:p[0]});if(!d[0])return n(s);if(d.length>1){let t=!1;const e=[];for(let t=0,e=d.length;t<e;t++)u[t]=[];for(let n=0,i=d.length;n<i;n++){const i=m[n];for(let s=0;s<i.length;s++){const a=i[s];let o=!0;for(let i=0;i<d.length;i++)r(a.p,d[i].p)&&(n!==i&&e.push({froms:n,tos:i,hole:s}),o?(o=!1,u[i].push(a)):t=!0);o&&u[n].push(a)}}e.length>0&&(t||(m=u))}for(let t=0,e=d.length;t<e;t++){l=d[t].s,c.push(l),f=m[t];for(let t=0,e=f.length;t<e;t++)l.holes.push(f[t].h)}return c}}const Wp=new Float32Array(1),Xp=new Int32Array(Wp.buffer);class jp{static toHalfFloat(t){t>65504&&(console.warn("THREE.DataUtils.toHalfFloat(): value exceeds 65504."),t=65504),Wp[0]=t;const e=Xp[0];let n=e>>16&32768,r=e>>12&2047;const i=e>>23&255;return i<103?n:i>142?(n|=31744,n|=(255==i?0:1)&&8388607&e,n):i<113?(r|=2048,n|=(r>>114-i)+(r>>113-i&1),n):(n|=i-112<<10|r>>1,n+=1&r,n)}}const Yp=0,qp=1,Qp=0,Zp=1,Jp=2;function Kp(t){return console.warn("THREE.MeshFaceMaterial has been removed. Use an Array instead."),t}function $p(t=[]){return console.warn("THREE.MultiMaterial has been removed. Use an Array instead."),t.isMultiMaterial=!0,t.materials=t,t.clone=function(){return t.slice()},t}function tf(t,e){return console.warn("THREE.PointCloud has been renamed to THREE.Points."),new Fc(t,e)}function ef(t){return console.warn("THREE.Particle has been renamed to THREE.Sprite."),new ql(t)}function nf(t,e){return console.warn("THREE.ParticleSystem has been renamed to THREE.Points."),new Fc(t,e)}function rf(t){return console.warn("THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial."),new Ec(t)}function sf(t){return console.warn("THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial."),new Ec(t)}function af(t){return console.warn("THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial."),new Ec(t)}function of(t,e,n){return console.warn("THREE.Vertex has been removed. Use THREE.Vector3 instead."),new lr(t,e,n)}function lf(t,e){return console.warn("THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setUsage( THREE.DynamicDrawUsage ) instead."),new Ii(t,e).setUsage(Mn)}function cf(t,e){return console.warn("THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead."),new Ui(t,e)}function hf(t,e){return console.warn("THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead."),new Ni(t,e)}function uf(t,e){return console.warn("THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead."),new Oi(t,e)}function df(t,e){return console.warn("THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead."),new Bi(t,e)}function pf(t,e){return console.warn("THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead."),new zi(t,e)}function ff(t,e){return console.warn("THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead."),new ki(t,e)}function mf(t,e){return console.warn("THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead."),new Hi(t,e)}function gf(t,e){return console.warn("THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead."),new Vi(t,e)}function vf(t,e){return console.warn("THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead."),new Wi(t,e)}function xf(t){return console.warn("THREE.AxisHelper has been renamed to THREE.AxesHelper."),new Gp(t)}function yf(t,e){return console.warn("THREE.BoundingBoxHelper has been deprecated. Creating a THREE.BoxHelper instead."),new Up(t,e)}function wf(t,e){return console.warn("THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead."),new Sc(new Yc(t.geometry),new gc({color:void 0!==e?e:16777215}))}function bf(t,e){return console.warn("THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead."),new Sc(new nu(t.geometry),new gc({color:void 0!==e?e:16777215}))}function _f(t){return console.warn("THREE.XHRLoader has been renamed to THREE.FileLoader."),new Uu(t)}function Mf(t){return console.warn("THREE.BinaryTextureLoader has been renamed to THREE.DataTextureLoader."),new ku(t)}function Tf(t,e,n){return console.warn("THREE.WebGLRenderTargetCube( width, height, options ) is now WebGLCubeRenderTarget( size, options )."),new Cs(t,n)}function Sf(){console.error("THREE.CanvasRenderer has been removed")}function Af(){console.error("THREE.JSONLoader has been removed.")}qc.create=function(t,e){return console.log("THREE.Curve.create() has been deprecated"),t.prototype=Object.create(qc.prototype),t.prototype.constructor=t,t.prototype.getPoint=e,t},mh.prototype.fromPoints=function(t){return console.warn("THREE.Path: .fromPoints() has been renamed to .setFromPoints()."),this.setFromPoints(t)},Tp.prototype.setColors=function(){console.error("THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.")},vp.prototype.update=function(){console.error("THREE.SkeletonHelper: update() no longer needs to be called.")},Du.prototype.extractUrlBase=function(t){return console.warn("THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead."),ld.extractUrlBase(t)},Du.Handlers={add:function(){console.error("THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead.")},get:function(){console.error("THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead.")}},lp.prototype.center=function(t){return console.warn("THREE.Box2: .center() has been renamed to .getCenter()."),this.getCenter(t)},lp.prototype.empty=function(){return console.warn("THREE.Box2: .empty() has been renamed to .isEmpty()."),this.isEmpty()},lp.prototype.isIntersectionBox=function(t){return console.warn("THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox()."),this.intersectsBox(t)},lp.prototype.size=function(t){return console.warn("THREE.Box2: .size() has been renamed to .getSize()."),this.getSize(t)},ur.prototype.center=function(t){return console.warn("THREE.Box3: .center() has been renamed to .getCenter()."),this.getCenter(t)},ur.prototype.empty=function(){return console.warn("THREE.Box3: .empty() has been renamed to .isEmpty()."),this.isEmpty()},ur.prototype.isIntersectionBox=function(t){return console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."),this.intersectsBox(t)},ur.prototype.isIntersectionSphere=function(t){return console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."),this.intersectsSphere(t)},ur.prototype.size=function(t){return console.warn("THREE.Box3: .size() has been renamed to .getSize()."),this.getSize(t)},Lr.prototype.empty=function(){return console.warn("THREE.Sphere: .empty() has been renamed to .isEmpty()."),this.isEmpty()},Us.prototype.setFromMatrix=function(t){return console.warn("THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix()."),this.setFromProjectionMatrix(t)},up.prototype.center=function(t){return console.warn("THREE.Line3: .center() has been renamed to .getCenter()."),this.getCenter(t)},Yn.prototype.flattenToArrayOffset=function(t,e){return console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."),this.toArray(t,e)},Yn.prototype.multiplyVector3=function(t){return console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."),t.applyMatrix3(this)},Yn.prototype.multiplyVector3Array=function(){console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.")},Yn.prototype.applyToBufferAttribute=function(t){return console.warn("THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead."),t.applyMatrix3(this)},Yn.prototype.applyToVector3Array=function(){console.error("THREE.Matrix3: .applyToVector3Array() has been removed.")},Yn.prototype.getInverse=function(t){return console.warn("THREE.Matrix3: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."),this.copy(t).invert()},zr.prototype.extractPosition=function(t){return console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."),this.copyPosition(t)},zr.prototype.flattenToArrayOffset=function(t,e){return console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."),this.toArray(t,e)},zr.prototype.getPosition=function(){return console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."),(new lr).setFromMatrixColumn(this,3)},zr.prototype.setRotationFromQuaternion=function(t){return console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."),this.makeRotationFromQuaternion(t)},zr.prototype.multiplyToArray=function(){console.warn("THREE.Matrix4: .multiplyToArray() has been removed.")},zr.prototype.multiplyVector3=function(t){return console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead."),t.applyMatrix4(this)},zr.prototype.multiplyVector4=function(t){return console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."),t.applyMatrix4(this)},zr.prototype.multiplyVector3Array=function(){console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.")},zr.prototype.rotateAxis=function(t){console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."),t.transformDirection(this)},zr.prototype.crossVector=function(t){return console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."),t.applyMatrix4(this)},zr.prototype.translate=function(){console.error("THREE.Matrix4: .translate() has been removed.")},zr.prototype.rotateX=function(){console.error("THREE.Matrix4: .rotateX() has been removed.")},zr.prototype.rotateY=function(){console.error("THREE.Matrix4: .rotateY() has been removed.")},zr.prototype.rotateZ=function(){console.error("THREE.Matrix4: .rotateZ() has been removed.")},zr.prototype.rotateByAxis=function(){console.error("THREE.Matrix4: .rotateByAxis() has been removed.")},zr.prototype.applyToBufferAttribute=function(t){return console.warn("THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead."),t.applyMatrix4(this)},zr.prototype.applyToVector3Array=function(){console.error("THREE.Matrix4: .applyToVector3Array() has been removed.")},zr.prototype.makeFrustum=function(t,e,n,r,i,s){return console.warn("THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead."),this.makePerspective(t,e,r,n,i,s)},zr.prototype.getInverse=function(t){return console.warn("THREE.Matrix4: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."),this.copy(t).invert()},Fs.prototype.isIntersectionLine=function(t){return console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."),this.intersectsLine(t)},or.prototype.multiplyVector3=function(t){return console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."),t.applyQuaternion(this)},or.prototype.inverse=function(){return console.warn("THREE.Quaternion: .inverse() has been renamed to invert()."),this.invert()},Br.prototype.isIntersectionBox=function(t){return console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."),this.intersectsBox(t)},Br.prototype.isIntersectionPlane=function(t){return console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."),this.intersectsPlane(t)},Br.prototype.isIntersectionSphere=function(t){return console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."),this.intersectsSphere(t)},bi.prototype.area=function(){return console.warn("THREE.Triangle: .area() has been renamed to .getArea()."),this.getArea()},bi.prototype.barycoordFromPoint=function(t,e){return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."),this.getBarycoord(t,e)},bi.prototype.midpoint=function(t){return console.warn("THREE.Triangle: .midpoint() has been renamed to .getMidpoint()."),this.getMidpoint(t)},bi.prototypenormal=function(t){return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."),this.getNormal(t)},bi.prototype.plane=function(t){return console.warn("THREE.Triangle: .plane() has been renamed to .getPlane()."),this.getPlane(t)},bi.barycoordFromPoint=function(t,e,n,r,i){return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."),bi.getBarycoord(t,e,n,r,i)},bi.normal=function(t,e,n,r){return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."),bi.getNormal(t,e,n,r)},gh.prototype.extractAllPoints=function(t){return console.warn("THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead."),this.extractPoints(t)},gh.prototype.extrude=function(t){return console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead."),new Wh(this,t)},gh.prototype.makeGeometry=function(t){return console.warn("THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead."),new Zh(this,t)},jn.prototype.fromAttribute=function(t,e,n){return console.warn("THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute()."),this.fromBufferAttribute(t,e,n)},jn.prototype.distanceToManhattan=function(t){return console.warn("THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."),this.manhattanDistanceTo(t)},jn.prototype.lengthManhattan=function(){return console.warn("THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength()."),this.manhattanLength()},lr.prototype.setEulerFromRotationMatrix=function(){console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.")},lr.prototype.setEulerFromQuaternion=function(){console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.")},lr.prototype.getPositionFromMatrix=function(t){return console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."),this.setFromMatrixPosition(t)},lr.prototype.getScaleFromMatrix=function(t){return console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."),this.setFromMatrixScale(t)},lr.prototype.getColumnFromMatrix=function(t,e){return console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."),this.setFromMatrixColumn(e,t)},lr.prototype.applyProjection=function(t){return console.warn("THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead."),this.applyMatrix4(t)},lr.prototype.fromAttribute=function(t,e,n){return console.warn("THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute()."),this.fromBufferAttribute(t,e,n)},lr.prototype.distanceToManhattan=function(t){return console.warn("THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."),this.manhattanDistanceTo(t)},lr.prototype.lengthManhattan=function(){return console.warn("THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength()."),this.manhattanLength()},rr.prototype.fromAttribute=function(t,e,n){return console.warn("THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute()."),this.fromBufferAttribute(t,e,n)},rr.prototype.lengthManhattan=function(){return console.warn("THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength()."),this.manhattanLength()},hi.prototype.getChildByName=function(t){return console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."),this.getObjectByName(t)},hi.prototype.renderDepth=function(){console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.")},hi.prototype.translate=function(t,e){return console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."),this.translateOnAxis(e,t)},hi.prototype.getWorldRotation=function(){console.error("THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.")},hi.prototype.applyMatrix=function(t){return console.warn("THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4()."),this.applyMatrix4(t)},Object.defineProperties(hi.prototype,{eulerOrder:{get:function(){return console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."),this.rotation.order},set:function(t){console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."),this.rotation.order=t}},useQuaternion:{get:function(){console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")},set:function(){console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")}}}),gs.prototype.setDrawMode=function(){console.error("THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.")},Object.defineProperties(gs.prototype,{drawMode:{get:function(){return console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode."),Ze},set:function(){console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.")}}}),ic.prototype.initBones=function(){console.error("THREE.SkinnedMesh: initBones() has been removed.")},Ts.prototype.setLens=function(t,e){console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."),void 0!==e&&(this.filmGauge=e),this.setFocalLength(t)},Object.defineProperties(Gu.prototype,{onlyShadow:{set:function(){console.warn("THREE.Light: .onlyShadow has been removed.")}},shadowCameraFov:{set:function(t){console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov."),this.shadow.camera.fov=t}},shadowCameraLeft:{set:function(t){console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left."),this.shadow.camera.left=t}},shadowCameraRight:{set:function(t){console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right."),this.shadow.camera.right=t}},shadowCameraTop:{set:function(t){console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top."),this.shadow.camera.top=t}},shadowCameraBottom:{set:function(t){console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."),this.shadow.camera.bottom=t}},shadowCameraNear:{set:function(t){console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near."),this.shadow.camera.near=t}},shadowCameraFar:{set:function(t){console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far."),this.shadow.camera.far=t}},shadowCameraVisible:{set:function(){console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.")}},shadowBias:{set:function(t){console.warn("THREE.Light: .shadowBias is now .shadow.bias."),this.shadow.bias=t}},shadowDarkness:{set:function(){console.warn("THREE.Light: .shadowDarkness has been removed.")}},shadowMapWidth:{set:function(t){console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."),this.shadow.mapSize.width=t}},shadowMapHeight:{set:function(t){console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."),this.shadow.mapSize.height=t}}}),Object.defineProperties(Ii.prototype,{length:{get:function(){return console.warn("THREE.BufferAttribute: .length has been deprecated. Use .count instead."),this.array.length}},dynamic:{get:function(){return console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."),this.usage===Mn},set:function(){console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."),this.setUsage(Mn)}}}),Ii.prototype.setDynamic=function(t){return console.warn("THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead."),this.setUsage(!0===t?Mn:_n),this},Ii.prototype.copyIndicesArray=function(){console.error("THREE.BufferAttribute: .copyIndicesArray() has been removed.")},Ii.prototype.setArray=function(){console.error("THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers")},Ki.prototype.addIndex=function(t){console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."),this.setIndex(t)},Ki.prototype.addAttribute=function(t,e){return console.warn("THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute()."),e&&e.isBufferAttribute||e&&e.isInterleavedBufferAttribute?"index"===t?(console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."),this.setIndex(e),this):this.setAttribute(t,e):(console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."),this.setAttribute(t,new Ii(arguments[1],arguments[2])))},Ki.prototype.addDrawCall=function(t,e,n){void 0!==n&&console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."),console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup()."),this.addGroup(t,e)},Ki.prototype.clearDrawCalls=function(){console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."),this.clearGroups()},Ki.prototype.computeOffsets=function(){console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.")},Ki.prototype.removeAttribute=function(t){return console.warn("THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute()."),this.deleteAttribute(t)},Ki.prototype.applyMatrix=function(t){return console.warn("THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4()."),this.applyMatrix4(t)},Object.defineProperties(Ki.prototype,{drawcalls:{get:function(){return console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups."),this.groups}},offsets:{get:function(){return console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups."),this.groups}}}),Rl.prototype.setDynamic=function(t){return console.warn("THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead."),this.setUsage(!0===t?Mn:_n),this},Rl.prototype.setArray=function(){console.error("THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers")},Wh.prototype.getArrays=function(){console.error("THREE.ExtrudeGeometry: .getArrays() has been removed.")},Wh.prototype.addShapeList=function(){console.error("THREE.ExtrudeGeometry: .addShapeList() has been removed.")},Wh.prototype.addShape=function(){console.error("THREE.ExtrudeGeometry: .addShape() has been removed.")},Ll.prototype.dispose=function(){console.error("THREE.Scene: .dispose() has been removed.")},$d.prototype.onUpdate=function(){return console.warn("THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead."),this},Object.defineProperties(Mi.prototype,{wrapAround:{get:function(){console.warn("THREE.Material: .wrapAround has been removed.")},set:function(){console.warn("THREE.Material: .wrapAround has been removed.")}},overdraw:{get:function(){console.warn("THREE.Material: .overdraw has been removed.")},set:function(){console.warn("THREE.Material: .overdraw has been removed.")}},wrapRGB:{get:function(){return console.warn("THREE.Material: .wrapRGB has been removed."),new Li}},shading:{get:function(){console.error("THREE."+this.type+": .shading has been removed. Use the boolean .flatShading instead.")},set:function(t){console.warn("THREE."+this.type+": .shading has been removed. Use the boolean .flatShading instead."),this.flatShading=t===b}},stencilMask:{get:function(){return console.warn("THREE."+this.type+": .stencilMask has been removed. Use .stencilFuncMask instead."),this.stencilFuncMask},set:function(t){console.warn("THREE."+this.type+": .stencilMask has been removed. Use .stencilFuncMask instead."),this.stencilFuncMask=t}},vertexTangents:{get:function(){console.warn("THREE."+this.type+": .vertexTangents has been removed.")},set:function(){console.warn("THREE."+this.type+": .vertexTangents has been removed.")}}}),Object.defineProperties(_s.prototype,{derivatives:{get:function(){return console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."),this.extensions.derivatives},set:function(t){console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."),this.extensions.derivatives=t}}}),Al.prototype.clearTarget=function(t,e,n,r){console.warn("THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead."),this.setRenderTarget(t),this.clear(e,n,r)},Al.prototype.animate=function(t){console.warn("THREE.WebGLRenderer: .animate() is now .setAnimationLoop()."),this.setAnimationLoop(t)},Al.prototype.getCurrentRenderTarget=function(){return console.warn("THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget()."),this.getRenderTarget()},Al.prototype.getMaxAnisotropy=function(){return console.warn("THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy()."),this.capabilities.getMaxAnisotropy()},Al.prototype.getPrecision=function(){return console.warn("THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision."),this.capabilities.precision},Al.prototype.resetGLState=function(){return console.warn("THREE.WebGLRenderer: .resetGLState() is now .state.reset()."),this.state.reset()},Al.prototype.supportsFloatTextures=function(){return console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."),this.extensions.get("OES_texture_float")},Al.prototype.supportsHalfFloatTextures=function(){return console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."),this.extensions.get("OES_texture_half_float")},Al.prototype.supportsStandardDerivatives=function(){return console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."),this.extensions.get("OES_standard_derivatives")},Al.prototype.supportsCompressedTextureS3TC=function(){return console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."),this.extensions.get("WEBGL_compressed_texture_s3tc")},Al.prototype.supportsCompressedTexturePVRTC=function(){return console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."),this.extensions.get("WEBGL_compressed_texture_pvrtc")},Al.prototype.supportsBlendMinMax=function(){return console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."),this.extensions.get("EXT_blend_minmax")},Al.prototype.supportsVertexTextures=function(){return console.warn("THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures."),this.capabilities.vertexTextures},Al.prototype.supportsInstancedArrays=function(){return console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."),this.extensions.get("ANGLE_instanced_arrays")},Al.prototype.enableScissorTest=function(t){console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."),this.setScissorTest(t)},Al.prototype.initMaterial=function(){console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.")},Al.prototype.addPrePlugin=function(){console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.")},Al.prototype.addPostPlugin=function(){console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.")},Al.prototype.updateShadowMap=function(){console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.")},Al.prototype.setFaceCulling=function(){console.warn("THREE.WebGLRenderer: .setFaceCulling() has been removed.")},Al.prototype.allocTextureUnit=function(){console.warn("THREE.WebGLRenderer: .allocTextureUnit() has been removed.")},Al.prototype.setTexture=function(){console.warn("THREE.WebGLRenderer: .setTexture() has been removed.")},Al.prototype.setTexture2D=function(){console.warn("THREE.WebGLRenderer: .setTexture2D() has been removed.")},Al.prototype.setTextureCube=function(){console.warn("THREE.WebGLRenderer: .setTextureCube() has been removed.")},Al.prototype.getActiveMipMapLevel=function(){return console.warn("THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel()."),this.getActiveMipmapLevel()},Object.defineProperties(Al.prototype,{shadowMapEnabled:{get:function(){return this.shadowMap.enabled},set:function(t){console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."),this.shadowMap.enabled=t}},shadowMapType:{get:function(){return this.shadowMap.type},set:function(t){console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."),this.shadowMap.type=t}},shadowMapCullFace:{get:function(){console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")},set:function(){console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")}},context:{get:function(){return console.warn("THREE.WebGLRenderer: .context has been removed. Use .getContext() instead."),this.getContext()}},vr:{get:function(){return console.warn("THREE.WebGLRenderer: .vr has been renamed to .xr"),this.xr}},gammaInput:{get:function(){return console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead."),!1},set:function(){console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.")}},gammaOutput:{get:function(){return console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."),!1},set:function(t){console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."),this.outputEncoding=!0===t?tn:$e}},toneMappingWhitePoint:{get:function(){return console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed."),1},set:function(){console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.")}},gammaFactor:{get:function(){return console.warn("THREE.WebGLRenderer: .gammaFactor has been removed."),2},set:function(){console.warn("THREE.WebGLRenderer: .gammaFactor has been removed.")}}}),Object.defineProperties(ml.prototype,{cullFace:{get:function(){console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")},set:function(){console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")}},renderReverseSided:{get:function(){console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")},set:function(){console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")}},renderSingleSided:{get:function(){console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")},set:function(){console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")}}}),Object.defineProperties(ir.prototype,{wrapS:{get:function(){return console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."),this.texture.wrapS},set:function(t){console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."),this.texture.wrapS=t}},wrapT:{get:function(){return console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."),this.texture.wrapT},set:function(t){console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."),this.texture.wrapT=t}},magFilter:{get:function(){return console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."),this.texture.magFilter},set:function(t){console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."),this.texture.magFilter=t}},minFilter:{get:function(){return console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."),this.texture.minFilter},set:function(t){console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."),this.texture.minFilter=t}},anisotropy:{get:function(){return console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."),this.texture.anisotropy},set:function(t){console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."),this.texture.anisotropy=t}},offset:{get:function(){return console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."),this.texture.offset},set:function(t){console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."),this.texture.offset=t}},repeat:{get:function(){return console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."),this.texture.repeat},set:function(t){console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."),this.texture.repeat=t}},format:{get:function(){return console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."),this.texture.format},set:function(t){console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."),this.texture.format=t}},type:{get:function(){return console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."),this.texture.type},set:function(t){console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."),this.texture.type=t}},generateMipmaps:{get:function(){return console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."),this.texture.generateMipmaps},set:function(t){console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."),this.texture.generateMipmaps=t}}}),Fd.prototype.load=function(t){console.warn("THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.");const e=this;return(new xd).load(t,(function(t){e.setBuffer(t)})),this},Bd.prototype.getData=function(){return console.warn("THREE.AudioAnalyser: .getData() is now .getFrequencyData()."),this.getFrequencyData()},As.prototype.updateCubeMap=function(t,e){return console.warn("THREE.CubeCamera: .updateCubeMap() is now .update()."),this.update(t,e)},As.prototype.clear=function(t,e,n,r){return console.warn("THREE.CubeCamera: .clear() is now .renderTarget.clear()."),this.renderTarget.clear(t,e,n,r)},$n.crossOrigin=void 0,$n.loadTexture=function(t,e,n,r){console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.");const i=new Hu;i.setCrossOrigin(this.crossOrigin);const s=i.load(t,n,void 0,r);return e&&(s.mapping=e),s},$n.loadTextureCube=function(t,e,n,r){console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.");const i=new zu;i.setCrossOrigin(this.crossOrigin);const s=i.load(t,n,void 0,r);return e&&(s.mapping=e),s},$n.loadCompressedTexture=function(){console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.")},$n.loadCompressedTextureCube=function(){console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.")};const Ef={createMultiMaterialObject:function(){console.error("THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js")},detach:function(){console.error("THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js")},attach:function(){console.error("THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js")}};function Cf(){console.error("THREE.LensFlare has been moved to /examples/jsm/objects/Lensflare.js")}function Pf(){return console.error("THREE.ParametricGeometry has been moved to /examples/jsm/geometries/ParametricGeometry.js"),new Ki}function Lf(){return console.error("THREE.TextGeometry has been moved to /examples/jsm/geometries/TextGeometry.js"),new Ki}function Rf(){console.error("THREE.FontLoader has been moved to /examples/jsm/loaders/FontLoader.js")}function Ff(){console.error("THREE.Font has been moved to /examples/jsm/loaders/FontLoader.js")}function Df(){console.error("THREE.ImmediateRenderObject has been removed.")}"undefined"!=typeof __THREE_DEVTOOLS__&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register",{detail:{revision:o}})),"undefined"!=typeof window&&(window.__THREE__?console.warn("WARNING: Multiple instances of Three.js being imported."):window.__THREE__=o);var If={uniforms:{tDiffuse:{value:null},opacity:{value:1}},vertexShader:"\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvUv = uv;\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t}",fragmentShader:"\n\n\t\tuniform float opacity;\n\n\t\tuniform sampler2D tDiffuse;\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvec4 texel = texture2D( tDiffuse, vUv );\n\t\t\tgl_FragColor = opacity * texel;\n\n\t\t}"};class Uf{constructor(){this.enabled=!0,this.needsSwap=!0,this.clear=!1,this.renderToScreen=!1}setSize(){}render(){console.error("THREE.Pass: .render() must be implemented in derived pass.")}}const Nf=new qs(-1,1,1,-1,0,1),Of=new Ki;Of.setAttribute("position",new Vi([-1,3,0,-1,-1,0,3,-1,0],3)),Of.setAttribute("uv",new Vi([0,2,0,0,2,0],2));class Bf{constructor(t){this._mesh=new gs(Of,t)}dispose(){this._mesh.geometry.dispose()}render(t){t.render(this._mesh,Nf)}get material(){return this._mesh.material}set material(t){this._mesh.material=t}}class zf extends Uf{constructor(t,e){super(),this.textureID=void 0!==e?e:"tDiffuse",t instanceof _s?(this.uniforms=t.uniforms,this.material=t):t&&(this.uniforms=bs.clone(t.uniforms),this.material=new _s({defines:Object.assign({},t.defines),uniforms:this.uniforms,vertexShader:t.vertexShader,fragmentShader:t.fragmentShader})),this.fsQuad=new Bf(this.material)}render(t,e,n){this.uniforms[this.textureID]&&(this.uniforms[this.textureID].value=n.texture),this.fsQuad.material=this.material,this.renderToScreen?(t.setRenderTarget(null),this.fsQuad.render(t)):(t.setRenderTarget(e),this.clear&&t.clear(t.autoClearColor,t.autoClearDepth,t.autoClearStencil),this.fsQuad.render(t))}}class kf extends Uf{constructor(t,e){super(),this.scene=t,this.camera=e,this.clear=!0,this.needsSwap=!1,this.inverse=!1}render(t,e,n){const r=t.getContext(),i=t.state;let s,a;i.buffers.color.setMask(!1),i.buffers.depth.setMask(!1),i.buffers.color.setLocked(!0),i.buffers.depth.setLocked(!0),this.inverse?(s=0,a=1):(s=1,a=0),i.buffers.stencil.setTest(!0),i.buffers.stencil.setOp(r.REPLACE,r.REPLACE,r.REPLACE),i.buffers.stencil.setFunc(r.ALWAYS,s,4294967295),i.buffers.stencil.setClear(a),i.buffers.stencil.setLocked(!0),t.setRenderTarget(n),this.clear&&t.clear(),t.render(this.scene,this.camera),t.setRenderTarget(e),this.clear&&t.clear(),t.render(this.scene,this.camera),i.buffers.color.setLocked(!1),i.buffers.depth.setLocked(!1),i.buffers.stencil.setLocked(!1),i.buffers.stencil.setFunc(r.EQUAL,1,4294967295),i.buffers.stencil.setOp(r.KEEP,r.KEEP,r.KEEP),i.buffers.stencil.setLocked(!0)}}class Hf extends Uf{constructor(){super(),this.needsSwap=!1}render(t){t.state.buffers.stencil.setLocked(!1),t.state.buffers.stencil.setTest(!1)}}new qs(-1,1,1,-1,0,1);const Gf=new Ki;Gf.setAttribute("position",new Vi([-1,3,0,-1,-1,0,3,-1,0],3)),Gf.setAttribute("uv",new Vi([0,2,0,0,2,0],2));const Vf={uniforms:{tDiffuse:{value:null},resolution:{value:new jn(1/1024,1/512)}},vertexShader:"\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvUv = uv;\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t}",fragmentShader:'\n\n\t\tprecision highp float;\n\n\t\tuniform sampler2D tDiffuse;\n\n\t\tuniform vec2 resolution;\n\n\t\tvarying vec2 vUv;\n\n\t\t#define FXAA_PC 1\n\t\t#define FXAA_GLSL_100 1\n\t\t#define FXAA_QUALITY_PRESET 12\n\n\t\t#define FXAA_GREEN_AS_LUMA 1\n\n\t\t/*--------------------------------------------------------------------------*/\n\t\t#ifndef FXAA_PC_CONSOLE\n\t\t\t\t//\n\t\t\t\t// The console algorithm for PC is included\n\t\t\t\t// for developers targeting really low spec machines.\n\t\t\t\t// Likely better to just run FXAA_PC, and use a really low preset.\n\t\t\t\t//\n\t\t\t\t#define FXAA_PC_CONSOLE 0\n\t\t#endif\n\t\t/*--------------------------------------------------------------------------*/\n\t\t#ifndef FXAA_GLSL_120\n\t\t\t\t#define FXAA_GLSL_120 0\n\t\t#endif\n\t\t/*--------------------------------------------------------------------------*/\n\t\t#ifndef FXAA_GLSL_130\n\t\t\t\t#define FXAA_GLSL_130 0\n\t\t#endif\n\t\t/*--------------------------------------------------------------------------*/\n\t\t#ifndef FXAA_HLSL_3\n\t\t\t\t#define FXAA_HLSL_3 0\n\t\t#endif\n\t\t/*--------------------------------------------------------------------------*/\n\t\t#ifndef FXAA_HLSL_4\n\t\t\t\t#define FXAA_HLSL_4 0\n\t\t#endif\n\t\t/*--------------------------------------------------------------------------*/\n\t\t#ifndef FXAA_HLSL_5\n\t\t\t\t#define FXAA_HLSL_5 0\n\t\t#endif\n\t\t/*==========================================================================*/\n\t\t#ifndef FXAA_GREEN_AS_LUMA\n\t\t\t\t//\n\t\t\t\t// For those using non-linear color,\n\t\t\t\t// and either not able to get luma in alpha, or not wanting to,\n\t\t\t\t// this enables FXAA to run using green as a proxy for luma.\n\t\t\t\t// So with this enabled, no need to pack luma in alpha.\n\t\t\t\t//\n\t\t\t\t// This will turn off AA on anything which lacks some amount of green.\n\t\t\t\t// Pure red and blue or combination of only R and B, will get no AA.\n\t\t\t\t//\n\t\t\t\t// Might want to lower the settings for both,\n\t\t\t\t//\t\tfxaaConsoleEdgeThresholdMin\n\t\t\t\t//\t\tfxaaQualityEdgeThresholdMin\n\t\t\t\t// In order to insure AA does not get turned off on colors\n\t\t\t\t// which contain a minor amount of green.\n\t\t\t\t//\n\t\t\t\t// 1 = On.\n\t\t\t\t// 0 = Off.\n\t\t\t\t//\n\t\t\t\t#define FXAA_GREEN_AS_LUMA 0\n\t\t#endif\n\t\t/*--------------------------------------------------------------------------*/\n\t\t#ifndef FXAA_EARLY_EXIT\n\t\t\t\t//\n\t\t\t\t// Controls algorithm\'s early exit path.\n\t\t\t\t// On PS3 turning this ON adds 2 cycles to the shader.\n\t\t\t\t// On 360 turning this OFF adds 10ths of a millisecond to the shader.\n\t\t\t\t// Turning this off on console will result in a more blurry image.\n\t\t\t\t// So this defaults to on.\n\t\t\t\t//\n\t\t\t\t// 1 = On.\n\t\t\t\t// 0 = Off.\n\t\t\t\t//\n\t\t\t\t#define FXAA_EARLY_EXIT 1\n\t\t#endif\n\t\t/*--------------------------------------------------------------------------*/\n\t\t#ifndef FXAA_DISCARD\n\t\t\t\t//\n\t\t\t\t// Only valid for PC OpenGL currently.\n\t\t\t\t// Probably will not work when FXAA_GREEN_AS_LUMA = 1.\n\t\t\t\t//\n\t\t\t\t// 1 = Use discard on pixels which don\'t need AA.\n\t\t\t\t//\t\t For APIs which enable concurrent TEX+ROP from same surface.\n\t\t\t\t// 0 = Return unchanged color on pixels which don\'t need AA.\n\t\t\t\t//\n\t\t\t\t#define FXAA_DISCARD 0\n\t\t#endif\n\t\t/*--------------------------------------------------------------------------*/\n\t\t#ifndef FXAA_FAST_PIXEL_OFFSET\n\t\t\t\t//\n\t\t\t\t// Used for GLSL 120 only.\n\t\t\t\t//\n\t\t\t\t// 1 = GL API supports fast pixel offsets\n\t\t\t\t// 0 = do not use fast pixel offsets\n\t\t\t\t//\n\t\t\t\t#ifdef GL_EXT_gpu_shader4\n\t\t\t\t\t\t#define FXAA_FAST_PIXEL_OFFSET 1\n\t\t\t\t#endif\n\t\t\t\t#ifdef GL_NV_gpu_shader5\n\t\t\t\t\t\t#define FXAA_FAST_PIXEL_OFFSET 1\n\t\t\t\t#endif\n\t\t\t\t#ifdef GL_ARB_gpu_shader5\n\t\t\t\t\t\t#define FXAA_FAST_PIXEL_OFFSET 1\n\t\t\t\t#endif\n\t\t\t\t#ifndef FXAA_FAST_PIXEL_OFFSET\n\t\t\t\t\t\t#define FXAA_FAST_PIXEL_OFFSET 0\n\t\t\t\t#endif\n\t\t#endif\n\t\t/*--------------------------------------------------------------------------*/\n\t\t#ifndef FXAA_GATHER4_ALPHA\n\t\t\t\t//\n\t\t\t\t// 1 = API supports gather4 on alpha channel.\n\t\t\t\t// 0 = API does not support gather4 on alpha channel.\n\t\t\t\t//\n\t\t\t\t#if (FXAA_HLSL_5 == 1)\n\t\t\t\t\t\t#define FXAA_GATHER4_ALPHA 1\n\t\t\t\t#endif\n\t\t\t\t#ifdef GL_ARB_gpu_shader5\n\t\t\t\t\t\t#define FXAA_GATHER4_ALPHA 1\n\t\t\t\t#endif\n\t\t\t\t#ifdef GL_NV_gpu_shader5\n\t\t\t\t\t\t#define FXAA_GATHER4_ALPHA 1\n\t\t\t\t#endif\n\t\t\t\t#ifndef FXAA_GATHER4_ALPHA\n\t\t\t\t\t\t#define FXAA_GATHER4_ALPHA 0\n\t\t\t\t#endif\n\t\t#endif\n\n\n\t\t/*============================================================================\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tFXAA QUALITY - TUNING KNOBS\n\t\t------------------------------------------------------------------------------\n\t\tNOTE the other tuning knobs are now in the shader function inputs!\n\t\t============================================================================*/\n\t\t#ifndef FXAA_QUALITY_PRESET\n\t\t\t\t//\n\t\t\t\t// Choose the quality preset.\n\t\t\t\t// This needs to be compiled into the shader as it effects code.\n\t\t\t\t// Best option to include multiple presets is to\n\t\t\t\t// in each shader define the preset, then include this file.\n\t\t\t\t//\n\t\t\t\t// OPTIONS\n\t\t\t\t// -----------------------------------------------------------------------\n\t\t\t\t// 10 to 15 - default medium dither (10=fastest, 15=highest quality)\n\t\t\t\t// 20 to 29 - less dither, more expensive (20=fastest, 29=highest quality)\n\t\t\t\t// 39\t\t\t - no dither, very expensive\n\t\t\t\t//\n\t\t\t\t// NOTES\n\t\t\t\t// -----------------------------------------------------------------------\n\t\t\t\t// 12 = slightly faster then FXAA 3.9 and higher edge quality (default)\n\t\t\t\t// 13 = about same speed as FXAA 3.9 and better than 12\n\t\t\t\t// 23 = closest to FXAA 3.9 visually and performance wise\n\t\t\t\t//\t_ = the lowest digit is directly related to performance\n\t\t\t\t// _\t= the highest digit is directly related to style\n\t\t\t\t//\n\t\t\t\t#define FXAA_QUALITY_PRESET 12\n\t\t#endif\n\n\n\t\t/*============================================================================\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t FXAA QUALITY - PRESETS\n\n\t\t============================================================================*/\n\n\t\t/*============================================================================\n\t\t\t\t\t\t\t\t\t\t\t\t FXAA QUALITY - MEDIUM DITHER PRESETS\n\t\t============================================================================*/\n\t\t#if (FXAA_QUALITY_PRESET == 10)\n\t\t\t\t#define FXAA_QUALITY_PS 3\n\t\t\t\t#define FXAA_QUALITY_P0 1.5\n\t\t\t\t#define FXAA_QUALITY_P1 3.0\n\t\t\t\t#define FXAA_QUALITY_P2 12.0\n\t\t#endif\n\t\t/*--------------------------------------------------------------------------*/\n\t\t#if (FXAA_QUALITY_PRESET == 11)\n\t\t\t\t#define FXAA_QUALITY_PS 4\n\t\t\t\t#define FXAA_QUALITY_P0 1.0\n\t\t\t\t#define FXAA_QUALITY_P1 1.5\n\t\t\t\t#define FXAA_QUALITY_P2 3.0\n\t\t\t\t#define FXAA_QUALITY_P3 12.0\n\t\t#endif\n\t\t/*--------------------------------------------------------------------------*/\n\t\t#if (FXAA_QUALITY_PRESET == 12)\n\t\t\t\t#define FXAA_QUALITY_PS 5\n\t\t\t\t#define FXAA_QUALITY_P0 1.0\n\t\t\t\t#define FXAA_QUALITY_P1 1.5\n\t\t\t\t#define FXAA_QUALITY_P2 2.0\n\t\t\t\t#define FXAA_QUALITY_P3 4.0\n\t\t\t\t#define FXAA_QUALITY_P4 12.0\n\t\t#endif\n\t\t/*--------------------------------------------------------------------------*/\n\t\t#if (FXAA_QUALITY_PRESET == 13)\n\t\t\t\t#define FXAA_QUALITY_PS 6\n\t\t\t\t#define FXAA_QUALITY_P0 1.0\n\t\t\t\t#define FXAA_QUALITY_P1 1.5\n\t\t\t\t#define FXAA_QUALITY_P2 2.0\n\t\t\t\t#define FXAA_QUALITY_P3 2.0\n\t\t\t\t#define FXAA_QUALITY_P4 4.0\n\t\t\t\t#define FXAA_QUALITY_P5 12.0\n\t\t#endif\n\t\t/*--------------------------------------------------------------------------*/\n\t\t#if (FXAA_QUALITY_PRESET == 14)\n\t\t\t\t#define FXAA_QUALITY_PS 7\n\t\t\t\t#define FXAA_QUALITY_P0 1.0\n\t\t\t\t#define FXAA_QUALITY_P1 1.5\n\t\t\t\t#define FXAA_QUALITY_P2 2.0\n\t\t\t\t#define FXAA_QUALITY_P3 2.0\n\t\t\t\t#define FXAA_QUALITY_P4 2.0\n\t\t\t\t#define FXAA_QUALITY_P5 4.0\n\t\t\t\t#define FXAA_QUALITY_P6 12.0\n\t\t#endif\n\t\t/*--------------------------------------------------------------------------*/\n\t\t#if (FXAA_QUALITY_PRESET == 15)\n\t\t\t\t#define FXAA_QUALITY_PS 8\n\t\t\t\t#define FXAA_QUALITY_P0 1.0\n\t\t\t\t#define FXAA_QUALITY_P1 1.5\n\t\t\t\t#define FXAA_QUALITY_P2 2.0\n\t\t\t\t#define FXAA_QUALITY_P3 2.0\n\t\t\t\t#define FXAA_QUALITY_P4 2.0\n\t\t\t\t#define FXAA_QUALITY_P5 2.0\n\t\t\t\t#define FXAA_QUALITY_P6 4.0\n\t\t\t\t#define FXAA_QUALITY_P7 12.0\n\t\t#endif\n\n\t\t/*============================================================================\n\t\t\t\t\t\t\t\t\t\t\t\t FXAA QUALITY - LOW DITHER PRESETS\n\t\t============================================================================*/\n\t\t#if (FXAA_QUALITY_PRESET == 20)\n\t\t\t\t#define FXAA_QUALITY_PS 3\n\t\t\t\t#define FXAA_QUALITY_P0 1.5\n\t\t\t\t#define FXAA_QUALITY_P1 2.0\n\t\t\t\t#define FXAA_QUALITY_P2 8.0\n\t\t#endif\n\t\t/*--------------------------------------------------------------------------*/\n\t\t#if (FXAA_QUALITY_PRESET == 21)\n\t\t\t\t#define FXAA_QUALITY_PS 4\n\t\t\t\t#define FXAA_QUALITY_P0 1.0\n\t\t\t\t#define FXAA_QUALITY_P1 1.5\n\t\t\t\t#define FXAA_QUALITY_P2 2.0\n\t\t\t\t#define FXAA_QUALITY_P3 8.0\n\t\t#endif\n\t\t/*--------------------------------------------------------------------------*/\n\t\t#if (FXAA_QUALITY_PRESET == 22)\n\t\t\t\t#define FXAA_QUALITY_PS 5\n\t\t\t\t#define FXAA_QUALITY_P0 1.0\n\t\t\t\t#define FXAA_QUALITY_P1 1.5\n\t\t\t\t#define FXAA_QUALITY_P2 2.0\n\t\t\t\t#define FXAA_QUALITY_P3 2.0\n\t\t\t\t#define FXAA_QUALITY_P4 8.0\n\t\t#endif\n\t\t/*--------------------------------------------------------------------------*/\n\t\t#if (FXAA_QUALITY_PRESET == 23)\n\t\t\t\t#define FXAA_QUALITY_PS 6\n\t\t\t\t#define FXAA_QUALITY_P0 1.0\n\t\t\t\t#define FXAA_QUALITY_P1 1.5\n\t\t\t\t#define FXAA_QUALITY_P2 2.0\n\t\t\t\t#define FXAA_QUALITY_P3 2.0\n\t\t\t\t#define FXAA_QUALITY_P4 2.0\n\t\t\t\t#define FXAA_QUALITY_P5 8.0\n\t\t#endif\n\t\t/*--------------------------------------------------------------------------*/\n\t\t#if (FXAA_QUALITY_PRESET == 24)\n\t\t\t\t#define FXAA_QUALITY_PS 7\n\t\t\t\t#define FXAA_QUALITY_P0 1.0\n\t\t\t\t#define FXAA_QUALITY_P1 1.5\n\t\t\t\t#define FXAA_QUALITY_P2 2.0\n\t\t\t\t#define FXAA_QUALITY_P3 2.0\n\t\t\t\t#define FXAA_QUALITY_P4 2.0\n\t\t\t\t#define FXAA_QUALITY_P5 3.0\n\t\t\t\t#define FXAA_QUALITY_P6 8.0\n\t\t#endif\n\t\t/*--------------------------------------------------------------------------*/\n\t\t#if (FXAA_QUALITY_PRESET == 25)\n\t\t\t\t#define FXAA_QUALITY_PS 8\n\t\t\t\t#define FXAA_QUALITY_P0 1.0\n\t\t\t\t#define FXAA_QUALITY_P1 1.5\n\t\t\t\t#define FXAA_QUALITY_P2 2.0\n\t\t\t\t#define FXAA_QUALITY_P3 2.0\n\t\t\t\t#define FXAA_QUALITY_P4 2.0\n\t\t\t\t#define FXAA_QUALITY_P5 2.0\n\t\t\t\t#define FXAA_QUALITY_P6 4.0\n\t\t\t\t#define FXAA_QUALITY_P7 8.0\n\t\t#endif\n\t\t/*--------------------------------------------------------------------------*/\n\t\t#if (FXAA_QUALITY_PRESET == 26)\n\t\t\t\t#define FXAA_QUALITY_PS 9\n\t\t\t\t#define FXAA_QUALITY_P0 1.0\n\t\t\t\t#define FXAA_QUALITY_P1 1.5\n\t\t\t\t#define FXAA_QUALITY_P2 2.0\n\t\t\t\t#define FXAA_QUALITY_P3 2.0\n\t\t\t\t#define FXAA_QUALITY_P4 2.0\n\t\t\t\t#define FXAA_QUALITY_P5 2.0\n\t\t\t\t#define FXAA_QUALITY_P6 2.0\n\t\t\t\t#define FXAA_QUALITY_P7 4.0\n\t\t\t\t#define FXAA_QUALITY_P8 8.0\n\t\t#endif\n\t\t/*--------------------------------------------------------------------------*/\n\t\t#if (FXAA_QUALITY_PRESET == 27)\n\t\t\t\t#define FXAA_QUALITY_PS 10\n\t\t\t\t#define FXAA_QUALITY_P0 1.0\n\t\t\t\t#define FXAA_QUALITY_P1 1.5\n\t\t\t\t#define FXAA_QUALITY_P2 2.0\n\t\t\t\t#define FXAA_QUALITY_P3 2.0\n\t\t\t\t#define FXAA_QUALITY_P4 2.0\n\t\t\t\t#define FXAA_QUALITY_P5 2.0\n\t\t\t\t#define FXAA_QUALITY_P6 2.0\n\t\t\t\t#define FXAA_QUALITY_P7 2.0\n\t\t\t\t#define FXAA_QUALITY_P8 4.0\n\t\t\t\t#define FXAA_QUALITY_P9 8.0\n\t\t#endif\n\t\t/*--------------------------------------------------------------------------*/\n\t\t#if (FXAA_QUALITY_PRESET == 28)\n\t\t\t\t#define FXAA_QUALITY_PS 11\n\t\t\t\t#define FXAA_QUALITY_P0 1.0\n\t\t\t\t#define FXAA_QUALITY_P1 1.5\n\t\t\t\t#define FXAA_QUALITY_P2 2.0\n\t\t\t\t#define FXAA_QUALITY_P3 2.0\n\t\t\t\t#define FXAA_QUALITY_P4 2.0\n\t\t\t\t#define FXAA_QUALITY_P5 2.0\n\t\t\t\t#define FXAA_QUALITY_P6 2.0\n\t\t\t\t#define FXAA_QUALITY_P7 2.0\n\t\t\t\t#define FXAA_QUALITY_P8 2.0\n\t\t\t\t#define FXAA_QUALITY_P9 4.0\n\t\t\t\t#define FXAA_QUALITY_P10 8.0\n\t\t#endif\n\t\t/*--------------------------------------------------------------------------*/\n\t\t#if (FXAA_QUALITY_PRESET == 29)\n\t\t\t\t#define FXAA_QUALITY_PS 12\n\t\t\t\t#define FXAA_QUALITY_P0 1.0\n\t\t\t\t#define FXAA_QUALITY_P1 1.5\n\t\t\t\t#define FXAA_QUALITY_P2 2.0\n\t\t\t\t#define FXAA_QUALITY_P3 2.0\n\t\t\t\t#define FXAA_QUALITY_P4 2.0\n\t\t\t\t#define FXAA_QUALITY_P5 2.0\n\t\t\t\t#define FXAA_QUALITY_P6 2.0\n\t\t\t\t#define FXAA_QUALITY_P7 2.0\n\t\t\t\t#define FXAA_QUALITY_P8 2.0\n\t\t\t\t#define FXAA_QUALITY_P9 2.0\n\t\t\t\t#define FXAA_QUALITY_P10 4.0\n\t\t\t\t#define FXAA_QUALITY_P11 8.0\n\t\t#endif\n\n\t\t/*============================================================================\n\t\t\t\t\t\t\t\t\t\t\t\t FXAA QUALITY - EXTREME QUALITY\n\t\t============================================================================*/\n\t\t#if (FXAA_QUALITY_PRESET == 39)\n\t\t\t\t#define FXAA_QUALITY_PS 12\n\t\t\t\t#define FXAA_QUALITY_P0 1.0\n\t\t\t\t#define FXAA_QUALITY_P1 1.0\n\t\t\t\t#define FXAA_QUALITY_P2 1.0\n\t\t\t\t#define FXAA_QUALITY_P3 1.0\n\t\t\t\t#define FXAA_QUALITY_P4 1.0\n\t\t\t\t#define FXAA_QUALITY_P5 1.5\n\t\t\t\t#define FXAA_QUALITY_P6 2.0\n\t\t\t\t#define FXAA_QUALITY_P7 2.0\n\t\t\t\t#define FXAA_QUALITY_P8 2.0\n\t\t\t\t#define FXAA_QUALITY_P9 2.0\n\t\t\t\t#define FXAA_QUALITY_P10 4.0\n\t\t\t\t#define FXAA_QUALITY_P11 8.0\n\t\t#endif\n\n\n\n\t\t/*============================================================================\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tAPI PORTING\n\n\t\t============================================================================*/\n\t\t#if (FXAA_GLSL_100 == 1) || (FXAA_GLSL_120 == 1) || (FXAA_GLSL_130 == 1)\n\t\t\t\t#define FxaaBool bool\n\t\t\t\t#define FxaaDiscard discard\n\t\t\t\t#define FxaaFloat float\n\t\t\t\t#define FxaaFloat2 vec2\n\t\t\t\t#define FxaaFloat3 vec3\n\t\t\t\t#define FxaaFloat4 vec4\n\t\t\t\t#define FxaaHalf float\n\t\t\t\t#define FxaaHalf2 vec2\n\t\t\t\t#define FxaaHalf3 vec3\n\t\t\t\t#define FxaaHalf4 vec4\n\t\t\t\t#define FxaaInt2 ivec2\n\t\t\t\t#define FxaaSat(x) clamp(x, 0.0, 1.0)\n\t\t\t\t#define FxaaTex sampler2D\n\t\t#else\n\t\t\t\t#define FxaaBool bool\n\t\t\t\t#define FxaaDiscard clip(-1)\n\t\t\t\t#define FxaaFloat float\n\t\t\t\t#define FxaaFloat2 float2\n\t\t\t\t#define FxaaFloat3 float3\n\t\t\t\t#define FxaaFloat4 float4\n\t\t\t\t#define FxaaHalf half\n\t\t\t\t#define FxaaHalf2 half2\n\t\t\t\t#define FxaaHalf3 half3\n\t\t\t\t#define FxaaHalf4 half4\n\t\t\t\t#define FxaaSat(x) saturate(x)\n\t\t#endif\n\t\t/*--------------------------------------------------------------------------*/\n\t\t#if (FXAA_GLSL_100 == 1)\n\t\t\t#define FxaaTexTop(t, p) texture2D(t, p, 0.0)\n\t\t\t#define FxaaTexOff(t, p, o, r) texture2D(t, p + (o * r), 0.0)\n\t\t#endif\n\t\t/*--------------------------------------------------------------------------*/\n\t\t#if (FXAA_GLSL_120 == 1)\n\t\t\t\t// Requires,\n\t\t\t\t//\t#version 120\n\t\t\t\t// And at least,\n\t\t\t\t//\t#extension GL_EXT_gpu_shader4 : enable\n\t\t\t\t//\t(or set FXAA_FAST_PIXEL_OFFSET 1 to work like DX9)\n\t\t\t\t#define FxaaTexTop(t, p) texture2DLod(t, p, 0.0)\n\t\t\t\t#if (FXAA_FAST_PIXEL_OFFSET == 1)\n\t\t\t\t\t\t#define FxaaTexOff(t, p, o, r) texture2DLodOffset(t, p, 0.0, o)\n\t\t\t\t#else\n\t\t\t\t\t\t#define FxaaTexOff(t, p, o, r) texture2DLod(t, p + (o * r), 0.0)\n\t\t\t\t#endif\n\t\t\t\t#if (FXAA_GATHER4_ALPHA == 1)\n\t\t\t\t\t\t// use #extension GL_ARB_gpu_shader5 : enable\n\t\t\t\t\t\t#define FxaaTexAlpha4(t, p) textureGather(t, p, 3)\n\t\t\t\t\t\t#define FxaaTexOffAlpha4(t, p, o) textureGatherOffset(t, p, o, 3)\n\t\t\t\t\t\t#define FxaaTexGreen4(t, p) textureGather(t, p, 1)\n\t\t\t\t\t\t#define FxaaTexOffGreen4(t, p, o) textureGatherOffset(t, p, o, 1)\n\t\t\t\t#endif\n\t\t#endif\n\t\t/*--------------------------------------------------------------------------*/\n\t\t#if (FXAA_GLSL_130 == 1)\n\t\t\t\t// Requires "#version 130" or better\n\t\t\t\t#define FxaaTexTop(t, p) textureLod(t, p, 0.0)\n\t\t\t\t#define FxaaTexOff(t, p, o, r) textureLodOffset(t, p, 0.0, o)\n\t\t\t\t#if (FXAA_GATHER4_ALPHA == 1)\n\t\t\t\t\t\t// use #extension GL_ARB_gpu_shader5 : enable\n\t\t\t\t\t\t#define FxaaTexAlpha4(t, p) textureGather(t, p, 3)\n\t\t\t\t\t\t#define FxaaTexOffAlpha4(t, p, o) textureGatherOffset(t, p, o, 3)\n\t\t\t\t\t\t#define FxaaTexGreen4(t, p) textureGather(t, p, 1)\n\t\t\t\t\t\t#define FxaaTexOffGreen4(t, p, o) textureGatherOffset(t, p, o, 1)\n\t\t\t\t#endif\n\t\t#endif\n\t\t/*--------------------------------------------------------------------------*/\n\t\t#if (FXAA_HLSL_3 == 1)\n\t\t\t\t#define FxaaInt2 float2\n\t\t\t\t#define FxaaTex sampler2D\n\t\t\t\t#define FxaaTexTop(t, p) tex2Dlod(t, float4(p, 0.0, 0.0))\n\t\t\t\t#define FxaaTexOff(t, p, o, r) tex2Dlod(t, float4(p + (o * r), 0, 0))\n\t\t#endif\n\t\t/*--------------------------------------------------------------------------*/\n\t\t#if (FXAA_HLSL_4 == 1)\n\t\t\t\t#define FxaaInt2 int2\n\t\t\t\tstruct FxaaTex { SamplerState smpl; Texture2D tex; };\n\t\t\t\t#define FxaaTexTop(t, p) t.tex.SampleLevel(t.smpl, p, 0.0)\n\t\t\t\t#define FxaaTexOff(t, p, o, r) t.tex.SampleLevel(t.smpl, p, 0.0, o)\n\t\t#endif\n\t\t/*--------------------------------------------------------------------------*/\n\t\t#if (FXAA_HLSL_5 == 1)\n\t\t\t\t#define FxaaInt2 int2\n\t\t\t\tstruct FxaaTex { SamplerState smpl; Texture2D tex; };\n\t\t\t\t#define FxaaTexTop(t, p) t.tex.SampleLevel(t.smpl, p, 0.0)\n\t\t\t\t#define FxaaTexOff(t, p, o, r) t.tex.SampleLevel(t.smpl, p, 0.0, o)\n\t\t\t\t#define FxaaTexAlpha4(t, p) t.tex.GatherAlpha(t.smpl, p)\n\t\t\t\t#define FxaaTexOffAlpha4(t, p, o) t.tex.GatherAlpha(t.smpl, p, o)\n\t\t\t\t#define FxaaTexGreen4(t, p) t.tex.GatherGreen(t.smpl, p)\n\t\t\t\t#define FxaaTexOffGreen4(t, p, o) t.tex.GatherGreen(t.smpl, p, o)\n\t\t#endif\n\n\n\t\t/*============================================================================\n\t\t\t\t\t\t\t\t\t\t\t GREEN AS LUMA OPTION SUPPORT FUNCTION\n\t\t============================================================================*/\n\t\t#if (FXAA_GREEN_AS_LUMA == 0)\n\t\t\t\tFxaaFloat FxaaLuma(FxaaFloat4 rgba) { return rgba.w; }\n\t\t#else\n\t\t\t\tFxaaFloat FxaaLuma(FxaaFloat4 rgba) { return rgba.y; }\n\t\t#endif\n\n\n\n\n\t\t/*============================================================================\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t FXAA3 QUALITY - PC\n\n\t\t============================================================================*/\n\t\t#if (FXAA_PC == 1)\n\t\t/*--------------------------------------------------------------------------*/\n\t\tFxaaFloat4 FxaaPixelShader(\n\t\t\t\t//\n\t\t\t\t// Use noperspective interpolation here (turn off perspective interpolation).\n\t\t\t\t// {xy} = center of pixel\n\t\t\t\tFxaaFloat2 pos,\n\t\t\t\t//\n\t\t\t\t// Used only for FXAA Console, and not used on the 360 version.\n\t\t\t\t// Use noperspective interpolation here (turn off perspective interpolation).\n\t\t\t\t// {xy_} = upper left of pixel\n\t\t\t\t// {_zw} = lower right of pixel\n\t\t\t\tFxaaFloat4 fxaaConsolePosPos,\n\t\t\t\t//\n\t\t\t\t// Input color texture.\n\t\t\t\t// {rgb_} = color in linear or perceptual color space\n\t\t\t\t// if (FXAA_GREEN_AS_LUMA == 0)\n\t\t\t\t//\t\t {__a} = luma in perceptual color space (not linear)\n\t\t\t\tFxaaTex tex,\n\t\t\t\t//\n\t\t\t\t// Only used on the optimized 360 version of FXAA Console.\n\t\t\t\t// For everything but 360, just use the same input here as for "tex".\n\t\t\t\t// For 360, same texture, just alias with a 2nd sampler.\n\t\t\t\t// This sampler needs to have an exponent bias of -1.\n\t\t\t\tFxaaTex fxaaConsole360TexExpBiasNegOne,\n\t\t\t\t//\n\t\t\t\t// Only used on the optimized 360 version of FXAA Console.\n\t\t\t\t// For everything but 360, just use the same input here as for "tex".\n\t\t\t\t// For 360, same texture, just alias with a 3nd sampler.\n\t\t\t\t// This sampler needs to have an exponent bias of -2.\n\t\t\t\tFxaaTex fxaaConsole360TexExpBiasNegTwo,\n\t\t\t\t//\n\t\t\t\t// Only used on FXAA Quality.\n\t\t\t\t// This must be from a constant/uniform.\n\t\t\t\t// {x_} = 1.0/screenWidthInPixels\n\t\t\t\t// {_y} = 1.0/screenHeightInPixels\n\t\t\t\tFxaaFloat2 fxaaQualityRcpFrame,\n\t\t\t\t//\n\t\t\t\t// Only used on FXAA Console.\n\t\t\t\t// This must be from a constant/uniform.\n\t\t\t\t// This effects sub-pixel AA quality and inversely sharpness.\n\t\t\t\t//\t Where N ranges between,\n\t\t\t\t//\t\t N = 0.50 (default)\n\t\t\t\t//\t\t N = 0.33 (sharper)\n\t\t\t\t// {x__} = -N/screenWidthInPixels\n\t\t\t\t// {_y_} = -N/screenHeightInPixels\n\t\t\t\t// {_z_} =\tN/screenWidthInPixels\n\t\t\t\t// {__w} =\tN/screenHeightInPixels\n\t\t\t\tFxaaFloat4 fxaaConsoleRcpFrameOpt,\n\t\t\t\t//\n\t\t\t\t// Only used on FXAA Console.\n\t\t\t\t// Not used on 360, but used on PS3 and PC.\n\t\t\t\t// This must be from a constant/uniform.\n\t\t\t\t// {x__} = -2.0/screenWidthInPixels\n\t\t\t\t// {_y_} = -2.0/screenHeightInPixels\n\t\t\t\t// {_z_} =\t2.0/screenWidthInPixels\n\t\t\t\t// {__w} =\t2.0/screenHeightInPixels\n\t\t\t\tFxaaFloat4 fxaaConsoleRcpFrameOpt2,\n\t\t\t\t//\n\t\t\t\t// Only used on FXAA Console.\n\t\t\t\t// Only used on 360 in place of fxaaConsoleRcpFrameOpt2.\n\t\t\t\t// This must be from a constant/uniform.\n\t\t\t\t// {x__} =\t8.0/screenWidthInPixels\n\t\t\t\t// {_y_} =\t8.0/screenHeightInPixels\n\t\t\t\t// {_z_} = -4.0/screenWidthInPixels\n\t\t\t\t// {__w} = -4.0/screenHeightInPixels\n\t\t\t\tFxaaFloat4 fxaaConsole360RcpFrameOpt2,\n\t\t\t\t//\n\t\t\t\t// Only used on FXAA Quality.\n\t\t\t\t// This used to be the FXAA_QUALITY_SUBPIX define.\n\t\t\t\t// It is here now to allow easier tuning.\n\t\t\t\t// Choose the amount of sub-pixel aliasing removal.\n\t\t\t\t// This can effect sharpness.\n\t\t\t\t//\t 1.00 - upper limit (softer)\n\t\t\t\t//\t 0.75 - default amount of filtering\n\t\t\t\t//\t 0.50 - lower limit (sharper, less sub-pixel aliasing removal)\n\t\t\t\t//\t 0.25 - almost off\n\t\t\t\t//\t 0.00 - completely off\n\t\t\t\tFxaaFloat fxaaQualitySubpix,\n\t\t\t\t//\n\t\t\t\t// Only used on FXAA Quality.\n\t\t\t\t// This used to be the FXAA_QUALITY_EDGE_THRESHOLD define.\n\t\t\t\t// It is here now to allow easier tuning.\n\t\t\t\t// The minimum amount of local contrast required to apply algorithm.\n\t\t\t\t//\t 0.333 - too little (faster)\n\t\t\t\t//\t 0.250 - low quality\n\t\t\t\t//\t 0.166 - default\n\t\t\t\t//\t 0.125 - high quality\n\t\t\t\t//\t 0.063 - overkill (slower)\n\t\t\t\tFxaaFloat fxaaQualityEdgeThreshold,\n\t\t\t\t//\n\t\t\t\t// Only used on FXAA Quality.\n\t\t\t\t// This used to be the FXAA_QUALITY_EDGE_THRESHOLD_MIN define.\n\t\t\t\t// It is here now to allow easier tuning.\n\t\t\t\t// Trims the algorithm from processing darks.\n\t\t\t\t//\t 0.0833 - upper limit (default, the start of visible unfiltered edges)\n\t\t\t\t//\t 0.0625 - high quality (faster)\n\t\t\t\t//\t 0.0312 - visible limit (slower)\n\t\t\t\t// Special notes when using FXAA_GREEN_AS_LUMA,\n\t\t\t\t//\t Likely want to set this to zero.\n\t\t\t\t//\t As colors that are mostly not-green\n\t\t\t\t//\t will appear very dark in the green channel!\n\t\t\t\t//\t Tune by looking at mostly non-green content,\n\t\t\t\t//\t then start at zero and increase until aliasing is a problem.\n\t\t\t\tFxaaFloat fxaaQualityEdgeThresholdMin,\n\t\t\t\t//\n\t\t\t\t// Only used on FXAA Console.\n\t\t\t\t// This used to be the FXAA_CONSOLE_EDGE_SHARPNESS define.\n\t\t\t\t// It is here now to allow easier tuning.\n\t\t\t\t// This does not effect PS3, as this needs to be compiled in.\n\t\t\t\t//\t Use FXAA_CONSOLE_PS3_EDGE_SHARPNESS for PS3.\n\t\t\t\t//\t Due to the PS3 being ALU bound,\n\t\t\t\t//\t there are only three safe values here: 2 and 4 and 8.\n\t\t\t\t//\t These options use the shaders ability to a free *|/ by 2|4|8.\n\t\t\t\t// For all other platforms can be a non-power of two.\n\t\t\t\t//\t 8.0 is sharper (default!!!)\n\t\t\t\t//\t 4.0 is softer\n\t\t\t\t//\t 2.0 is really soft (good only for vector graphics inputs)\n\t\t\t\tFxaaFloat fxaaConsoleEdgeSharpness,\n\t\t\t\t//\n\t\t\t\t// Only used on FXAA Console.\n\t\t\t\t// This used to be the FXAA_CONSOLE_EDGE_THRESHOLD define.\n\t\t\t\t// It is here now to allow easier tuning.\n\t\t\t\t// This does not effect PS3, as this needs to be compiled in.\n\t\t\t\t//\t Use FXAA_CONSOLE_PS3_EDGE_THRESHOLD for PS3.\n\t\t\t\t//\t Due to the PS3 being ALU bound,\n\t\t\t\t//\t there are only two safe values here: 1/4 and 1/8.\n\t\t\t\t//\t These options use the shaders ability to a free *|/ by 2|4|8.\n\t\t\t\t// The console setting has a different mapping than the quality setting.\n\t\t\t\t// Other platforms can use other values.\n\t\t\t\t//\t 0.125 leaves less aliasing, but is softer (default!!!)\n\t\t\t\t//\t 0.25 leaves more aliasing, and is sharper\n\t\t\t\tFxaaFloat fxaaConsoleEdgeThreshold,\n\t\t\t\t//\n\t\t\t\t// Only used on FXAA Console.\n\t\t\t\t// This used to be the FXAA_CONSOLE_EDGE_THRESHOLD_MIN define.\n\t\t\t\t// It is here now to allow easier tuning.\n\t\t\t\t// Trims the algorithm from processing darks.\n\t\t\t\t// The console setting has a different mapping than the quality setting.\n\t\t\t\t// This only applies when FXAA_EARLY_EXIT is 1.\n\t\t\t\t// This does not apply to PS3,\n\t\t\t\t// PS3 was simplified to avoid more shader instructions.\n\t\t\t\t//\t 0.06 - faster but more aliasing in darks\n\t\t\t\t//\t 0.05 - default\n\t\t\t\t//\t 0.04 - slower and less aliasing in darks\n\t\t\t\t// Special notes when using FXAA_GREEN_AS_LUMA,\n\t\t\t\t//\t Likely want to set this to zero.\n\t\t\t\t//\t As colors that are mostly not-green\n\t\t\t\t//\t will appear very dark in the green channel!\n\t\t\t\t//\t Tune by looking at mostly non-green content,\n\t\t\t\t//\t then start at zero and increase until aliasing is a problem.\n\t\t\t\tFxaaFloat fxaaConsoleEdgeThresholdMin,\n\t\t\t\t//\n\t\t\t\t// Extra constants for 360 FXAA Console only.\n\t\t\t\t// Use zeros or anything else for other platforms.\n\t\t\t\t// These must be in physical constant registers and NOT immediates.\n\t\t\t\t// Immediates will result in compiler un-optimizing.\n\t\t\t\t// {xyzw} = float4(1.0, -1.0, 0.25, -0.25)\n\t\t\t\tFxaaFloat4 fxaaConsole360ConstDir\n\t\t) {\n\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\tFxaaFloat2 posM;\n\t\t\t\tposM.x = pos.x;\n\t\t\t\tposM.y = pos.y;\n\t\t\t\t#if (FXAA_GATHER4_ALPHA == 1)\n\t\t\t\t\t\t#if (FXAA_DISCARD == 0)\n\t\t\t\t\t\t\t\tFxaaFloat4 rgbyM = FxaaTexTop(tex, posM);\n\t\t\t\t\t\t\t\t#if (FXAA_GREEN_AS_LUMA == 0)\n\t\t\t\t\t\t\t\t\t\t#define lumaM rgbyM.w\n\t\t\t\t\t\t\t\t#else\n\t\t\t\t\t\t\t\t\t\t#define lumaM rgbyM.y\n\t\t\t\t\t\t\t\t#endif\n\t\t\t\t\t\t#endif\n\t\t\t\t\t\t#if (FXAA_GREEN_AS_LUMA == 0)\n\t\t\t\t\t\t\t\tFxaaFloat4 luma4A = FxaaTexAlpha4(tex, posM);\n\t\t\t\t\t\t\t\tFxaaFloat4 luma4B = FxaaTexOffAlpha4(tex, posM, FxaaInt2(-1, -1));\n\t\t\t\t\t\t#else\n\t\t\t\t\t\t\t\tFxaaFloat4 luma4A = FxaaTexGreen4(tex, posM);\n\t\t\t\t\t\t\t\tFxaaFloat4 luma4B = FxaaTexOffGreen4(tex, posM, FxaaInt2(-1, -1));\n\t\t\t\t\t\t#endif\n\t\t\t\t\t\t#if (FXAA_DISCARD == 1)\n\t\t\t\t\t\t\t\t#define lumaM luma4A.w\n\t\t\t\t\t\t#endif\n\t\t\t\t\t\t#define lumaE luma4A.z\n\t\t\t\t\t\t#define lumaS luma4A.x\n\t\t\t\t\t\t#define lumaSE luma4A.y\n\t\t\t\t\t\t#define lumaNW luma4B.w\n\t\t\t\t\t\t#define lumaN luma4B.z\n\t\t\t\t\t\t#define lumaW luma4B.x\n\t\t\t\t#else\n\t\t\t\t\t\tFxaaFloat4 rgbyM = FxaaTexTop(tex, posM);\n\t\t\t\t\t\t#if (FXAA_GREEN_AS_LUMA == 0)\n\t\t\t\t\t\t\t\t#define lumaM rgbyM.w\n\t\t\t\t\t\t#else\n\t\t\t\t\t\t\t\t#define lumaM rgbyM.y\n\t\t\t\t\t\t#endif\n\t\t\t\t\t\t#if (FXAA_GLSL_100 == 1)\n\t\t\t\t\t\t\tFxaaFloat lumaS = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 0.0, 1.0), fxaaQualityRcpFrame.xy));\n\t\t\t\t\t\t\tFxaaFloat lumaE = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 1.0, 0.0), fxaaQualityRcpFrame.xy));\n\t\t\t\t\t\t\tFxaaFloat lumaN = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 0.0,-1.0), fxaaQualityRcpFrame.xy));\n\t\t\t\t\t\t\tFxaaFloat lumaW = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2(-1.0, 0.0), fxaaQualityRcpFrame.xy));\n\t\t\t\t\t\t#else\n\t\t\t\t\t\t\tFxaaFloat lumaS = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 0, 1), fxaaQualityRcpFrame.xy));\n\t\t\t\t\t\t\tFxaaFloat lumaE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 1, 0), fxaaQualityRcpFrame.xy));\n\t\t\t\t\t\t\tFxaaFloat lumaN = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 0,-1), fxaaQualityRcpFrame.xy));\n\t\t\t\t\t\t\tFxaaFloat lumaW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1, 0), fxaaQualityRcpFrame.xy));\n\t\t\t\t\t\t#endif\n\t\t\t\t#endif\n\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\tFxaaFloat maxSM = max(lumaS, lumaM);\n\t\t\t\tFxaaFloat minSM = min(lumaS, lumaM);\n\t\t\t\tFxaaFloat maxESM = max(lumaE, maxSM);\n\t\t\t\tFxaaFloat minESM = min(lumaE, minSM);\n\t\t\t\tFxaaFloat maxWN = max(lumaN, lumaW);\n\t\t\t\tFxaaFloat minWN = min(lumaN, lumaW);\n\t\t\t\tFxaaFloat rangeMax = max(maxWN, maxESM);\n\t\t\t\tFxaaFloat rangeMin = min(minWN, minESM);\n\t\t\t\tFxaaFloat rangeMaxScaled = rangeMax * fxaaQualityEdgeThreshold;\n\t\t\t\tFxaaFloat range = rangeMax - rangeMin;\n\t\t\t\tFxaaFloat rangeMaxClamped = max(fxaaQualityEdgeThresholdMin, rangeMaxScaled);\n\t\t\t\tFxaaBool earlyExit = range < rangeMaxClamped;\n\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\tif(earlyExit)\n\t\t\t\t\t\t#if (FXAA_DISCARD == 1)\n\t\t\t\t\t\t\t\tFxaaDiscard;\n\t\t\t\t\t\t#else\n\t\t\t\t\t\t\t\treturn rgbyM;\n\t\t\t\t\t\t#endif\n\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\t#if (FXAA_GATHER4_ALPHA == 0)\n\t\t\t\t\t\t#if (FXAA_GLSL_100 == 1)\n\t\t\t\t\t\t\tFxaaFloat lumaNW = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2(-1.0,-1.0), fxaaQualityRcpFrame.xy));\n\t\t\t\t\t\t\tFxaaFloat lumaSE = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 1.0, 1.0), fxaaQualityRcpFrame.xy));\n\t\t\t\t\t\t\tFxaaFloat lumaNE = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 1.0,-1.0), fxaaQualityRcpFrame.xy));\n\t\t\t\t\t\t\tFxaaFloat lumaSW = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2(-1.0, 1.0), fxaaQualityRcpFrame.xy));\n\t\t\t\t\t\t#else\n\t\t\t\t\t\t\tFxaaFloat lumaNW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1,-1), fxaaQualityRcpFrame.xy));\n\t\t\t\t\t\t\tFxaaFloat lumaSE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 1, 1), fxaaQualityRcpFrame.xy));\n\t\t\t\t\t\t\tFxaaFloat lumaNE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 1,-1), fxaaQualityRcpFrame.xy));\n\t\t\t\t\t\t\tFxaaFloat lumaSW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1, 1), fxaaQualityRcpFrame.xy));\n\t\t\t\t\t\t#endif\n\t\t\t\t#else\n\t\t\t\t\t\tFxaaFloat lumaNE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(1, -1), fxaaQualityRcpFrame.xy));\n\t\t\t\t\t\tFxaaFloat lumaSW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1, 1), fxaaQualityRcpFrame.xy));\n\t\t\t\t#endif\n\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\tFxaaFloat lumaNS = lumaN + lumaS;\n\t\t\t\tFxaaFloat lumaWE = lumaW + lumaE;\n\t\t\t\tFxaaFloat subpixRcpRange = 1.0/range;\n\t\t\t\tFxaaFloat subpixNSWE = lumaNS + lumaWE;\n\t\t\t\tFxaaFloat edgeHorz1 = (-2.0 * lumaM) + lumaNS;\n\t\t\t\tFxaaFloat edgeVert1 = (-2.0 * lumaM) + lumaWE;\n\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\tFxaaFloat lumaNESE = lumaNE + lumaSE;\n\t\t\t\tFxaaFloat lumaNWNE = lumaNW + lumaNE;\n\t\t\t\tFxaaFloat edgeHorz2 = (-2.0 * lumaE) + lumaNESE;\n\t\t\t\tFxaaFloat edgeVert2 = (-2.0 * lumaN) + lumaNWNE;\n\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\tFxaaFloat lumaNWSW = lumaNW + lumaSW;\n\t\t\t\tFxaaFloat lumaSWSE = lumaSW + lumaSE;\n\t\t\t\tFxaaFloat edgeHorz4 = (abs(edgeHorz1) * 2.0) + abs(edgeHorz2);\n\t\t\t\tFxaaFloat edgeVert4 = (abs(edgeVert1) * 2.0) + abs(edgeVert2);\n\t\t\t\tFxaaFloat edgeHorz3 = (-2.0 * lumaW) + lumaNWSW;\n\t\t\t\tFxaaFloat edgeVert3 = (-2.0 * lumaS) + lumaSWSE;\n\t\t\t\tFxaaFloat edgeHorz = abs(edgeHorz3) + edgeHorz4;\n\t\t\t\tFxaaFloat edgeVert = abs(edgeVert3) + edgeVert4;\n\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\tFxaaFloat subpixNWSWNESE = lumaNWSW + lumaNESE;\n\t\t\t\tFxaaFloat lengthSign = fxaaQualityRcpFrame.x;\n\t\t\t\tFxaaBool horzSpan = edgeHorz >= edgeVert;\n\t\t\t\tFxaaFloat subpixA = subpixNSWE * 2.0 + subpixNWSWNESE;\n\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\tif(!horzSpan) lumaN = lumaW;\n\t\t\t\tif(!horzSpan) lumaS = lumaE;\n\t\t\t\tif(horzSpan) lengthSign = fxaaQualityRcpFrame.y;\n\t\t\t\tFxaaFloat subpixB = (subpixA * (1.0/12.0)) - lumaM;\n\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\tFxaaFloat gradientN = lumaN - lumaM;\n\t\t\t\tFxaaFloat gradientS = lumaS - lumaM;\n\t\t\t\tFxaaFloat lumaNN = lumaN + lumaM;\n\t\t\t\tFxaaFloat lumaSS = lumaS + lumaM;\n\t\t\t\tFxaaBool pairN = abs(gradientN) >= abs(gradientS);\n\t\t\t\tFxaaFloat gradient = max(abs(gradientN), abs(gradientS));\n\t\t\t\tif(pairN) lengthSign = -lengthSign;\n\t\t\t\tFxaaFloat subpixC = FxaaSat(abs(subpixB) * subpixRcpRange);\n\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\tFxaaFloat2 posB;\n\t\t\t\tposB.x = posM.x;\n\t\t\t\tposB.y = posM.y;\n\t\t\t\tFxaaFloat2 offNP;\n\t\t\t\toffNP.x = (!horzSpan) ? 0.0 : fxaaQualityRcpFrame.x;\n\t\t\t\toffNP.y = ( horzSpan) ? 0.0 : fxaaQualityRcpFrame.y;\n\t\t\t\tif(!horzSpan) posB.x += lengthSign * 0.5;\n\t\t\t\tif( horzSpan) posB.y += lengthSign * 0.5;\n\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\tFxaaFloat2 posN;\n\t\t\t\tposN.x = posB.x - offNP.x * FXAA_QUALITY_P0;\n\t\t\t\tposN.y = posB.y - offNP.y * FXAA_QUALITY_P0;\n\t\t\t\tFxaaFloat2 posP;\n\t\t\t\tposP.x = posB.x + offNP.x * FXAA_QUALITY_P0;\n\t\t\t\tposP.y = posB.y + offNP.y * FXAA_QUALITY_P0;\n\t\t\t\tFxaaFloat subpixD = ((-2.0)*subpixC) + 3.0;\n\t\t\t\tFxaaFloat lumaEndN = FxaaLuma(FxaaTexTop(tex, posN));\n\t\t\t\tFxaaFloat subpixE = subpixC * subpixC;\n\t\t\t\tFxaaFloat lumaEndP = FxaaLuma(FxaaTexTop(tex, posP));\n\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\tif(!pairN) lumaNN = lumaSS;\n\t\t\t\tFxaaFloat gradientScaled = gradient * 1.0/4.0;\n\t\t\t\tFxaaFloat lumaMM = lumaM - lumaNN * 0.5;\n\t\t\t\tFxaaFloat subpixF = subpixD * subpixE;\n\t\t\t\tFxaaBool lumaMLTZero = lumaMM < 0.0;\n\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\tlumaEndN -= lumaNN * 0.5;\n\t\t\t\tlumaEndP -= lumaNN * 0.5;\n\t\t\t\tFxaaBool doneN = abs(lumaEndN) >= gradientScaled;\n\t\t\t\tFxaaBool doneP = abs(lumaEndP) >= gradientScaled;\n\t\t\t\tif(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P1;\n\t\t\t\tif(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P1;\n\t\t\t\tFxaaBool doneNP = (!doneN) || (!doneP);\n\t\t\t\tif(!doneP) posP.x += offNP.x * FXAA_QUALITY_P1;\n\t\t\t\tif(!doneP) posP.y += offNP.y * FXAA_QUALITY_P1;\n\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\tif(doneNP) {\n\t\t\t\t\t\tif(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n\t\t\t\t\t\tif(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n\t\t\t\t\t\tif(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n\t\t\t\t\t\tif(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n\t\t\t\t\t\tdoneN = abs(lumaEndN) >= gradientScaled;\n\t\t\t\t\t\tdoneP = abs(lumaEndP) >= gradientScaled;\n\t\t\t\t\t\tif(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P2;\n\t\t\t\t\t\tif(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P2;\n\t\t\t\t\t\tdoneNP = (!doneN) || (!doneP);\n\t\t\t\t\t\tif(!doneP) posP.x += offNP.x * FXAA_QUALITY_P2;\n\t\t\t\t\t\tif(!doneP) posP.y += offNP.y * FXAA_QUALITY_P2;\n\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\t\t\t#if (FXAA_QUALITY_PS > 3)\n\t\t\t\t\t\tif(doneNP) {\n\t\t\t\t\t\t\t\tif(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n\t\t\t\t\t\t\t\tif(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n\t\t\t\t\t\t\t\tif(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n\t\t\t\t\t\t\t\tif(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n\t\t\t\t\t\t\t\tdoneN = abs(lumaEndN) >= gradientScaled;\n\t\t\t\t\t\t\t\tdoneP = abs(lumaEndP) >= gradientScaled;\n\t\t\t\t\t\t\t\tif(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P3;\n\t\t\t\t\t\t\t\tif(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P3;\n\t\t\t\t\t\t\t\tdoneNP = (!doneN) || (!doneP);\n\t\t\t\t\t\t\t\tif(!doneP) posP.x += offNP.x * FXAA_QUALITY_P3;\n\t\t\t\t\t\t\t\tif(!doneP) posP.y += offNP.y * FXAA_QUALITY_P3;\n\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\t\t\t\t\t#if (FXAA_QUALITY_PS > 4)\n\t\t\t\t\t\t\t\tif(doneNP) {\n\t\t\t\t\t\t\t\t\t\tif(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n\t\t\t\t\t\t\t\t\t\tif(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n\t\t\t\t\t\t\t\t\t\tif(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n\t\t\t\t\t\t\t\t\t\tif(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n\t\t\t\t\t\t\t\t\t\tdoneN = abs(lumaEndN) >= gradientScaled;\n\t\t\t\t\t\t\t\t\t\tdoneP = abs(lumaEndP) >= gradientScaled;\n\t\t\t\t\t\t\t\t\t\tif(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P4;\n\t\t\t\t\t\t\t\t\t\tif(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P4;\n\t\t\t\t\t\t\t\t\t\tdoneNP = (!doneN) || (!doneP);\n\t\t\t\t\t\t\t\t\t\tif(!doneP) posP.x += offNP.x * FXAA_QUALITY_P4;\n\t\t\t\t\t\t\t\t\t\tif(!doneP) posP.y += offNP.y * FXAA_QUALITY_P4;\n\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\t\t\t\t\t\t\t#if (FXAA_QUALITY_PS > 5)\n\t\t\t\t\t\t\t\t\t\tif(doneNP) {\n\t\t\t\t\t\t\t\t\t\t\t\tif(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n\t\t\t\t\t\t\t\t\t\t\t\tif(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n\t\t\t\t\t\t\t\t\t\t\t\tif(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n\t\t\t\t\t\t\t\t\t\t\t\tif(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n\t\t\t\t\t\t\t\t\t\t\t\tdoneN = abs(lumaEndN) >= gradientScaled;\n\t\t\t\t\t\t\t\t\t\t\t\tdoneP = abs(lumaEndP) >= gradientScaled;\n\t\t\t\t\t\t\t\t\t\t\t\tif(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P5;\n\t\t\t\t\t\t\t\t\t\t\t\tif(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P5;\n\t\t\t\t\t\t\t\t\t\t\t\tdoneNP = (!doneN) || (!doneP);\n\t\t\t\t\t\t\t\t\t\t\t\tif(!doneP) posP.x += offNP.x * FXAA_QUALITY_P5;\n\t\t\t\t\t\t\t\t\t\t\t\tif(!doneP) posP.y += offNP.y * FXAA_QUALITY_P5;\n\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\t\t\t\t\t\t\t\t\t#if (FXAA_QUALITY_PS > 6)\n\t\t\t\t\t\t\t\t\t\t\t\tif(doneNP) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tdoneN = abs(lumaEndN) >= gradientScaled;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tdoneP = abs(lumaEndP) >= gradientScaled;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P6;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P6;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tdoneNP = (!doneN) || (!doneP);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(!doneP) posP.x += offNP.x * FXAA_QUALITY_P6;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(!doneP) posP.y += offNP.y * FXAA_QUALITY_P6;\n\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t#if (FXAA_QUALITY_PS > 7)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(doneNP) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tdoneN = abs(lumaEndN) >= gradientScaled;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tdoneP = abs(lumaEndP) >= gradientScaled;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P7;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P7;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tdoneNP = (!doneN) || (!doneP);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(!doneP) posP.x += offNP.x * FXAA_QUALITY_P7;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(!doneP) posP.y += offNP.y * FXAA_QUALITY_P7;\n\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\t#if (FXAA_QUALITY_PS > 8)\n\t\t\t\tif(doneNP) {\n\t\t\t\t\t\tif(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n\t\t\t\t\t\tif(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n\t\t\t\t\t\tif(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n\t\t\t\t\t\tif(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n\t\t\t\t\t\tdoneN = abs(lumaEndN) >= gradientScaled;\n\t\t\t\t\t\tdoneP = abs(lumaEndP) >= gradientScaled;\n\t\t\t\t\t\tif(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P8;\n\t\t\t\t\t\tif(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P8;\n\t\t\t\t\t\tdoneNP = (!doneN) || (!doneP);\n\t\t\t\t\t\tif(!doneP) posP.x += offNP.x * FXAA_QUALITY_P8;\n\t\t\t\t\t\tif(!doneP) posP.y += offNP.y * FXAA_QUALITY_P8;\n\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\t\t\t#if (FXAA_QUALITY_PS > 9)\n\t\t\t\t\t\tif(doneNP) {\n\t\t\t\t\t\t\t\tif(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n\t\t\t\t\t\t\t\tif(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n\t\t\t\t\t\t\t\tif(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n\t\t\t\t\t\t\t\tif(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n\t\t\t\t\t\t\t\tdoneN = abs(lumaEndN) >= gradientScaled;\n\t\t\t\t\t\t\t\tdoneP = abs(lumaEndP) >= gradientScaled;\n\t\t\t\t\t\t\t\tif(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P9;\n\t\t\t\t\t\t\t\tif(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P9;\n\t\t\t\t\t\t\t\tdoneNP = (!doneN) || (!doneP);\n\t\t\t\t\t\t\t\tif(!doneP) posP.x += offNP.x * FXAA_QUALITY_P9;\n\t\t\t\t\t\t\t\tif(!doneP) posP.y += offNP.y * FXAA_QUALITY_P9;\n\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\t\t\t\t\t#if (FXAA_QUALITY_PS > 10)\n\t\t\t\t\t\t\t\tif(doneNP) {\n\t\t\t\t\t\t\t\t\t\tif(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n\t\t\t\t\t\t\t\t\t\tif(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n\t\t\t\t\t\t\t\t\t\tif(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n\t\t\t\t\t\t\t\t\t\tif(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n\t\t\t\t\t\t\t\t\t\tdoneN = abs(lumaEndN) >= gradientScaled;\n\t\t\t\t\t\t\t\t\t\tdoneP = abs(lumaEndP) >= gradientScaled;\n\t\t\t\t\t\t\t\t\t\tif(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P10;\n\t\t\t\t\t\t\t\t\t\tif(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P10;\n\t\t\t\t\t\t\t\t\t\tdoneNP = (!doneN) || (!doneP);\n\t\t\t\t\t\t\t\t\t\tif(!doneP) posP.x += offNP.x * FXAA_QUALITY_P10;\n\t\t\t\t\t\t\t\t\t\tif(!doneP) posP.y += offNP.y * FXAA_QUALITY_P10;\n\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\t\t\t\t\t\t\t#if (FXAA_QUALITY_PS > 11)\n\t\t\t\t\t\t\t\t\t\tif(doneNP) {\n\t\t\t\t\t\t\t\t\t\t\t\tif(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n\t\t\t\t\t\t\t\t\t\t\t\tif(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n\t\t\t\t\t\t\t\t\t\t\t\tif(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n\t\t\t\t\t\t\t\t\t\t\t\tif(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n\t\t\t\t\t\t\t\t\t\t\t\tdoneN = abs(lumaEndN) >= gradientScaled;\n\t\t\t\t\t\t\t\t\t\t\t\tdoneP = abs(lumaEndP) >= gradientScaled;\n\t\t\t\t\t\t\t\t\t\t\t\tif(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P11;\n\t\t\t\t\t\t\t\t\t\t\t\tif(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P11;\n\t\t\t\t\t\t\t\t\t\t\t\tdoneNP = (!doneN) || (!doneP);\n\t\t\t\t\t\t\t\t\t\t\t\tif(!doneP) posP.x += offNP.x * FXAA_QUALITY_P11;\n\t\t\t\t\t\t\t\t\t\t\t\tif(!doneP) posP.y += offNP.y * FXAA_QUALITY_P11;\n\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\t\t\t\t\t\t\t\t\t#if (FXAA_QUALITY_PS > 12)\n\t\t\t\t\t\t\t\t\t\t\t\tif(doneNP) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tdoneN = abs(lumaEndN) >= gradientScaled;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tdoneP = abs(lumaEndP) >= gradientScaled;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P12;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P12;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tdoneNP = (!doneN) || (!doneP);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(!doneP) posP.x += offNP.x * FXAA_QUALITY_P12;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(!doneP) posP.y += offNP.y * FXAA_QUALITY_P12;\n\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t#endif\n\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t#endif\n\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t#endif\n\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\t\t\t}\n\t\t\t\t\t\t#endif\n\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\t}\n\t\t\t\t#endif\n\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t#endif\n\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t#endif\n\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t#endif\n\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t#endif\n\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\t\t\t}\n\t\t\t\t\t\t#endif\n\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\t}\n\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\tFxaaFloat dstN = posM.x - posN.x;\n\t\t\t\tFxaaFloat dstP = posP.x - posM.x;\n\t\t\t\tif(!horzSpan) dstN = posM.y - posN.y;\n\t\t\t\tif(!horzSpan) dstP = posP.y - posM.y;\n\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\tFxaaBool goodSpanN = (lumaEndN < 0.0) != lumaMLTZero;\n\t\t\t\tFxaaFloat spanLength = (dstP + dstN);\n\t\t\t\tFxaaBool goodSpanP = (lumaEndP < 0.0) != lumaMLTZero;\n\t\t\t\tFxaaFloat spanLengthRcp = 1.0/spanLength;\n\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\tFxaaBool directionN = dstN < dstP;\n\t\t\t\tFxaaFloat dst = min(dstN, dstP);\n\t\t\t\tFxaaBool goodSpan = directionN ? goodSpanN : goodSpanP;\n\t\t\t\tFxaaFloat subpixG = subpixF * subpixF;\n\t\t\t\tFxaaFloat pixelOffset = (dst * (-spanLengthRcp)) + 0.5;\n\t\t\t\tFxaaFloat subpixH = subpixG * fxaaQualitySubpix;\n\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\tFxaaFloat pixelOffsetGood = goodSpan ? pixelOffset : 0.0;\n\t\t\t\tFxaaFloat pixelOffsetSubpix = max(pixelOffsetGood, subpixH);\n\t\t\t\tif(!horzSpan) posM.x += pixelOffsetSubpix * lengthSign;\n\t\t\t\tif( horzSpan) posM.y += pixelOffsetSubpix * lengthSign;\n\t\t\t\t#if (FXAA_DISCARD == 1)\n\t\t\t\t\t\treturn FxaaTexTop(tex, posM);\n\t\t\t\t#else\n\t\t\t\t\t\treturn FxaaFloat4(FxaaTexTop(tex, posM).xyz, lumaM);\n\t\t\t\t#endif\n\t\t}\n\t\t/*==========================================================================*/\n\t\t#endif\n\n\t\tvoid main() {\n\t\t\tgl_FragColor = FxaaPixelShader(\n\t\t\t\tvUv,\n\t\t\t\tvec4(0.0),\n\t\t\t\ttDiffuse,\n\t\t\t\ttDiffuse,\n\t\t\t\ttDiffuse,\n\t\t\t\tresolution,\n\t\t\t\tvec4(0.0),\n\t\t\t\tvec4(0.0),\n\t\t\t\tvec4(0.0),\n\t\t\t\t0.75,\n\t\t\t\t0.166,\n\t\t\t\t0.0833,\n\t\t\t\t0.0,\n\t\t\t\t0.0,\n\t\t\t\t0.0,\n\t\t\t\tvec4(0.0)\n\t\t\t);\n\n\t\t\t// TODO avoid querying texture twice for same texel\n\t\t\tgl_FragColor.a = texture2D(tDiffuse, vUv).a;\n\t\t}'},Wf={defines:{SMAA_THRESHOLD:"0.1"},uniforms:{tDiffuse:{value:null},resolution:{value:new jn(1/1024,1/512)}},vertexShader:"\n\n\t\tuniform vec2 resolution;\n\n\t\tvarying vec2 vUv;\n\t\tvarying vec4 vOffset[ 3 ];\n\n\t\tvoid SMAAEdgeDetectionVS( vec2 texcoord ) {\n\t\t\tvOffset[ 0 ] = texcoord.xyxy + resolution.xyxy * vec4( -1.0, 0.0, 0.0,  1.0 ); // WebGL port note: Changed sign in W component\n\t\t\tvOffset[ 1 ] = texcoord.xyxy + resolution.xyxy * vec4(  1.0, 0.0, 0.0, -1.0 ); // WebGL port note: Changed sign in W component\n\t\t\tvOffset[ 2 ] = texcoord.xyxy + resolution.xyxy * vec4( -2.0, 0.0, 0.0,  2.0 ); // WebGL port note: Changed sign in W component\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvUv = uv;\n\n\t\t\tSMAAEdgeDetectionVS( vUv );\n\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t}",fragmentShader:"\n\n\t\tuniform sampler2D tDiffuse;\n\n\t\tvarying vec2 vUv;\n\t\tvarying vec4 vOffset[ 3 ];\n\n\t\tvec4 SMAAColorEdgeDetectionPS( vec2 texcoord, vec4 offset[3], sampler2D colorTex ) {\n\t\t\tvec2 threshold = vec2( SMAA_THRESHOLD, SMAA_THRESHOLD );\n\n\t\t\t// Calculate color deltas:\n\t\t\tvec4 delta;\n\t\t\tvec3 C = texture2D( colorTex, texcoord ).rgb;\n\n\t\t\tvec3 Cleft = texture2D( colorTex, offset[0].xy ).rgb;\n\t\t\tvec3 t = abs( C - Cleft );\n\t\t\tdelta.x = max( max( t.r, t.g ), t.b );\n\n\t\t\tvec3 Ctop = texture2D( colorTex, offset[0].zw ).rgb;\n\t\t\tt = abs( C - Ctop );\n\t\t\tdelta.y = max( max( t.r, t.g ), t.b );\n\n\t\t\t// We do the usual threshold:\n\t\t\tvec2 edges = step( threshold, delta.xy );\n\n\t\t\t// Then discard if there is no edge:\n\t\t\tif ( dot( edges, vec2( 1.0, 1.0 ) ) == 0.0 )\n\t\t\t\tdiscard;\n\n\t\t\t// Calculate right and bottom deltas:\n\t\t\tvec3 Cright = texture2D( colorTex, offset[1].xy ).rgb;\n\t\t\tt = abs( C - Cright );\n\t\t\tdelta.z = max( max( t.r, t.g ), t.b );\n\n\t\t\tvec3 Cbottom  = texture2D( colorTex, offset[1].zw ).rgb;\n\t\t\tt = abs( C - Cbottom );\n\t\t\tdelta.w = max( max( t.r, t.g ), t.b );\n\n\t\t\t// Calculate the maximum delta in the direct neighborhood:\n\t\t\tfloat maxDelta = max( max( max( delta.x, delta.y ), delta.z ), delta.w );\n\n\t\t\t// Calculate left-left and top-top deltas:\n\t\t\tvec3 Cleftleft  = texture2D( colorTex, offset[2].xy ).rgb;\n\t\t\tt = abs( C - Cleftleft );\n\t\t\tdelta.z = max( max( t.r, t.g ), t.b );\n\n\t\t\tvec3 Ctoptop = texture2D( colorTex, offset[2].zw ).rgb;\n\t\t\tt = abs( C - Ctoptop );\n\t\t\tdelta.w = max( max( t.r, t.g ), t.b );\n\n\t\t\t// Calculate the final maximum delta:\n\t\t\tmaxDelta = max( max( maxDelta, delta.z ), delta.w );\n\n\t\t\t// Local contrast adaptation in action:\n\t\t\tedges.xy *= step( 0.5 * maxDelta, delta.xy );\n\n\t\t\treturn vec4( edges, 0.0, 0.0 );\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tgl_FragColor = SMAAColorEdgeDetectionPS( vUv, vOffset, tDiffuse );\n\n\t\t}"},Xf={defines:{SMAA_MAX_SEARCH_STEPS:"8",SMAA_AREATEX_MAX_DISTANCE:"16",SMAA_AREATEX_PIXEL_SIZE:"( 1.0 / vec2( 160.0, 560.0 ) )",SMAA_AREATEX_SUBTEX_SIZE:"( 1.0 / 7.0 )"},uniforms:{tDiffuse:{value:null},tArea:{value:null},tSearch:{value:null},resolution:{value:new jn(1/1024,1/512)}},vertexShader:"\n\n\t\tuniform vec2 resolution;\n\n\t\tvarying vec2 vUv;\n\t\tvarying vec4 vOffset[ 3 ];\n\t\tvarying vec2 vPixcoord;\n\n\t\tvoid SMAABlendingWeightCalculationVS( vec2 texcoord ) {\n\t\t\tvPixcoord = texcoord / resolution;\n\n\t\t\t// We will use these offsets for the searches later on (see @PSEUDO_GATHER4):\n\t\t\tvOffset[ 0 ] = texcoord.xyxy + resolution.xyxy * vec4( -0.25, 0.125, 1.25, 0.125 ); // WebGL port note: Changed sign in Y and W components\n\t\t\tvOffset[ 1 ] = texcoord.xyxy + resolution.xyxy * vec4( -0.125, 0.25, -0.125, -1.25 ); // WebGL port note: Changed sign in Y and W components\n\n\t\t\t// And these for the searches, they indicate the ends of the loops:\n\t\t\tvOffset[ 2 ] = vec4( vOffset[ 0 ].xz, vOffset[ 1 ].yw ) + vec4( -2.0, 2.0, -2.0, 2.0 ) * resolution.xxyy * float( SMAA_MAX_SEARCH_STEPS );\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvUv = uv;\n\n\t\t\tSMAABlendingWeightCalculationVS( vUv );\n\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t}",fragmentShader:"\n\n\t\t#define SMAASampleLevelZeroOffset( tex, coord, offset ) texture2D( tex, coord + float( offset ) * resolution, 0.0 )\n\n\t\tuniform sampler2D tDiffuse;\n\t\tuniform sampler2D tArea;\n\t\tuniform sampler2D tSearch;\n\t\tuniform vec2 resolution;\n\n\t\tvarying vec2 vUv;\n\t\tvarying vec4 vOffset[3];\n\t\tvarying vec2 vPixcoord;\n\n\t\t#if __VERSION__ == 100\n\t\tvec2 round( vec2 x ) {\n\t\t\treturn sign( x ) * floor( abs( x ) + 0.5 );\n\t\t}\n\t\t#endif\n\n\t\tfloat SMAASearchLength( sampler2D searchTex, vec2 e, float bias, float scale ) {\n\t\t\t// Not required if searchTex accesses are set to point:\n\t\t\t// float2 SEARCH_TEX_PIXEL_SIZE = 1.0 / float2(66.0, 33.0);\n\t\t\t// e = float2(bias, 0.0) + 0.5 * SEARCH_TEX_PIXEL_SIZE +\n\t\t\t//     e * float2(scale, 1.0) * float2(64.0, 32.0) * SEARCH_TEX_PIXEL_SIZE;\n\t\t\te.r = bias + e.r * scale;\n\t\t\treturn 255.0 * texture2D( searchTex, e, 0.0 ).r;\n\t\t}\n\n\t\tfloat SMAASearchXLeft( sampler2D edgesTex, sampler2D searchTex, vec2 texcoord, float end ) {\n\t\t\t/**\n\t\t\t\t* @PSEUDO_GATHER4\n\t\t\t\t* This texcoord has been offset by (-0.25, -0.125) in the vertex shader to\n\t\t\t\t* sample between edge, thus fetching four edges in a row.\n\t\t\t\t* Sampling with different offsets in each direction allows to disambiguate\n\t\t\t\t* which edges are active from the four fetched ones.\n\t\t\t\t*/\n\t\t\tvec2 e = vec2( 0.0, 1.0 );\n\n\t\t\tfor ( int i = 0; i < SMAA_MAX_SEARCH_STEPS; i ++ ) { // WebGL port note: Changed while to for\n\t\t\t\te = texture2D( edgesTex, texcoord, 0.0 ).rg;\n\t\t\t\ttexcoord -= vec2( 2.0, 0.0 ) * resolution;\n\t\t\t\tif ( ! ( texcoord.x > end && e.g > 0.8281 && e.r == 0.0 ) ) break;\n\t\t\t}\n\n\t\t\t// We correct the previous (-0.25, -0.125) offset we applied:\n\t\t\ttexcoord.x += 0.25 * resolution.x;\n\n\t\t\t// The searches are bias by 1, so adjust the coords accordingly:\n\t\t\ttexcoord.x += resolution.x;\n\n\t\t\t// Disambiguate the length added by the last step:\n\t\t\ttexcoord.x += 2.0 * resolution.x; // Undo last step\n\t\t\ttexcoord.x -= resolution.x * SMAASearchLength(searchTex, e, 0.0, 0.5);\n\n\t\t\treturn texcoord.x;\n\t\t}\n\n\t\tfloat SMAASearchXRight( sampler2D edgesTex, sampler2D searchTex, vec2 texcoord, float end ) {\n\t\t\tvec2 e = vec2( 0.0, 1.0 );\n\n\t\t\tfor ( int i = 0; i < SMAA_MAX_SEARCH_STEPS; i ++ ) { // WebGL port note: Changed while to for\n\t\t\t\te = texture2D( edgesTex, texcoord, 0.0 ).rg;\n\t\t\t\ttexcoord += vec2( 2.0, 0.0 ) * resolution;\n\t\t\t\tif ( ! ( texcoord.x < end && e.g > 0.8281 && e.r == 0.0 ) ) break;\n\t\t\t}\n\n\t\t\ttexcoord.x -= 0.25 * resolution.x;\n\t\t\ttexcoord.x -= resolution.x;\n\t\t\ttexcoord.x -= 2.0 * resolution.x;\n\t\t\ttexcoord.x += resolution.x * SMAASearchLength( searchTex, e, 0.5, 0.5 );\n\n\t\t\treturn texcoord.x;\n\t\t}\n\n\t\tfloat SMAASearchYUp( sampler2D edgesTex, sampler2D searchTex, vec2 texcoord, float end ) {\n\t\t\tvec2 e = vec2( 1.0, 0.0 );\n\n\t\t\tfor ( int i = 0; i < SMAA_MAX_SEARCH_STEPS; i ++ ) { // WebGL port note: Changed while to for\n\t\t\t\te = texture2D( edgesTex, texcoord, 0.0 ).rg;\n\t\t\t\ttexcoord += vec2( 0.0, 2.0 ) * resolution; // WebGL port note: Changed sign\n\t\t\t\tif ( ! ( texcoord.y > end && e.r > 0.8281 && e.g == 0.0 ) ) break;\n\t\t\t}\n\n\t\t\ttexcoord.y -= 0.25 * resolution.y; // WebGL port note: Changed sign\n\t\t\ttexcoord.y -= resolution.y; // WebGL port note: Changed sign\n\t\t\ttexcoord.y -= 2.0 * resolution.y; // WebGL port note: Changed sign\n\t\t\ttexcoord.y += resolution.y * SMAASearchLength( searchTex, e.gr, 0.0, 0.5 ); // WebGL port note: Changed sign\n\n\t\t\treturn texcoord.y;\n\t\t}\n\n\t\tfloat SMAASearchYDown( sampler2D edgesTex, sampler2D searchTex, vec2 texcoord, float end ) {\n\t\t\tvec2 e = vec2( 1.0, 0.0 );\n\n\t\t\tfor ( int i = 0; i < SMAA_MAX_SEARCH_STEPS; i ++ ) { // WebGL port note: Changed while to for\n\t\t\t\te = texture2D( edgesTex, texcoord, 0.0 ).rg;\n\t\t\t\ttexcoord -= vec2( 0.0, 2.0 ) * resolution; // WebGL port note: Changed sign\n\t\t\t\tif ( ! ( texcoord.y < end && e.r > 0.8281 && e.g == 0.0 ) ) break;\n\t\t\t}\n\n\t\t\ttexcoord.y += 0.25 * resolution.y; // WebGL port note: Changed sign\n\t\t\ttexcoord.y += resolution.y; // WebGL port note: Changed sign\n\t\t\ttexcoord.y += 2.0 * resolution.y; // WebGL port note: Changed sign\n\t\t\ttexcoord.y -= resolution.y * SMAASearchLength( searchTex, e.gr, 0.5, 0.5 ); // WebGL port note: Changed sign\n\n\t\t\treturn texcoord.y;\n\t\t}\n\n\t\tvec2 SMAAArea( sampler2D areaTex, vec2 dist, float e1, float e2, float offset ) {\n\t\t\t// Rounding prevents precision errors of bilinear filtering:\n\t\t\tvec2 texcoord = float( SMAA_AREATEX_MAX_DISTANCE ) * round( 4.0 * vec2( e1, e2 ) ) + dist;\n\n\t\t\t// We do a scale and bias for mapping to texel space:\n\t\t\ttexcoord = SMAA_AREATEX_PIXEL_SIZE * texcoord + ( 0.5 * SMAA_AREATEX_PIXEL_SIZE );\n\n\t\t\t// Move to proper place, according to the subpixel offset:\n\t\t\ttexcoord.y += SMAA_AREATEX_SUBTEX_SIZE * offset;\n\n\t\t\treturn texture2D( areaTex, texcoord, 0.0 ).rg;\n\t\t}\n\n\t\tvec4 SMAABlendingWeightCalculationPS( vec2 texcoord, vec2 pixcoord, vec4 offset[ 3 ], sampler2D edgesTex, sampler2D areaTex, sampler2D searchTex, ivec4 subsampleIndices ) {\n\t\t\tvec4 weights = vec4( 0.0, 0.0, 0.0, 0.0 );\n\n\t\t\tvec2 e = texture2D( edgesTex, texcoord ).rg;\n\n\t\t\tif ( e.g > 0.0 ) { // Edge at north\n\t\t\t\tvec2 d;\n\n\t\t\t\t// Find the distance to the left:\n\t\t\t\tvec2 coords;\n\t\t\t\tcoords.x = SMAASearchXLeft( edgesTex, searchTex, offset[ 0 ].xy, offset[ 2 ].x );\n\t\t\t\tcoords.y = offset[ 1 ].y; // offset[1].y = texcoord.y - 0.25 * resolution.y (@CROSSING_OFFSET)\n\t\t\t\td.x = coords.x;\n\n\t\t\t\t// Now fetch the left crossing edges, two at a time using bilinear\n\t\t\t\t// filtering. Sampling at -0.25 (see @CROSSING_OFFSET) enables to\n\t\t\t\t// discern what value each edge has:\n\t\t\t\tfloat e1 = texture2D( edgesTex, coords, 0.0 ).r;\n\n\t\t\t\t// Find the distance to the right:\n\t\t\t\tcoords.x = SMAASearchXRight( edgesTex, searchTex, offset[ 0 ].zw, offset[ 2 ].y );\n\t\t\t\td.y = coords.x;\n\n\t\t\t\t// We want the distances to be in pixel units (doing this here allow to\n\t\t\t\t// better interleave arithmetic and memory accesses):\n\t\t\t\td = d / resolution.x - pixcoord.x;\n\n\t\t\t\t// SMAAArea below needs a sqrt, as the areas texture is compressed\n\t\t\t\t// quadratically:\n\t\t\t\tvec2 sqrt_d = sqrt( abs( d ) );\n\n\t\t\t\t// Fetch the right crossing edges:\n\t\t\t\tcoords.y -= 1.0 * resolution.y; // WebGL port note: Added\n\t\t\t\tfloat e2 = SMAASampleLevelZeroOffset( edgesTex, coords, ivec2( 1, 0 ) ).r;\n\n\t\t\t\t// Ok, we know how this pattern looks like, now it is time for getting\n\t\t\t\t// the actual area:\n\t\t\t\tweights.rg = SMAAArea( areaTex, sqrt_d, e1, e2, float( subsampleIndices.y ) );\n\t\t\t}\n\n\t\t\tif ( e.r > 0.0 ) { // Edge at west\n\t\t\t\tvec2 d;\n\n\t\t\t\t// Find the distance to the top:\n\t\t\t\tvec2 coords;\n\n\t\t\t\tcoords.y = SMAASearchYUp( edgesTex, searchTex, offset[ 1 ].xy, offset[ 2 ].z );\n\t\t\t\tcoords.x = offset[ 0 ].x; // offset[1].x = texcoord.x - 0.25 * resolution.x;\n\t\t\t\td.x = coords.y;\n\n\t\t\t\t// Fetch the top crossing edges:\n\t\t\t\tfloat e1 = texture2D( edgesTex, coords, 0.0 ).g;\n\n\t\t\t\t// Find the distance to the bottom:\n\t\t\t\tcoords.y = SMAASearchYDown( edgesTex, searchTex, offset[ 1 ].zw, offset[ 2 ].w );\n\t\t\t\td.y = coords.y;\n\n\t\t\t\t// We want the distances to be in pixel units:\n\t\t\t\td = d / resolution.y - pixcoord.y;\n\n\t\t\t\t// SMAAArea below needs a sqrt, as the areas texture is compressed\n\t\t\t\t// quadratically:\n\t\t\t\tvec2 sqrt_d = sqrt( abs( d ) );\n\n\t\t\t\t// Fetch the bottom crossing edges:\n\t\t\t\tcoords.y -= 1.0 * resolution.y; // WebGL port note: Added\n\t\t\t\tfloat e2 = SMAASampleLevelZeroOffset( edgesTex, coords, ivec2( 0, 1 ) ).g;\n\n\t\t\t\t// Get the area for this direction:\n\t\t\t\tweights.ba = SMAAArea( areaTex, sqrt_d, e1, e2, float( subsampleIndices.x ) );\n\t\t\t}\n\n\t\t\treturn weights;\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tgl_FragColor = SMAABlendingWeightCalculationPS( vUv, vPixcoord, vOffset, tDiffuse, tArea, tSearch, ivec4( 0.0 ) );\n\n\t\t}"},jf={uniforms:{tDiffuse:{value:null},tColor:{value:null},resolution:{value:new jn(1/1024,1/512)}},vertexShader:"\n\n\t\tuniform vec2 resolution;\n\n\t\tvarying vec2 vUv;\n\t\tvarying vec4 vOffset[ 2 ];\n\n\t\tvoid SMAANeighborhoodBlendingVS( vec2 texcoord ) {\n\t\t\tvOffset[ 0 ] = texcoord.xyxy + resolution.xyxy * vec4( -1.0, 0.0, 0.0, 1.0 ); // WebGL port note: Changed sign in W component\n\t\t\tvOffset[ 1 ] = texcoord.xyxy + resolution.xyxy * vec4( 1.0, 0.0, 0.0, -1.0 ); // WebGL port note: Changed sign in W component\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvUv = uv;\n\n\t\t\tSMAANeighborhoodBlendingVS( vUv );\n\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t}",fragmentShader:"\n\n\t\tuniform sampler2D tDiffuse;\n\t\tuniform sampler2D tColor;\n\t\tuniform vec2 resolution;\n\n\t\tvarying vec2 vUv;\n\t\tvarying vec4 vOffset[ 2 ];\n\n\t\tvec4 SMAANeighborhoodBlendingPS( vec2 texcoord, vec4 offset[ 2 ], sampler2D colorTex, sampler2D blendTex ) {\n\t\t\t// Fetch the blending weights for current pixel:\n\t\t\tvec4 a;\n\t\t\ta.xz = texture2D( blendTex, texcoord ).xz;\n\t\t\ta.y = texture2D( blendTex, offset[ 1 ].zw ).g;\n\t\t\ta.w = texture2D( blendTex, offset[ 1 ].xy ).a;\n\n\t\t\t// Is there any blending weight with a value greater than 0.0?\n\t\t\tif ( dot(a, vec4( 1.0, 1.0, 1.0, 1.0 )) < 1e-5 ) {\n\t\t\t\treturn texture2D( colorTex, texcoord, 0.0 );\n\t\t\t} else {\n\t\t\t\t// Up to 4 lines can be crossing a pixel (one through each edge). We\n\t\t\t\t// favor blending by choosing the line with the maximum weight for each\n\t\t\t\t// direction:\n\t\t\t\tvec2 offset;\n\t\t\t\toffset.x = a.a > a.b ? a.a : -a.b; // left vs. right\n\t\t\t\toffset.y = a.g > a.r ? -a.g : a.r; // top vs. bottom // WebGL port note: Changed signs\n\n\t\t\t\t// Then we go in the direction that has the maximum weight:\n\t\t\t\tif ( abs( offset.x ) > abs( offset.y )) { // horizontal vs. vertical\n\t\t\t\t\toffset.y = 0.0;\n\t\t\t\t} else {\n\t\t\t\t\toffset.x = 0.0;\n\t\t\t\t}\n\n\t\t\t\t// Fetch the opposite color and lerp by hand:\n\t\t\t\tvec4 C = texture2D( colorTex, texcoord, 0.0 );\n\t\t\t\ttexcoord += sign( offset ) * resolution;\n\t\t\t\tvec4 Cop = texture2D( colorTex, texcoord, 0.0 );\n\t\t\t\tfloat s = abs( offset.x ) > abs( offset.y ) ? abs( offset.x ) : abs( offset.y );\n\n\t\t\t\t// WebGL port note: Added gamma correction\n\t\t\t\tC.xyz = pow(C.xyz, vec3(2.2));\n\t\t\t\tCop.xyz = pow(Cop.xyz, vec3(2.2));\n\t\t\t\tvec4 mixed = mix(C, Cop, s);\n\t\t\t\tmixed.xyz = pow(mixed.xyz, vec3(1.0 / 2.2));\n\n\t\t\t\treturn mixed;\n\t\t\t}\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tgl_FragColor = SMAANeighborhoodBlendingPS( vUv, vOffset, tColor, tDiffuse );\n\n\t\t}"},Yf=[[[0,0]],[[4,4],[-4,-4]],[[-2,-6],[6,-2],[-6,2],[2,6]],[[1,-3],[-1,3],[5,1],[-3,-5],[-5,5],[-7,-1],[3,7],[7,-7]],[[1,1],[-1,-3],[-3,2],[4,-1],[-5,-2],[2,5],[5,3],[3,-5],[-2,6],[0,-7],[-4,-6],[-6,4],[-8,0],[7,-4],[6,7],[-7,-8]],[[-4,-7],[-7,-5],[-3,-5],[-5,-4],[-1,-4],[-2,-2],[-6,-1],[-4,0],[-7,1],[-1,2],[-6,3],[-3,3],[-7,6],[-3,6],[-5,7],[-1,7],[5,-7],[1,-6],[6,-5],[4,-4],[2,-3],[7,-2],[1,-1],[4,-1],[2,1],[6,2],[0,4],[4,4],[2,5],[7,5],[5,6],[3,7]]],qf={defines:{NUM_SAMPLES:7,NUM_RINGS:4,NORMAL_TEXTURE:0,DIFFUSE_TEXTURE:0,DEPTH_PACKING:1,PERSPECTIVE_CAMERA:1},uniforms:{tDepth:{value:null},tDiffuse:{value:null},tNormal:{value:null},size:{value:new jn(512,512)},cameraNear:{value:1},cameraFar:{value:100},cameraProjectionMatrix:{value:new zr},cameraInverseProjectionMatrix:{value:new zr},scale:{value:1},intensity:{value:.1},bias:{value:.5},minResolution:{value:0},kernelRadius:{value:100},randomSeed:{value:0}},vertexShader:"\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\t\t\tvUv = uv;\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t}",fragmentShader:"\n\n\t\t#include <common>\n\n\t\tvarying vec2 vUv;\n\n\t\t#if DIFFUSE_TEXTURE == 1\n\t\tuniform sampler2D tDiffuse;\n\t\t#endif\n\n\t\tuniform sampler2D tDepth;\n\n\t\t#if NORMAL_TEXTURE == 1\n\t\tuniform sampler2D tNormal;\n\t\t#endif\n\n\t\tuniform float cameraNear;\n\t\tuniform float cameraFar;\n\t\tuniform mat4 cameraProjectionMatrix;\n\t\tuniform mat4 cameraInverseProjectionMatrix;\n\n\t\tuniform float scale;\n\t\tuniform float intensity;\n\t\tuniform float bias;\n\t\tuniform float kernelRadius;\n\t\tuniform float minResolution;\n\t\tuniform vec2 size;\n\t\tuniform float randomSeed;\n\n\t\t// RGBA depth\n\n\t\t#include <packing>\n\n\t\tvec4 getDefaultColor( const in vec2 screenPosition ) {\n\t\t\t#if DIFFUSE_TEXTURE == 1\n\t\t\treturn texture2D( tDiffuse, vUv );\n\t\t\t#else\n\t\t\treturn vec4( 1.0 );\n\t\t\t#endif\n\t\t}\n\n\t\tfloat getDepth( const in vec2 screenPosition ) {\n\t\t\t#if DEPTH_PACKING == 1\n\t\t\treturn unpackRGBAToDepth( texture2D( tDepth, screenPosition ) );\n\t\t\t#else\n\t\t\treturn texture2D( tDepth, screenPosition ).x;\n\t\t\t#endif\n\t\t}\n\n\t\tfloat getViewZ( const in float depth ) {\n\t\t\t#if PERSPECTIVE_CAMERA == 1\n\t\t\treturn perspectiveDepthToViewZ( depth, cameraNear, cameraFar );\n\t\t\t#else\n\t\t\treturn orthographicDepthToViewZ( depth, cameraNear, cameraFar );\n\t\t\t#endif\n\t\t}\n\n\t\tvec3 getViewPosition( const in vec2 screenPosition, const in float depth, const in float viewZ ) {\n\t\t\tfloat clipW = cameraProjectionMatrix[2][3] * viewZ + cameraProjectionMatrix[3][3];\n\t\t\tvec4 clipPosition = vec4( ( vec3( screenPosition, depth ) - 0.5 ) * 2.0, 1.0 );\n\t\t\tclipPosition *= clipW; // unprojection.\n\n\t\t\treturn ( cameraInverseProjectionMatrix * clipPosition ).xyz;\n\t\t}\n\n\t\tvec3 getViewNormal( const in vec3 viewPosition, const in vec2 screenPosition ) {\n\t\t\t#if NORMAL_TEXTURE == 1\n\t\t\treturn unpackRGBToNormal( texture2D( tNormal, screenPosition ).xyz );\n\t\t\t#else\n\t\t\treturn normalize( cross( dFdx( viewPosition ), dFdy( viewPosition ) ) );\n\t\t\t#endif\n\t\t}\n\n\t\tfloat scaleDividedByCameraFar;\n\t\tfloat minResolutionMultipliedByCameraFar;\n\n\t\tfloat getOcclusion( const in vec3 centerViewPosition, const in vec3 centerViewNormal, const in vec3 sampleViewPosition ) {\n\t\t\tvec3 viewDelta = sampleViewPosition - centerViewPosition;\n\t\t\tfloat viewDistance = length( viewDelta );\n\t\t\tfloat scaledScreenDistance = scaleDividedByCameraFar * viewDistance;\n\n\t\t\treturn max(0.0, (dot(centerViewNormal, viewDelta) - minResolutionMultipliedByCameraFar) / scaledScreenDistance - bias) / (1.0 + pow2( scaledScreenDistance ) );\n\t\t}\n\n\t\t// moving costly divides into consts\n\t\tconst float ANGLE_STEP = PI2 * float( NUM_RINGS ) / float( NUM_SAMPLES );\n\t\tconst float INV_NUM_SAMPLES = 1.0 / float( NUM_SAMPLES );\n\n\t\tfloat getAmbientOcclusion( const in vec3 centerViewPosition ) {\n\t\t\t// precompute some variables require in getOcclusion.\n\t\t\tscaleDividedByCameraFar = scale / cameraFar;\n\t\t\tminResolutionMultipliedByCameraFar = minResolution * cameraFar;\n\t\t\tvec3 centerViewNormal = getViewNormal( centerViewPosition, vUv );\n\n\t\t\t// jsfiddle that shows sample pattern: https://jsfiddle.net/a16ff1p7/\n\t\t\tfloat angle = rand( vUv + randomSeed ) * PI2;\n\t\t\tvec2 radius = vec2( kernelRadius * INV_NUM_SAMPLES ) / size;\n\t\t\tvec2 radiusStep = radius;\n\n\t\t\tfloat occlusionSum = 0.0;\n\t\t\tfloat weightSum = 0.0;\n\n\t\t\tfor( int i = 0; i < NUM_SAMPLES; i ++ ) {\n\t\t\t\tvec2 sampleUv = vUv + vec2( cos( angle ), sin( angle ) ) * radius;\n\t\t\t\tradius += radiusStep;\n\t\t\t\tangle += ANGLE_STEP;\n\n\t\t\t\tfloat sampleDepth = getDepth( sampleUv );\n\t\t\t\tif( sampleDepth >= ( 1.0 - EPSILON ) ) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tfloat sampleViewZ = getViewZ( sampleDepth );\n\t\t\t\tvec3 sampleViewPosition = getViewPosition( sampleUv, sampleDepth, sampleViewZ );\n\t\t\t\tocclusionSum += getOcclusion( centerViewPosition, centerViewNormal, sampleViewPosition );\n\t\t\t\tweightSum += 1.0;\n\t\t\t}\n\n\t\t\tif( weightSum == 0.0 ) discard;\n\n\t\t\treturn occlusionSum * ( intensity / weightSum );\n\t\t}\n\n\t\tvoid main() {\n\t\t\tfloat centerDepth = getDepth( vUv );\n\t\t\tif( centerDepth >= ( 1.0 - EPSILON ) ) {\n\t\t\t\tdiscard;\n\t\t\t}\n\n\t\t\tfloat centerViewZ = getViewZ( centerDepth );\n\t\t\tvec3 viewPosition = getViewPosition( vUv, centerDepth, centerViewZ );\n\n\t\t\tfloat ambientOcclusion = getAmbientOcclusion( viewPosition );\n\n\t\t\tgl_FragColor = getDefaultColor( vUv );\n\t\t\tgl_FragColor.xyz *=  1.0 - ambientOcclusion;\n\t\t}"},Qf={defines:{KERNEL_RADIUS:4,DEPTH_PACKING:1,PERSPECTIVE_CAMERA:1},uniforms:{tDiffuse:{value:null},size:{value:new jn(512,512)},sampleUvOffsets:{value:[new jn(0,0)]},sampleWeights:{value:[1]},tDepth:{value:null},cameraNear:{value:10},cameraFar:{value:1e3},depthCutoff:{value:10}},vertexShader:"\n\n\t\t#include <common>\n\n\t\tuniform vec2 size;\n\n\t\tvarying vec2 vUv;\n\t\tvarying vec2 vInvSize;\n\n\t\tvoid main() {\n\t\t\tvUv = uv;\n\t\t\tvInvSize = 1.0 / size;\n\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t}",fragmentShader:"\n\n\t\t#include <common>\n\t\t#include <packing>\n\n\t\tuniform sampler2D tDiffuse;\n\t\tuniform sampler2D tDepth;\n\n\t\tuniform float cameraNear;\n\t\tuniform float cameraFar;\n\t\tuniform float depthCutoff;\n\n\t\tuniform vec2 sampleUvOffsets[ KERNEL_RADIUS + 1 ];\n\t\tuniform float sampleWeights[ KERNEL_RADIUS + 1 ];\n\n\t\tvarying vec2 vUv;\n\t\tvarying vec2 vInvSize;\n\n\t\tfloat getDepth( const in vec2 screenPosition ) {\n\t\t\t#if DEPTH_PACKING == 1\n\t\t\treturn unpackRGBAToDepth( texture2D( tDepth, screenPosition ) );\n\t\t\t#else\n\t\t\treturn texture2D( tDepth, screenPosition ).x;\n\t\t\t#endif\n\t\t}\n\n\t\tfloat getViewZ( const in float depth ) {\n\t\t\t#if PERSPECTIVE_CAMERA == 1\n\t\t\treturn perspectiveDepthToViewZ( depth, cameraNear, cameraFar );\n\t\t\t#else\n\t\t\treturn orthographicDepthToViewZ( depth, cameraNear, cameraFar );\n\t\t\t#endif\n\t\t}\n\n\t\tvoid main() {\n\t\t\tfloat depth = getDepth( vUv );\n\t\t\tif( depth >= ( 1.0 - EPSILON ) ) {\n\t\t\t\tdiscard;\n\t\t\t}\n\n\t\t\tfloat centerViewZ = -getViewZ( depth );\n\t\t\tbool rBreak = false, lBreak = false;\n\n\t\t\tfloat weightSum = sampleWeights[0];\n\t\t\tvec4 diffuseSum = texture2D( tDiffuse, vUv ) * weightSum;\n\n\t\t\tfor( int i = 1; i <= KERNEL_RADIUS; i ++ ) {\n\n\t\t\t\tfloat sampleWeight = sampleWeights[i];\n\t\t\t\tvec2 sampleUvOffset = sampleUvOffsets[i] * vInvSize;\n\n\t\t\t\tvec2 sampleUv = vUv + sampleUvOffset;\n\t\t\t\tfloat viewZ = -getViewZ( getDepth( sampleUv ) );\n\n\t\t\t\tif( abs( viewZ - centerViewZ ) > depthCutoff ) rBreak = true;\n\n\t\t\t\tif( ! rBreak ) {\n\t\t\t\t\tdiffuseSum += texture2D( tDiffuse, sampleUv ) * sampleWeight;\n\t\t\t\t\tweightSum += sampleWeight;\n\t\t\t\t}\n\n\t\t\t\tsampleUv = vUv - sampleUvOffset;\n\t\t\t\tviewZ = -getViewZ( getDepth( sampleUv ) );\n\n\t\t\t\tif( abs( viewZ - centerViewZ ) > depthCutoff ) lBreak = true;\n\n\t\t\t\tif( ! lBreak ) {\n\t\t\t\t\tdiffuseSum += texture2D( tDiffuse, sampleUv ) * sampleWeight;\n\t\t\t\t\tweightSum += sampleWeight;\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tgl_FragColor = diffuseSum / weightSum;\n\t\t}"},Zf={createSampleWeights:function(t,e){const n=[];for(let r=0;r<=t;r++)n.push(Jf(r,e));return n},createSampleOffsets:function(t,e){const n=[];for(let r=0;r<=t;r++)n.push(e.clone().multiplyScalar(r));return n},configure:function(t,e,n,r){t.defines.KERNEL_RADIUS=e,t.uniforms.sampleUvOffsets.value=Zf.createSampleOffsets(e,r),t.uniforms.sampleWeights.value=Zf.createSampleWeights(e,n),t.needsUpdate=!0}};function Jf(t,e){return Math.exp(-t*t/(e*e*2))/(Math.sqrt(2*Math.PI)*e)}const Kf={uniforms:{tDiffuse:{value:null},opacity:{value:1}},vertexShader:"\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvUv = uv;\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t}",fragmentShader:"\n\n\t\tuniform float opacity;\n\n\t\tuniform sampler2D tDiffuse;\n\n\t\tvarying vec2 vUv;\n\n\t\t#include <packing>\n\n\t\tvoid main() {\n\n\t\t\tfloat depth = 1.0 - unpackRGBAToDepth( texture2D( tDiffuse, vUv ) );\n\t\t\tgl_FragColor = vec4( vec3( depth ), opacity );\n\n\t\t}"};class $f extends Uf{constructor(t,e,n=!1,r=!1,i=new jn(256,256)){let s;super(),this.scene=t,this.camera=e,this.clear=!0,this.needsSwap=!1,this.supportsDepthTextureExtension=n,this.supportsNormalTexture=r,this.originalClearColor=new Li,this._oldClearColor=new Li,this.oldClearAlpha=1,this.params={output:0,saoBias:.5,saoIntensity:.18,saoScale:1,saoKernelRadius:100,saoMinResolution:0,saoBlur:!0,saoBlurRadius:8,saoBlurStdDev:4,saoBlurDepthCutoff:.01},this.resolution=new jn(i.x,i.y),this.saoRenderTarget=new ir(this.resolution.x,this.resolution.y,{minFilter:Mt,magFilter:Mt,format:Gt}),this.blurIntermediateRenderTarget=this.saoRenderTarget.clone(),this.beautyRenderTarget=this.saoRenderTarget.clone(),this.normalRenderTarget=new ir(this.resolution.x,this.resolution.y,{minFilter:xt,magFilter:xt,format:Gt}),this.depthRenderTarget=this.normalRenderTarget.clone(),this.supportsDepthTextureExtension&&(s=new Ml,s.type=Rt,this.beautyRenderTarget.depthTexture=s,this.beautyRenderTarget.depthBuffer=!0),this.depthMaterial=new pl,this.depthMaterial.depthPacking=nn,this.depthMaterial.blending=M,this.normalMaterial=new hu,this.normalMaterial.blending=M,void 0===qf&&console.error("THREE.SAOPass relies on SAOShader"),this.saoMaterial=new _s({defines:Object.assign({},qf.defines),fragmentShader:qf.fragmentShader,vertexShader:qf.vertexShader,uniforms:bs.clone(qf.uniforms)}),this.saoMaterial.extensions.derivatives=!0,this.saoMaterial.defines.DEPTH_PACKING=this.supportsDepthTextureExtension?0:1,this.saoMaterial.defines.NORMAL_TEXTURE=this.supportsNormalTexture?1:0,this.saoMaterial.defines.PERSPECTIVE_CAMERA=this.camera.isPerspectiveCamera?1:0,this.saoMaterial.uniforms.tDepth.value=this.supportsDepthTextureExtension?s:this.depthRenderTarget.texture,this.saoMaterial.uniforms.tNormal.value=this.normalRenderTarget.texture,this.saoMaterial.uniforms.size.value.set(this.resolution.x,this.resolution.y),this.saoMaterial.uniforms.cameraInverseProjectionMatrix.value.copy(this.camera.projectionMatrixInverse),this.saoMaterial.uniforms.cameraProjectionMatrix.value=this.camera.projectionMatrix,this.saoMaterial.blending=M,void 0===Qf&&console.error("THREE.SAOPass relies on DepthLimitedBlurShader"),this.vBlurMaterial=new _s({uniforms:bs.clone(Qf.uniforms),defines:Object.assign({},Qf.defines),vertexShader:Qf.vertexShader,fragmentShader:Qf.fragmentShader}),this.vBlurMaterial.defines.DEPTH_PACKING=this.supportsDepthTextureExtension?0:1,this.vBlurMaterial.defines.PERSPECTIVE_CAMERA=this.camera.isPerspectiveCamera?1:0,this.vBlurMaterial.uniforms.tDiffuse.value=this.saoRenderTarget.texture,this.vBlurMaterial.uniforms.tDepth.value=this.supportsDepthTextureExtension?s:this.depthRenderTarget.texture,this.vBlurMaterial.uniforms.size.value.set(this.resolution.x,this.resolution.y),this.vBlurMaterial.blending=M,this.hBlurMaterial=new _s({uniforms:bs.clone(Qf.uniforms),defines:Object.assign({},Qf.defines),vertexShader:Qf.vertexShader,fragmentShader:Qf.fragmentShader}),this.hBlurMaterial.defines.DEPTH_PACKING=this.supportsDepthTextureExtension?0:1,this.hBlurMaterial.defines.PERSPECTIVE_CAMERA=this.camera.isPerspectiveCamera?1:0,this.hBlurMaterial.uniforms.tDiffuse.value=this.blurIntermediateRenderTarget.texture,this.hBlurMaterial.uniforms.tDepth.value=this.supportsDepthTextureExtension?s:this.depthRenderTarget.texture,this.hBlurMaterial.uniforms.size.value.set(this.resolution.x,this.resolution.y),this.hBlurMaterial.blending=M,void 0===If&&console.error("THREE.SAOPass relies on CopyShader"),this.materialCopy=new _s({uniforms:bs.clone(If.uniforms),vertexShader:If.vertexShader,fragmentShader:If.fragmentShader,blending:M}),this.materialCopy.transparent=!0,this.materialCopy.depthTest=!1,this.materialCopy.depthWrite=!1,this.materialCopy.blending=C,this.materialCopy.blendSrc=G,this.materialCopy.blendDst=I,this.materialCopy.blendEquation=P,this.materialCopy.blendSrcAlpha=k,this.materialCopy.blendDstAlpha=I,this.materialCopy.blendEquationAlpha=P,void 0===Kf&&console.error("THREE.SAOPass relies on UnpackDepthRGBAShader"),this.depthCopy=new _s({uniforms:bs.clone(Kf.uniforms),vertexShader:Kf.vertexShader,fragmentShader:Kf.fragmentShader,blending:M}),this.fsQuad=new Bf(null)}render(t,e,n){if(this.renderToScreen&&(this.materialCopy.blending=M,this.materialCopy.uniforms.tDiffuse.value=n.texture,this.materialCopy.needsUpdate=!0,this.renderPass(t,this.materialCopy,null)),1===this.params.output)return;t.getClearColor(this._oldClearColor),this.oldClearAlpha=t.getClearAlpha();const r=t.autoClear;t.autoClear=!1,t.setRenderTarget(this.depthRenderTarget),t.clear(),this.saoMaterial.uniforms.bias.value=this.params.saoBias,this.saoMaterial.uniforms.intensity.value=this.params.saoIntensity,this.saoMaterial.uniforms.scale.value=this.params.saoScale,this.saoMaterial.uniforms.kernelRadius.value=this.params.saoKernelRadius,this.saoMaterial.uniforms.minResolution.value=this.params.saoMinResolution,this.saoMaterial.uniforms.cameraNear.value=this.camera.near,this.saoMaterial.uniforms.cameraFar.value=this.camera.far;const i=this.params.saoBlurDepthCutoff*(this.camera.far-this.camera.near);this.vBlurMaterial.uniforms.depthCutoff.value=i,this.hBlurMaterial.uniforms.depthCutoff.value=i,this.vBlurMaterial.uniforms.cameraNear.value=this.camera.near,this.vBlurMaterial.uniforms.cameraFar.value=this.camera.far,this.hBlurMaterial.uniforms.cameraNear.value=this.camera.near,this.hBlurMaterial.uniforms.cameraFar.value=this.camera.far,this.params.saoBlurRadius=Math.floor(this.params.saoBlurRadius),this.prevStdDev===this.params.saoBlurStdDev&&this.prevNumSamples===this.params.saoBlurRadius||(Zf.configure(this.vBlurMaterial,this.params.saoBlurRadius,this.params.saoBlurStdDev,new jn(0,1)),Zf.configure(this.hBlurMaterial,this.params.saoBlurRadius,this.params.saoBlurStdDev,new jn(1,0)),this.prevStdDev=this.params.saoBlurStdDev,this.prevNumSamples=this.params.saoBlurRadius),t.setClearColor(0),t.setRenderTarget(this.beautyRenderTarget),t.clear(),t.render(this.scene,this.camera),this.supportsDepthTextureExtension||this.renderOverride(t,this.depthMaterial,this.depthRenderTarget,0,1),this.supportsNormalTexture&&this.renderOverride(t,this.normalMaterial,this.normalRenderTarget,7829503,1),this.renderPass(t,this.saoMaterial,this.saoRenderTarget,16777215,1),this.params.saoBlur&&(this.renderPass(t,this.vBlurMaterial,this.blurIntermediateRenderTarget,16777215,1),this.renderPass(t,this.hBlurMaterial,this.saoRenderTarget,16777215,1));let s=this.materialCopy;3===this.params.output?this.supportsDepthTextureExtension?(this.materialCopy.uniforms.tDiffuse.value=this.beautyRenderTarget.depthTexture,this.materialCopy.needsUpdate=!0):(this.depthCopy.uniforms.tDiffuse.value=this.depthRenderTarget.texture,this.depthCopy.needsUpdate=!0,s=this.depthCopy):4===this.params.output?(this.materialCopy.uniforms.tDiffuse.value=this.normalRenderTarget.texture,this.materialCopy.needsUpdate=!0):(this.materialCopy.uniforms.tDiffuse.value=this.saoRenderTarget.texture,this.materialCopy.needsUpdate=!0),0===this.params.output?s.blending=C:s.blending=M,this.renderPass(t,s,this.renderToScreen?null:n),t.setClearColor(this._oldClearColor,this.oldClearAlpha),t.autoClear=r}renderPass(t,e,n,r,i){t.getClearColor(this.originalClearColor);const s=t.getClearAlpha(),a=t.autoClear;t.setRenderTarget(n),t.autoClear=!1,null!=r&&(t.setClearColor(r),t.setClearAlpha(i||0),t.clear()),this.fsQuad.material=e,this.fsQuad.render(t),t.autoClear=a,t.setClearColor(this.originalClearColor),t.setClearAlpha(s)}renderOverride(t,e,n,r,i){t.getClearColor(this.originalClearColor);const s=t.getClearAlpha(),a=t.autoClear;t.setRenderTarget(n),t.autoClear=!1,r=e.clearColor||r,i=e.clearAlpha||i,null!=r&&(t.setClearColor(r),t.setClearAlpha(i||0),t.clear()),this.scene.overrideMaterial=e,t.render(this.scene,this.camera),this.scene.overrideMaterial=null,t.autoClear=a,t.setClearColor(this.originalClearColor),t.setClearAlpha(s)}setSize(t,e){this.beautyRenderTarget.setSize(t,e),this.saoRenderTarget.setSize(t,e),this.blurIntermediateRenderTarget.setSize(t,e),this.normalRenderTarget.setSize(t,e),this.depthRenderTarget.setSize(t,e),this.saoMaterial.uniforms.size.value.set(t,e),this.saoMaterial.uniforms.cameraInverseProjectionMatrix.value.copy(this.camera.projectionMatrixInverse),this.saoMaterial.uniforms.cameraProjectionMatrix.value=this.camera.projectionMatrix,this.saoMaterial.needsUpdate=!0,this.vBlurMaterial.uniforms.size.value.set(t,e),this.vBlurMaterial.needsUpdate=!0,this.hBlurMaterial.uniforms.size.value.set(t,e),this.hBlurMaterial.needsUpdate=!0}}$f.OUTPUT={Beauty:1,Default:0,SAO:2,Depth:3,Normal:4};const tm={shaderID:"luminosityHighPass",uniforms:{tDiffuse:{value:null},luminosityThreshold:{value:1},smoothWidth:{value:1},defaultColor:{value:new Li(0)},defaultOpacity:{value:0}},vertexShader:"\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvUv = uv;\n\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t}",fragmentShader:"\n\n\t\tuniform sampler2D tDiffuse;\n\t\tuniform vec3 defaultColor;\n\t\tuniform float defaultOpacity;\n\t\tuniform float luminosityThreshold;\n\t\tuniform float smoothWidth;\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvec4 texel = texture2D( tDiffuse, vUv );\n\n\t\t\tvec3 luma = vec3( 0.299, 0.587, 0.114 );\n\n\t\t\tfloat v = dot( texel.xyz, luma );\n\n\t\t\tvec4 outputColor = vec4( defaultColor.rgb, defaultOpacity );\n\n\t\t\tfloat alpha = smoothstep( luminosityThreshold, luminosityThreshold + smoothWidth, v );\n\n\t\t\tgl_FragColor = mix( outputColor, texel, alpha );\n\n\t\t}"};class em extends Uf{constructor(t,e,n,r){super(),this.strength=void 0!==e?e:1,this.radius=n,this.threshold=r,this.resolution=void 0!==t?new jn(t.x,t.y):new jn(256,256),this.clearColor=new Li(0,0,0);const i={minFilter:Mt,magFilter:Mt,format:Gt};this.renderTargetsHorizontal=[],this.renderTargetsVertical=[],this.nMips=5;let s=Math.round(this.resolution.x/2),a=Math.round(this.resolution.y/2);this.renderTargetBright=new ir(s,a,i),this.renderTargetBright.texture.name="UnrealBloomPass.bright",this.renderTargetBright.texture.generateMipmaps=!1;for(let t=0;t<this.nMips;t++){const e=new ir(s,a,i);e.texture.name="UnrealBloomPass.h"+t,e.texture.generateMipmaps=!1,this.renderTargetsHorizontal.push(e);const n=new ir(s,a,i);n.texture.name="UnrealBloomPass.v"+t,n.texture.generateMipmaps=!1,this.renderTargetsVertical.push(n),s=Math.round(s/2),a=Math.round(a/2)}void 0===tm&&console.error("THREE.UnrealBloomPass relies on LuminosityHighPassShader");const o=tm;this.highPassUniforms=bs.clone(o.uniforms),this.highPassUniforms.luminosityThreshold.value=r,this.highPassUniforms.smoothWidth.value=.01,this.materialHighPassFilter=new _s({uniforms:this.highPassUniforms,vertexShader:o.vertexShader,fragmentShader:o.fragmentShader,defines:{}}),this.separableBlurMaterials=[];const l=[3,5,7,9,11];s=Math.round(this.resolution.x/2),a=Math.round(this.resolution.y/2);for(let t=0;t<this.nMips;t++)this.separableBlurMaterials.push(this.getSeperableBlurMaterial(l[t])),this.separableBlurMaterials[t].uniforms.texSize.value=new jn(s,a),s=Math.round(s/2),a=Math.round(a/2);this.compositeMaterial=this.getCompositeMaterial(this.nMips),this.compositeMaterial.uniforms.blurTexture1.value=this.renderTargetsVertical[0].texture,this.compositeMaterial.uniforms.blurTexture2.value=this.renderTargetsVertical[1].texture,this.compositeMaterial.uniforms.blurTexture3.value=this.renderTargetsVertical[2].texture,this.compositeMaterial.uniforms.blurTexture4.value=this.renderTargetsVertical[3].texture,this.compositeMaterial.uniforms.blurTexture5.value=this.renderTargetsVertical[4].texture,this.compositeMaterial.uniforms.bloomStrength.value=e,this.compositeMaterial.uniforms.bloomRadius.value=.1,this.compositeMaterial.needsUpdate=!0,this.compositeMaterial.uniforms.bloomFactors.value=[1,.8,.6,.4,.2],this.bloomTintColors=[new lr(1,1,1),new lr(1,1,1),new lr(1,1,1),new lr(1,1,1),new lr(1,1,1)],this.compositeMaterial.uniforms.bloomTintColors.value=this.bloomTintColors,void 0===If&&console.error("THREE.UnrealBloomPass relies on CopyShader");const c=If;this.copyUniforms=bs.clone(c.uniforms),this.copyUniforms.opacity.value=1,this.materialCopy=new _s({uniforms:this.copyUniforms,vertexShader:c.vertexShader,fragmentShader:c.fragmentShader,blending:S,depthTest:!1,depthWrite:!1,transparent:!0}),this.enabled=!0,this.needsSwap=!1,this._oldClearColor=new Li,this.oldClearAlpha=1,this.basic=new Ri,this.fsQuad=new Bf(null)}dispose(){for(let t=0;t<this.renderTargetsHorizontal.length;t++)this.renderTargetsHorizontal[t].dispose();for(let t=0;t<this.renderTargetsVertical.length;t++)this.renderTargetsVertical[t].dispose();this.renderTargetBright.dispose()}setSize(t,e){let n=Math.round(t/2),r=Math.round(e/2);this.renderTargetBright.setSize(n,r);for(let t=0;t<this.nMips;t++)this.renderTargetsHorizontal[t].setSize(n,r),this.renderTargetsVertical[t].setSize(n,r),this.separableBlurMaterials[t].uniforms.texSize.value=new jn(n,r),n=Math.round(n/2),r=Math.round(r/2)}render(t,e,n,r,i){t.getClearColor(this._oldClearColor),this.oldClearAlpha=t.getClearAlpha();const s=t.autoClear;t.autoClear=!1,t.setClearColor(this.clearColor,0),i&&t.state.buffers.stencil.setTest(!1),this.renderToScreen&&(this.fsQuad.material=this.basic,this.basic.map=n.texture,t.setRenderTarget(null),t.clear(),this.fsQuad.render(t)),this.highPassUniforms.tDiffuse.value=n.texture,this.highPassUniforms.luminosityThreshold.value=this.threshold,this.fsQuad.material=this.materialHighPassFilter,t.setRenderTarget(this.renderTargetBright),t.clear(),this.fsQuad.render(t);let a=this.renderTargetBright;for(let e=0;e<this.nMips;e++)this.fsQuad.material=this.separableBlurMaterials[e],this.separableBlurMaterials[e].uniforms.colorTexture.value=a.texture,this.separableBlurMaterials[e].uniforms.direction.value=em.BlurDirectionX,t.setRenderTarget(this.renderTargetsHorizontal[e]),t.clear(),this.fsQuad.render(t),this.separableBlurMaterials[e].uniforms.colorTexture.value=this.renderTargetsHorizontal[e].texture,this.separableBlurMaterials[e].uniforms.direction.value=em.BlurDirectionY,t.setRenderTarget(this.renderTargetsVertical[e]),t.clear(),this.fsQuad.render(t),a=this.renderTargetsVertical[e];this.fsQuad.material=this.compositeMaterial,this.compositeMaterial.uniforms.bloomStrength.value=this.strength,this.compositeMaterial.uniforms.bloomRadius.value=this.radius,this.compositeMaterial.uniforms.bloomTintColors.value=this.bloomTintColors,t.setRenderTarget(this.renderTargetsHorizontal[0]),t.clear(),this.fsQuad.render(t),this.fsQuad.material=this.materialCopy,this.copyUniforms.tDiffuse.value=this.renderTargetsHorizontal[0].texture,i&&t.state.buffers.stencil.setTest(!0),this.renderToScreen?(t.setRenderTarget(null),this.fsQuad.render(t)):(t.setRenderTarget(n),this.fsQuad.render(t)),t.setClearColor(this._oldClearColor,this.oldClearAlpha),t.autoClear=s}getSeperableBlurMaterial(t){return new _s({defines:{KERNEL_RADIUS:t,SIGMA:t},uniforms:{colorTexture:{value:null},texSize:{value:new jn(.5,.5)},direction:{value:new jn(.5,.5)}},vertexShader:"varying vec2 vUv;\n\t\t\t\tvoid main() {\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t}",fragmentShader:"#include <common>\n\t\t\t\tvarying vec2 vUv;\n\t\t\t\tuniform sampler2D colorTexture;\n\t\t\t\tuniform vec2 texSize;\n\t\t\t\tuniform vec2 direction;\n\n\t\t\t\tfloat gaussianPdf(in float x, in float sigma) {\n\t\t\t\t\treturn 0.39894 * exp( -0.5 * x * x/( sigma * sigma))/sigma;\n\t\t\t\t}\n\t\t\t\tvoid main() {\n\t\t\t\t\tvec2 invSize = 1.0 / texSize;\n\t\t\t\t\tfloat fSigma = float(SIGMA);\n\t\t\t\t\tfloat weightSum = gaussianPdf(0.0, fSigma);\n\t\t\t\t\tvec3 diffuseSum = texture2D( colorTexture, vUv).rgb * weightSum;\n\t\t\t\t\tfor( int i = 1; i < KERNEL_RADIUS; i ++ ) {\n\t\t\t\t\t\tfloat x = float(i);\n\t\t\t\t\t\tfloat w = gaussianPdf(x, fSigma);\n\t\t\t\t\t\tvec2 uvOffset = direction * invSize * x;\n\t\t\t\t\t\tvec3 sample1 = texture2D( colorTexture, vUv + uvOffset).rgb;\n\t\t\t\t\t\tvec3 sample2 = texture2D( colorTexture, vUv - uvOffset).rgb;\n\t\t\t\t\t\tdiffuseSum += (sample1 + sample2) * w;\n\t\t\t\t\t\tweightSum += 2.0 * w;\n\t\t\t\t\t}\n\t\t\t\t\tgl_FragColor = vec4(diffuseSum/weightSum, 1.0);\n\t\t\t\t}"})}getCompositeMaterial(t){return new _s({defines:{NUM_MIPS:t},uniforms:{blurTexture1:{value:null},blurTexture2:{value:null},blurTexture3:{value:null},blurTexture4:{value:null},blurTexture5:{value:null},dirtTexture:{value:null},bloomStrength:{value:1},bloomFactors:{value:null},bloomTintColors:{value:null},bloomRadius:{value:0}},vertexShader:"varying vec2 vUv;\n\t\t\t\tvoid main() {\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t}",fragmentShader:"varying vec2 vUv;\n\t\t\t\tuniform sampler2D blurTexture1;\n\t\t\t\tuniform sampler2D blurTexture2;\n\t\t\t\tuniform sampler2D blurTexture3;\n\t\t\t\tuniform sampler2D blurTexture4;\n\t\t\t\tuniform sampler2D blurTexture5;\n\t\t\t\tuniform sampler2D dirtTexture;\n\t\t\t\tuniform float bloomStrength;\n\t\t\t\tuniform float bloomRadius;\n\t\t\t\tuniform float bloomFactors[NUM_MIPS];\n\t\t\t\tuniform vec3 bloomTintColors[NUM_MIPS];\n\n\t\t\t\tfloat lerpBloomFactor(const in float factor) {\n\t\t\t\t\tfloat mirrorFactor = 1.2 - factor;\n\t\t\t\t\treturn mix(factor, mirrorFactor, bloomRadius);\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\t\t\t\t\tgl_FragColor = bloomStrength * ( lerpBloomFactor(bloomFactors[0]) * vec4(bloomTintColors[0], 1.0) * texture2D(blurTexture1, vUv) +\n\t\t\t\t\t\tlerpBloomFactor(bloomFactors[1]) * vec4(bloomTintColors[1], 1.0) * texture2D(blurTexture2, vUv) +\n\t\t\t\t\t\tlerpBloomFactor(bloomFactors[2]) * vec4(bloomTintColors[2], 1.0) * texture2D(blurTexture3, vUv) +\n\t\t\t\t\t\tlerpBloomFactor(bloomFactors[3]) * vec4(bloomTintColors[3], 1.0) * texture2D(blurTexture4, vUv) +\n\t\t\t\t\t\tlerpBloomFactor(bloomFactors[4]) * vec4(bloomTintColors[4], 1.0) * texture2D(blurTexture5, vUv) );\n\t\t\t\t}"})}}em.BlurDirectionX=new jn(1,0),em.BlurDirectionY=new jn(0,1);const nm={uniforms:{tDiffuse:{value:null},resolution:{value:new jn}},vertexShader:"\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvUv = uv;\n\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t}",fragmentShader:"\n\n\t\tuniform sampler2D tDiffuse;\n\t\tuniform vec2 resolution;\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvec2 texel = vec2( 1.0 / resolution.x, 1.0 / resolution.y );\n\n\t\t// kernel definition (in glsl matrices are filled in column-major order)\n\n\t\t\tconst mat3 Gx = mat3( -1, -2, -1, 0, 0, 0, 1, 2, 1 ); // x direction kernel\n\t\t\tconst mat3 Gy = mat3( -1, 0, 1, -2, 0, 2, -1, 0, 1 ); // y direction kernel\n\n\t\t// fetch the 3x3 neighbourhood of a fragment\n\n\t\t// first column\n\n\t\t\tfloat tx0y0 = texture2D( tDiffuse, vUv + texel * vec2( -1, -1 ) ).r;\n\t\t\tfloat tx0y1 = texture2D( tDiffuse, vUv + texel * vec2( -1,  0 ) ).r;\n\t\t\tfloat tx0y2 = texture2D( tDiffuse, vUv + texel * vec2( -1,  1 ) ).r;\n\n\t\t// second column\n\n\t\t\tfloat tx1y0 = texture2D( tDiffuse, vUv + texel * vec2(  0, -1 ) ).r;\n\t\t\tfloat tx1y1 = texture2D( tDiffuse, vUv + texel * vec2(  0,  0 ) ).r;\n\t\t\tfloat tx1y2 = texture2D( tDiffuse, vUv + texel * vec2(  0,  1 ) ).r;\n\n\t\t// third column\n\n\t\t\tfloat tx2y0 = texture2D( tDiffuse, vUv + texel * vec2(  1, -1 ) ).r;\n\t\t\tfloat tx2y1 = texture2D( tDiffuse, vUv + texel * vec2(  1,  0 ) ).r;\n\t\t\tfloat tx2y2 = texture2D( tDiffuse, vUv + texel * vec2(  1,  1 ) ).r;\n\n\t\t// gradient value in x direction\n\n\t\t\tfloat valueGx = Gx[0][0] * tx0y0 + Gx[1][0] * tx1y0 + Gx[2][0] * tx2y0 +\n\t\t\t\tGx[0][1] * tx0y1 + Gx[1][1] * tx1y1 + Gx[2][1] * tx2y1 +\n\t\t\t\tGx[0][2] * tx0y2 + Gx[1][2] * tx1y2 + Gx[2][2] * tx2y2;\n\n\t\t// gradient value in y direction\n\n\t\t\tfloat valueGy = Gy[0][0] * tx0y0 + Gy[1][0] * tx1y0 + Gy[2][0] * tx2y0 +\n\t\t\t\tGy[0][1] * tx0y1 + Gy[1][1] * tx1y1 + Gy[2][1] * tx2y1 +\n\t\t\t\tGy[0][2] * tx0y2 + Gy[1][2] * tx1y2 + Gy[2][2] * tx2y2;\n\n\t\t// magnitute of the total gradient\n\n\t\t\tfloat G = sqrt( ( valueGx * valueGx ) + ( valueGy * valueGy ) );\n\n\t\t\tgl_FragColor = vec4( vec3( G ), 1 );\n\n\t\t}"};var rm={defines:{MAX_STEP:0,PERSPECTIVE_CAMERA:!0,DISTANCE_ATTENUATION:!0,FRESNEL:!0,INFINITE_THICK:!1,SELECTIVE:!1},uniforms:{tDiffuse:{value:null},tNormal:{value:null},tMetalness:{value:null},tDepth:{value:null},cameraNear:{value:null},cameraFar:{value:null},resolution:{value:new jn},cameraProjectionMatrix:{value:new zr},cameraInverseProjectionMatrix:{value:new zr},opacity:{value:.5},maxDistance:{value:180},cameraRange:{value:0},thickness:{value:.018}},vertexShader:"\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvUv = uv;\n\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t}\n\n\t",fragmentShader:'\n\t\t// precision highp float;\n\t\tprecision highp sampler2D;\n\t\tvarying vec2 vUv;\n\t\tuniform sampler2D tDepth;\n\t\tuniform sampler2D tNormal;\n\t\tuniform sampler2D tMetalness;\n\t\tuniform sampler2D tDiffuse;\n\t\tuniform float cameraRange;\n\t\tuniform vec2 resolution;\n\t\tuniform float opacity;\n\t\tuniform float cameraNear;\n\t\tuniform float cameraFar;\n\t\tuniform float maxDistance;\n\t\tuniform float thickness;\n\t\tuniform mat4 cameraProjectionMatrix;\n\t\tuniform mat4 cameraInverseProjectionMatrix;\n\t\t#include <packing>\n\t\tfloat pointToLineDistance(vec3 x0, vec3 x1, vec3 x2) {\n\t\t\t//x0: point, x1: linePointA, x2: linePointB\n\t\t\t//https://mathworld.wolfram.com/Point-LineDistance3-Dimensional.html\n\t\t\treturn length(cross(x0-x1,x0-x2))/length(x2-x1);\n\t\t}\n\t\tfloat pointPlaneDistance(vec3 point,vec3 planePoint,vec3 planeNormal){\n\t\t\t// https://mathworld.wolfram.com/Point-PlaneDistance.html\n\t\t\t//// https://en.wikipedia.org/wiki/Plane_(geometry)\n\t\t\t//// http://paulbourke.net/geometry/pointlineplane/\n\t\t\tfloat a=planeNormal.x,b=planeNormal.y,c=planeNormal.z;\n\t\t\tfloat x0=point.x,y0=point.y,z0=point.z;\n\t\t\tfloat x=planePoint.x,y=planePoint.y,z=planePoint.z;\n\t\t\tfloat d=-(a*x+b*y+c*z);\n\t\t\tfloat distance=(a*x0+b*y0+c*z0+d)/sqrt(a*a+b*b+c*c);\n\t\t\treturn distance;\n\t\t}\n\t\tfloat getDepth( const in vec2 uv ) {\n\t\t\treturn texture2D( tDepth, uv ).x;\n\t\t}\n\t\tfloat getViewZ( const in float depth ) {\n\t\t\t#ifdef PERSPECTIVE_CAMERA\n\t\t\t\treturn perspectiveDepthToViewZ( depth, cameraNear, cameraFar );\n\t\t\t#else\n\t\t\t\treturn orthographicDepthToViewZ( depth, cameraNear, cameraFar );\n\t\t\t#endif\n\t\t}\n\t\tvec3 getViewPosition( const in vec2 uv, const in float depth/*clip space*/, const in float clipW ) {\n\t\t\tvec4 clipPosition = vec4( ( vec3( uv, depth ) - 0.5 ) * 2.0, 1.0 );//ndc\n\t\t\tclipPosition *= clipW; //clip\n\t\t\treturn ( cameraInverseProjectionMatrix * clipPosition ).xyz;//view\n\t\t}\n\t\tvec3 getViewNormal( const in vec2 uv ) {\n\t\t\treturn unpackRGBToNormal( texture2D( tNormal, uv ).xyz );\n\t\t}\n\t\tvec2 viewPositionToXY(vec3 viewPosition){\n\t\t\tvec2 xy;\n\t\t\tvec4 clip=cameraProjectionMatrix*vec4(viewPosition,1);\n\t\t\txy=clip.xy;//clip\n\t\t\tfloat clipW=clip.w;\n\t\t\txy/=clipW;//NDC\n\t\t\txy=(xy+1.)/2.;//uv\n\t\t\txy*=resolution;//screen\n\t\t\treturn xy;\n\t\t}\n\t\tvoid main(){\n\t\t\t#ifdef SELECTIVE\n\t\t\t\tfloat metalness=texture2D(tMetalness,vUv).r;\n\t\t\t\tif(metalness==0.) return;\n\t\t\t#endif\n\n\t\t\tfloat depth = getDepth( vUv );\n\t\t\tfloat viewZ = getViewZ( depth );\n\t\t\tif(-viewZ>=cameraFar) return;\n\n\t\t\tfloat clipW = cameraProjectionMatrix[2][3] * viewZ+cameraProjectionMatrix[3][3];\n\t\t\tvec3 viewPosition=getViewPosition( vUv, depth, clipW );\n\n\t\t\tvec2 d0=gl_FragCoord.xy;\n\t\t\tvec2 d1;\n\n\t\t\tvec3 viewNormal=getViewNormal( vUv );\n\n\t\t\t#ifdef PERSPECTIVE_CAMERA\n\t\t\t\tvec3 viewIncidentDir=normalize(viewPosition);\n\t\t\t\tvec3 viewReflectDir=reflect(viewIncidentDir,viewNormal);\n\t\t\t#else\n\t\t\t\tvec3 viewIncidentDir=vec3(0,0,-1);\n\t\t\t\tvec3 viewReflectDir=reflect(viewIncidentDir,viewNormal);\n\t\t\t#endif\n\n\t\t\tfloat maxReflectRayLen=maxDistance/dot(-viewIncidentDir,viewNormal);\n\t\t\t// dot(a,b)==length(a)*length(b)*cos(theta) // https://www.mathsisfun.com/algebra/vectors-dot-product.html\n\t\t\t// if(a.isNormalized&&b.isNormalized) dot(a,b)==cos(theta)\n\t\t\t// maxDistance/maxReflectRayLen=cos(theta)\n\t\t\t// maxDistance/maxReflectRayLen==dot(a,b)\n\t\t\t// maxReflectRayLen==maxDistance/dot(a,b)\n\n\t\t\tvec3 d1viewPosition=viewPosition+viewReflectDir*maxReflectRayLen;\n\t\t\t#ifdef PERSPECTIVE_CAMERA\n\t\t\t\tif(d1viewPosition.z>-cameraNear){\n\t\t\t\t\t//https://tutorial.math.lamar.edu/Classes/CalcIII/EqnsOfLines.aspx\n\t\t\t\t\tfloat t=(-cameraNear-viewPosition.z)/viewReflectDir.z;\n\t\t\t\t\td1viewPosition=viewPosition+viewReflectDir*t;\n\t\t\t\t}\n\t\t\t#endif\n\t\t\td1=viewPositionToXY(d1viewPosition);\n\n\t\t\tfloat totalLen=length(d1-d0);\n\t\t\tfloat xLen=d1.x-d0.x;\n\t\t\tfloat yLen=d1.y-d0.y;\n\t\t\tfloat totalStep=max(abs(xLen),abs(yLen));\n\t\t\tfloat xSpan=xLen/totalStep;\n\t\t\tfloat ySpan=yLen/totalStep;\n\t\t\tfor(float i=0.;i<float(MAX_STEP);i++){\n\t\t\t\tif(i>=totalStep) break;\n\t\t\t\tvec2 xy=vec2(d0.x+i*xSpan,d0.y+i*ySpan);\n\t\t\t\tif(xy.x<0.||xy.x>resolution.x||xy.y<0.||xy.y>resolution.y) break;\n\t\t\t\tfloat s=length(xy-d0)/totalLen;\n\t\t\t\tvec2 uv=xy/resolution;\n\n\t\t\t\tfloat d = getDepth(uv);\n\t\t\t\tfloat vZ = getViewZ( d );\n\t\t\t\tif(-vZ>=cameraFar) continue;\n\t\t\t\tfloat cW = cameraProjectionMatrix[2][3] * vZ+cameraProjectionMatrix[3][3];\n\t\t\t\tvec3 vP=getViewPosition( uv, d, cW );\n\n\t\t\t\t#ifdef PERSPECTIVE_CAMERA\n\t\t\t\t\t// https://comp.nus.edu.sg/~lowkl/publications/lowk_persp_interp_techrep.pdf\n\t\t\t\t\tfloat recipVPZ=1./viewPosition.z;\n\t\t\t\t\tfloat viewReflectRayZ=1./(recipVPZ+s*(1./d1viewPosition.z-recipVPZ));\n\t\t\t\t#else\n\t\t\t\t\tfloat viewReflectRayZ=viewPosition.z+s*(d1viewPosition.z-viewPosition.z);\n\t\t\t\t#endif\n\n\t\t\t\t// if(viewReflectRayZ>vZ) continue; // will cause "npm run make-screenshot webgl_postprocessing_ssr" high probability hang.\n\t\t\t\t// https://github.com/mrdoob/three.js/pull/21539#issuecomment-821061164\n\t\t\t\tif(viewReflectRayZ<=vZ){\n\n\t\t\t\t\tbool hit;\n\t\t\t\t\t#ifdef INFINITE_THICK\n\t\t\t\t\t\thit=true;\n\t\t\t\t\t#else\n\t\t\t\t\t\tfloat away=pointToLineDistance(vP,viewPosition,d1viewPosition);\n\n\t\t\t\t\t\tfloat minThickness;\n\t\t\t\t\t\tvec2 xyNeighbor=xy;\n\t\t\t\t\t\txyNeighbor.x+=1.;\n\t\t\t\t\t\tvec2 uvNeighbor=xyNeighbor/resolution;\n\t\t\t\t\t\tvec3 vPNeighbor=getViewPosition(uvNeighbor,d,cW);\n\t\t\t\t\t\tminThickness=vPNeighbor.x-vP.x;\n\t\t\t\t\t\tminThickness*=3.;\n\t\t\t\t\t\tfloat tk=max(minThickness,thickness);\n\n\t\t\t\t\t\thit=away<=tk;\n\t\t\t\t\t#endif\n\n\t\t\t\t\tif(hit){\n\t\t\t\t\t\tvec3 vN=getViewNormal( uv );\n\t\t\t\t\t\tif(dot(viewReflectDir,vN)>=0.) continue;\n\t\t\t\t\t\tfloat distance=pointPlaneDistance(vP,viewPosition,viewNormal);\n\t\t\t\t\t\tif(distance>maxDistance) break;\n\t\t\t\t\t\tfloat op=opacity;\n\t\t\t\t\t\t#ifdef DISTANCE_ATTENUATION\n\t\t\t\t\t\t\tfloat ratio=1.-(distance/maxDistance);\n\t\t\t\t\t\t\tfloat attenuation=ratio*ratio;\n\t\t\t\t\t\t\top=opacity*attenuation;\n\t\t\t\t\t\t#endif\n\t\t\t\t\t\t#ifdef FRESNEL\n\t\t\t\t\t\t\tfloat fresnelCoe=(dot(viewIncidentDir,viewReflectDir)+1.)/2.;\n\t\t\t\t\t\t\top*=fresnelCoe;\n\t\t\t\t\t\t#endif\n\t\t\t\t\t\tvec4 reflectColor=texture2D(tDiffuse,uv);\n\t\t\t\t\t\tgl_FragColor.xyz=reflectColor.xyz;\n\t\t\t\t\t\tgl_FragColor.a=op;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t'},im={PERSPECTIVE_CAMERA:1},sm={tDepth:{value:null},cameraNear:{value:null},cameraFar:{value:null}},am="\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvUv = uv;\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t}\n\n\t",om="\n\n\t\tuniform sampler2D tDepth;\n\n\t\tuniform float cameraNear;\n\t\tuniform float cameraFar;\n\n\t\tvarying vec2 vUv;\n\n\t\t#include <packing>\n\n\t\tfloat getLinearDepth( const in vec2 uv ) {\n\n\t\t\t#if PERSPECTIVE_CAMERA == 1\n\n\t\t\t\tfloat fragCoordZ = texture2D( tDepth, uv ).x;\n\t\t\t\tfloat viewZ = perspectiveDepthToViewZ( fragCoordZ, cameraNear, cameraFar );\n\t\t\t\treturn viewZToOrthographicDepth( viewZ, cameraNear, cameraFar );\n\n\t\t\t#else\n\n\t\t\t\treturn texture2D( tDepth, uv ).x;\n\n\t\t\t#endif\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tfloat depth = getLinearDepth( vUv );\n\t\t\tfloat d = 1.0 - depth;\n\t\t\t// d=(d-.999)*1000.;\n\t\t\tgl_FragColor = vec4( vec3( d ), 1.0 );\n\n\t\t}\n\n\t",lm={uniforms:{tDiffuse:{value:null},resolution:{value:new jn},opacity:{value:.5}},vertexShader:"\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvUv = uv;\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t}\n\n\t",fragmentShader:"\n\n\t\tuniform sampler2D tDiffuse;\n\t\tuniform vec2 resolution;\n\t\tvarying vec2 vUv;\n\t\tvoid main() {\n\t\t\t//reverse engineering from PhotoShop blur filter, then change coefficient\n\n\t\t\tvec2 texelSize = ( 1.0 / resolution );\n\n\t\t\tvec4 c=texture2D(tDiffuse,vUv);\n\n\t\t\tvec2 offset;\n\n\t\t\toffset=(vec2(-1,0))*texelSize;\n\t\t\tvec4 cl=texture2D(tDiffuse,vUv+offset);\n\n\t\t\toffset=(vec2(1,0))*texelSize;\n\t\t\tvec4 cr=texture2D(tDiffuse,vUv+offset);\n\n\t\t\toffset=(vec2(0,-1))*texelSize;\n\t\t\tvec4 cb=texture2D(tDiffuse,vUv+offset);\n\n\t\t\toffset=(vec2(0,1))*texelSize;\n\t\t\tvec4 ct=texture2D(tDiffuse,vUv+offset);\n\n\t\t\t// float coeCenter=.5;\n\t\t\t// float coeSide=.125;\n\t\t\tfloat coeCenter=.2;\n\t\t\tfloat coeSide=.2;\n\t\t\tfloat a=c.a*coeCenter+cl.a*coeSide+cr.a*coeSide+cb.a*coeSide+ct.a*coeSide;\n\t\t\tvec3 rgb=(c.rgb*c.a*coeCenter+cl.rgb*cl.a*coeSide+cr.rgb*cr.a*coeSide+cb.rgb*cb.a*coeSide+ct.rgb*ct.a*coeSide)/a;\n\t\t\tgl_FragColor=vec4(rgb,a);\n\n\t\t}\n\t"};class cm extends Uf{constructor({renderer:t,scene:e,camera:n,width:r,height:i,selects:s,bouncing:a=!1,groundReflector:o}){super(),this.width=void 0!==r?r:512,this.height=void 0!==i?i:512,this.clear=!0,this.renderer=t,this.scene=e,this.camera=n,this.groundReflector=o,this.opacity=rm.uniforms.opacity.value,this.output=0,this.maxDistance=rm.uniforms.maxDistance.value,this.thickness=rm.uniforms.thickness.value,this.tempColor=new Li,this._selects=s,this.selective=Array.isArray(this._selects),Object.defineProperty(this,"selects",{get(){return this._selects},set(t){this._selects!==t&&(this._selects=t,Array.isArray(t)?(this.selective=!0,this.ssrMaterial.defines.SELECTIVE=!0,this.ssrMaterial.needsUpdate=!0):(this.selective=!1,this.ssrMaterial.defines.SELECTIVE=!1,this.ssrMaterial.needsUpdate=!0))}}),this._bouncing=a,Object.defineProperty(this,"bouncing",{get(){return this._bouncing},set(t){this._bouncing!==t&&(this._bouncing=t,this.ssrMaterial.uniforms.tDiffuse.value=t?this.prevRenderTarget.texture:this.beautyRenderTarget.texture)}}),this.blur=!0,this._distanceAttenuation=rm.defines.DISTANCE_ATTENUATION,Object.defineProperty(this,"distanceAttenuation",{get(){return this._distanceAttenuation},set(t){this._distanceAttenuation!==t&&(this._distanceAttenuation=t,this.ssrMaterial.defines.DISTANCE_ATTENUATION=t,this.ssrMaterial.needsUpdate=!0)}}),this._fresnel=rm.defines.FRESNEL,Object.defineProperty(this,"fresnel",{get(){return this._fresnel},set(t){this._fresnel!==t&&(this._fresnel=t,this.ssrMaterial.defines.FRESNEL=t,this.ssrMaterial.needsUpdate=!0)}}),this._infiniteThick=rm.defines.INFINITE_THICK,Object.defineProperty(this,"infiniteThick",{get(){return this._infiniteThick},set(t){this._infiniteThick!==t&&(this._infiniteThick=t,this.ssrMaterial.defines.INFINITE_THICK=t,this.ssrMaterial.needsUpdate=!0)}});const l=new Ml;l.type=Rt,l.minFilter=xt,l.magFilter=xt,this.beautyRenderTarget=new ir(this.width,this.height,{minFilter:xt,magFilter:xt,format:Gt,depthTexture:l,depthBuffer:!0}),this.prevRenderTarget=new ir(this.width,this.height,{minFilter:xt,magFilter:xt,format:Gt}),this.normalRenderTarget=new ir(this.width,this.height,{minFilter:xt,magFilter:xt,format:Gt,type:Ut}),this.metalnessRenderTarget=new ir(this.width,this.height,{minFilter:xt,magFilter:xt,format:Gt}),this.ssrRenderTarget=new ir(this.width,this.height,{minFilter:xt,magFilter:xt,format:Gt}),this.blurRenderTarget=this.ssrRenderTarget.clone(),this.blurRenderTarget2=this.ssrRenderTarget.clone(),void 0===rm&&console.error("THREE.SSRPass: The pass relies on SSRShader."),this.ssrMaterial=new _s({defines:Object.assign({},rm.defines,{MAX_STEP:Math.sqrt(this.width*this.width+this.height*this.height)}),uniforms:bs.clone(rm.uniforms),vertexShader:rm.vertexShader,fragmentShader:rm.fragmentShader,blending:M}),this.ssrMaterial.uniforms.tDiffuse.value=this.beautyRenderTarget.texture,this.ssrMaterial.uniforms.tNormal.value=this.normalRenderTarget.texture,this.ssrMaterial.defines.SELECTIVE=this.selective,this.ssrMaterial.needsUpdate=!0,this.ssrMaterial.uniforms.tMetalness.value=this.metalnessRenderTarget.texture,this.ssrMaterial.uniforms.tDepth.value=this.beautyRenderTarget.depthTexture,this.ssrMaterial.uniforms.cameraNear.value=this.camera.near,this.ssrMaterial.uniforms.cameraFar.value=this.camera.far,this.ssrMaterial.uniforms.thickness.value=this.thickness,this.ssrMaterial.uniforms.resolution.value.set(this.width,this.height),this.ssrMaterial.uniforms.cameraProjectionMatrix.value.copy(this.camera.projectionMatrix),this.ssrMaterial.uniforms.cameraInverseProjectionMatrix.value.copy(this.camera.projectionMatrixInverse),this.normalMaterial=new hu,this.normalMaterial.blending=M,this.metalnessOnMaterial=new Ri({color:"white"}),this.metalnessOffMaterial=new Ri({color:"black"}),this.blurMaterial=new _s({defines:Object.assign({},lm.defines),uniforms:bs.clone(lm.uniforms),vertexShader:lm.vertexShader,fragmentShader:lm.fragmentShader}),this.blurMaterial.uniforms.tDiffuse.value=this.ssrRenderTarget.texture,this.blurMaterial.uniforms.resolution.value.set(this.width,this.height),this.blurMaterial2=new _s({defines:Object.assign({},lm.defines),uniforms:bs.clone(lm.uniforms),vertexShader:lm.vertexShader,fragmentShader:lm.fragmentShader}),this.blurMaterial2.uniforms.tDiffuse.value=this.blurRenderTarget.texture,this.blurMaterial2.uniforms.resolution.value.set(this.width,this.height),this.depthRenderMaterial=new _s({defines:Object.assign({},im),uniforms:bs.clone(sm),vertexShader:am,fragmentShader:om,blending:M}),this.depthRenderMaterial.uniforms.tDepth.value=this.beautyRenderTarget.depthTexture,this.depthRenderMaterial.uniforms.cameraNear.value=this.camera.near,this.depthRenderMaterial.uniforms.cameraFar.value=this.camera.far,this.copyMaterial=new _s({uniforms:bs.clone(If.uniforms),vertexShader:If.vertexShader,fragmentShader:If.fragmentShader,transparent:!0,depthTest:!1,depthWrite:!1,blendSrc:B,blendDst:z,blendEquation:P,blendSrcAlpha:B,blendDstAlpha:z,blendEquationAlpha:P}),this.fsQuad=new Bf(null),this.originalClearColor=new Li}dispose(){this.beautyRenderTarget.dispose(),this.prevRenderTarget.dispose(),this.normalRenderTarget.dispose(),this.metalnessRenderTarget.dispose(),this.ssrRenderTarget.dispose(),this.blurRenderTarget.dispose(),this.blurRenderTarget2.dispose(),this.normalMaterial.dispose(),this.metalnessOnMaterial.dispose(),this.metalnessOffMaterial.dispose(),this.blurMaterial.dispose(),this.blurMaterial2.dispose(),this.copyMaterial.dispose(),this.depthRenderMaterial.dispose(),this.fsQuad.dispose()}render(t,e){switch(t.setRenderTarget(this.beautyRenderTarget),t.clear(),this.groundReflector&&(this.groundReflector.visible=!1,this.groundReflector.doRender(this.renderer,this.scene,this.camera),this.groundReflector.visible=!0),t.render(this.scene,this.camera),this.groundReflector&&(this.groundReflector.visible=!1),this.renderOverride(t,this.normalMaterial,this.normalRenderTarget,0,0),this.selective&&this.renderMetalness(t,this.metalnessOnMaterial,this.metalnessRenderTarget,0,0),this.ssrMaterial.uniforms.opacity.value=this.opacity,this.ssrMaterial.uniforms.maxDistance.value=this.maxDistance,this.ssrMaterial.uniforms.thickness.value=this.thickness,this.renderPass(t,this.ssrMaterial,this.ssrRenderTarget),this.blur&&(this.renderPass(t,this.blurMaterial,this.blurRenderTarget),this.renderPass(t,this.blurMaterial2,this.blurRenderTarget2)),this.output){case cm.OUTPUT.Default:this.bouncing?(this.copyMaterial.uniforms.tDiffuse.value=this.beautyRenderTarget.texture,this.copyMaterial.blending=M,this.renderPass(t,this.copyMaterial,this.prevRenderTarget),this.blur?this.copyMaterial.uniforms.tDiffuse.value=this.blurRenderTarget2.texture:this.copyMaterial.uniforms.tDiffuse.value=this.ssrRenderTarget.texture,this.copyMaterial.blending=T,this.renderPass(t,this.copyMaterial,this.prevRenderTarget),this.copyMaterial.uniforms.tDiffuse.value=this.prevRenderTarget.texture,this.copyMaterial.blending=M,this.renderPass(t,this.copyMaterial,this.renderToScreen?null:e)):(this.copyMaterial.uniforms.tDiffuse.value=this.beautyRenderTarget.texture,this.copyMaterial.blending=M,this.renderPass(t,this.copyMaterial,this.renderToScreen?null:e),this.blur?this.copyMaterial.uniforms.tDiffuse.value=this.blurRenderTarget2.texture:this.copyMaterial.uniforms.tDiffuse.value=this.ssrRenderTarget.texture,this.copyMaterial.blending=T,this.renderPass(t,this.copyMaterial,this.renderToScreen?null:e));break;case cm.OUTPUT.SSR:this.blur?this.copyMaterial.uniforms.tDiffuse.value=this.blurRenderTarget2.texture:this.copyMaterial.uniforms.tDiffuse.value=this.ssrRenderTarget.texture,this.copyMaterial.blending=M,this.renderPass(t,this.copyMaterial,this.renderToScreen?null:e),this.bouncing&&(this.blur?this.copyMaterial.uniforms.tDiffuse.value=this.blurRenderTarget2.texture:this.copyMaterial.uniforms.tDiffuse.value=this.beautyRenderTarget.texture,this.copyMaterial.blending=M,this.renderPass(t,this.copyMaterial,this.prevRenderTarget),this.copyMaterial.uniforms.tDiffuse.value=this.ssrRenderTarget.texture,this.copyMaterial.blending=T,this.renderPass(t,this.copyMaterial,this.prevRenderTarget));break;case cm.OUTPUT.Beauty:this.copyMaterial.uniforms.tDiffuse.value=this.beautyRenderTarget.texture,this.copyMaterial.blending=M,this.renderPass(t,this.copyMaterial,this.renderToScreen?null:e);break;case cm.OUTPUT.Depth:this.renderPass(t,this.depthRenderMaterial,this.renderToScreen?null:e);break;case cm.OUTPUT.Normal:this.copyMaterial.uniforms.tDiffuse.value=this.normalRenderTarget.texture,this.copyMaterial.blending=M,this.renderPass(t,this.copyMaterial,this.renderToScreen?null:e);break;case cm.OUTPUT.Metalness:this.copyMaterial.uniforms.tDiffuse.value=this.metalnessRenderTarget.texture,this.copyMaterial.blending=M,this.renderPass(t,this.copyMaterial,this.renderToScreen?null:e);break;default:console.warn("THREE.SSRPass: Unknown output type.")}}renderPass(t,e,n,r,i){this.originalClearColor.copy(t.getClearColor(this.tempColor));const s=t.getClearAlpha(this.tempColor),a=t.autoClear;t.setRenderTarget(n),t.autoClear=!1,null!=r&&(t.setClearColor(r),t.setClearAlpha(i||0),t.clear()),this.fsQuad.material=e,this.fsQuad.render(t),t.autoClear=a,t.setClearColor(this.originalClearColor),t.setClearAlpha(s)}renderOverride(t,e,n,r,i){this.originalClearColor.copy(t.getClearColor(this.tempColor));const s=t.getClearAlpha(this.tempColor),a=t.autoClear;t.setRenderTarget(n),t.autoClear=!1,r=e.clearColor||r,i=e.clearAlpha||i,null!=r&&(t.setClearColor(r),t.setClearAlpha(i||0),t.clear()),this.scene.overrideMaterial=e,t.render(this.scene,this.camera),this.scene.overrideMaterial=null,t.autoClear=a,t.setClearColor(this.originalClearColor),t.setClearAlpha(s)}renderMetalness(t,e,n,r,i){this.originalClearColor.copy(t.getClearColor(this.tempColor));const s=t.getClearAlpha(this.tempColor),a=t.autoClear;t.setRenderTarget(n),t.autoClear=!1,r=e.clearColor||r,i=e.clearAlpha||i,null!=r&&(t.setClearColor(r),t.setClearAlpha(i||0),t.clear()),this.scene.traverseVisible((t=>{t._SSRPassBackupMaterial=t.material,this._selects.includes(t)?t.material=this.metalnessOnMaterial:t.material=this.metalnessOffMaterial})),t.render(this.scene,this.camera),this.scene.traverseVisible((t=>{t.material=t._SSRPassBackupMaterial})),t.autoClear=a,t.setClearColor(this.originalClearColor),t.setClearAlpha(s)}setSize(t,e){this.width=t,this.height=e,this.ssrMaterial.defines.MAX_STEP=Math.sqrt(t*t+e*e),this.ssrMaterial.needsUpdate=!0,this.beautyRenderTarget.setSize(t,e),this.prevRenderTarget.setSize(t,e),this.ssrRenderTarget.setSize(t,e),this.normalRenderTarget.setSize(t,e),this.metalnessRenderTarget.setSize(t,e),this.blurRenderTarget.setSize(t,e),this.blurRenderTarget2.setSize(t,e),this.ssrMaterial.uniforms.resolution.value.set(t,e),this.ssrMaterial.uniforms.cameraProjectionMatrix.value.copy(this.camera.projectionMatrix),this.ssrMaterial.uniforms.cameraInverseProjectionMatrix.value.copy(this.camera.projectionMatrixInverse),this.blurMaterial.uniforms.resolution.value.set(t,e),this.blurMaterial2.uniforms.resolution.value.set(t,e)}}cm.OUTPUT={Default:0,SSR:1,Beauty:3,Depth:4,Normal:5,Metalness:7};const hm={defines:{DEPTH_PACKING:1,PERSPECTIVE_CAMERA:1},uniforms:{tColor:{value:null},tDepth:{value:null},focus:{value:1},aspect:{value:1},aperture:{value:.025},maxblur:{value:.01},nearClip:{value:1},farClip:{value:1e3}},vertexShader:"\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvUv = uv;\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t}",fragmentShader:"\n\n\t\t#include <common>\n\n\t\tvarying vec2 vUv;\n\n\t\tuniform sampler2D tColor;\n\t\tuniform sampler2D tDepth;\n\n\t\tuniform float maxblur; // max blur amount\n\t\tuniform float aperture; // aperture - bigger values for shallower depth of field\n\n\t\tuniform float nearClip;\n\t\tuniform float farClip;\n\n\t\tuniform float focus;\n\t\tuniform float aspect;\n\n\t\t#include <packing>\n\n\t\tfloat getDepth( const in vec2 screenPosition ) {\n\t\t\t#if DEPTH_PACKING == 1\n\t\t\treturn unpackRGBAToDepth( texture2D( tDepth, screenPosition ) );\n\t\t\t#else\n\t\t\treturn texture2D( tDepth, screenPosition ).x;\n\t\t\t#endif\n\t\t}\n\n\t\tfloat getViewZ( const in float depth ) {\n\t\t\t#if PERSPECTIVE_CAMERA == 1\n\t\t\treturn perspectiveDepthToViewZ( depth, nearClip, farClip );\n\t\t\t#else\n\t\t\treturn orthographicDepthToViewZ( depth, nearClip, farClip );\n\t\t\t#endif\n\t\t}\n\n\n\t\tvoid main() {\n\n\t\t\tvec2 aspectcorrect = vec2( 1.0, aspect );\n\n\t\t\tfloat viewZ = getViewZ( getDepth( vUv ) );\n\n\t\t\tfloat factor = ( focus + viewZ ); // viewZ is <= 0, so this is a difference equation\n\n\t\t\tvec2 dofblur = vec2 ( clamp( factor * aperture, -maxblur, maxblur ) );\n\n\t\t\tvec2 dofblur9 = dofblur * 0.9;\n\t\t\tvec2 dofblur7 = dofblur * 0.7;\n\t\t\tvec2 dofblur4 = dofblur * 0.4;\n\n\t\t\tvec4 col = vec4( 0.0 );\n\n\t\t\tcol += texture2D( tColor, vUv.xy );\n\t\t\tcol += texture2D( tColor, vUv.xy + ( vec2(  0.0,   0.4  ) * aspectcorrect ) * dofblur );\n\t\t\tcol += texture2D( tColor, vUv.xy + ( vec2(  0.15,  0.37 ) * aspectcorrect ) * dofblur );\n\t\t\tcol += texture2D( tColor, vUv.xy + ( vec2(  0.29,  0.29 ) * aspectcorrect ) * dofblur );\n\t\t\tcol += texture2D( tColor, vUv.xy + ( vec2( -0.37,  0.15 ) * aspectcorrect ) * dofblur );\n\t\t\tcol += texture2D( tColor, vUv.xy + ( vec2(  0.40,  0.0  ) * aspectcorrect ) * dofblur );\n\t\t\tcol += texture2D( tColor, vUv.xy + ( vec2(  0.37, -0.15 ) * aspectcorrect ) * dofblur );\n\t\t\tcol += texture2D( tColor, vUv.xy + ( vec2(  0.29, -0.29 ) * aspectcorrect ) * dofblur );\n\t\t\tcol += texture2D( tColor, vUv.xy + ( vec2( -0.15, -0.37 ) * aspectcorrect ) * dofblur );\n\t\t\tcol += texture2D( tColor, vUv.xy + ( vec2(  0.0,  -0.4  ) * aspectcorrect ) * dofblur );\n\t\t\tcol += texture2D( tColor, vUv.xy + ( vec2( -0.15,  0.37 ) * aspectcorrect ) * dofblur );\n\t\t\tcol += texture2D( tColor, vUv.xy + ( vec2( -0.29,  0.29 ) * aspectcorrect ) * dofblur );\n\t\t\tcol += texture2D( tColor, vUv.xy + ( vec2(  0.37,  0.15 ) * aspectcorrect ) * dofblur );\n\t\t\tcol += texture2D( tColor, vUv.xy + ( vec2( -0.4,   0.0  ) * aspectcorrect ) * dofblur );\n\t\t\tcol += texture2D( tColor, vUv.xy + ( vec2( -0.37, -0.15 ) * aspectcorrect ) * dofblur );\n\t\t\tcol += texture2D( tColor, vUv.xy + ( vec2( -0.29, -0.29 ) * aspectcorrect ) * dofblur );\n\t\t\tcol += texture2D( tColor, vUv.xy + ( vec2(  0.15, -0.37 ) * aspectcorrect ) * dofblur );\n\n\t\t\tcol += texture2D( tColor, vUv.xy + ( vec2(  0.15,  0.37 ) * aspectcorrect ) * dofblur9 );\n\t\t\tcol += texture2D( tColor, vUv.xy + ( vec2( -0.37,  0.15 ) * aspectcorrect ) * dofblur9 );\n\t\t\tcol += texture2D( tColor, vUv.xy + ( vec2(  0.37, -0.15 ) * aspectcorrect ) * dofblur9 );\n\t\t\tcol += texture2D( tColor, vUv.xy + ( vec2( -0.15, -0.37 ) * aspectcorrect ) * dofblur9 );\n\t\t\tcol += texture2D( tColor, vUv.xy + ( vec2( -0.15,  0.37 ) * aspectcorrect ) * dofblur9 );\n\t\t\tcol += texture2D( tColor, vUv.xy + ( vec2(  0.37,  0.15 ) * aspectcorrect ) * dofblur9 );\n\t\t\tcol += texture2D( tColor, vUv.xy + ( vec2( -0.37, -0.15 ) * aspectcorrect ) * dofblur9 );\n\t\t\tcol += texture2D( tColor, vUv.xy + ( vec2(  0.15, -0.37 ) * aspectcorrect ) * dofblur9 );\n\n\t\t\tcol += texture2D( tColor, vUv.xy + ( vec2(  0.29,  0.29 ) * aspectcorrect ) * dofblur7 );\n\t\t\tcol += texture2D( tColor, vUv.xy + ( vec2(  0.40,  0.0  ) * aspectcorrect ) * dofblur7 );\n\t\t\tcol += texture2D( tColor, vUv.xy + ( vec2(  0.29, -0.29 ) * aspectcorrect ) * dofblur7 );\n\t\t\tcol += texture2D( tColor, vUv.xy + ( vec2(  0.0,  -0.4  ) * aspectcorrect ) * dofblur7 );\n\t\t\tcol += texture2D( tColor, vUv.xy + ( vec2( -0.29,  0.29 ) * aspectcorrect ) * dofblur7 );\n\t\t\tcol += texture2D( tColor, vUv.xy + ( vec2( -0.4,   0.0  ) * aspectcorrect ) * dofblur7 );\n\t\t\tcol += texture2D( tColor, vUv.xy + ( vec2( -0.29, -0.29 ) * aspectcorrect ) * dofblur7 );\n\t\t\tcol += texture2D( tColor, vUv.xy + ( vec2(  0.0,   0.4  ) * aspectcorrect ) * dofblur7 );\n\n\t\t\tcol += texture2D( tColor, vUv.xy + ( vec2(  0.29,  0.29 ) * aspectcorrect ) * dofblur4 );\n\t\t\tcol += texture2D( tColor, vUv.xy + ( vec2(  0.4,   0.0  ) * aspectcorrect ) * dofblur4 );\n\t\t\tcol += texture2D( tColor, vUv.xy + ( vec2(  0.29, -0.29 ) * aspectcorrect ) * dofblur4 );\n\t\t\tcol += texture2D( tColor, vUv.xy + ( vec2(  0.0,  -0.4  ) * aspectcorrect ) * dofblur4 );\n\t\t\tcol += texture2D( tColor, vUv.xy + ( vec2( -0.29,  0.29 ) * aspectcorrect ) * dofblur4 );\n\t\t\tcol += texture2D( tColor, vUv.xy + ( vec2( -0.4,   0.0  ) * aspectcorrect ) * dofblur4 );\n\t\t\tcol += texture2D( tColor, vUv.xy + ( vec2( -0.29, -0.29 ) * aspectcorrect ) * dofblur4 );\n\t\t\tcol += texture2D( tColor, vUv.xy + ( vec2(  0.0,   0.4  ) * aspectcorrect ) * dofblur4 );\n\n\t\t\tgl_FragColor = col / 41.0;\n\t\t\tgl_FragColor.a = 1.0;\n\n\t\t}"},um=new zr;class dm{constructor(t){t=t||{},this.vertices={near:[new lr,new lr,new lr,new lr],far:[new lr,new lr,new lr,new lr]},void 0!==t.projectionMatrix&&this.setFromProjectionMatrix(t.projectionMatrix,t.maxFar||1e4)}setFromProjectionMatrix(t,e){const n=0===t.elements[11];return um.copy(t).invert(),this.vertices.near[0].set(1,1,-1),this.vertices.near[1].set(1,-1,-1),this.vertices.near[2].set(-1,-1,-1),this.vertices.near[3].set(-1,1,-1),this.vertices.near.forEach((function(t){t.applyMatrix4(um)})),this.vertices.far[0].set(1,1,1),this.vertices.far[1].set(1,-1,1),this.vertices.far[2].set(-1,-1,1),this.vertices.far[3].set(-1,1,1),this.vertices.far.forEach((function(t){t.applyMatrix4(um);const r=Math.abs(t.z);n?t.z*=Math.min(e/r,1):t.multiplyScalar(Math.min(e/r,1))})),this.vertices}split(t,e){for(;t.length>e.length;)e.push(new dm);e.length=t.length;for(let n=0;n<t.length;n++){const r=e[n];if(0===n)for(let t=0;t<4;t++)r.vertices.near[t].copy(this.vertices.near[t]);else for(let e=0;e<4;e++)r.vertices.near[e].lerpVectors(this.vertices.near[e],this.vertices.far[e],t[n-1]);if(n===t.length-1)for(let t=0;t<4;t++)r.vertices.far[t].copy(this.vertices.far[t]);else for(let e=0;e<4;e++)r.vertices.far[e].lerpVectors(this.vertices.near[e],this.vertices.far[e],t[n])}}toSpace(t,e){for(var n=0;n<4;n++)e.vertices.near[n].copy(this.vertices.near[n]).applyMatrix4(t),e.vertices.far[n].copy(this.vertices.far[n]).applyMatrix4(t)}}const pm={lights_fragment_begin:"\nGeometricContext geometry;\n\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n\n#ifdef CLEARCOAT\n\n\tgeometry.clearcoatNormal = clearcoatNormal;\n\n#endif\n\nIncidentLight directLight;\n\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\n\t\tpointLight = pointLights[ i ];\n\n\t\tgetPointLightInfo( pointLight, geometry, directLight );\n\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\n\t}\n\t#pragma unroll_loop_end\n\n#endif\n\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\n\tSpotLight spotLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\n\t\tspotLight = spotLights[ i ];\n\n\t\tgetSpotLightInfo( spotLight, geometry, directLight );\n\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\n\t}\n\t#pragma unroll_loop_end\n\n#endif\n\n#if ( NUM_DIR_LIGHTS > 0) && defined( RE_Direct ) && defined( USE_CSM ) && defined( CSM_CASCADES )\n\n\tDirectionalLight directionalLight;\n\tfloat linearDepth = (vViewPosition.z) / (shadowFar - cameraNear);\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\n\t#if defined( USE_SHADOWMAP ) && defined( CSM_FADE )\n\tvec2 cascade;\n\tfloat cascadeCenter;\n\tfloat closestEdge;\n\tfloat margin;\n\tfloat csmx;\n\tfloat csmy;\n\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalLightInfo( directionalLight, geometry, directLight );\n\n\t\t// NOTE: Depth gets larger away from the camera.\n\t\t// cascade.x is closer, cascade.y is further\n\t\tcascade = CSM_cascades[ i ];\n\t\tcascadeCenter = ( cascade.x + cascade.y ) / 2.0;\n\t\tclosestEdge = linearDepth < cascadeCenter ? cascade.x : cascade.y;\n\t\tmargin = 0.25 * pow( closestEdge, 2.0 );\n\t\tcsmx = cascade.x - margin / 2.0;\n\t\tcsmy = cascade.y + margin / 2.0;\n\t\tif( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS && linearDepth >= csmx && ( linearDepth < csmy || UNROLLED_LOOP_INDEX == CSM_CASCADES - 1 ) ) {\n\n\t\t\tfloat dist = min( linearDepth - csmx, csmy - linearDepth );\n\t\t\tfloat ratio = clamp( dist / margin, 0.0, 1.0 );\n\t\t\tif( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS ) {\n\n\t\t\t\tvec3 prevColor = directLight.color;\n\t\t\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\t\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\n\t\t\t\tbool shouldFadeLastCascade = UNROLLED_LOOP_INDEX == CSM_CASCADES - 1 && linearDepth > cascadeCenter;\n\t\t\t\tdirectLight.color = mix( prevColor, directLight.color, shouldFadeLastCascade ? ratio : 1.0 );\n\n\t\t\t}\n\n\t\t\tReflectedLight prevLight = reflectedLight;\n\t\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\n\t\t\tbool shouldBlend = UNROLLED_LOOP_INDEX != CSM_CASCADES - 1 || UNROLLED_LOOP_INDEX == CSM_CASCADES - 1 && linearDepth < cascadeCenter;\n\t\t\tfloat blendRatio = shouldBlend ? ratio : 1.0;\n\n\t\t\treflectedLight.directDiffuse = mix( prevLight.directDiffuse, reflectedLight.directDiffuse, blendRatio );\n\t\t\treflectedLight.directSpecular = mix( prevLight.directSpecular, reflectedLight.directSpecular, blendRatio );\n\t\t\treflectedLight.indirectDiffuse = mix( prevLight.indirectDiffuse, reflectedLight.indirectDiffuse, blendRatio );\n\t\t\treflectedLight.indirectSpecular = mix( prevLight.indirectSpecular, reflectedLight.indirectSpecular, blendRatio );\n\n\t\t}\n\n\t}\n\t#pragma unroll_loop_end\n\t#else\n\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalLightInfo( directionalLight, geometry, directLight );\n\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tif(linearDepth >= CSM_cascades[UNROLLED_LOOP_INDEX].x && linearDepth < CSM_cascades[UNROLLED_LOOP_INDEX].y) directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\n\t\t#endif\n\n\t\tif(linearDepth >= CSM_cascades[UNROLLED_LOOP_INDEX].x && (linearDepth < CSM_cascades[UNROLLED_LOOP_INDEX].y || UNROLLED_LOOP_INDEX == CSM_CASCADES - 1)) RE_Direct( directLight, geometry, material, reflectedLight );\n\n\t}\n\t#pragma unroll_loop_end\n\n\t#endif\n\n#endif\n\n\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct ) && !defined( USE_CSM ) && !defined( CSM_CASCADES )\n\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\n\t\tdirectionalLight = directionalLights[ i ];\n\n\t\tgetDirectionalLightInfo( directionalLight, geometry, directLight );\n\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\n\t}\n\t#pragma unroll_loop_end\n\n#endif\n\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\n\tRectAreaLight rectAreaLight;\n\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\n\t}\n\t#pragma unroll_loop_end\n\n#endif\n\n#if defined( RE_IndirectDiffuse )\n\n\tvec3 iblIrradiance = vec3( 0.0 );\n\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry.normal );\n\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\n\n\t\t}\n\t\t#pragma unroll_loop_end\n\n\t#endif\n\n#endif\n\n#if defined( RE_IndirectSpecular )\n\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n\n#endif\n",lights_pars_begin:"\n#if defined( USE_CSM ) && defined( CSM_CASCADES )\nuniform vec2 CSM_cascades[CSM_CASCADES];\nuniform float cameraNear;\nuniform float shadowFar;\n#endif\n\t"+zs.lights_pars_begin},fm=new zr,mm=new dm,gm=new lr,vm=new ur,xm=[],ym=[],wm={type:"change"},bm={type:"start"},_m={type:"end"};class Mm extends Du{constructor(t){super(t),this.dracoLoader=null,this.ktx2Loader=null,this.meshoptDecoder=null,this.pluginCallbacks=[],this.register((function(t){return new Cm(t)})),this.register((function(t){return new Im(t)})),this.register((function(t){return new Um(t)})),this.register((function(t){return new Pm(t)})),this.register((function(t){return new Lm(t)})),this.register((function(t){return new Rm(t)})),this.register((function(t){return new Fm(t)})),this.register((function(t){return new Dm(t)})),this.register((function(t){return new Am(t)})),this.register((function(t){return new Nm(t)}))}load(t,e,n,r){const i=this;let s;s=""!==this.resourcePath?this.resourcePath:""!==this.path?this.path:ld.extractUrlBase(t),this.manager.itemStart(t);const a=function(e){r?r(e):console.error(e),i.manager.itemError(t),i.manager.itemEnd(t)},o=new Uu(this.manager);o.setPath(this.path),o.setResponseType("arraybuffer"),o.setRequestHeader(this.requestHeader),o.setWithCredentials(this.withCredentials),o.load(t,(function(n){try{i.parse(n,s,(function(n){e(n),i.manager.itemEnd(t)}),a)}catch(t){a(t)}}),n,a)}setDRACOLoader(t){return this.dracoLoader=t,this}setDDSLoader(){throw new Error('THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".')}setKTX2Loader(t){return this.ktx2Loader=t,this}setMeshoptDecoder(t){return this.meshoptDecoder=t,this}register(t){return-1===this.pluginCallbacks.indexOf(t)&&this.pluginCallbacks.push(t),this}unregister(t){return-1!==this.pluginCallbacks.indexOf(t)&&this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(t),1),this}parse(t,e,n,r){let i;const s={},a={};if("string"==typeof t)i=t;else if(ld.decodeText(new Uint8Array(t,0,4))===Om){try{s[Sm.KHR_BINARY_GLTF]=new Bm(t)}catch(t){return void(r&&r(t))}i=s[Sm.KHR_BINARY_GLTF].content}else i=ld.decodeText(new Uint8Array(t));const o=JSON.parse(i);if(void 0===o.asset||o.asset.version[0]<2)return void(r&&r(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported.")));const l=new ag(o,{path:e||this.resourcePath||"",crossOrigin:this.crossOrigin,requestHeader:this.requestHeader,manager:this.manager,ktx2Loader:this.ktx2Loader,meshoptDecoder:this.meshoptDecoder});l.fileLoader.setRequestHeader(this.requestHeader);for(let t=0;t<this.pluginCallbacks.length;t++){const e=this.pluginCallbacks[t](l);a[e.name]=e,s[e.name]=!0}if(o.extensionsUsed)for(let t=0;t<o.extensionsUsed.length;++t){const e=o.extensionsUsed[t],n=o.extensionsRequired||[];switch(e){case Sm.KHR_MATERIALS_UNLIT:s[e]=new Em;break;case Sm.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:s[e]=new Gm;break;case Sm.KHR_DRACO_MESH_COMPRESSION:s[e]=new zm(o,this.dracoLoader);break;case Sm.KHR_TEXTURE_TRANSFORM:s[e]=new km;break;case Sm.KHR_MESH_QUANTIZATION:s[e]=new Vm;break;default:n.indexOf(e)>=0&&void 0===a[e]&&console.warn('THREE.GLTFLoader: Unknown extension "'+e+'".')}}l.setExtensions(s),l.setPlugins(a),l.parse(n,r)}parseAsync(t,e){const n=this;return new Promise((function(r,i){n.parse(t,e,r,i)}))}}function Tm(){let t={};return{get:function(e){return t[e]},add:function(e,n){t[e]=n},remove:function(e){delete t[e]},removeAll:function(){t={}}}}const Sm={KHR_BINARY_GLTF:"KHR_binary_glTF",KHR_DRACO_MESH_COMPRESSION:"KHR_draco_mesh_compression",KHR_LIGHTS_PUNCTUAL:"KHR_lights_punctual",KHR_MATERIALS_CLEARCOAT:"KHR_materials_clearcoat",KHR_MATERIALS_IOR:"KHR_materials_ior",KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:"KHR_materials_pbrSpecularGlossiness",KHR_MATERIALS_SHEEN:"KHR_materials_sheen",KHR_MATERIALS_SPECULAR:"KHR_materials_specular",KHR_MATERIALS_TRANSMISSION:"KHR_materials_transmission",KHR_MATERIALS_UNLIT:"KHR_materials_unlit",KHR_MATERIALS_VOLUME:"KHR_materials_volume",KHR_TEXTURE_BASISU:"KHR_texture_basisu",KHR_TEXTURE_TRANSFORM:"KHR_texture_transform",KHR_MESH_QUANTIZATION:"KHR_mesh_quantization",EXT_TEXTURE_WEBP:"EXT_texture_webp",EXT_MESHOPT_COMPRESSION:"EXT_meshopt_compression"};class Am{constructor(t){this.parser=t,this.name=Sm.KHR_LIGHTS_PUNCTUAL,this.cache={refs:{},uses:{}}}_markDefs(){const t=this.parser,e=this.parser.json.nodes||[];for(let n=0,r=e.length;n<r;n++){const r=e[n];r.extensions&&r.extensions[this.name]&&void 0!==r.extensions[this.name].light&&t._addNodeRef(this.cache,r.extensions[this.name].light)}}_loadLight(t){const e=this.parser,n="light:"+t;let r=e.cache.get(n);if(r)return r;const i=e.json,s=((i.extensions&&i.extensions[this.name]||{}).lights||[])[t];let a;const o=new Li(16777215);void 0!==s.color&&o.fromArray(s.color);const l=void 0!==s.range?s.range:0;switch(s.type){case"directional":a=new nd(o),a.target.position.set(0,0,-1),a.add(a.target);break;case"point":a=new td(o),a.distance=l;break;case"spot":a=new Qu(o),a.distance=l,s.spot=s.spot||{},s.spot.innerConeAngle=void 0!==s.spot.innerConeAngle?s.spot.innerConeAngle:0,s.spot.outerConeAngle=void 0!==s.spot.outerConeAngle?s.spot.outerConeAngle:Math.PI/4,a.angle=s.spot.outerConeAngle,a.penumbra=1-s.spot.innerConeAngle/s.spot.outerConeAngle,a.target.position.set(0,0,-1),a.add(a.target);break;default:throw new Error("THREE.GLTFLoader: Unexpected light type: "+s.type)}return a.position.set(0,0,0),a.decay=2,void 0!==s.intensity&&(a.intensity=s.intensity),a.name=e.createUniqueName(s.name||"light_"+t),r=Promise.resolve(a),e.cache.add(n,r),r}createNodeAttachment(t){const e=this,n=this.parser,r=n.json.nodes[t],i=(r.extensions&&r.extensions[this.name]||{}).light;return void 0===i?null:this._loadLight(i).then((function(t){return n._getNodeRef(e.cache,i,t)}))}}class Em{constructor(){this.name=Sm.KHR_MATERIALS_UNLIT}getMaterialType(){return Ri}extendParams(t,e,n){const r=[];t.color=new Li(1,1,1),t.opacity=1;const i=e.pbrMetallicRoughness;if(i){if(Array.isArray(i.baseColorFactor)){const e=i.baseColorFactor;t.color.fromArray(e),t.opacity=e[3]}void 0!==i.baseColorTexture&&r.push(n.assignTexture(t,"map",i.baseColorTexture))}return Promise.all(r)}}class Cm{constructor(t){this.parser=t,this.name=Sm.KHR_MATERIALS_CLEARCOAT}getMaterialType(t){const e=this.parser.json.materials[t];return e.extensions&&e.extensions[this.name]?ou:null}extendMaterialParams(t,e){const n=this.parser,r=n.json.materials[t];if(!r.extensions||!r.extensions[this.name])return Promise.resolve();const i=[],s=r.extensions[this.name];if(void 0!==s.clearcoatFactor&&(e.clearcoat=s.clearcoatFactor),void 0!==s.clearcoatTexture&&i.push(n.assignTexture(e,"clearcoatMap",s.clearcoatTexture)),void 0!==s.clearcoatRoughnessFactor&&(e.clearcoatRoughness=s.clearcoatRoughnessFactor),void 0!==s.clearcoatRoughnessTexture&&i.push(n.assignTexture(e,"clearcoatRoughnessMap",s.clearcoatRoughnessTexture)),void 0!==s.clearcoatNormalTexture&&(i.push(n.assignTexture(e,"clearcoatNormalMap",s.clearcoatNormalTexture)),void 0!==s.clearcoatNormalTexture.scale)){const t=s.clearcoatNormalTexture.scale;e.clearcoatNormalScale=new jn(t,t)}return Promise.all(i)}}class Pm{constructor(t){this.parser=t,this.name=Sm.KHR_MATERIALS_SHEEN}getMaterialType(t){const e=this.parser.json.materials[t];return e.extensions&&e.extensions[this.name]?ou:null}extendMaterialParams(t,e){const n=this.parser,r=n.json.materials[t];if(!r.extensions||!r.extensions[this.name])return Promise.resolve();const i=[];e.sheenColor=new Li(0,0,0),e.sheenRoughness=0,e.sheen=1;const s=r.extensions[this.name];return void 0!==s.sheenColorFactor&&e.sheenColor.fromArray(s.sheenColorFactor),void 0!==s.sheenRoughnessFactor&&(e.sheenRoughness=s.sheenRoughnessFactor),void 0!==s.sheenColorTexture&&i.push(n.assignTexture(e,"sheenColorMap",s.sheenColorTexture)),void 0!==s.sheenRoughnessTexture&&i.push(n.assignTexture(e,"sheenRoughnessMap",s.sheenRoughnessTexture)),Promise.all(i)}}class Lm{constructor(t){this.parser=t,this.name=Sm.KHR_MATERIALS_TRANSMISSION}getMaterialType(t){const e=this.parser.json.materials[t];return e.extensions&&e.extensions[this.name]?ou:null}extendMaterialParams(t,e){const n=this.parser,r=n.json.materials[t];if(!r.extensions||!r.extensions[this.name])return Promise.resolve();const i=[],s=r.extensions[this.name];return void 0!==s.transmissionFactor&&(e.transmission=s.transmissionFactor),void 0!==s.transmissionTexture&&i.push(n.assignTexture(e,"transmissionMap",s.transmissionTexture)),Promise.all(i)}}class Rm{constructor(t){this.parser=t,this.name=Sm.KHR_MATERIALS_VOLUME}getMaterialType(t){const e=this.parser.json.materials[t];return e.extensions&&e.extensions[this.name]?ou:null}extendMaterialParams(t,e){const n=this.parser,r=n.json.materials[t];if(!r.extensions||!r.extensions[this.name])return Promise.resolve();const i=[],s=r.extensions[this.name];e.thickness=void 0!==s.thicknessFactor?s.thicknessFactor:0,void 0!==s.thicknessTexture&&i.push(n.assignTexture(e,"thicknessMap",s.thicknessTexture)),e.attenuationDistance=s.attenuationDistance||0;const a=s.attenuationColor||[1,1,1];return e.attenuationColor=new Li(a[0],a[1],a[2]),Promise.all(i)}}class Fm{constructor(t){this.parser=t,this.name=Sm.KHR_MATERIALS_IOR}getMaterialType(t){const e=this.parser.json.materials[t];return e.extensions&&e.extensions[this.name]?ou:null}extendMaterialParams(t,e){const n=this.parser.json.materials[t];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();const r=n.extensions[this.name];return e.ior=void 0!==r.ior?r.ior:1.5,Promise.resolve()}}class Dm{constructor(t){this.parser=t,this.name=Sm.KHR_MATERIALS_SPECULAR}getMaterialType(t){const e=this.parser.json.materials[t];return e.extensions&&e.extensions[this.name]?ou:null}extendMaterialParams(t,e){const n=this.parser,r=n.json.materials[t];if(!r.extensions||!r.extensions[this.name])return Promise.resolve();const i=[],s=r.extensions[this.name];e.specularIntensity=void 0!==s.specularFactor?s.specularFactor:1,void 0!==s.specularTexture&&i.push(n.assignTexture(e,"specularIntensityMap",s.specularTexture));const a=s.specularColorFactor||[1,1,1];return e.specularColor=new Li(a[0],a[1],a[2]),void 0!==s.specularColorTexture&&i.push(n.assignTexture(e,"specularColorMap",s.specularColorTexture).then((function(t){t.encoding=tn}))),Promise.all(i)}}class Im{constructor(t){this.parser=t,this.name=Sm.KHR_TEXTURE_BASISU}loadTexture(t){const e=this.parser,n=e.json,r=n.textures[t];if(!r.extensions||!r.extensions[this.name])return null;const i=r.extensions[this.name],s=n.images[i.source],a=e.options.ktx2Loader;if(!a){if(n.extensionsRequired&&n.extensionsRequired.indexOf(this.name)>=0)throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");return null}return e.loadTextureImage(t,s,a)}}class Um{constructor(t){this.parser=t,this.name=Sm.EXT_TEXTURE_WEBP,this.isSupported=null}loadTexture(t){const e=this.name,n=this.parser,r=n.json,i=r.textures[t];if(!i.extensions||!i.extensions[e])return null;const s=i.extensions[e],a=r.images[s.source];let o=n.textureLoader;if(a.uri){const t=n.options.manager.getHandler(a.uri);null!==t&&(o=t)}return this.detectSupport().then((function(i){if(i)return n.loadTextureImage(t,a,o);if(r.extensionsRequired&&r.extensionsRequired.indexOf(e)>=0)throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported.");return n.loadTexture(t)}))}detectSupport(){return this.isSupported||(this.isSupported=new Promise((function(t){const e=new Image;e.src="data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA",e.onload=e.onerror=function(){t(1===e.height)}}))),this.isSupported}}class Nm{constructor(t){this.name=Sm.EXT_MESHOPT_COMPRESSION,this.parser=t}loadBufferView(t){const e=this.parser.json,n=e.bufferViews[t];if(n.extensions&&n.extensions[this.name]){const t=n.extensions[this.name],r=this.parser.getDependency("buffer",t.buffer),i=this.parser.options.meshoptDecoder;if(!i||!i.supported){if(e.extensionsRequired&&e.extensionsRequired.indexOf(this.name)>=0)throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");return null}return Promise.all([r,i.ready]).then((function(e){const n=t.byteOffset||0,r=t.byteLength||0,s=t.count,a=t.byteStride,o=new ArrayBuffer(s*a),l=new Uint8Array(e[0],n,r);return i.decodeGltfBuffer(new Uint8Array(o),s,a,l,t.mode,t.filter),o}))}return null}}const Om="glTF";class Bm{constructor(t){this.name=Sm.KHR_BINARY_GLTF,this.content=null,this.body=null;const e=new DataView(t,0,12);if(this.header={magic:ld.decodeText(new Uint8Array(t.slice(0,4))),version:e.getUint32(4,!0),length:e.getUint32(8,!0)},this.header.magic!==Om)throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");if(this.header.version<2)throw new Error("THREE.GLTFLoader: Legacy binary file detected.");const n=this.header.length-12,r=new DataView(t,12);let i=0;for(;i<n;){const e=r.getUint32(i,!0);i+=4;const n=r.getUint32(i,!0);if(i+=4,1313821514===n){const n=new Uint8Array(t,12+i,e);this.content=ld.decodeText(n)}else if(5130562===n){const n=12+i;this.body=t.slice(n,n+e)}i+=e}if(null===this.content)throw new Error("THREE.GLTFLoader: JSON content not found.")}}class zm{constructor(t,e){if(!e)throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");this.name=Sm.KHR_DRACO_MESH_COMPRESSION,this.json=t,this.dracoLoader=e,this.dracoLoader.preload()}decodePrimitive(t,e){const n=this.json,r=this.dracoLoader,i=t.extensions[this.name].bufferView,s=t.extensions[this.name].attributes,a={},o={},l={};for(const t in s){const e=Jm[t]||t.toLowerCase();a[e]=s[t]}for(const e in t.attributes){const r=Jm[e]||e.toLowerCase();if(void 0!==s[e]){const i=n.accessors[t.attributes[e]],s=Ym[i.componentType];l[r]=s,o[r]=!0===i.normalized}}return e.getDependency("bufferView",i).then((function(t){return new Promise((function(e){r.decodeDracoFile(t,(function(t){for(const e in t.attributes){const n=t.attributes[e],r=o[e];void 0!==r&&(n.normalized=r)}e(t)}),a,l)}))}))}}class km{constructor(){this.name=Sm.KHR_TEXTURE_TRANSFORM}extendTexture(t,e){return void 0!==e.texCoord&&console.warn('THREE.GLTFLoader: Custom UV sets in "'+this.name+'" extension not yet supported.'),void 0===e.offset&&void 0===e.rotation&&void 0===e.scale||(t=t.clone(),void 0!==e.offset&&t.offset.fromArray(e.offset),void 0!==e.rotation&&(t.rotation=e.rotation),void 0!==e.scale&&t.repeat.fromArray(e.scale),t.needsUpdate=!0),t}}class Hm extends au{constructor(t){super(),this.isGLTFSpecularGlossinessMaterial=!0;const e=["#ifdef USE_SPECULARMAP","\tuniform sampler2D specularMap;","#endif"].join("\n"),n=["#ifdef USE_GLOSSINESSMAP","\tuniform sampler2D glossinessMap;","#endif"].join("\n"),r=["vec3 specularFactor = specular;","#ifdef USE_SPECULARMAP","\tvec4 texelSpecular = texture2D( specularMap, vUv );","\ttexelSpecular = sRGBToLinear( texelSpecular );","\t// reads channel RGB, compatible with a glTF Specular-Glossiness (RGBA) texture","\tspecularFactor *= texelSpecular.rgb;","#endif"].join("\n"),i=["float glossinessFactor = glossiness;","#ifdef USE_GLOSSINESSMAP","\tvec4 texelGlossiness = texture2D( glossinessMap, vUv );","\t// reads channel A, compatible with a glTF Specular-Glossiness (RGBA) texture","\tglossinessFactor *= texelGlossiness.a;","#endif"].join("\n"),s=["PhysicalMaterial material;","material.diffuseColor = diffuseColor.rgb * ( 1. - max( specularFactor.r, max( specularFactor.g, specularFactor.b ) ) );","vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );","float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );","material.roughness = max( 1.0 - glossinessFactor, 0.0525 ); // 0.0525 corresponds to the base mip of a 256 cubemap.","material.roughness += geometryRoughness;","material.roughness = min( material.roughness, 1.0 );","material.specularColor = specularFactor;"].join("\n"),a={specular:{value:(new Li).setHex(16777215)},glossiness:{value:1},specularMap:{value:null},glossinessMap:{value:null}};this._extraUniforms=a,this.onBeforeCompile=function(t){for(const e in a)t.uniforms[e]=a[e];t.fragmentShader=t.fragmentShader.replace("uniform float roughness;","uniform vec3 specular;").replace("uniform float metalness;","uniform float glossiness;").replace("#include <roughnessmap_pars_fragment>",e).replace("#include <metalnessmap_pars_fragment>",n).replace("#include <roughnessmap_fragment>",r).replace("#include <metalnessmap_fragment>",i).replace("#include <lights_physical_fragment>",s)},Object.defineProperties(this,{specular:{get:function(){return a.specular.value},set:function(t){a.specular.value=t}},specularMap:{get:function(){return a.specularMap.value},set:function(t){a.specularMap.value=t,t?this.defines.USE_SPECULARMAP="":delete this.defines.USE_SPECULARMAP}},glossiness:{get:function(){return a.glossiness.value},set:function(t){a.glossiness.value=t}},glossinessMap:{get:function(){return a.glossinessMap.value},set:function(t){a.glossinessMap.value=t,t?(this.defines.USE_GLOSSINESSMAP="",this.defines.USE_UV=""):(delete this.defines.USE_GLOSSINESSMAP,delete this.defines.USE_UV)}}}),delete this.metalness,delete this.roughness,delete this.metalnessMap,delete this.roughnessMap,this.setValues(t)}copy(t){return super.copy(t),this.specularMap=t.specularMap,this.specular.copy(t.specular),this.glossinessMap=t.glossinessMap,this.glossiness=t.glossiness,delete this.metalness,delete this.roughness,delete this.metalnessMap,delete this.roughnessMap,this}}class Gm{constructor(){this.name=Sm.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS,this.specularGlossinessParams=["color","map","lightMap","lightMapIntensity","aoMap","aoMapIntensity","emissive","emissiveIntensity","emissiveMap","bumpMap","bumpScale","normalMap","normalMapType","displacementMap","displacementScale","displacementBias","specularMap","specular","glossinessMap","glossiness","alphaMap","envMap","envMapIntensity","refractionRatio"]}getMaterialType(){return Hm}extendParams(t,e,n){const r=e.extensions[this.name];t.color=new Li(1,1,1),t.opacity=1;const i=[];if(Array.isArray(r.diffuseFactor)){const e=r.diffuseFactor;t.color.fromArray(e),t.opacity=e[3]}if(void 0!==r.diffuseTexture&&i.push(n.assignTexture(t,"map",r.diffuseTexture)),t.emissive=new Li(0,0,0),t.glossiness=void 0!==r.glossinessFactor?r.glossinessFactor:1,t.specular=new Li(1,1,1),Array.isArray(r.specularFactor)&&t.specular.fromArray(r.specularFactor),void 0!==r.specularGlossinessTexture){const e=r.specularGlossinessTexture;i.push(n.assignTexture(t,"glossinessMap",e)),i.push(n.assignTexture(t,"specularMap",e))}return Promise.all(i)}createMaterial(t){const e=new Hm(t);return e.fog=!0,e.color=t.color,e.map=void 0===t.map?null:t.map,e.lightMap=null,e.lightMapIntensity=1,e.aoMap=void 0===t.aoMap?null:t.aoMap,e.aoMapIntensity=1,e.emissive=t.emissive,e.emissiveIntensity=1,e.emissiveMap=void 0===t.emissiveMap?null:t.emissiveMap,e.bumpMap=void 0===t.bumpMap?null:t.bumpMap,e.bumpScale=1,e.normalMap=void 0===t.normalMap?null:t.normalMap,e.normalMapType=rn,t.normalScale&&(e.normalScale=t.normalScale),e.displacementMap=null,e.displacementScale=1,e.displacementBias=0,e.specularMap=void 0===t.specularMap?null:t.specularMap,e.specular=t.specular,e.glossinessMap=void 0===t.glossinessMap?null:t.glossinessMap,e.glossiness=t.glossiness,e.alphaMap=null,e.envMap=void 0===t.envMap?null:t.envMap,e.envMapIntensity=1,e.refractionRatio=.98,e}}class Vm{constructor(){this.name=Sm.KHR_MESH_QUANTIZATION}}class Wm extends gu{constructor(t,e,n,r){super(t,e,n,r)}copySampleValue_(t){const e=this.resultBuffer,n=this.sampleValues,r=this.valueSize,i=t*r*3+r;for(let t=0;t!==r;t++)e[t]=n[i+t];return e}}Wm.prototype.beforeStart_=Wm.prototype.copySampleValue_,Wm.prototype.afterEnd_=Wm.prototype.copySampleValue_,Wm.prototype.interpolate_=function(t,e,n,r){const i=this.resultBuffer,s=this.sampleValues,a=this.valueSize,o=2*a,l=3*a,c=r-e,h=(n-e)/c,u=h*h,d=u*h,p=t*l,f=p-l,m=-2*d+3*u,g=d-u,v=1-m,x=g-u+h;for(let t=0;t!==a;t++){const e=s[f+t+a],n=s[f+t+o]*c,r=s[p+t+a],l=s[p+t]*c;i[t]=v*e+x*n+m*r+g*l}return i};const Xm=new or;class jm extends Wm{interpolate_(t,e,n,r){const i=super.interpolate_(t,e,n,r);return Xm.fromArray(i).normalize().toArray(i),i}}const Ym={5120:Int8Array,5121:Uint8Array,5122:Int16Array,5123:Uint16Array,5125:Uint32Array,5126:Float32Array},qm={9728:xt,9729:Mt,9984:yt,9985:Tt,9986:bt,9987:At},Qm={33071:gt,33648:vt,10497:mt},Zm={SCALAR:1,VEC2:2,VEC3:3,VEC4:4,MAT2:4,MAT3:9,MAT4:16},Jm={POSITION:"position",NORMAL:"normal",TANGENT:"tangent",TEXCOORD_0:"uv",TEXCOORD_1:"uv2",COLOR_0:"color",WEIGHTS_0:"skinWeight",JOINTS_0:"skinIndex"},Km={scale:"scale",translation:"position",rotation:"quaternion",weights:"morphTargetInfluences"},$m={CUBICSPLINE:void 0,LINEAR:Ve,STEP:Ge};function tg(t,e,n){for(const r in n.extensions)void 0===t[r]&&(e.userData.gltfExtensions=e.userData.gltfExtensions||{},e.userData.gltfExtensions[r]=n.extensions[r])}function eg(t,e){void 0!==e.extras&&("object"==typeof e.extras?Object.assign(t.userData,e.extras):console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, "+e.extras))}function ng(t,e){if(t.updateMorphTargets(),void 0!==e.weights)for(let n=0,r=e.weights.length;n<r;n++)t.morphTargetInfluences[n]=e.weights[n];if(e.extras&&Array.isArray(e.extras.targetNames)){const n=e.extras.targetNames;if(t.morphTargetInfluences.length===n.length){t.morphTargetDictionary={};for(let e=0,r=n.length;e<r;e++)t.morphTargetDictionary[n[e]]=e}else console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.")}}function rg(t){const e=t.extensions&&t.extensions[Sm.KHR_DRACO_MESH_COMPRESSION];let n;return n=e?"draco:"+e.bufferView+":"+e.indices+":"+ig(e.attributes):t.indices+":"+ig(t.attributes)+":"+t.mode,n}function ig(t){let e="";const n=Object.keys(t).sort();for(let r=0,i=n.length;r<i;r++)e+=n[r]+":"+t[n[r]]+";";return e}function sg(t){switch(t){case Int8Array:return 1/127;case Uint8Array:return 1/255;case Int16Array:return 1/32767;case Uint16Array:return 1/65535;default:throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.")}}class ag{constructor(t={},e={}){this.json=t,this.extensions={},this.plugins={},this.options=e,this.cache=new Tm,this.associations=new Map,this.primitiveCache={},this.meshCache={refs:{},uses:{}},this.cameraCache={refs:{},uses:{}},this.lightCache={refs:{},uses:{}},this.textureCache={},this.nodeNamesUsed={},"undefined"!=typeof createImageBitmap&&!1===/Firefox|Safari/.test(navigator.userAgent)?this.textureLoader=new md(this.options.manager):this.textureLoader=new Hu(this.options.manager),this.textureLoader.setCrossOrigin(this.options.crossOrigin),this.textureLoader.setRequestHeader(this.options.requestHeader),this.fileLoader=new Uu(this.options.manager),this.fileLoader.setResponseType("arraybuffer"),"use-credentials"===this.options.crossOrigin&&this.fileLoader.setWithCredentials(!0)}setExtensions(t){this.extensions=t}setPlugins(t){this.plugins=t}parse(t,e){const n=this,r=this.json,i=this.extensions;this.cache.removeAll(),this._invokeAll((function(t){return t._markDefs&&t._markDefs()})),Promise.all(this._invokeAll((function(t){return t.beforeRoot&&t.beforeRoot()}))).then((function(){return Promise.all([n.getDependencies("scene"),n.getDependencies("animation"),n.getDependencies("camera")])})).then((function(e){const s={scene:e[0][r.scene||0],scenes:e[0],animations:e[1],cameras:e[2],asset:r.asset,parser:n,userData:{}};tg(i,s,r),eg(s,r),Promise.all(n._invokeAll((function(t){return t.afterRoot&&t.afterRoot(s)}))).then((function(){t(s)}))})).catch(e)}_markDefs(){const t=this.json.nodes||[],e=this.json.skins||[],n=this.json.meshes||[];for(let n=0,r=e.length;n<r;n++){const r=e[n].joints;for(let e=0,n=r.length;e<n;e++)t[r[e]].isBone=!0}for(let e=0,r=t.length;e<r;e++){const r=t[e];void 0!==r.mesh&&(this._addNodeRef(this.meshCache,r.mesh),void 0!==r.skin&&(n[r.mesh].isSkinnedMesh=!0)),void 0!==r.camera&&this._addNodeRef(this.cameraCache,r.camera)}}_addNodeRef(t,e){void 0!==e&&(void 0===t.refs[e]&&(t.refs[e]=t.uses[e]=0),t.refs[e]++)}_getNodeRef(t,e,n){if(t.refs[e]<=1)return n;const r=n.clone(),i=(t,e)=>{const n=this.associations.get(t);null!=n&&this.associations.set(e,n);for(const[n,r]of t.children.entries())i(r,e.children[n])};return i(n,r),r.name+="_instance_"+t.uses[e]++,r}_invokeOne(t){const e=Object.values(this.plugins);e.push(this);for(let n=0;n<e.length;n++){const r=t(e[n]);if(r)return r}return null}_invokeAll(t){const e=Object.values(this.plugins);e.unshift(this);const n=[];for(let r=0;r<e.length;r++){const i=t(e[r]);i&&n.push(i)}return n}getDependency(t,e){const n=t+":"+e;let r=this.cache.get(n);if(!r){switch(t){case"scene":r=this.loadScene(e);break;case"node":r=this.loadNode(e);break;case"mesh":r=this._invokeOne((function(t){return t.loadMesh&&t.loadMesh(e)}));break;case"accessor":r=this.loadAccessor(e);break;case"bufferView":r=this._invokeOne((function(t){return t.loadBufferView&&t.loadBufferView(e)}));break;case"buffer":r=this.loadBuffer(e);break;case"material":r=this._invokeOne((function(t){return t.loadMaterial&&t.loadMaterial(e)}));break;case"texture":r=this._invokeOne((function(t){return t.loadTexture&&t.loadTexture(e)}));break;case"skin":r=this.loadSkin(e);break;case"animation":r=this.loadAnimation(e);break;case"camera":r=this.loadCamera(e);break;default:throw new Error("Unknown type: "+t)}this.cache.add(n,r)}return r}getDependencies(t){let e=this.cache.get(t);if(!e){const n=this,r=this.json[t+("mesh"===t?"es":"s")]||[];e=Promise.all(r.map((function(e,r){return n.getDependency(t,r)}))),this.cache.add(t,e)}return e}loadBuffer(t){const e=this.json.buffers[t],n=this.fileLoader;if(e.type&&"arraybuffer"!==e.type)throw new Error("THREE.GLTFLoader: "+e.type+" buffer type is not supported.");if(void 0===e.uri&&0===t)return Promise.resolve(this.extensions[Sm.KHR_BINARY_GLTF].body);const r=this.options;return new Promise((function(t,i){n.load(ld.resolveURL(e.uri,r.path),t,void 0,(function(){i(new Error('THREE.GLTFLoader: Failed to load buffer "'+e.uri+'".'))}))}))}loadBufferView(t){const e=this.json.bufferViews[t];return this.getDependency("buffer",e.buffer).then((function(t){const n=e.byteLength||0,r=e.byteOffset||0;return t.slice(r,r+n)}))}loadAccessor(t){const e=this,n=this.json,r=this.json.accessors[t];if(void 0===r.bufferView&&void 0===r.sparse)return Promise.resolve(null);const i=[];return void 0!==r.bufferView?i.push(this.getDependency("bufferView",r.bufferView)):i.push(null),void 0!==r.sparse&&(i.push(this.getDependency("bufferView",r.sparse.indices.bufferView)),i.push(this.getDependency("bufferView",r.sparse.values.bufferView))),Promise.all(i).then((function(t){const i=t[0],s=Zm[r.type],a=Ym[r.componentType],o=a.BYTES_PER_ELEMENT,l=o*s,c=r.byteOffset||0,h=void 0!==r.bufferView?n.bufferViews[r.bufferView].byteStride:void 0,u=!0===r.normalized;let d,p;if(h&&h!==l){const t=Math.floor(c/h),n="InterleavedBuffer:"+r.bufferView+":"+r.componentType+":"+t+":"+r.count;let l=e.cache.get(n);l||(d=new a(i,t*h,r.count*h/o),l=new Rl(d,h/o),e.cache.add(n,l)),p=new Dl(l,s,c%h/o,u)}else d=null===i?new a(r.count*s):new a(i,c,r.count*s),p=new Ii(d,s,u);if(void 0!==r.sparse){const e=Zm.SCALAR,n=Ym[r.sparse.indices.componentType],o=r.sparse.indices.byteOffset||0,l=r.sparse.values.byteOffset||0,c=new n(t[1],o,r.sparse.count*e),h=new a(t[2],l,r.sparse.count*s);null!==i&&(p=new Ii(p.array.slice(),p.itemSize,p.normalized));for(let t=0,e=c.length;t<e;t++){const e=c[t];if(p.setX(e,h[t*s]),s>=2&&p.setY(e,h[t*s+1]),s>=3&&p.setZ(e,h[t*s+2]),s>=4&&p.setW(e,h[t*s+3]),s>=5)throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.")}}return p}))}loadTexture(t){const e=this.json,n=this.options,r=e.textures[t],i=e.images[r.source];let s=this.textureLoader;if(i.uri){const t=n.manager.getHandler(i.uri);null!==t&&(s=t)}return this.loadTextureImage(t,i,s)}loadTextureImage(t,e,n){const r=this,i=this.json,s=this.options,a=i.textures[t],o=(e.uri||e.bufferView)+":"+a.sampler;if(this.textureCache[o])return this.textureCache[o];const l=self.URL||self.webkitURL;let c=e.uri||"",h=!1;if(void 0!==e.bufferView)c=r.getDependency("bufferView",e.bufferView).then((function(t){h=!0;const n=new Blob([t],{type:e.mimeType});return c=l.createObjectURL(n),c}));else if(void 0===e.uri)throw new Error("THREE.GLTFLoader: Image "+t+" is missing URI and bufferView");const u=Promise.resolve(c).then((function(t){return new Promise((function(e,r){let i=e;!0===n.isImageBitmapLoader&&(i=function(t){const n=new er(t);n.needsUpdate=!0,e(n)}),n.load(ld.resolveURL(t,s.path),i,void 0,r)}))})).then((function(e){!0===h&&l.revokeObjectURL(c),e.flipY=!1,a.name&&(e.name=a.name);const n=(i.samplers||{})[a.sampler]||{};return e.magFilter=qm[n.magFilter]||Mt,e.minFilter=qm[n.minFilter]||At,e.wrapS=Qm[n.wrapS]||mt,e.wrapT=Qm[n.wrapT]||mt,r.associations.set(e,{textures:t}),e})).catch((function(){return console.error("THREE.GLTFLoader: Couldn't load texture",c),null}));return this.textureCache[o]=u,u}assignTexture(t,e,n){const r=this;return this.getDependency("texture",n.index).then((function(i){if(void 0===n.texCoord||0==n.texCoord||"aoMap"===e&&1==n.texCoord||console.warn("THREE.GLTFLoader: Custom UV set "+n.texCoord+" for texture "+e+" not yet supported."),r.extensions[Sm.KHR_TEXTURE_TRANSFORM]){const t=void 0!==n.extensions?n.extensions[Sm.KHR_TEXTURE_TRANSFORM]:void 0;if(t){const e=r.associations.get(i);i=r.extensions[Sm.KHR_TEXTURE_TRANSFORM].extendTexture(i,t),r.associations.set(i,e)}}return t[e]=i,i}))}assignFinalMaterial(t){const e=t.geometry;let n=t.material;const r=void 0===e.attributes.tangent,i=void 0!==e.attributes.color,s=void 0===e.attributes.normal;if(t.isPoints){const t="PointsMaterial:"+n.uuid;let e=this.cache.get(t);e||(e=new Ec,Mi.prototype.copy.call(e,n),e.color.copy(n.color),e.map=n.map,e.sizeAttenuation=!1,this.cache.add(t,e)),n=e}else if(t.isLine){const t="LineBasicMaterial:"+n.uuid;let e=this.cache.get(t);e||(e=new gc,Mi.prototype.copy.call(e,n),e.color.copy(n.color),this.cache.add(t,e)),n=e}if(r||i||s){let t="ClonedMaterial:"+n.uuid+":";n.isGLTFSpecularGlossinessMaterial&&(t+="specular-glossiness:"),r&&(t+="derivative-tangents:"),i&&(t+="vertex-colors:"),s&&(t+="flat-shading:");let e=this.cache.get(t);e||(e=n.clone(),i&&(e.vertexColors=!0),s&&(e.flatShading=!0),r&&(e.normalScale&&(e.normalScale.y*=-1),e.clearcoatNormalScale&&(e.clearcoatNormalScale.y*=-1)),this.cache.add(t,e),this.associations.set(e,this.associations.get(n))),n=e}n.aoMap&&void 0===e.attributes.uv2&&void 0!==e.attributes.uv&&e.setAttribute("uv2",e.attributes.uv),t.material=n}getMaterialType(){return au}loadMaterial(t){const e=this,n=this.json,r=this.extensions,i=n.materials[t];let s;const a={},o=i.extensions||{},l=[];if(o[Sm.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS]){const t=r[Sm.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS];s=t.getMaterialType(),l.push(t.extendParams(a,i,e))}else if(o[Sm.KHR_MATERIALS_UNLIT]){const t=r[Sm.KHR_MATERIALS_UNLIT];s=t.getMaterialType(),l.push(t.extendParams(a,i,e))}else{const n=i.pbrMetallicRoughness||{};if(a.color=new Li(1,1,1),a.opacity=1,Array.isArray(n.baseColorFactor)){const t=n.baseColorFactor;a.color.fromArray(t),a.opacity=t[3]}void 0!==n.baseColorTexture&&l.push(e.assignTexture(a,"map",n.baseColorTexture)),a.metalness=void 0!==n.metallicFactor?n.metallicFactor:1,a.roughness=void 0!==n.roughnessFactor?n.roughnessFactor:1,void 0!==n.metallicRoughnessTexture&&(l.push(e.assignTexture(a,"metalnessMap",n.metallicRoughnessTexture)),l.push(e.assignTexture(a,"roughnessMap",n.metallicRoughnessTexture))),s=this._invokeOne((function(e){return e.getMaterialType&&e.getMaterialType(t)})),l.push(Promise.all(this._invokeAll((function(e){return e.extendMaterialParams&&e.extendMaterialParams(t,a)}))))}!0===i.doubleSided&&(a.side=w);const c=i.alphaMode||"OPAQUE";if("BLEND"===c?(a.transparent=!0,a.depthWrite=!1):(a.format=Ht,a.transparent=!1,"MASK"===c&&(a.alphaTest=void 0!==i.alphaCutoff?i.alphaCutoff:.5)),void 0!==i.normalTexture&&s!==Ri&&(l.push(e.assignTexture(a,"normalMap",i.normalTexture)),a.normalScale=new jn(1,1),void 0!==i.normalTexture.scale)){const t=i.normalTexture.scale;a.normalScale.set(t,t)}return void 0!==i.occlusionTexture&&s!==Ri&&(l.push(e.assignTexture(a,"aoMap",i.occlusionTexture)),void 0!==i.occlusionTexture.strength&&(a.aoMapIntensity=i.occlusionTexture.strength)),void 0!==i.emissiveFactor&&s!==Ri&&(a.emissive=(new Li).fromArray(i.emissiveFactor)),void 0!==i.emissiveTexture&&s!==Ri&&l.push(e.assignTexture(a,"emissiveMap",i.emissiveTexture)),Promise.all(l).then((function(){let n;return n=s===Hm?r[Sm.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS].createMaterial(a):new s(a),i.name&&(n.name=i.name),n.map&&(n.map.encoding=tn),n.emissiveMap&&(n.emissiveMap.encoding=tn),eg(n,i),e.associations.set(n,{materials:t}),i.extensions&&tg(r,n,i),n}))}createUniqueName(t){const e=Qd.sanitizeNodeName(t||"");let n=e;for(let t=1;this.nodeNamesUsed[n];++t)n=e+"_"+t;return this.nodeNamesUsed[n]=!0,n}loadGeometries(t){const e=this,n=this.extensions,r=this.primitiveCache;function i(t){return n[Sm.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(t,e).then((function(n){return lg(n,t,e)}))}const s=[];for(let n=0,a=t.length;n<a;n++){const a=t[n],o=rg(a),l=r[o];if(l)s.push(l.promise);else{let t;t=a.extensions&&a.extensions[Sm.KHR_DRACO_MESH_COMPRESSION]?i(a):lg(new Ki,a,e),r[o]={primitive:a,promise:t},s.push(t)}}return Promise.all(s)}loadMesh(t){const e=this,n=this.json,r=this.extensions,i=n.meshes[t],s=i.primitives,a=[];for(let t=0,e=s.length;t<e;t++){const e=void 0===s[t].material?(void 0===(o=this.cache).DefaultMaterial&&(o.DefaultMaterial=new au({color:16777215,emissive:0,metalness:1,roughness:1,transparent:!1,depthTest:!0,side:x})),o.DefaultMaterial):this.getDependency("material",s[t].material);a.push(e)}var o;return a.push(e.loadGeometries(s)),Promise.all(a).then((function(n){const a=n.slice(0,n.length-1),o=n[n.length-1],l=[];for(let n=0,c=o.length;n<c;n++){const c=o[n],h=s[n];let u;const d=a[n];if(4===h.mode||5===h.mode||6===h.mode||void 0===h.mode)u=!0===i.isSkinnedMesh?new ic(c,d):new gs(c,d),!0!==u.isSkinnedMesh||u.geometry.attributes.skinWeight.normalized||u.normalizeSkinWeights(),5===h.mode?u.geometry=cg(u.geometry,Je):6===h.mode&&(u.geometry=cg(u.geometry,Ke));else if(1===h.mode)u=new Sc(c,d);else if(3===h.mode)u=new _c(c,d);else if(2===h.mode)u=new Ac(c,d);else{if(0!==h.mode)throw new Error("THREE.GLTFLoader: Primitive mode unsupported: "+h.mode);u=new Fc(c,d)}Object.keys(u.geometry.morphAttributes).length>0&&ng(u,i),u.name=e.createUniqueName(i.name||"mesh_"+t),eg(u,i),h.extensions&&tg(r,u,h),e.assignFinalMaterial(u),l.push(u)}for(let n=0,r=l.length;n<r;n++)e.associations.set(l[n],{meshes:t,primitives:n});if(1===l.length)return l[0];const c=new wl;e.associations.set(c,{meshes:t});for(let t=0,e=l.length;t<e;t++)c.add(l[t]);return c}))}loadCamera(t){let e;const n=this.json.cameras[t],r=n[n.type];if(r)return"perspective"===n.type?e=new Ts(Xn.radToDeg(r.yfov),r.aspectRatio||1,r.znear||1,r.zfar||2e6):"orthographic"===n.type&&(e=new qs(-r.xmag,r.xmag,r.ymag,-r.ymag,r.znear,r.zfar)),n.name&&(e.name=this.createUniqueName(n.name)),eg(e,n),Promise.resolve(e);console.warn("THREE.GLTFLoader: Missing camera parameters.")}loadSkin(t){const e=this.json.skins[t],n={joints:e.joints};return void 0===e.inverseBindMatrices?Promise.resolve(n):this.getDependency("accessor",e.inverseBindMatrices).then((function(t){return n.inverseBindMatrices=t,n}))}loadAnimation(t){const e=this.json.animations[t],n=[],r=[],i=[],s=[],a=[];for(let t=0,o=e.channels.length;t<o;t++){const o=e.channels[t],l=e.samplers[o.sampler],c=o.target,h=void 0!==c.node?c.node:c.id,u=void 0!==e.parameters?e.parameters[l.input]:l.input,d=void 0!==e.parameters?e.parameters[l.output]:l.output;n.push(this.getDependency("node",h)),r.push(this.getDependency("accessor",u)),i.push(this.getDependency("accessor",d)),s.push(l),a.push(c)}return Promise.all([Promise.all(n),Promise.all(r),Promise.all(i),Promise.all(s),Promise.all(a)]).then((function(n){const r=n[0],i=n[1],s=n[2],a=n[3],o=n[4],l=[];for(let t=0,e=r.length;t<e;t++){const e=r[t],n=i[t],c=s[t],h=a[t],u=o[t];if(void 0===e)continue;let d;switch(e.updateMatrix(),e.matrixAutoUpdate=!0,Km[u.path]){case Km.weights:d=Mu;break;case Km.rotation:d=Su;break;default:d=Eu}const p=e.name?e.name:e.uuid,f=void 0!==h.interpolation?$m[h.interpolation]:Ve,m=[];Km[u.path]===Km.weights?e.traverse((function(t){t.morphTargetInfluences&&m.push(t.name?t.name:t.uuid)})):m.push(p);let g=c.array;if(c.normalized){const t=sg(g.constructor),e=new Float32Array(g.length);for(let n=0,r=g.length;n<r;n++)e[n]=g[n]*t;g=e}for(let t=0,e=m.length;t<e;t++){const e=new d(m[t]+"."+Km[u.path],n.array,g,f);"CUBICSPLINE"===h.interpolation&&(e.createInterpolant=function(t){return new(this instanceof Su?jm:Wm)(this.times,this.values,this.getValueSize()/3,t)},e.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline=!0),l.push(e)}}const c=e.name?e.name:"animation_"+t;return new Cu(c,void 0,l)}))}createNodeMesh(t){const e=this.json,n=this,r=e.nodes[t];return void 0===r.mesh?null:n.getDependency("mesh",r.mesh).then((function(t){const e=n._getNodeRef(n.meshCache,r.mesh,t);return void 0!==r.weights&&e.traverse((function(t){if(t.isMesh)for(let e=0,n=r.weights.length;e<n;e++)t.morphTargetInfluences[e]=r.weights[e]})),e}))}loadNode(t){const e=this.json,n=this.extensions,r=this,i=e.nodes[t],s=i.name?r.createUniqueName(i.name):"";return function(){const e=[],n=r._invokeOne((function(e){return e.createNodeMesh&&e.createNodeMesh(t)}));return n&&e.push(n),void 0!==i.camera&&e.push(r.getDependency("camera",i.camera).then((function(t){return r._getNodeRef(r.cameraCache,i.camera,t)}))),r._invokeAll((function(e){return e.createNodeAttachment&&e.createNodeAttachment(t)})).forEach((function(t){e.push(t)})),Promise.all(e)}().then((function(e){let a;if(a=!0===i.isBone?new sc:e.length>1?new wl:1===e.length?e[0]:new hi,a!==e[0])for(let t=0,n=e.length;t<n;t++)a.add(e[t]);if(i.name&&(a.userData.name=i.name,a.name=s),eg(a,i),i.extensions&&tg(n,a,i),void 0!==i.matrix){const t=new zr;t.fromArray(i.matrix),a.applyMatrix4(t)}else void 0!==i.translation&&a.position.fromArray(i.translation),void 0!==i.rotation&&a.quaternion.fromArray(i.rotation),void 0!==i.scale&&a.scale.fromArray(i.scale);return r.associations.has(a)||r.associations.set(a,{}),r.associations.get(a).nodes=t,a}))}loadScene(t){const e=this.json,n=this.extensions,r=this.json.scenes[t],i=this,s=new wl;r.name&&(s.name=i.createUniqueName(r.name)),eg(s,r),r.extensions&&tg(n,s,r);const a=r.nodes||[],o=[];for(let t=0,n=a.length;t<n;t++)o.push(og(a[t],s,e,i));return Promise.all(o).then((function(){return i.associations=(t=>{const e=new Map;for(const[t,n]of i.associations)(t instanceof Mi||t instanceof er)&&e.set(t,n);return t.traverse((t=>{const n=i.associations.get(t);null!=n&&e.set(t,n)})),e})(s),s}))}}function og(t,e,n,r){const i=n.nodes[t];return r.getDependency("node",t).then((function(t){if(void 0===i.skin)return t;let e;return r.getDependency("skin",i.skin).then((function(t){e=t;const n=[];for(let t=0,i=e.joints.length;t<i;t++)n.push(r.getDependency("node",e.joints[t]));return Promise.all(n)})).then((function(n){return t.traverse((function(t){if(!t.isMesh)return;const r=[],i=[];for(let t=0,s=n.length;t<s;t++){const s=n[t];if(s){r.push(s);const n=new zr;void 0!==e.inverseBindMatrices&&n.fromArray(e.inverseBindMatrices.array,16*t),i.push(n)}else console.warn('THREE.GLTFLoader: Joint "%s" could not be found.',e.joints[t])}t.bind(new cc(r,i),t.matrixWorld)})),t}))})).then((function(t){e.add(t);const s=[];if(i.children){const e=i.children;for(let i=0,a=e.length;i<a;i++){const a=e[i];s.push(og(a,t,n,r))}}return Promise.all(s)}))}function lg(t,e,n){const r=e.attributes,i=[];function s(e,r){return n.getDependency("accessor",e).then((function(e){t.setAttribute(r,e)}))}for(const e in r){const n=Jm[e]||e.toLowerCase();n in t.attributes||i.push(s(r[e],n))}if(void 0!==e.indices&&!t.index){const r=n.getDependency("accessor",e.indices).then((function(e){t.setIndex(e)}));i.push(r)}return eg(t,e),function(t,e,n){const r=e.attributes,i=new ur;if(void 0===r.POSITION)return;{const t=n.json.accessors[r.POSITION],e=t.min,s=t.max;if(void 0===e||void 0===s)return void console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");if(i.set(new lr(e[0],e[1],e[2]),new lr(s[0],s[1],s[2])),t.normalized){const e=sg(Ym[t.componentType]);i.min.multiplyScalar(e),i.max.multiplyScalar(e)}}const s=e.targets;if(void 0!==s){const t=new lr,e=new lr;for(let r=0,i=s.length;r<i;r++){const i=s[r];if(void 0!==i.POSITION){const r=n.json.accessors[i.POSITION],s=r.min,a=r.max;if(void 0!==s&&void 0!==a){if(e.setX(Math.max(Math.abs(s[0]),Math.abs(a[0]))),e.setY(Math.max(Math.abs(s[1]),Math.abs(a[1]))),e.setZ(Math.max(Math.abs(s[2]),Math.abs(a[2]))),r.normalized){const t=sg(Ym[r.componentType]);e.multiplyScalar(t)}t.max(e)}else console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.")}}i.expandByVector(t)}t.boundingBox=i;const a=new Lr;i.getCenter(a.center),a.radius=i.min.distanceTo(i.max)/2,t.boundingSphere=a}(t,e,n),Promise.all(i).then((function(){return void 0!==e.targets?function(t,e,n){let r=!1,i=!1;for(let t=0,n=e.length;t<n;t++){const n=e[t];if(void 0!==n.POSITION&&(r=!0),void 0!==n.NORMAL&&(i=!0),r&&i)break}if(!r&&!i)return Promise.resolve(t);const s=[],a=[];for(let o=0,l=e.length;o<l;o++){const l=e[o];if(r){const e=void 0!==l.POSITION?n.getDependency("accessor",l.POSITION):t.attributes.position;s.push(e)}if(i){const e=void 0!==l.NORMAL?n.getDependency("accessor",l.NORMAL):t.attributes.normal;a.push(e)}}return Promise.all([Promise.all(s),Promise.all(a)]).then((function(e){const n=e[0],s=e[1];return r&&(t.morphAttributes.position=n),i&&(t.morphAttributes.normal=s),t.morphTargetsRelative=!0,t}))}(t,e.targets,n):t}))}function cg(t,e){let n=t.getIndex();if(null===n){const e=[],r=t.getAttribute("position");if(void 0===r)return console.error("THREE.GLTFLoader.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."),t;for(let t=0;t<r.count;t++)e.push(t);t.setIndex(e),n=t.getIndex()}const r=n.count-2,i=[];if(e===Ke)for(let t=1;t<=r;t++)i.push(n.getX(0)),i.push(n.getX(t)),i.push(n.getX(t+1));else for(let t=0;t<r;t++)t%2==0?(i.push(n.getX(t)),i.push(n.getX(t+1)),i.push(n.getX(t+2))):(i.push(n.getX(t+2)),i.push(n.getX(t+1)),i.push(n.getX(t)));i.length/3!==r&&console.error("THREE.GLTFLoader.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");const s=t.clone();return s.setIndex(i),s}class hg{constructor(){this.pluginCallbacks=[],this.register((function(t){return new wg(t)})),this.register((function(t){return new bg(t)})),this.register((function(t){return new _g(t)})),this.register((function(t){return new Tg(t)})),this.register((function(t){return new Sg(t)})),this.register((function(t){return new Mg(t)}))}register(t){return-1===this.pluginCallbacks.indexOf(t)&&this.pluginCallbacks.push(t),this}unregister(t){return-1!==this.pluginCallbacks.indexOf(t)&&this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(t),1),this}parse(t,e,n,r){"object"==typeof n&&(console.warn("THREE.GLTFExporter: parse() expects options as the fourth argument now."),r=n);const i=new yg,s=[];for(let t=0,e=this.pluginCallbacks.length;t<e;t++)s.push(this.pluginCallbacks[t](i));i.setPlugins(s),i.write(t,e,r).catch(n)}parseAsync(t,e){const n=this;return new Promise((function(r,i){n.parse(t,r,i,e)}))}}const ug=5121,dg=5123,pg={};pg[xt]=9728,pg[yt]=9984,pg[bt]=9986,pg[Mt]=9729,pg[Tt]=9985,pg[At]=9987,pg[gt]=33071,pg[mt]=10497,pg[vt]=33648;const fg={scale:"scale",position:"translation",quaternion:"rotation",morphTargetInfluences:"weights"};function mg(t,e){return t.length===e.length&&t.every((function(t,n){return t===e[n]}))}function gg(t){return 4*Math.ceil(t/4)}function vg(t,e=0){const n=gg(t.byteLength);if(n!==t.byteLength){const r=new Uint8Array(n);if(r.set(new Uint8Array(t)),0!==e)for(let i=t.byteLength;i<n;i++)r[i]=e;return r.buffer}return t}let xg=null;class yg{constructor(){this.plugins=[],this.options={},this.pending=[],this.buffers=[],this.byteOffset=0,this.buffers=[],this.nodeMap=new Map,this.skins=[],this.extensionsUsed={},this.uids=new Map,this.uid=0,this.json={asset:{version:"2.0",generator:"THREE.GLTFExporter"}},this.cache={meshes:new Map,attributes:new Map,attributesNormalized:new Map,materials:new Map,textures:new Map,images:new Map}}setPlugins(t){this.plugins=t}async write(t,e,n){this.options=Object.assign({},{binary:!1,trs:!1,onlyVisible:!0,truncateDrawRange:!0,embedImages:!0,maxTextureSize:1/0,animations:[],includeCustomExtensions:!1},n),this.options.animations.length>0&&(this.options.trs=!0),this.processInput(t),await Promise.all(this.pending);const r=this,i=r.buffers,s=r.json;n=r.options;const a=r.extensionsUsed,o=new Blob(i,{type:"application/octet-stream"}),l=Object.keys(a);if(l.length>0&&(s.extensionsUsed=l),s.buffers&&s.buffers.length>0&&(s.buffers[0].byteLength=o.size),!0===n.binary){const t=new window.FileReader;t.readAsArrayBuffer(o),t.onloadend=function(){const n=vg(t.result),r=new DataView(new ArrayBuffer(8));r.setUint32(0,n.byteLength,!0),r.setUint32(4,5130562,!0);const i=vg(function(t){if(void 0!==window.TextEncoder)return(new TextEncoder).encode(t).buffer;const e=new Uint8Array(new ArrayBuffer(t.length));for(let n=0,r=t.length;n<r;n++){const r=t.charCodeAt(n);e[n]=r>255?32:r}return e.buffer}(JSON.stringify(s)),32),a=new DataView(new ArrayBuffer(8));a.setUint32(0,i.byteLength,!0),a.setUint32(4,1313821514,!0);const o=new ArrayBuffer(12),l=new DataView(o);l.setUint32(0,1179937895,!0),l.setUint32(4,2,!0);const c=12+a.byteLength+i.byteLength+r.byteLength+n.byteLength;l.setUint32(8,c,!0);const h=new Blob([o,a,i,r,n],{type:"application/octet-stream"}),u=new window.FileReader;u.readAsArrayBuffer(h),u.onloadend=function(){e(u.result)}}}else if(s.buffers&&s.buffers.length>0){const t=new window.FileReader;t.readAsDataURL(o),t.onloadend=function(){const n=t.result;s.buffers[0].uri=n,e(s)}}else e(s)}serializeUserData(t,e){if(0===Object.keys(t.userData).length)return;const n=this.options,r=this.extensionsUsed;try{const i=JSON.parse(JSON.stringify(t.userData));if(n.includeCustomExtensions&&i.gltfExtensions){void 0===e.extensions&&(e.extensions={});for(const t in i.gltfExtensions)e.extensions[t]=i.gltfExtensions[t],r[t]=!0;delete i.gltfExtensions}Object.keys(i).length>0&&(e.extras=i)}catch(e){console.warn("THREE.GLTFExporter: userData of '"+t.name+"' won't be serialized because of JSON.stringify error - "+e.message)}}getUID(t){return this.uids.has(t)||this.uids.set(t,this.uid++),this.uids.get(t)}isNormalizedNormalAttribute(t){if(this.cache.attributesNormalized.has(t))return!1;const e=new lr;for(let n=0,r=t.count;n<r;n++)if(Math.abs(e.fromBufferAttribute(t,n).length()-1)>5e-4)return!1;return!0}createNormalizedNormalAttribute(t){const e=this.cache;if(e.attributesNormalized.has(t))return e.attributesNormalized.get(t);const n=t.clone(),r=new lr;for(let t=0,e=n.count;t<e;t++)r.fromBufferAttribute(n,t),0===r.x&&0===r.y&&0===r.z?r.setX(1):r.normalize(),n.setXYZ(t,r.x,r.y,r.z);return e.attributesNormalized.set(t,n),n}applyTextureTransform(t,e){let n=!1;const r={};0===e.offset.x&&0===e.offset.y||(r.offset=e.offset.toArray(),n=!0),0!==e.rotation&&(r.rotation=e.rotation,n=!0),1===e.repeat.x&&1===e.repeat.y||(r.scale=e.repeat.toArray(),n=!0),n&&(t.extensions=t.extensions||{},t.extensions.KHR_texture_transform=r,this.extensionsUsed.KHR_texture_transform=!0)}processBuffer(t){const e=this.json,n=this.buffers;return e.buffers||(e.buffers=[{byteLength:0}]),n.push(t),0}processBufferView(t,e,n,r,i){const s=this.json;let a;s.bufferViews||(s.bufferViews=[]),a=e===ug?1:e===dg?2:4;const o=gg(r*t.itemSize*a),l=new DataView(new ArrayBuffer(o));let c=0;for(let i=n;i<n+r;i++)for(let n=0;n<t.itemSize;n++){let r;t.itemSize>4?r=t.array[i*t.itemSize+n]:0===n?r=t.getX(i):1===n?r=t.getY(i):2===n?r=t.getZ(i):3===n&&(r=t.getW(i)),5126===e?l.setFloat32(c,r,!0):5125===e?l.setUint32(c,r,!0):e===dg?l.setUint16(c,r,!0):e===ug&&l.setUint8(c,r),c+=a}const h={buffer:this.processBuffer(l.buffer),byteOffset:this.byteOffset,byteLength:o};return void 0!==i&&(h.target=i),34962===i&&(h.byteStride=t.itemSize*a),this.byteOffset+=o,s.bufferViews.push(h),{id:s.bufferViews.length-1,byteLength:0}}processBufferViewImage(t){const e=this,n=e.json;return n.bufferViews||(n.bufferViews=[]),new Promise((function(r){const i=new window.FileReader;i.readAsArrayBuffer(t),i.onloadend=function(){const t=vg(i.result),s={buffer:e.processBuffer(t),byteOffset:e.byteOffset,byteLength:t.byteLength};e.byteOffset+=t.byteLength,r(n.bufferViews.push(s)-1)}}))}processAccessor(t,e,n,r){const i=this.options,s=this.json;let a;if(t.array.constructor===Float32Array)a=5126;else if(t.array.constructor===Uint32Array)a=5125;else if(t.array.constructor===Uint16Array)a=dg;else{if(t.array.constructor!==Uint8Array)throw new Error("THREE.GLTFExporter: Unsupported bufferAttribute component type.");a=ug}if(void 0===n&&(n=0),void 0===r&&(r=t.count),i.truncateDrawRange&&void 0!==e&&null===e.index){const i=n+r,s=e.drawRange.count===1/0?t.count:e.drawRange.start+e.drawRange.count;n=Math.max(n,e.drawRange.start),(r=Math.min(i,s)-n)<0&&(r=0)}if(0===r)return null;const o=function(t,e,n){const r={min:new Array(t.itemSize).fill(Number.POSITIVE_INFINITY),max:new Array(t.itemSize).fill(Number.NEGATIVE_INFINITY)};for(let i=e;i<e+n;i++)for(let e=0;e<t.itemSize;e++){let n;t.itemSize>4?n=t.array[i*t.itemSize+e]:0===e?n=t.getX(i):1===e?n=t.getY(i):2===e?n=t.getZ(i):3===e&&(n=t.getW(i)),r.min[e]=Math.min(r.min[e],n),r.max[e]=Math.max(r.max[e],n)}return r}(t,n,r);let l;void 0!==e&&(l=t===e.index?34963:34962);const c=this.processBufferView(t,a,n,r,l),h={bufferView:c.id,byteOffset:c.byteOffset,componentType:a,count:r,max:o.max,min:o.min,type:{1:"SCALAR",2:"VEC2",3:"VEC3",4:"VEC4",16:"MAT4"}[t.itemSize]};return!0===t.normalized&&(h.normalized=!0),s.accessors||(s.accessors=[]),s.accessors.push(h)-1}processImage(t,e,n){const r=this,i=r.cache,s=r.json,a=r.options,o=r.pending;i.images.has(t)||i.images.set(t,{});const l=i.images.get(t),c=e===Gt?"image/png":"image/jpeg",h=c+":flipY/"+n.toString();if(void 0!==l[h])return l[h];s.images||(s.images=[]);const u={mimeType:c};if(a.embedImages){const i=xg=xg||document.createElement("canvas");i.width=Math.min(t.width,a.maxTextureSize),i.height=Math.min(t.height,a.maxTextureSize);const s=i.getContext("2d");if(!0===n&&(s.translate(0,i.height),s.scale(1,-1)),"undefined"!=typeof HTMLImageElement&&t instanceof HTMLImageElement||"undefined"!=typeof HTMLCanvasElement&&t instanceof HTMLCanvasElement||"undefined"!=typeof OffscreenCanvas&&t instanceof OffscreenCanvas||"undefined"!=typeof ImageBitmap&&t instanceof ImageBitmap)s.drawImage(t,0,0,i.width,i.height);else{e!==Gt&&e!==Ht&&console.error("GLTFExporter: Only RGB and RGBA formats are supported."),(t.width>a.maxTextureSize||t.height>a.maxTextureSize)&&console.warn("GLTFExporter: Image size is bigger than maxTextureSize",t);const n=new Uint8ClampedArray(t.height*t.width*4);if(e===Gt)for(let e=0;e<n.length;e+=4)n[e+0]=t.data[e+0],n[e+1]=t.data[e+1],n[e+2]=t.data[e+2],n[e+3]=t.data[e+3];else for(let e=0,r=0;e<n.length;e+=4,r+=3)n[e+0]=t.data[r+0],n[e+1]=t.data[r+1],n[e+2]=t.data[r+2],n[e+3]=255;s.putImageData(new ImageData(n,t.width,t.height),0,0)}!0===a.binary?o.push(new Promise((function(t){i.toBlob((function(e){r.processBufferViewImage(e).then((function(e){u.bufferView=e,t()}))}),c)}))):u.uri=i.toDataURL(c)}else u.uri=t.src;const d=s.images.push(u)-1;return l[h]=d,d}processSampler(t){const e=this.json;e.samplers||(e.samplers=[]);const n={magFilter:pg[t.magFilter],minFilter:pg[t.minFilter],wrapS:pg[t.wrapS],wrapT:pg[t.wrapT]};return e.samplers.push(n)-1}processTexture(t){const e=this.cache,n=this.json;if(e.textures.has(t))return e.textures.get(t);n.textures||(n.textures=[]);const r={sampler:this.processSampler(t),source:this.processImage(t.image,t.format,t.flipY)};t.name&&(r.name=t.name),this._invokeAll((function(e){e.writeTexture&&e.writeTexture(t,r)}));const i=n.textures.push(r)-1;return e.textures.set(t,i),i}processMaterial(t){const e=this.cache,n=this.json;if(e.materials.has(t))return e.materials.get(t);if(t.isShaderMaterial)return console.warn("GLTFExporter: THREE.ShaderMaterial not supported."),null;n.materials||(n.materials=[]);const r={pbrMetallicRoughness:{}};!0!==t.isMeshStandardMaterial&&!0!==t.isMeshBasicMaterial&&console.warn("GLTFExporter: Use MeshStandardMaterial or MeshBasicMaterial for best results.");const i=t.color.toArray().concat([t.opacity]);if(mg(i,[1,1,1,1])||(r.pbrMetallicRoughness.baseColorFactor=i),t.isMeshStandardMaterial?(r.pbrMetallicRoughness.metallicFactor=t.metalness,r.pbrMetallicRoughness.roughnessFactor=t.roughness):(r.pbrMetallicRoughness.metallicFactor=.5,r.pbrMetallicRoughness.roughnessFactor=.5),t.metalnessMap||t.roughnessMap)if(t.metalnessMap===t.roughnessMap){const e={index:this.processTexture(t.metalnessMap)};this.applyTextureTransform(e,t.metalnessMap),r.pbrMetallicRoughness.metallicRoughnessTexture=e}else console.warn("THREE.GLTFExporter: Ignoring metalnessMap and roughnessMap because they are not the same Texture.");if(t.map){const e={index:this.processTexture(t.map)};this.applyTextureTransform(e,t.map),r.pbrMetallicRoughness.baseColorTexture=e}if(t.emissive){const e=t.emissive.clone().multiplyScalar(t.emissiveIntensity),n=Math.max(e.r,e.g,e.b);if(n>1&&(e.multiplyScalar(1/n),console.warn("THREE.GLTFExporter: Some emissive components exceed 1; emissive has been limited")),n>0&&(r.emissiveFactor=e.toArray()),t.emissiveMap){const e={index:this.processTexture(t.emissiveMap)};this.applyTextureTransform(e,t.emissiveMap),r.emissiveTexture=e}}if(t.normalMap){const e={index:this.processTexture(t.normalMap)};t.normalScale&&1!==t.normalScale.x&&(e.scale=t.normalScale.x),this.applyTextureTransform(e,t.normalMap),r.normalTexture=e}if(t.aoMap){const e={index:this.processTexture(t.aoMap),texCoord:1};1!==t.aoMapIntensity&&(e.strength=t.aoMapIntensity),this.applyTextureTransform(e,t.aoMap),r.occlusionTexture=e}t.transparent?r.alphaMode="BLEND":t.alphaTest>0&&(r.alphaMode="MASK",r.alphaCutoff=t.alphaTest),t.side===w&&(r.doubleSided=!0),""!==t.name&&(r.name=t.name),this.serializeUserData(t,r),this._invokeAll((function(e){e.writeMaterial&&e.writeMaterial(t,r)}));const s=n.materials.push(r)-1;return e.materials.set(t,s),s}processMesh(t){const e=this.cache,n=this.json,r=[t.geometry.uuid];if(Array.isArray(t.material))for(let e=0,n=t.material.length;e<n;e++)r.push(t.material[e].uuid);else r.push(t.material.uuid);const i=r.join(":");if(e.meshes.has(i))return e.meshes.get(i);const s=t.geometry;let a;if(a=t.isLineSegments?1:t.isLineLoop?2:t.isLine?3:t.isPoints?0:t.material.wireframe?1:4,!0!==s.isBufferGeometry)throw new Error("THREE.GLTFExporter: Geometry is not of type THREE.BufferGeometry.");const o={},l={},c=[],h=[],u={uv:"TEXCOORD_0",uv2:"TEXCOORD_1",color:"COLOR_0",skinWeight:"WEIGHTS_0",skinIndex:"JOINTS_0"},d=s.getAttribute("normal");void 0===d||this.isNormalizedNormalAttribute(d)||(console.warn("THREE.GLTFExporter: Creating normalized normal attribute from the non-normalized one."),s.setAttribute("normal",this.createNormalizedNormalAttribute(d)));let p=null;for(let t in s.attributes){if("morph"===t.substr(0,5))continue;const n=s.attributes[t];if(t=u[t]||t.toUpperCase(),/^(POSITION|NORMAL|TANGENT|TEXCOORD_\d+|COLOR_\d+|JOINTS_\d+|WEIGHTS_\d+)$/.test(t)||(t="_"+t),e.attributes.has(this.getUID(n))){l[t]=e.attributes.get(this.getUID(n));continue}p=null;const r=n.array;"JOINTS_0"!==t||r instanceof Uint16Array||r instanceof Uint8Array||(console.warn('GLTFExporter: Attribute "skinIndex" converted to type UNSIGNED_SHORT.'),p=new Ii(new Uint16Array(r),n.itemSize,n.normalized));const i=this.processAccessor(p||n,s);null!==i&&(l[t]=i,e.attributes.set(this.getUID(n),i))}if(void 0!==d&&s.setAttribute("normal",d),0===Object.keys(l).length)return null;if(void 0!==t.morphTargetInfluences&&t.morphTargetInfluences.length>0){const n=[],r=[],i={};if(void 0!==t.morphTargetDictionary)for(const e in t.morphTargetDictionary)i[t.morphTargetDictionary[e]]=e;for(let a=0;a<t.morphTargetInfluences.length;++a){const o={};let l=!1;for(const t in s.morphAttributes){if("position"!==t&&"normal"!==t){l||(console.warn("GLTFExporter: Only POSITION and NORMAL morph are supported."),l=!0);continue}const n=s.morphAttributes[t][a],r=t.toUpperCase(),i=s.attributes[t];if(e.attributes.has(this.getUID(n))){o[r]=e.attributes.get(this.getUID(n));continue}const c=n.clone();if(!s.morphTargetsRelative)for(let t=0,e=n.count;t<e;t++)c.setXYZ(t,n.getX(t)-i.getX(t),n.getY(t)-i.getY(t),n.getZ(t)-i.getZ(t));o[r]=this.processAccessor(c,s),e.attributes.set(this.getUID(i),o[r])}h.push(o),n.push(t.morphTargetInfluences[a]),void 0!==t.morphTargetDictionary&&r.push(i[a])}o.weights=n,r.length>0&&(o.extras={},o.extras.targetNames=r)}const f=Array.isArray(t.material);if(f&&0===s.groups.length)return null;const m=f?t.material:[t.material],g=f?s.groups:[{materialIndex:0,start:void 0,count:void 0}];for(let t=0,n=g.length;t<n;t++){const n={mode:a,attributes:l};if(this.serializeUserData(s,n),h.length>0&&(n.targets=h),null!==s.index){let r=this.getUID(s.index);void 0===g[t].start&&void 0===g[t].count||(r+=":"+g[t].start+":"+g[t].count),e.attributes.has(r)?n.indices=e.attributes.get(r):(n.indices=this.processAccessor(s.index,s,g[t].start,g[t].count),e.attributes.set(r,n.indices)),null===n.indices&&delete n.indices}const r=this.processMaterial(m[g[t].materialIndex]);null!==r&&(n.material=r),c.push(n)}o.primitives=c,n.meshes||(n.meshes=[]),this._invokeAll((function(e){e.writeMesh&&e.writeMesh(t,o)}));const v=n.meshes.push(o)-1;return e.meshes.set(i,v),v}processCamera(t){const e=this.json;e.cameras||(e.cameras=[]);const n=t.isOrthographicCamera,r={type:n?"orthographic":"perspective"};return n?r.orthographic={xmag:2*t.right,ymag:2*t.top,zfar:t.far<=0?.001:t.far,znear:t.near<0?0:t.near}:r.perspective={aspectRatio:t.aspect,yfov:Xn.degToRad(t.fov),zfar:t.far<=0?.001:t.far,znear:t.near<0?0:t.near},""!==t.name&&(r.name=t.type),e.cameras.push(r)-1}processAnimation(t,e){const n=this.json,r=this.nodeMap;n.animations||(n.animations=[]);const i=(t=hg.Utils.mergeMorphTargetTracks(t.clone(),e)).tracks,s=[],a=[];for(let t=0;t<i.length;++t){const n=i[t],o=Qd.parseTrackName(n.name);let l=Qd.findNode(e,o.nodeName);const c=fg[o.propertyName];if("bones"===o.objectName&&(l=!0===l.isSkinnedMesh?l.skeleton.getBoneByName(o.objectIndex):void 0),!l||!c)return console.warn('THREE.GLTFExporter: Could not export animation track "%s".',n.name),null;const h=1;let u,d=n.values.length/n.times.length;c===fg.morphTargetInfluences&&(d/=l.morphTargetInfluences.length),!0===n.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline?(u="CUBICSPLINE",d/=3):u=n.getInterpolation()===Ge?"STEP":"LINEAR",a.push({input:this.processAccessor(new Ii(n.times,h)),output:this.processAccessor(new Ii(n.values,d)),interpolation:u}),s.push({sampler:a.length-1,target:{node:r.get(l),path:c}})}return n.animations.push({name:t.name||"clip_"+n.animations.length,samplers:a,channels:s}),n.animations.length-1}processSkin(t){const e=this.json,n=this.nodeMap,r=e.nodes[n.get(t)],i=t.skeleton;if(void 0===i)return null;const s=t.skeleton.bones[0];if(void 0===s)return null;const a=[],o=new Float32Array(16*i.bones.length),l=new zr;for(let e=0;e<i.bones.length;++e)a.push(n.get(i.bones[e])),l.copy(i.boneInverses[e]),l.multiply(t.bindMatrix).toArray(o,16*e);return void 0===e.skins&&(e.skins=[]),e.skins.push({inverseBindMatrices:this.processAccessor(new Ii(o,16)),joints:a,skeleton:n.get(s)}),r.skin=e.skins.length-1}processNode(t){const e=this.json,n=this.options,r=this.nodeMap;e.nodes||(e.nodes=[]);const i={};if(n.trs){const e=t.quaternion.toArray(),n=t.position.toArray(),r=t.scale.toArray();mg(e,[0,0,0,1])||(i.rotation=e),mg(n,[0,0,0])||(i.translation=n),mg(r,[1,1,1])||(i.scale=r)}else t.matrixAutoUpdate&&t.updateMatrix(),!1===mg(t.matrix.elements,[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1])&&(i.matrix=t.matrix.elements);if(""!==t.name&&(i.name=String(t.name)),this.serializeUserData(t,i),t.isMesh||t.isLine||t.isPoints){const e=this.processMesh(t);null!==e&&(i.mesh=e)}else t.isCamera&&(i.camera=this.processCamera(t));if(t.isSkinnedMesh&&this.skins.push(t),t.children.length>0){const e=[];for(let r=0,i=t.children.length;r<i;r++){const i=t.children[r];if(i.visible||!1===n.onlyVisible){const t=this.processNode(i);null!==t&&e.push(t)}}e.length>0&&(i.children=e)}this._invokeAll((function(e){e.writeNode&&e.writeNode(t,i)}));const s=e.nodes.push(i)-1;return r.set(t,s),s}processScene(t){const e=this.json,n=this.options;e.scenes||(e.scenes=[],e.scene=0);const r={};""!==t.name&&(r.name=t.name),e.scenes.push(r);const i=[];for(let e=0,r=t.children.length;e<r;e++){const r=t.children[e];if(r.visible||!1===n.onlyVisible){const t=this.processNode(r);null!==t&&i.push(t)}}i.length>0&&(r.nodes=i),this.serializeUserData(t,r)}processObjects(t){const e=new Ll;e.name="AuxScene";for(let n=0;n<t.length;n++)e.children.push(t[n]);this.processScene(e)}processInput(t){const e=this.options;t=t instanceof Array?t:[t],this._invokeAll((function(e){e.beforeParse&&e.beforeParse(t)}));const n=[];for(let e=0;e<t.length;e++)t[e]instanceof Ll?this.processScene(t[e]):n.push(t[e]);n.length>0&&this.processObjects(n);for(let t=0;t<this.skins.length;++t)this.processSkin(this.skins[t]);for(let n=0;n<e.animations.length;++n)this.processAnimation(e.animations[n],t[0]);this._invokeAll((function(e){e.afterParse&&e.afterParse(t)}))}_invokeAll(t){for(let e=0,n=this.plugins.length;e<n;e++)t(this.plugins[e])}}class wg{constructor(t){this.writer=t,this.name="KHR_lights_punctual"}writeNode(t,e){if(!t.isLight)return;if(!t.isDirectionalLight&&!t.isPointLight&&!t.isSpotLight)return void console.warn("THREE.GLTFExporter: Only directional, point, and spot lights are supported.",t);const n=this.writer,r=n.json,i=n.extensionsUsed,s={};t.name&&(s.name=t.name),s.color=t.color.toArray(),s.intensity=t.intensity,t.isDirectionalLight?s.type="directional":t.isPointLight?(s.type="point",t.distance>0&&(s.range=t.distance)):t.isSpotLight&&(s.type="spot",t.distance>0&&(s.range=t.distance),s.spot={},s.spot.innerConeAngle=(t.penumbra-1)*t.angle*-1,s.spot.outerConeAngle=t.angle),void 0!==t.decay&&2!==t.decay&&console.warn("THREE.GLTFExporter: Light decay may be lost. glTF is physically-based, and expects light.decay=2."),!t.target||t.target.parent===t&&0===t.target.position.x&&0===t.target.position.y&&-1===t.target.position.z||console.warn("THREE.GLTFExporter: Light direction may be lost. For best results, make light.target a child of the light with position 0,0,-1."),i[this.name]||(r.extensions=r.extensions||{},r.extensions[this.name]={lights:[]},i[this.name]=!0);const a=r.extensions[this.name].lights;a.push(s),e.extensions=e.extensions||{},e.extensions[this.name]={light:a.length-1}}}class bg{constructor(t){this.writer=t,this.name="KHR_materials_unlit"}writeMaterial(t,e){if(!t.isMeshBasicMaterial)return;const n=this.writer.extensionsUsed;e.extensions=e.extensions||{},e.extensions[this.name]={},n[this.name]=!0,e.pbrMetallicRoughness.metallicFactor=0,e.pbrMetallicRoughness.roughnessFactor=.9}}class _g{constructor(t){this.writer=t,this.name="KHR_materials_pbrSpecularGlossiness"}writeMaterial(t,e){if(!t.isGLTFSpecularGlossinessMaterial)return;const n=this.writer,r=n.extensionsUsed,i={};e.pbrMetallicRoughness.baseColorFactor&&(i.diffuseFactor=e.pbrMetallicRoughness.baseColorFactor);const s=[1,1,1];if(t.specular.toArray(s,0),i.specularFactor=s,i.glossinessFactor=t.glossiness,e.pbrMetallicRoughness.baseColorTexture&&(i.diffuseTexture=e.pbrMetallicRoughness.baseColorTexture),t.specularMap){const e={index:n.processTexture(t.specularMap)};n.applyTextureTransform(e,t.specularMap),i.specularGlossinessTexture=e}e.extensions=e.extensions||{},e.extensions[this.name]=i,r[this.name]=!0}}class Mg{constructor(t){this.writer=t,this.name="KHR_materials_clearcoat"}writeMaterial(t,e){if(!t.isMeshPhysicalMaterial)return;const n=this.writer,r=n.extensionsUsed,i={};if(i.clearcoatFactor=t.clearcoat,t.clearcoatMap){const e={index:n.processTexture(t.clearcoatMap)};n.applyTextureTransform(e,t.clearcoatMap),i.clearcoatTexture=e}if(i.clearcoatRoughnessFactor=t.clearcoatRoughness,t.clearcoatRoughnessMap){const e={index:n.processTexture(t.clearcoatRoughnessMap)};n.applyTextureTransform(e,t.clearcoatRoughnessMap),i.clearcoatRoughnessTexture=e}if(t.clearcoatNormalMap){const e={index:n.processTexture(t.clearcoatNormalMap)};n.applyTextureTransform(e,t.clearcoatNormalMap),i.clearcoatNormalTexture=e}e.extensions=e.extensions||{},e.extensions[this.name]=i,r[this.name]=!0}}class Tg{constructor(t){this.writer=t,this.name="KHR_materials_transmission"}writeMaterial(t,e){if(!t.isMeshPhysicalMaterial||0===t.transmission)return;const n=this.writer,r=n.extensionsUsed,i={};if(i.transmissionFactor=t.transmission,t.transmissionMap){const e={index:n.processTexture(t.transmissionMap)};n.applyTextureTransform(e,t.transmissionMap),i.transmissionTexture=e}e.extensions=e.extensions||{},e.extensions[this.name]=i,r[this.name]=!0}}class Sg{constructor(t){this.writer=t,this.name="KHR_materials_volume"}writeMaterial(t,e){if(!t.isMeshPhysicalMaterial||0===t.transmission)return;const n=this.writer,r=n.extensionsUsed,i={};if(i.thicknessFactor=t.thickness,t.thicknessMap){const e={index:n.processTexture(t.thicknessMap)};n.applyTextureTransform(e,t.thicknessMap),i.thicknessTexture=e}i.attenuationDistance=t.attenuationDistance,i.attenuationColor=t.attenuationColor.toArray(),e.extensions=e.extensions||{},e.extensions[this.name]=i,r[this.name]=!0}}hg.Utils={insertKeyframe:function(t,e){const n=.001,r=t.getValueSize(),i=new t.TimeBufferType(t.times.length+1),s=new t.ValueBufferType(t.values.length+r),a=t.createInterpolant(new t.ValueBufferType(r));let o;if(0===t.times.length){i[0]=e;for(let t=0;t<r;t++)s[t]=0;o=0}else if(e<t.times[0]){if(Math.abs(t.times[0]-e)<n)return 0;i[0]=e,i.set(t.times,1),s.set(a.evaluate(e),0),s.set(t.values,r),o=0}else if(e>t.times[t.times.length-1]){if(Math.abs(t.times[t.times.length-1]-e)<n)return t.times.length-1;i[i.length-1]=e,i.set(t.times,0),s.set(t.values,0),s.set(a.evaluate(e),t.values.length),o=i.length-1}else for(let l=0;l<t.times.length;l++){if(Math.abs(t.times[l]-e)<n)return l;if(t.times[l]<e&&t.times[l+1]>e){i.set(t.times.slice(0,l+1),0),i[l+1]=e,i.set(t.times.slice(l+1),l+2),s.set(t.values.slice(0,(l+1)*r),0),s.set(a.evaluate(e),(l+1)*r),s.set(t.values.slice((l+1)*r),(l+2)*r),o=l+1;break}}return t.times=i,t.values=s,o},mergeMorphTargetTracks:function(t,e){const n=[],r={},i=t.tracks;for(let t=0;t<i.length;++t){let s=i[t];const a=Qd.parseTrackName(s.name),o=Qd.findNode(e,a.nodeName);if("morphTargetInfluences"!==a.propertyName||void 0===a.propertyIndex){n.push(s);continue}if(s.createInterpolant!==s.InterpolantFactoryMethodDiscrete&&s.createInterpolant!==s.InterpolantFactoryMethodLinear){if(s.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline)throw new Error("THREE.GLTFExporter: Cannot merge tracks with glTF CUBICSPLINE interpolation.");console.warn("THREE.GLTFExporter: Morph target interpolation mode not yet supported. Using LINEAR instead."),s=s.clone(),s.setInterpolation(Ve)}const l=o.morphTargetInfluences.length,c=o.morphTargetDictionary[a.propertyIndex];if(void 0===c)throw new Error("THREE.GLTFExporter: Morph target name not found: "+a.propertyIndex);let h;if(void 0===r[o.uuid]){h=s.clone();const t=new h.ValueBufferType(l*h.times.length);for(let e=0;e<h.times.length;e++)t[e*l+c]=h.values[e];h.name=(a.nodeName||"")+".morphTargetInfluences",h.values=t,r[o.uuid]=h,n.push(h);continue}const u=s.createInterpolant(new s.ValueBufferType(1));h=r[o.uuid];for(let t=0;t<h.times.length;t++)h.values[t*l+c]=u.evaluate(h.times[t]);for(let t=0;t<s.times.length;t++){const e=this.insertKeyframe(h,s.times[t]);h.values[e*l+c]=s.values[t]}}return t.tracks=n,t}};const Ag=new WeakMap;function Eg(){let t,e;function n(t,e,n,r,i,s){const a=s.num_components(),o=n.num_points()*a,l=o*i.BYTES_PER_ELEMENT,c=function(t,e){switch(e){case Float32Array:return t.DT_FLOAT32;case Int8Array:return t.DT_INT8;case Int16Array:return t.DT_INT16;case Int32Array:return t.DT_INT32;case Uint8Array:return t.DT_UINT8;case Uint16Array:return t.DT_UINT16;case Uint32Array:return t.DT_UINT32}}(t,i),h=t._malloc(l);e.GetAttributeDataArrayForAllPoints(n,s,c,l,h);const u=new i(t.HEAPF32.buffer,h,o).slice();return t._free(h),{name:r,array:u,itemSize:a}}onmessage=function(r){const i=r.data;switch(i.type){case"init":t=i.decoderConfig,e=new Promise((function(e){t.onModuleLoaded=function(t){e({draco:t})},DracoDecoderModule(t)}));break;case"decode":const r=i.buffer,s=i.taskConfig;e.then((t=>{const e=t.draco,a=new e.Decoder,o=new e.DecoderBuffer;o.Init(new Int8Array(r),r.byteLength);try{const t=function(t,e,r,i){const s=i.attributeIDs,a=i.attributeTypes;let o,l;const c=e.GetEncodedGeometryType(r);if(c===t.TRIANGULAR_MESH)o=new t.Mesh,l=e.DecodeBufferToMesh(r,o);else{if(c!==t.POINT_CLOUD)throw new Error("THREE.DRACOLoader: Unexpected geometry type.");o=new t.PointCloud,l=e.DecodeBufferToPointCloud(r,o)}if(!l.ok()||0===o.ptr)throw new Error("THREE.DRACOLoader: Decoding failed: "+l.error_msg());const h={index:null,attributes:[]};for(const r in s){const l=self[a[r]];let c,u;if(i.useUniqueIDs)u=s[r],c=e.GetAttributeByUniqueId(o,u);else{if(u=e.GetAttributeId(o,t[s[r]]),-1===u)continue;c=e.GetAttribute(o,u)}h.attributes.push(n(t,e,o,r,l,c))}return c===t.TRIANGULAR_MESH&&(h.index=function(t,e,n){const r=3*n.num_faces(),i=4*r,s=t._malloc(i);e.GetTrianglesUInt32Array(n,i,s);const a=new Uint32Array(t.HEAPF32.buffer,s,r).slice();return t._free(s),{array:a,itemSize:1}}(t,e,o)),t.destroy(o),h}(e,a,o,s),r=t.attributes.map((t=>t.array.buffer));t.index&&r.push(t.index.array.buffer),self.postMessage({type:"decode",id:i.id,geometry:t},r)}catch(t){console.error(t),self.postMessage({type:"error",id:i.id,error:t.message})}finally{e.destroy(o),e.destroy(a)}}))}}}var Cg={},Pg=function(t){return URL.createObjectURL(new Blob([t],{type:"text/javascript"}))},Lg=function(t){return new Worker(t)};try{URL.revokeObjectURL(Pg(""))}catch(t){Pg=function(t){return"data:application/javascript;charset=UTF-8,"+encodeURI(t)},Lg=function(t){return new Worker(t,{type:"module"})}}var Rg=Uint8Array,Fg=Uint16Array,Dg=Uint32Array,Ig=new Rg([0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,0,0,0]),Ug=new Rg([0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,0,0]),Ng=new Rg([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]),Og=function(t,e){for(var n=new Fg(31),r=0;r<31;++r)n[r]=e+=1<<t[r-1];var i=new Dg(n[30]);for(r=1;r<30;++r)for(var s=n[r];s<n[r+1];++s)i[s]=s-n[r]<<5|r;return[n,i]},Bg=Og(Ig,2),zg=Bg[0],kg=Bg[1];zg[28]=258,kg[258]=28;for(var Hg=Og(Ug,0),Gg=Hg[0],Vg=Hg[1],Wg=new Fg(32768),Xg=0;Xg<32768;++Xg){var jg=(43690&Xg)>>>1|(21845&Xg)<<1;jg=(61680&(jg=(52428&jg)>>>2|(13107&jg)<<2))>>>4|(3855&jg)<<4,Wg[Xg]=((65280&jg)>>>8|(255&jg)<<8)>>>1}var Yg=function(t,e,n){for(var r=t.length,i=0,s=new Fg(e);i<r;++i)++s[t[i]-1];var a,o=new Fg(e);for(i=0;i<e;++i)o[i]=o[i-1]+s[i-1]<<1;if(n){a=new Fg(1<<e);var l=15-e;for(i=0;i<r;++i)if(t[i])for(var c=i<<4|t[i],h=e-t[i],u=o[t[i]-1]++<<h,d=u|(1<<h)-1;u<=d;++u)a[Wg[u]>>>l]=c}else for(a=new Fg(r),i=0;i<r;++i)t[i]&&(a[i]=Wg[o[t[i]-1]++]>>>15-t[i]);return a},qg=new Rg(288);for(Xg=0;Xg<144;++Xg)qg[Xg]=8;for(Xg=144;Xg<256;++Xg)qg[Xg]=9;for(Xg=256;Xg<280;++Xg)qg[Xg]=7;for(Xg=280;Xg<288;++Xg)qg[Xg]=8;var Qg=new Rg(32);for(Xg=0;Xg<32;++Xg)Qg[Xg]=5;var Zg=Yg(qg,9,0),Jg=Yg(qg,9,1),Kg=Yg(Qg,5,0),$g=Yg(Qg,5,1),tv=function(t){for(var e=t[0],n=1;n<t.length;++n)t[n]>e&&(e=t[n]);return e},ev=function(t,e,n){var r=e/8|0;return(t[r]|t[r+1]<<8)>>(7&e)&n},nv=function(t,e){var n=e/8|0;return(t[n]|t[n+1]<<8|t[n+2]<<16)>>(7&e)},rv=function(t){return(t/8|0)+(7&t&&1)},iv=function(t,e,n){(null==e||e<0)&&(e=0),(null==n||n>t.length)&&(n=t.length);var r=new(t instanceof Fg?Fg:t instanceof Dg?Dg:Rg)(n-e);return r.set(t.subarray(e,n)),r},sv=function(t,e,n){var r=t.length;if(!r||n&&!n.l&&r<5)return e||new Rg(0);var i=!e||n,s=!n||n.i;n||(n={}),e||(e=new Rg(3*r));var a=function(t){var n=e.length;if(t>n){var r=new Rg(Math.max(2*n,t));r.set(e),e=r}},o=n.f||0,l=n.p||0,c=n.b||0,h=n.l,u=n.d,d=n.m,p=n.n,f=8*r;do{if(!h){n.f=o=ev(t,l,1);var m=ev(t,l+1,3);if(l+=3,!m){var g=t[(E=rv(l)+4)-4]|t[E-3]<<8,v=E+g;if(v>r){if(s)throw"unexpected EOF";break}i&&a(c+g),e.set(t.subarray(E,v),c),n.b=c+=g,n.p=l=8*v;continue}if(1==m)h=Jg,u=$g,d=9,p=5;else{if(2!=m)throw"invalid block type";var x=ev(t,l,31)+257,y=ev(t,l+10,15)+4,w=x+ev(t,l+5,31)+1;l+=14;for(var b=new Rg(w),_=new Rg(19),M=0;M<y;++M)_[Ng[M]]=ev(t,l+3*M,7);l+=3*y;var T=tv(_),S=(1<<T)-1,A=Yg(_,T,1);for(M=0;M<w;){var E,C=A[ev(t,l,S)];if(l+=15&C,(E=C>>>4)<16)b[M++]=E;else{var P=0,L=0;for(16==E?(L=3+ev(t,l,3),l+=2,P=b[M-1]):17==E?(L=3+ev(t,l,7),l+=3):18==E&&(L=11+ev(t,l,127),l+=7);L--;)b[M++]=P}}var R=b.subarray(0,x),F=b.subarray(x);d=tv(R),p=tv(F),h=Yg(R,d,1),u=Yg(F,p,1)}if(l>f){if(s)throw"unexpected EOF";break}}i&&a(c+131072);for(var D=(1<<d)-1,I=(1<<p)-1,U=l;;U=l){var N=(P=h[nv(t,l)&D])>>>4;if((l+=15&P)>f){if(s)throw"unexpected EOF";break}if(!P)throw"invalid length/literal";if(N<256)e[c++]=N;else{if(256==N){U=l,h=null;break}var O=N-254;if(N>264){var B=Ig[M=N-257];O=ev(t,l,(1<<B)-1)+zg[M],l+=B}var z=u[nv(t,l)&I],k=z>>>4;if(!z)throw"invalid distance";if(l+=15&z,F=Gg[k],k>3&&(B=Ug[k],F+=nv(t,l)&(1<<B)-1,l+=B),l>f){if(s)throw"unexpected EOF";break}i&&a(c+131072);for(var H=c+O;c<H;c+=4)e[c]=e[c-F],e[c+1]=e[c+1-F],e[c+2]=e[c+2-F],e[c+3]=e[c+3-F];c=H}}n.l=h,n.p=U,n.b=c,h&&(o=1,n.m=d,n.d=u,n.n=p)}while(!o);return c==e.length?e:iv(e,0,c)},av=function(t,e,n){n<<=7&e;var r=e/8|0;t[r]|=n,t[r+1]|=n>>>8},ov=function(t,e,n){n<<=7&e;var r=e/8|0;t[r]|=n,t[r+1]|=n>>>8,t[r+2]|=n>>>16},lv=function(t,e){for(var n=[],r=0;r<t.length;++r)t[r]&&n.push({s:r,f:t[r]});var i=n.length,s=n.slice();if(!i)return[mv,0];if(1==i){var a=new Rg(n[0].s+1);return a[n[0].s]=1,[a,1]}n.sort((function(t,e){return t.f-e.f})),n.push({s:-1,f:25001});var o=n[0],l=n[1],c=0,h=1,u=2;for(n[0]={s:-1,f:o.f+l.f,l:o,r:l};h!=i-1;)o=n[n[c].f<n[u].f?c++:u++],l=n[c!=h&&n[c].f<n[u].f?c++:u++],n[h++]={s:-1,f:o.f+l.f,l:o,r:l};var d=s[0].s;for(r=1;r<i;++r)s[r].s>d&&(d=s[r].s);var p=new Fg(d+1),f=cv(n[h-1],p,0);if(f>e){r=0;var m=0,g=f-e,v=1<<g;for(s.sort((function(t,e){return p[e.s]-p[t.s]||t.f-e.f}));r<i;++r){var x=s[r].s;if(!(p[x]>e))break;m+=v-(1<<f-p[x]),p[x]=e}for(m>>>=g;m>0;){var y=s[r].s;p[y]<e?m-=1<<e-p[y]++-1:++r}for(;r>=0&&m;--r){var w=s[r].s;p[w]==e&&(--p[w],++m)}f=e}return[new Rg(p),f]},cv=function(t,e,n){return-1==t.s?Math.max(cv(t.l,e,n+1),cv(t.r,e,n+1)):e[t.s]=n},hv=function(t){for(var e=t.length;e&&!t[--e];);for(var n=new Fg(++e),r=0,i=t[0],s=1,a=function(t){n[r++]=t},o=1;o<=e;++o)if(t[o]==i&&o!=e)++s;else{if(!i&&s>2){for(;s>138;s-=138)a(32754);s>2&&(a(s>10?s-11<<5|28690:s-3<<5|12305),s=0)}else if(s>3){for(a(i),--s;s>6;s-=6)a(8304);s>2&&(a(s-3<<5|8208),s=0)}for(;s--;)a(i);s=1,i=t[o]}return[n.subarray(0,r),e]},uv=function(t,e){for(var n=0,r=0;r<e.length;++r)n+=t[r]*e[r];return n},dv=function(t,e,n){var r=n.length,i=rv(e+2);t[i]=255&r,t[i+1]=r>>>8,t[i+2]=255^t[i],t[i+3]=255^t[i+1];for(var s=0;s<r;++s)t[i+s+4]=n[s];return 8*(i+4+r)},pv=function(t,e,n,r,i,s,a,o,l,c,h){av(e,h++,n),++i[256];for(var u=lv(i,15),d=u[0],p=u[1],f=lv(s,15),m=f[0],g=f[1],v=hv(d),x=v[0],y=v[1],w=hv(m),b=w[0],_=w[1],M=new Fg(19),T=0;T<x.length;++T)M[31&x[T]]++;for(T=0;T<b.length;++T)M[31&b[T]]++;for(var S=lv(M,7),A=S[0],E=S[1],C=19;C>4&&!A[Ng[C-1]];--C);var P,L,R,F,D=c+5<<3,I=uv(i,qg)+uv(s,Qg)+a,U=uv(i,d)+uv(s,m)+a+14+3*C+uv(M,A)+(2*M[16]+3*M[17]+7*M[18]);if(D<=I&&D<=U)return dv(e,h,t.subarray(l,l+c));if(av(e,h,1+(U<I)),h+=2,U<I){P=Yg(d,p,0),L=d,R=Yg(m,g,0),F=m;var N=Yg(A,E,0);for(av(e,h,y-257),av(e,h+5,_-1),av(e,h+10,C-4),h+=14,T=0;T<C;++T)av(e,h+3*T,A[Ng[T]]);h+=3*C;for(var O=[x,b],B=0;B<2;++B){var z=O[B];for(T=0;T<z.length;++T){var k=31&z[T];av(e,h,N[k]),h+=A[k],k>15&&(av(e,h,z[T]>>>5&127),h+=z[T]>>>12)}}}else P=Zg,L=qg,R=Kg,F=Qg;for(T=0;T<o;++T)if(r[T]>255){k=r[T]>>>18&31,ov(e,h,P[k+257]),h+=L[k+257],k>7&&(av(e,h,r[T]>>>23&31),h+=Ig[k]);var H=31&r[T];ov(e,h,R[H]),h+=F[H],H>3&&(ov(e,h,r[T]>>>5&8191),h+=Ug[H])}else ov(e,h,P[r[T]]),h+=L[r[T]];return ov(e,h,P[256]),h+L[256]},fv=new Dg([65540,131080,131088,131104,262176,1048704,1048832,2114560,2117632]),mv=new Rg(0),gv=function(t,e,n,r,i,s){var a=t.length,o=new Rg(r+a+5*(1+Math.ceil(a/7e3))+i),l=o.subarray(r,o.length-i),c=0;if(!e||a<8)for(var h=0;h<=a;h+=65535){var u=h+65535;u<a?c=dv(l,c,t.subarray(h,u)):(l[h]=s,c=dv(l,c,t.subarray(h,a)))}else{for(var d=fv[e-1],p=d>>>13,f=8191&d,m=(1<<n)-1,g=new Fg(32768),v=new Fg(m+1),x=Math.ceil(n/3),y=2*x,w=function(e){return(t[e]^t[e+1]<<x^t[e+2]<<y)&m},b=new Dg(25e3),_=new Fg(288),M=new Fg(32),T=0,S=0,A=(h=0,0),E=0,C=0;h<a;++h){var P=w(h),L=32767&h,R=v[P];if(g[L]=R,v[P]=L,E<=h){var F=a-h;if((T>7e3||A>24576)&&F>423){c=pv(t,l,0,b,_,M,S,A,C,h-C,c),A=T=S=0,C=h;for(var D=0;D<286;++D)_[D]=0;for(D=0;D<30;++D)M[D]=0}var I=2,U=0,N=f,O=L-R&32767;if(F>2&&P==w(h-O))for(var B=Math.min(p,F)-1,z=Math.min(32767,h),k=Math.min(258,F);O<=z&&--N&&L!=R;){if(t[h+I]==t[h+I-O]){for(var H=0;H<k&&t[h+H]==t[h+H-O];++H);if(H>I){if(I=H,U=O,H>B)break;var G=Math.min(O,H-2),V=0;for(D=0;D<G;++D){var W=h-O+D+32768&32767,X=W-g[W]+32768&32767;X>V&&(V=X,R=W)}}}O+=(L=R)-(R=g[L])+32768&32767}if(U){b[A++]=268435456|kg[I]<<18|Vg[U];var j=31&kg[I],Y=31&Vg[U];S+=Ig[j]+Ug[Y],++_[257+j],++M[Y],E=h+I,++T}else b[A++]=t[h],++_[t[h]]}}c=pv(t,l,s,b,_,M,S,A,C,h-C,c),!s&&7&c&&(c=dv(l,c+1,mv))}return iv(o,0,r+rv(c)+i)},vv=function(){for(var t=new Dg(256),e=0;e<256;++e){for(var n=e,r=9;--r;)n=(1&n&&3988292384)^n>>>1;t[e]=n}return t}(),xv=function(){var t=-1;return{p:function(e){for(var n=t,r=0;r<e.length;++r)n=vv[255&n^e[r]]^n>>>8;t=n},d:function(){return~t}}},yv=function(){var t=1,e=0;return{p:function(n){for(var r=t,i=e,s=n.length,a=0;a!=s;){for(var o=Math.min(a+2655,s);a<o;++a)i+=r+=n[a];r=(65535&r)+15*(r>>16),i=(65535&i)+15*(i>>16)}t=r,e=i},d:function(){return(255&(t%=65521))<<24|t>>>8<<16|(255&(e%=65521))<<8|e>>>8}}},wv=function(t,e,n,r,i){return gv(t,null==e.level?6:e.level,null==e.mem?Math.ceil(1.5*Math.max(8,Math.min(13,Math.log(t.length)))):12+e.mem,n,r,!i)},bv=function(t,e){var n={};for(var r in t)n[r]=t[r];for(var r in e)n[r]=e[r];return n},_v=function(t,e,n){for(var r=t(),i=t.toString(),s=i.slice(i.indexOf("[")+1,i.lastIndexOf("]")).replace(/ /g,"").split(","),a=0;a<r.length;++a){var o=r[a],l=s[a];if("function"==typeof o){e+=";"+l+"=";var c=o.toString();if(o.prototype)if(-1!=c.indexOf("[native code]")){var h=c.indexOf(" ",8)+1;e+=c.slice(h,c.indexOf("(",h))}else for(var u in e+=c,o.prototype)e+=";"+l+".prototype."+u+"="+o.prototype[u].toString();else e+=c}else n[l]=o}return[e,n]},Mv=[],Tv=function(t,e,n,r){var i;if(!Mv[n]){for(var s="",a={},o=t.length-1,l=0;l<o;++l)s=(i=_v(t[l],s,a))[0],a=i[1];Mv[n]=_v(t[o],s,a)}var c=bv({},Mv[n][1]);return function(t,e,n,r,i){var s=Lg(Cg[e]||(Cg[e]=Pg(t)));return s.onerror=function(t){return i(t.error,null)},s.onmessage=function(t){return i(null,t.data)},s.postMessage(n,r),s}(Mv[n][0]+";onmessage=function(e){for(var k in e.data)self[k]=e.data[k];onmessage="+e.toString()+"}",n,c,function(t){var e=[];for(var n in t)(t[n]instanceof Rg||t[n]instanceof Fg||t[n]instanceof Dg)&&e.push((t[n]=new t[n].constructor(t[n])).buffer);return e}(c),r)},Sv=function(){return[Rg,Fg,Dg,Ig,Ug,Ng,zg,Gg,Jg,$g,Wg,Yg,tv,ev,nv,rv,iv,sv,tx,Rv,Fv]},Av=function(){return[Rg,Fg,Dg,Ig,Ug,Ng,kg,Vg,Zg,qg,Kg,Qg,Wg,fv,mv,Yg,av,ov,lv,cv,hv,uv,dv,pv,rv,iv,gv,wv,Zv,Rv]},Ev=function(){return[kv,Vv,zv,xv,vv]},Cv=function(){return[Hv,Gv]},Pv=function(){return[Wv,zv,yv]},Lv=function(){return[Xv]},Rv=function(t){return postMessage(t,[t.buffer])},Fv=function(t){return t&&t.size&&new Rg(t.size)},Dv=function(t,e,n,r,i,s){var a=Tv(n,r,i,(function(t,e){a.terminate(),s(t,e)}));return a.postMessage([t,e],e.consume?[t.buffer]:[]),function(){a.terminate()}},Iv=function(t){return t.ondata=function(t,e){return postMessage([t,e],[t.buffer])},function(e){return t.push(e.data[0],e.data[1])}},Uv=function(t,e,n,r,i){var s,a=Tv(t,r,i,(function(t,n){t?(a.terminate(),e.ondata.call(e,t)):(n[1]&&a.terminate(),e.ondata.call(e,t,n[0],n[1]))}));a.postMessage(n),e.push=function(t,n){if(s)throw"stream finished";if(!e.ondata)throw"no stream handler";a.postMessage([t,s=n],[t.buffer])},e.terminate=function(){a.terminate()}},Nv=function(t,e){return t[e]|t[e+1]<<8},Ov=function(t,e){return(t[e]|t[e+1]<<8|t[e+2]<<16|t[e+3]<<24)>>>0},Bv=function(t,e){return Ov(t,e)+4294967296*Ov(t,e+4)},zv=function(t,e,n){for(;n;++e)t[e]=n,n>>>=8},kv=function(t,e){var n=e.filename;if(t[0]=31,t[1]=139,t[2]=8,t[8]=e.level<2?4:9==e.level?2:0,t[9]=3,0!=e.mtime&&zv(t,4,Math.floor(new Date(e.mtime||Date.now())/1e3)),n){t[3]=8;for(var r=0;r<=n.length;++r)t[r+10]=n.charCodeAt(r)}},Hv=function(t){if(31!=t[0]||139!=t[1]||8!=t[2])throw"invalid gzip data";var e=t[3],n=10;4&e&&(n+=t[10]|2+(t[11]<<8));for(var r=(e>>3&1)+(e>>4&1);r>0;r-=!t[n++]);return n+(2&e)},Gv=function(t){var e=t.length;return(t[e-4]|t[e-3]<<8|t[e-2]<<16|t[e-1]<<24)>>>0},Vv=function(t){return 10+(t.filename&&t.filename.length+1||0)},Wv=function(t,e){var n=e.level,r=0==n?0:n<6?1:9==n?3:2;t[0]=120,t[1]=r<<6|(r?32-2*r:1)},Xv=function(t){if(8!=(15&t[0])||t[0]>>>4>7||(t[0]<<8|t[1])%31)throw"invalid zlib data";if(32&t[1])throw"invalid zlib data: preset dictionaries not supported"};function jv(t,e){return e||"function"!=typeof t||(e=t,t={}),this.ondata=e,t}var Yv=function(){function t(t,e){e||"function"!=typeof t||(e=t,t={}),this.ondata=e,this.o=t||{}}return t.prototype.p=function(t,e){this.ondata(wv(t,this.o,0,0,!e),e)},t.prototype.push=function(t,e){if(this.d)throw"stream finished";if(!this.ondata)throw"no stream handler";this.d=e,this.p(t,e||!1)},t}(),qv=function(){return function(t,e){Uv([Av,function(){return[Iv,Yv]}],this,jv.call(this,t,e),(function(t){var e=new Yv(t.data);onmessage=Iv(e)}),6)}}();function Qv(t,e,n){if(n||(n=e,e={}),"function"!=typeof n)throw"no callback";return Dv(t,e,[Av],(function(t){return Rv(Zv(t.data[0],t.data[1]))}),0,n)}function Zv(t,e){return wv(t,e||{},0,0)}var Jv=function(){function t(t){this.s={},this.p=new Rg(0),this.ondata=t}return t.prototype.e=function(t){if(this.d)throw"stream finished";if(!this.ondata)throw"no stream handler";var e=this.p.length,n=new Rg(e+t.length);n.set(this.p),n.set(t,e),this.p=n},t.prototype.c=function(t){this.d=this.s.i=t||!1;var e=this.s.b,n=sv(this.p,this.o,this.s);this.ondata(iv(n,e,this.s.b),this.d),this.o=iv(n,this.s.b-32768),this.s.b=this.o.length,this.p=iv(this.p,this.s.p/8|0),this.s.p&=7},t.prototype.push=function(t,e){this.e(t),this.c(e)},t}(),Kv=function(){return function(t){this.ondata=t,Uv([Sv,function(){return[Iv,Jv]}],this,0,(function(){var t=new Jv;onmessage=Iv(t)}),7)}}();function $v(t,e,n){if(n||(n=e,e={}),"function"!=typeof n)throw"no callback";return Dv(t,e,[Sv],(function(t){return Rv(tx(t.data[0],Fv(t.data[1])))}),1,n)}function tx(t,e){return sv(t,e)}var ex=function(){function t(t,e){this.c=xv(),this.l=0,this.v=1,Yv.call(this,t,e)}return t.prototype.push=function(t,e){Yv.prototype.push.call(this,t,e)},t.prototype.p=function(t,e){this.c.p(t),this.l+=t.length;var n=wv(t,this.o,this.v&&Vv(this.o),e&&8,!e);this.v&&(kv(n,this.o),this.v=0),e&&(zv(n,n.length-8,this.c.d()),zv(n,n.length-4,this.l)),this.ondata(n,e)},t}(),nx=function(){return function(t,e){Uv([Av,Ev,function(){return[Iv,Yv,ex]}],this,jv.call(this,t,e),(function(t){var e=new ex(t.data);onmessage=Iv(e)}),8)}}();function rx(t,e,n){if(n||(n=e,e={}),"function"!=typeof n)throw"no callback";return Dv(t,e,[Av,Ev,function(){return[ix]}],(function(t){return Rv(ix(t.data[0],t.data[1]))}),2,n)}function ix(t,e){e||(e={});var n=xv(),r=t.length;n.p(t);var i=wv(t,e,Vv(e),8),s=i.length;return kv(i,e),zv(i,s-8,n.d()),zv(i,s-4,r),i}var sx=function(){function t(t){this.v=1,Jv.call(this,t)}return t.prototype.push=function(t,e){if(Jv.prototype.e.call(this,t),this.v){var n=this.p.length>3?Hv(this.p):4;if(n>=this.p.length&&!e)return;this.p=this.p.subarray(n),this.v=0}if(e){if(this.p.length<8)throw"invalid gzip stream";this.p=this.p.subarray(0,-8)}Jv.prototype.c.call(this,e)},t}(),ax=function(){return function(t){this.ondata=t,Uv([Sv,Cv,function(){return[Iv,Jv,sx]}],this,0,(function(){var t=new sx;onmessage=Iv(t)}),9)}}();function ox(t,e,n){if(n||(n=e,e={}),"function"!=typeof n)throw"no callback";return Dv(t,e,[Sv,Cv,function(){return[lx]}],(function(t){return Rv(lx(t.data[0]))}),3,n)}function lx(t,e){return sv(t.subarray(Hv(t),-8),e||new Rg(Gv(t)))}var cx=function(){function t(t,e){this.c=yv(),this.v=1,Yv.call(this,t,e)}return t.prototype.push=function(t,e){Yv.prototype.push.call(this,t,e)},t.prototype.p=function(t,e){this.c.p(t);var n=wv(t,this.o,this.v&&2,e&&4,!e);this.v&&(Wv(n,this.o),this.v=0),e&&zv(n,n.length-4,this.c.d()),this.ondata(n,e)},t}(),hx=function(){return function(t,e){Uv([Av,Pv,function(){return[Iv,Yv,cx]}],this,jv.call(this,t,e),(function(t){var e=new cx(t.data);onmessage=Iv(e)}),10)}}();function ux(t,e,n){if(n||(n=e,e={}),"function"!=typeof n)throw"no callback";return Dv(t,e,[Av,Pv,function(){return[dx]}],(function(t){return Rv(dx(t.data[0],t.data[1]))}),4,n)}function dx(t,e){e||(e={});var n=yv();n.p(t);var r=wv(t,e,2,4);return Wv(r,e),zv(r,r.length-4,n.d()),r}var px=function(){function t(t){this.v=1,Jv.call(this,t)}return t.prototype.push=function(t,e){if(Jv.prototype.e.call(this,t),this.v){if(this.p.length<2&&!e)return;this.p=this.p.subarray(2),this.v=0}if(e){if(this.p.length<4)throw"invalid zlib stream";this.p=this.p.subarray(0,-4)}Jv.prototype.c.call(this,e)},t}(),fx=function(){return function(t){this.ondata=t,Uv([Sv,Lv,function(){return[Iv,Jv,px]}],this,0,(function(){var t=new px;onmessage=Iv(t)}),11)}}();function mx(t,e,n){if(n||(n=e,e={}),"function"!=typeof n)throw"no callback";return Dv(t,e,[Sv,Lv,function(){return[gx]}],(function(t){return Rv(gx(t.data[0],Fv(t.data[1])))}),5,n)}function gx(t,e){return sv((Xv(t),t.subarray(2,-4)),e)}var vx=function(){function t(t){this.G=sx,this.I=Jv,this.Z=px,this.ondata=t}return t.prototype.push=function(t,e){if(!this.ondata)throw"no stream handler";if(this.s)this.s.push(t,e);else{if(this.p&&this.p.length){var n=new Rg(this.p.length+t.length);n.set(this.p),n.set(t,this.p.length)}else this.p=t;if(this.p.length>2){var r=this,i=function(){r.ondata.apply(r,arguments)};this.s=31==this.p[0]&&139==this.p[1]&&8==this.p[2]?new this.G(i):8!=(15&this.p[0])||this.p[0]>>4>7||(this.p[0]<<8|this.p[1])%31?new this.I(i):new this.Z(i),this.s.push(this.p,e),this.p=null}}},t}(),xx=function(){function t(t){this.G=ax,this.I=Kv,this.Z=fx,this.ondata=t}return t.prototype.push=function(t,e){vx.prototype.push.call(this,t,e)},t}();function yx(t,e,n){if(n||(n=e,e={}),"function"!=typeof n)throw"no callback";return 31==t[0]&&139==t[1]&&8==t[2]?ox(t,e,n):8!=(15&t[0])||t[0]>>4>7||(t[0]<<8|t[1])%31?$v(t,e,n):mx(t,e,n)}function wx(t,e){return 31==t[0]&&139==t[1]&&8==t[2]?lx(t,e):8!=(15&t[0])||t[0]>>4>7||(t[0]<<8|t[1])%31?tx(t,e):gx(t,e)}var bx=function(t,e,n,r){for(var i in t){var s=t[i],a=e+i;s instanceof Rg?n[a]=[s,r]:Array.isArray(s)?n[a]=[s[0],bv(r,s[1])]:bx(s,a+"/",n,r)}},_x="undefined"!=typeof TextEncoder&&new TextEncoder,Mx="undefined"!=typeof TextDecoder&&new TextDecoder,Tx=0;try{Mx.decode(mv,{stream:!0}),Tx=1}catch(t){}var Sx=function(t){for(var e="",n=0;;){var r=t[n++],i=(r>127)+(r>223)+(r>239);if(n+i>t.length)return[e,iv(t,n-1)];i?3==i?(r=((15&r)<<18|(63&t[n++])<<12|(63&t[n++])<<6|63&t[n++])-65536,e+=String.fromCharCode(55296|r>>10,56320|1023&r)):e+=1&i?String.fromCharCode((31&r)<<6|63&t[n++]):String.fromCharCode((15&r)<<12|(63&t[n++])<<6|63&t[n++]):e+=String.fromCharCode(r)}},Ax=function(){function t(t){this.ondata=t,Tx?this.t=new TextDecoder:this.p=mv}return t.prototype.push=function(t,e){if(!this.ondata)throw"no callback";if(e=!!e,this.t){if(this.ondata(this.t.decode(t,{stream:!0}),e),e){if(this.t.decode().length)throw"invalid utf-8 data";this.t=null}}else{if(!this.p)throw"stream finished";var n=new Rg(this.p.length+t.length);n.set(this.p),n.set(t,this.p.length);var r=Sx(n),i=r[0],s=r[1];if(e){if(s.length)throw"invalid utf-8 data";this.p=null}else this.p=s;this.ondata(i,e)}},t}(),Ex=function(){function t(t){this.ondata=t}return t.prototype.push=function(t,e){if(!this.ondata)throw"no callback";if(this.d)throw"stream finished";this.ondata(Cx(t),this.d=e||!1)},t}();function Cx(t,e){if(e){for(var n=new Rg(t.length),r=0;r<t.length;++r)n[r]=t.charCodeAt(r);return n}if(_x)return _x.encode(t);var i=t.length,s=new Rg(t.length+(t.length>>1)),a=0,o=function(t){s[a++]=t};for(r=0;r<i;++r){if(a+5>s.length){var l=new Rg(a+8+(i-r<<1));l.set(s),s=l}var c=t.charCodeAt(r);c<128||e?o(c):c<2048?(o(192|c>>6),o(128|63&c)):c>55295&&c<57344?(o(240|(c=65536+(1047552&c)|1023&t.charCodeAt(++r))>>18),o(128|c>>12&63),o(128|c>>6&63),o(128|63&c)):(o(224|c>>12),o(128|c>>6&63),o(128|63&c))}return iv(s,0,a)}function Px(t,e){if(e){for(var n="",r=0;r<t.length;r+=16384)n+=String.fromCharCode.apply(null,t.subarray(r,r+16384));return n}if(Mx)return Mx.decode(t);var i=Sx(t),s=i[0];if(i[1].length)throw"invalid utf-8 data";return s}var Lx=function(t){return 1==t?3:t<6?2:9==t?1:0},Rx=function(t,e){return e+30+Nv(t,e+26)+Nv(t,e+28)},Fx=function(t,e,n){var r=Nv(t,e+28),i=Px(t.subarray(e+46,e+46+r),!(2048&Nv(t,e+8))),s=e+46+r,a=Ov(t,e+20),o=n&&4294967295==a?Dx(t,s):[a,Ov(t,e+24),Ov(t,e+42)],l=o[0],c=o[1],h=o[2];return[Nv(t,e+10),l,c,i,s+Nv(t,e+30)+Nv(t,e+32),h]},Dx=function(t,e){for(;1!=Nv(t,e);e+=4+Nv(t,e+2));return[Bv(t,e+12),Bv(t,e+4),Bv(t,e+20)]},Ix=function(t){var e=0;if(t)for(var n in t){var r=t[n].length;if(r>65535)throw"extra field too long";e+=r+4}return e},Ux=function(t,e,n,r,i,s,a,o){var l=r.length,c=n.extra,h=o&&o.length,u=Ix(c);zv(t,e,null!=a?33639248:67324752),e+=4,null!=a&&(t[e++]=20,t[e++]=n.os),t[e]=20,e+=2,t[e++]=n.flag<<1|(null==s&&8),t[e++]=i&&8,t[e++]=255&n.compression,t[e++]=n.compression>>8;var d=new Date(null==n.mtime?Date.now():n.mtime),p=d.getFullYear()-1980;if(p<0||p>119)throw"date not in range 1980-2099";if(zv(t,e,p<<25|d.getMonth()+1<<21|d.getDate()<<16|d.getHours()<<11|d.getMinutes()<<5|d.getSeconds()>>>1),e+=4,null!=s&&(zv(t,e,n.crc),zv(t,e+4,s),zv(t,e+8,n.size)),zv(t,e+12,l),zv(t,e+14,u),e+=16,null!=a&&(zv(t,e,h),zv(t,e+6,n.attrs),zv(t,e+10,a),e+=14),t.set(r,e),e+=l,u)for(var f in c){var m=c[f],g=m.length;zv(t,e,+f),zv(t,e+2,g),t.set(m,e+4),e+=4+g}return h&&(t.set(o,e),e+=h),e},Nx=function(t,e,n,r,i){zv(t,e,101010256),zv(t,e+8,n),zv(t,e+10,n),zv(t,e+12,r),zv(t,e+16,i)},Ox=function(){function t(t){this.filename=t,this.c=xv(),this.size=0,this.compression=0}return t.prototype.process=function(t,e){this.ondata(null,t,e)},t.prototype.push=function(t,e){if(!this.ondata)throw"no callback - add to ZIP archive before pushing";this.c.p(t),this.size+=t.length,e&&(this.crc=this.c.d()),this.process(t,e||!1)},t}(),Bx=function(){function t(t,e){var n=this;e||(e={}),Ox.call(this,t),this.d=new Yv(e,(function(t,e){n.ondata(null,t,e)})),this.compression=8,this.flag=Lx(e.level)}return t.prototype.process=function(t,e){try{this.d.push(t,e)}catch(t){this.ondata(t,null,e)}},t.prototype.push=function(t,e){Ox.prototype.push.call(this,t,e)},t}(),zx=function(){function t(t,e){var n=this;e||(e={}),Ox.call(this,t),this.d=new qv(e,(function(t,e,r){n.ondata(t,e,r)})),this.compression=8,this.flag=Lx(e.level),this.terminate=this.d.terminate}return t.prototype.process=function(t,e){this.d.push(t,e)},t.prototype.push=function(t,e){Ox.prototype.push.call(this,t,e)},t}(),kx=function(){function t(t){this.ondata=t,this.u=[],this.d=1}return t.prototype.add=function(t){var e=this;if(2&this.d)throw"stream finished";var n=Cx(t.filename),r=n.length,i=t.comment,s=i&&Cx(i),a=r!=t.filename.length||s&&i.length!=s.length,o=r+Ix(t.extra)+30;if(r>65535)throw"filename too long";var l=new Rg(o);Ux(l,0,t,n,a);var c=[l],h=function(){for(var t=0,n=c;t<n.length;t++){var r=n[t];e.ondata(null,r,!1)}c=[]},u=this.d;this.d=0;var d=this.u.length,p=bv(t,{f:n,u:a,o:s,t:function(){t.terminate&&t.terminate()},r:function(){if(h(),u){var t=e.u[d+1];t?t.r():e.d=1}u=1}}),f=0;t.ondata=function(n,r,i){if(n)e.ondata(n,r,i),e.terminate();else if(f+=r.length,c.push(r),i){var s=new Rg(16);zv(s,0,134695760),zv(s,4,t.crc),zv(s,8,f),zv(s,12,t.size),c.push(s),p.c=f,p.b=o+f+16,p.crc=t.crc,p.size=t.size,u&&p.r(),u=1}else u&&h()},this.u.push(p)},t.prototype.end=function(){var t=this;if(2&this.d){if(1&this.d)throw"stream finishing";throw"stream finished"}this.d?this.e():this.u.push({r:function(){1&t.d&&(t.u.splice(-1,1),t.e())},t:function(){}}),this.d=3},t.prototype.e=function(){for(var t=0,e=0,n=0,r=0,i=this.u;r<i.length;r++)n+=46+(l=i[r]).f.length+Ix(l.extra)+(l.o?l.o.length:0);for(var s=new Rg(n+22),a=0,o=this.u;a<o.length;a++){var l=o[a];Ux(s,t,l,l.f,l.u,l.c,e,l.o),t+=46+l.f.length+Ix(l.extra)+(l.o?l.o.length:0),e+=l.b}Nx(s,t,this.u.length,n,e),this.ondata(null,s,!0),this.d=2},t.prototype.terminate=function(){for(var t=0,e=this.u;t<e.length;t++)e[t].t();this.d=2},t}();function Hx(t,e,n){if(n||(n=e,e={}),"function"!=typeof n)throw"no callback";var r={};bx(t,"",r,e);var i=Object.keys(r),s=i.length,a=0,o=0,l=s,c=new Array(s),h=[],u=function(){for(var t=0;t<h.length;++t)h[t]()},d=function(){var t=new Rg(o+22),e=a,r=o-a;o=0;for(var i=0;i<l;++i){var s=c[i];try{var h=s.c.length;Ux(t,o,s,s.f,s.u,h);var u=30+s.f.length+Ix(s.extra),d=o+u;t.set(s.c,d),Ux(t,a,s,s.f,s.u,h,o,s.m),a+=16+u+(s.m?s.m.length:0),o=d+h}catch(t){return n(t,null)}}Nx(t,a,c.length,r,e),n(null,t)};s||d();for(var p=function(t){var e=i[t],l=r[e],p=l[0],f=l[1],m=xv(),g=p.length;m.p(p);var v=Cx(e),x=v.length,y=f.comment,w=y&&Cx(y),b=w&&w.length,_=Ix(f.extra),M=0==f.level?0:8,T=function(r,i){if(r)u(),n(r,null);else{var l=i.length;c[t]=bv(f,{size:g,crc:m.d(),c:i,f:v,m:w,u:x!=e.length||w&&y.length!=b,compression:M}),a+=30+x+_+l,o+=76+2*(x+_)+(b||0)+l,--s||d()}};if(x>65535&&T("filename too long",null),M)if(g<16e4)try{T(null,Zv(p,f))}catch(t){T(t,null)}else h.push(Qv(p,f,T));else T(null,p)},f=0;f<l;++f)p(f);return u}function Gx(t,e){e||(e={});var n={},r=[];bx(t,"",n,e);var i=0,s=0;for(var a in n){var o=n[a],l=o[0],c=o[1],h=0==c.level?0:8,u=(M=Cx(a)).length,d=c.comment,p=d&&Cx(d),f=p&&p.length,m=Ix(c.extra);if(u>65535)throw"filename too long";var g=h?Zv(l,c):l,v=g.length,x=xv();x.p(l),r.push(bv(c,{size:l.length,crc:x.d(),c:g,f:M,m:p,u:u!=a.length||p&&d.length!=f,o:i,compression:h})),i+=30+u+m+v,s+=76+2*(u+m)+(f||0)+v}for(var y=new Rg(s+22),w=i,b=s-i,_=0;_<r.length;++_){var M=r[_];Ux(y,M.o,M,M.f,M.u,M.c.length);var T=30+M.f.length+Ix(M.extra);y.set(M.c,M.o+T),Ux(y,i,M,M.f,M.u,M.c.length,M.o,M.m),i+=16+T+(M.m?M.m.length:0)}return Nx(y,i,r.length,b,w),y}var Vx=function(){function t(){}return t.prototype.push=function(t,e){this.ondata(null,t,e)},t.compression=0,t}(),Wx=function(){function t(){var t=this;this.i=new Jv((function(e,n){t.ondata(null,e,n)}))}return t.prototype.push=function(t,e){try{this.i.push(t,e)}catch(n){this.ondata(n,t,e)}},t.compression=8,t}(),Xx=function(){function t(t,e){var n=this;e<32e4?this.i=new Jv((function(t,e){n.ondata(null,t,e)})):(this.i=new Kv((function(t,e,r){n.ondata(t,e,r)})),this.terminate=this.i.terminate)}return t.prototype.push=function(t,e){this.i.terminate&&(t=iv(t,0)),this.i.push(t,e)},t.compression=8,t}(),jx=function(){function t(t){this.onfile=t,this.k=[],this.o={0:Vx},this.p=mv}return t.prototype.push=function(t,e){var n=this;if(!this.onfile)throw"no callback";if(!this.p)throw"stream finished";if(this.c>0){var r=Math.min(this.c,t.length),i=t.subarray(0,r);if(this.c-=r,this.d?this.d.push(i,!this.c):this.k[0].push(i),(t=t.subarray(r)).length)return this.push(t,e)}else{var s=0,a=0,o=void 0,l=void 0;this.p.length?t.length?((l=new Rg(this.p.length+t.length)).set(this.p),l.set(t,this.p.length)):l=this.p:l=t;for(var c=l.length,h=this.c,u=h&&this.d,d=function(){var t,e=Ov(l,a);if(67324752==e){s=1,o=a,p.d=null,p.c=0;var r=Nv(l,a+6),i=Nv(l,a+8),u=2048&r,d=8&r,f=Nv(l,a+26),m=Nv(l,a+28);if(c>a+30+f+m){var g=[];p.k.unshift(g),s=2;var v,x=Ov(l,a+18),y=Ov(l,a+22),w=Px(l.subarray(a+30,a+=30+f),!u);4294967295==x?(t=d?[-2]:Dx(l,a),x=t[0],y=t[1]):d&&(x=-1),a+=m,p.c=x;var b={name:w,compression:i,start:function(){if(!b.ondata)throw"no callback";if(x){var t=n.o[i];if(!t)throw"unknown compression type "+i;(v=x<0?new t(w):new t(w,x,y)).ondata=function(t,e,n){b.ondata(t,e,n)};for(var e=0,r=g;e<r.length;e++){var s=r[e];v.push(s,!1)}n.k[0]==g&&n.c?n.d=v:v.push(mv,!0)}else b.ondata(null,mv,!0)},terminate:function(){v&&v.terminate&&v.terminate()}};x>=0&&(b.size=x,b.originalSize=y),p.onfile(b)}return"break"}if(h){if(134695760==e)return o=a+=12+(-2==h&&8),s=3,p.c=0,"break";if(33639248==e)return o=a-=4,s=3,p.c=0,"break"}},p=this;a<c-4&&"break"!==d();++a);if(this.p=mv,h<0){var f=s?l.subarray(0,o-12-(-2==h&&8)-(134695760==Ov(l,o-16)&&4)):l.subarray(0,a);u?u.push(f,!!s):this.k[+(2==s)].push(f)}if(2&s)return this.push(l.subarray(a),e);this.p=l.subarray(a)}if(e){if(this.c)throw"invalid zip file";this.p=null}},t.prototype.register=function(t){this.o[t.compression]=t},t}();function Yx(t,e){if("function"!=typeof e)throw"no callback";for(var n=[],r=function(){for(var t=0;t<n.length;++t)n[t]()},i={},s=t.length-22;101010256!=Ov(t,s);--s)if(!s||t.length-s>65558)return void e("invalid zip file",null);var a=Nv(t,s+8);a||e(null,{});var o=a,l=Ov(t,s+16),c=4294967295==l;if(c){if(s=Ov(t,s-12),101075792!=Ov(t,s))return void e("invalid zip file",null);o=a=Ov(t,s+32),l=Ov(t,s+48)}for(var h=function(s){var o=Fx(t,l,c),h=o[0],u=o[1],d=o[2],p=o[3],f=o[4],m=o[5],g=Rx(t,m);l=f;var v=function(t,n){t?(r(),e(t,null)):(i[p]=n,--a||e(null,i))};if(h)if(8==h){var x=t.subarray(g,g+u);if(u<32e4)try{v(null,tx(x,new Rg(d)))}catch(t){v(t,null)}else n.push($v(x,{size:d},v))}else v("unknown compression type "+h,null);else v(null,iv(t,g,g+u))},u=0;u<o;++u)h();return r}function qx(t){for(var e={},n=t.length-22;101010256!=Ov(t,n);--n)if(!n||t.length-n>65558)throw"invalid zip file";var r=Nv(t,n+8);if(!r)return{};var i=Ov(t,n+16),s=4294967295==i;if(s){if(n=Ov(t,n-12),101075792!=Ov(t,n))throw"invalid zip file";r=Ov(t,n+32),i=Ov(t,n+48)}for(var a=0;a<r;++a){var o=Fx(t,i,s),l=o[0],c=o[1],h=o[2],u=o[3],d=o[4],p=o[5],f=Rx(t,p);if(i=d,l){if(8!=l)throw"unknown compression type "+l;e[u]=tx(t.subarray(f,f+c),new Rg(h))}else e[u]=iv(t,f,f+c)}return e}function Qx(t,e){if("undefined"!=typeof HTMLImageElement&&t instanceof HTMLImageElement||"undefined"!=typeof HTMLCanvasElement&&t instanceof HTMLCanvasElement||"undefined"!=typeof OffscreenCanvas&&t instanceof OffscreenCanvas||"undefined"!=typeof ImageBitmap&&t instanceof ImageBitmap){const n=1024/Math.max(t.width,t.height),r=document.createElement("canvas");r.width=t.width*Math.min(1,n),r.height=t.height*Math.min(1,n);const i=r.getContext("2d");if(i.drawImage(t,0,0,r.width,r.height),void 0!==e){const t=parseInt(e,16),n=(t>>16&255)/255,s=(t>>8&255)/255,a=(255&t)/255,o=i.getImageData(0,0,r.width,r.height),l=o.data;for(let t=0;t<l.length;t+=4)l[t+0]=l[t+0]*n,l[t+1]=l[t+1]*s,l[t+2]=l[t+2]*a;i.putImageData(o,0,0)}return r}}function Zx(t,e){return`(${t[e+0]}, ${t[e+1]}, ${t[e+2]}, ${t[e+3]})`}function Jx(t,e){if(void 0===t)return console.warn("USDZExporter: Normals missing."),Array(e).fill("(0, 0, 0)").join(", ");const n=[];for(let e=0;e<t.count;e++){const r=t.getX(e),i=t.getY(e),s=t.getZ(e);n.push(`(${r.toPrecision(7)}, ${i.toPrecision(7)}, ${s.toPrecision(7)})`)}return n.join(", ")}function Kx(t,e){const n="            ",r=[],i=[];function s(n,r,i){const s=n.id+(i?"_"+i.getHexString():""),a=1023===n.format;return e[s]=n,`\n        def Shader "Transform2d_${r}" (\n            sdrMetadata = {\n                string role = "math"\n            }\n        )\n        {\n            uniform token info:id = "UsdTransform2d"\n            float2 inputs:in.connect = </Materials/Material_${t.id}/uvReader_st.outputs:result>\n            float2 inputs:scale = ${ty(n.repeat)}\n            float2 inputs:translation = ${ty(n.offset)}\n            float2 outputs:result\n        }\n\n        def Shader "Texture_${n.id}_${r}"\n        {\n            uniform token info:id = "UsdUVTexture"\n            asset inputs:file = @textures/Texture_${s}.${a?"png":"jpg"}@\n            float2 inputs:st.connect = </Materials/Material_${t.id}/Transform2d_${r}.outputs:result>\n            token inputs:wrapS = "repeat"\n            token inputs:wrapT = "repeat"\n            float outputs:r\n            float outputs:g\n            float outputs:b\n            float3 outputs:rgb\n        }`}return null!==t.map?(r.push(`${n}color3f inputs:diffuseColor.connect = </Materials/Material_${t.id}/Texture_${t.map.id}_diffuse.outputs:rgb>`),i.push(s(t.map,"diffuse",t.color))):r.push(`${n}color3f inputs:diffuseColor = ${$x(t.color)}`),null!==t.emissiveMap?(r.push(`${n}color3f inputs:emissiveColor.connect = </Materials/Material_${t.id}/Texture_${t.emissiveMap.id}_emissive.outputs:rgb>`),i.push(s(t.emissiveMap,"emissive"))):t.emissive.getHex()>0&&r.push(`${n}color3f inputs:emissiveColor = ${$x(t.emissive)}`),null!==t.normalMap&&(r.push(`${n}normal3f inputs:normal.connect = </Materials/Material_${t.id}/Texture_${t.normalMap.id}_normal.outputs:rgb>`),i.push(s(t.normalMap,"normal"))),null!==t.aoMap&&(r.push(`${n}float inputs:occlusion.connect = </Materials/Material_${t.id}/Texture_${t.aoMap.id}_occlusion.outputs:r>`),i.push(s(t.aoMap,"occlusion"))),null!==t.roughnessMap&&1===t.roughness?(r.push(`${n}float inputs:roughness.connect = </Materials/Material_${t.id}/Texture_${t.roughnessMap.id}_roughness.outputs:g>`),i.push(s(t.roughnessMap,"roughness"))):r.push(`${n}float inputs:roughness = ${t.roughness}`),null!==t.metalnessMap&&1===t.metalness?(r.push(`${n}float inputs:metallic.connect = </Materials/Material_${t.id}/Texture_${t.metalnessMap.id}_metallic.outputs:b>`),i.push(s(t.metalnessMap,"metallic"))):r.push(`${n}float inputs:metallic = ${t.metalness}`),null!==t.alphaMap?(r.push(`${n}float inputs:opacity.connect = </Materials/Material_${t.id}/Texture_${t.alphaMap.id}_opacity.outputs:r>`),r.push(`${n}float inputs:opacityThreshold = 0.0001`),i.push(s(t.alphaMap,"opacity"))):r.push(`${n}float inputs:opacity = ${t.opacity}`),t.isMeshPhysicalMaterial&&(r.push(`${n}float inputs:clearcoat = ${t.clearcoat}`),r.push(`${n}float inputs:clearcoatRoughness = ${t.clearcoatRoughness}`),r.push(`${n}float inputs:ior = ${t.ior}`)),`\n    def Material "Material_${t.id}"\n    {\n        def Shader "PreviewSurface"\n        {\n            uniform token info:id = "UsdPreviewSurface"\n${r.join("\n")}\n            int inputs:useSpecularWorkflow = 0\n            token outputs:surface\n        }\n\n        token outputs:surface.connect = </Materials/Material_${t.id}/PreviewSurface.outputs:surface>\n        token inputs:frame:stPrimvarName = "st"\n\n        def Shader "uvReader_st"\n        {\n            uniform token info:id = "UsdPrimvarReader_float2"\n            token inputs:varname.connect = </Materials/Material_${t.id}.inputs:frame:stPrimvarName>\n            float2 inputs:fallback = (0.0, 0.0)\n            float2 outputs:result\n        }\n\n${i.join("\n")}\n\n    }\n`}function $x(t){return`(${t.r}, ${t.g}, ${t.b})`}function ty(t){return`(${t.x}, ${t.y})`}const ey=new lr,ny=new up,ry=new Fs,iy=new lr,sy=new bi;class ay{constructor(){this.tolerance=-1,this.faces=[],this.newFaces=[],this.assigned=new hy,this.unassigned=new hy,this.vertices=[]}setFromPoints(t){!0!==Array.isArray(t)&&console.error("THREE.ConvexHull: Points parameter is not an array."),t.length<4&&console.error("THREE.ConvexHull: The algorithm needs at least four points."),this.makeEmpty();for(let e=0,n=t.length;e<n;e++)this.vertices.push(new cy(t[e]));return this.compute(),this}setFromObject(t){const e=[];return t.updateMatrixWorld(!0),t.traverse((function(t){const n=t.geometry;if(void 0!==n){if(n.isGeometry)return void console.error("THREE.ConvexHull no longer supports Geometry. Use THREE.BufferGeometry instead.");if(n.isBufferGeometry){const r=n.attributes.position;if(void 0!==r)for(let n=0,i=r.count;n<i;n++){const i=new lr;i.fromBufferAttribute(r,n).applyMatrix4(t.matrixWorld),e.push(i)}}}})),this.setFromPoints(e)}containsPoint(t){const e=this.faces;for(let n=0,r=e.length;n<r;n++)if(e[n].distanceToPoint(t)>this.tolerance)return!1;return!0}intersectRay(t,e){const n=this.faces;let r=-1/0,i=1/0;for(let e=0,s=n.length;e<s;e++){const s=n[e],a=s.distanceToPoint(t.origin),o=s.normal.dot(t.direction);if(a>0&&o>=0)return null;const l=0!==o?-a/o:0;if(!(l<=0)&&(o>0?i=Math.min(l,i):r=Math.max(l,r),r>i))return null}return r!==-1/0?t.at(r,e):t.at(i,e),e}intersectsRay(t){return null!==this.intersectRay(t,ey)}makeEmpty(){return this.faces=[],this.vertices=[],this}addVertexToFace(t,e){return t.face=e,null===e.outside?this.assigned.append(t):this.assigned.insertBefore(e.outside,t),e.outside=t,this}removeVertexFromFace(t,e){return t===e.outside&&(null!==t.next&&t.next.face===e?e.outside=t.next:e.outside=null),this.assigned.remove(t),this}removeAllVerticesFromFace(t){if(null!==t.outside){const e=t.outside;let n=t.outside;for(;null!==n.next&&n.next.face===t;)n=n.next;return this.assigned.removeSubList(e,n),e.prev=n.next=null,t.outside=null,e}}deleteFaceVertices(t,e){const n=this.removeAllVerticesFromFace(t);if(void 0!==n)if(void 0===e)this.unassigned.appendChain(n);else{let t=n;do{const n=t.next;e.distanceToPoint(t.point)>this.tolerance?this.addVertexToFace(t,e):this.unassigned.append(t),t=n}while(null!==t)}return this}resolveUnassignedPoints(t){if(!1===this.unassigned.isEmpty()){let e=this.unassigned.first();do{const n=e.next;let r=this.tolerance,i=null;for(let n=0;n<t.length;n++){const s=t[n];if(0===s.mark){const t=s.distanceToPoint(e.point);if(t>r&&(r=t,i=s),r>1e3*this.tolerance)break}}null!==i&&this.addVertexToFace(e,i),e=n}while(null!==e)}return this}computeExtremes(){const t=new lr,e=new lr,n=[],r=[];for(let t=0;t<3;t++)n[t]=r[t]=this.vertices[0];t.copy(this.vertices[0].point),e.copy(this.vertices[0].point);for(let i=0,s=this.vertices.length;i<s;i++){const s=this.vertices[i],a=s.point;for(let e=0;e<3;e++)a.getComponent(e)<t.getComponent(e)&&(t.setComponent(e,a.getComponent(e)),n[e]=s);for(let t=0;t<3;t++)a.getComponent(t)>e.getComponent(t)&&(e.setComponent(t,a.getComponent(t)),r[t]=s)}return this.tolerance=3*Number.EPSILON*(Math.max(Math.abs(t.x),Math.abs(e.x))+Math.max(Math.abs(t.y),Math.abs(e.y))+Math.max(Math.abs(t.z),Math.abs(e.z))),{min:n,max:r}}computeInitialHull(){const t=this.vertices,e=this.computeExtremes(),n=e.min,r=e.max;let i=0,s=0;for(let t=0;t<3;t++){const e=r[t].point.getComponent(t)-n[t].point.getComponent(t);e>i&&(i=e,s=t)}const a=n[s],o=r[s];let l,c;i=0,ny.set(a.point,o.point);for(let e=0,n=this.vertices.length;e<n;e++){const n=t[e];if(n!==a&&n!==o){ny.closestPointToPoint(n.point,!0,iy);const t=iy.distanceToSquared(n.point);t>i&&(i=t,l=n)}}i=-1,ry.setFromCoplanarPoints(a.point,o.point,l.point);for(let e=0,n=this.vertices.length;e<n;e++){const n=t[e];if(n!==a&&n!==o&&n!==l){const t=Math.abs(ry.distanceToPoint(n.point));t>i&&(i=t,c=n)}}const h=[];if(ry.distanceToPoint(c.point)<0){h.push(oy.create(a,o,l),oy.create(c,o,a),oy.create(c,l,o),oy.create(c,a,l));for(let t=0;t<3;t++){const e=(t+1)%3;h[t+1].getEdge(2).setTwin(h[0].getEdge(e)),h[t+1].getEdge(1).setTwin(h[e+1].getEdge(0))}}else{h.push(oy.create(a,l,o),oy.create(c,a,o),oy.create(c,o,l),oy.create(c,l,a));for(let t=0;t<3;t++){const e=(t+1)%3;h[t+1].getEdge(2).setTwin(h[0].getEdge((3-t)%3)),h[t+1].getEdge(0).setTwin(h[e+1].getEdge(1))}}for(let t=0;t<4;t++)this.faces.push(h[t]);for(let e=0,n=t.length;e<n;e++){const n=t[e];if(n!==a&&n!==o&&n!==l&&n!==c){i=this.tolerance;let t=null;for(let e=0;e<4;e++){const r=this.faces[e].distanceToPoint(n.point);r>i&&(i=r,t=this.faces[e])}null!==t&&this.addVertexToFace(n,t)}}return this}reindexFaces(){const t=[];for(let e=0;e<this.faces.length;e++){const n=this.faces[e];0===n.mark&&t.push(n)}return this.faces=t,this}nextVertexToAdd(){if(!1===this.assigned.isEmpty()){let t,e=0;const n=this.assigned.first().face;let r=n.outside;do{const i=n.distanceToPoint(r.point);i>e&&(e=i,t=r),r=r.next}while(null!==r&&r.face===n);return t}}computeHorizon(t,e,n,r){let i;this.deleteFaceVertices(n),n.mark=1,i=null===e?e=n.getEdge(0):e.next;do{const e=i.twin,n=e.face;0===n.mark&&(n.distanceToPoint(t)>this.tolerance?this.computeHorizon(t,e,n,r):r.push(i)),i=i.next}while(i!==e);return this}addAdjoiningFace(t,e){const n=oy.create(t,e.tail(),e.head());return this.faces.push(n),n.getEdge(-1).setTwin(e.twin),n.getEdge(0)}addNewFaces(t,e){this.newFaces=[];let n=null,r=null;for(let i=0;i<e.length;i++){const s=e[i],a=this.addAdjoiningFace(t,s);null===n?n=a:a.next.setTwin(r),this.newFaces.push(a.face),r=a}return n.next.setTwin(r),this}addVertexToHull(t){const e=[];return this.unassigned.clear(),this.removeVertexFromFace(t,t.face),this.computeHorizon(t.point,null,t.face,e),this.addNewFaces(t,e),this.resolveUnassignedPoints(this.newFaces),this}cleanup(){return this.assigned.clear(),this.unassigned.clear(),this.newFaces=[],this}compute(){let t;for(this.computeInitialHull();void 0!==(t=this.nextVertexToAdd());)this.addVertexToHull(t);return this.reindexFaces(),this.cleanup(),this}}class oy{constructor(){this.normal=new lr,this.midpoint=new lr,this.area=0,this.constant=0,this.outside=null,this.mark=0,this.edge=null}static create(t,e,n){const r=new oy,i=new ly(t,r),s=new ly(e,r),a=new ly(n,r);return i.next=a.prev=s,s.next=i.prev=a,a.next=s.prev=i,r.edge=i,r.compute()}getEdge(t){let e=this.edge;for(;t>0;)e=e.next,t--;for(;t<0;)e=e.prev,t++;return e}compute(){const t=this.edge.tail(),e=this.edge.head(),n=this.edge.next.head();return sy.set(t.point,e.point,n.point),sy.getNormal(this.normal),sy.getMidpoint(this.midpoint),this.area=sy.getArea(),this.constant=this.normal.dot(this.midpoint),this}distanceToPoint(t){return this.normal.dot(t)-this.constant}}class ly{constructor(t,e){this.vertex=t,this.prev=null,this.next=null,this.twin=null,this.face=e}head(){return this.vertex}tail(){return this.prev?this.prev.vertex:null}length(){const t=this.head(),e=this.tail();return null!==e?e.point.distanceTo(t.point):-1}lengthSquared(){const t=this.head(),e=this.tail();return null!==e?e.point.distanceToSquared(t.point):-1}setTwin(t){return this.twin=t,t.twin=this,this}}class cy{constructor(t){this.point=t,this.prev=null,this.next=null,this.face=null}}class hy{constructor(){this.head=null,this.tail=null}first(){return this.head}last(){return this.tail}clear(){return this.head=this.tail=null,this}insertBefore(t,e){return e.prev=t.prev,e.next=t,null===e.prev?this.head=e:e.prev.next=e,t.prev=e,this}insertAfter(t,e){return e.prev=t,e.next=t.next,null===e.next?this.tail=e:e.next.prev=e,t.next=e,this}append(t){return null===this.head?this.head=t:this.tail.next=t,t.prev=this.tail,t.next=null,this.tail=t,this}appendChain(t){for(null===this.head?this.head=t:this.tail.next=t,t.prev=this.tail;null!==t.next;)t=t.next;return this.tail=t,this}remove(t){return null===t.prev?this.head=t.next:t.prev.next=t.next,null===t.next?this.tail=t.prev:t.next.prev=t.prev,this}removeSubList(t,e){return null===t.prev?this.head=e.next:t.prev.next=e.next,null===e.next?this.tail=t.prev:e.next.prev=t.prev,this}isEmpty(){return null===this.head}}function uy(t,e=!1){const n=null!==t[0].index,r=new Set(Object.keys(t[0].attributes)),i=new Set(Object.keys(t[0].morphAttributes)),s={},a={},o=t[0].morphTargetsRelative,l=new Ki;let c=0;for(let h=0;h<t.length;++h){const u=t[h];let d=0;if(n!==(null!==u.index))return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index "+h+". All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them."),null;for(const t in u.attributes){if(!r.has(t))return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index "+h+'. All geometries must have compatible attributes; make sure "'+t+'" attribute exists among all geometries, or in none of them.'),null;void 0===s[t]&&(s[t]=[]),s[t].push(u.attributes[t]),d++}if(d!==r.size)return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index "+h+". Make sure all geometries have the same number of attributes."),null;if(o!==u.morphTargetsRelative)return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index "+h+". .morphTargetsRelative must be consistent throughout all geometries."),null;for(const t in u.morphAttributes){if(!i.has(t))return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index "+h+".  .morphAttributes must be consistent throughout all geometries."),null;void 0===a[t]&&(a[t]=[]),a[t].push(u.morphAttributes[t])}if(l.userData.mergedUserData=l.userData.mergedUserData||[],l.userData.mergedUserData.push(u.userData),e){let t;if(n)t=u.index.count;else{if(void 0===u.attributes.position)return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index "+h+". The geometry must have either an index or a position attribute"),null;t=u.attributes.position.count}l.addGroup(c,t,h),c+=t}}if(n){let e=0;const n=[];for(let r=0;r<t.length;++r){const i=t[r].index;for(let t=0;t<i.count;++t)n.push(i.getX(t)+e);e+=t[r].attributes.position.count}l.setIndex(n)}for(const t in s){const e=dy(s[t]);if(!e)return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the "+t+" attribute."),null;l.setAttribute(t,e)}for(const t in a){const e=a[t][0].length;if(0===e)break;l.morphAttributes=l.morphAttributes||{},l.morphAttributes[t]=[];for(let n=0;n<e;++n){const e=[];for(let r=0;r<a[t].length;++r)e.push(a[t][r][n]);const r=dy(e);if(!r)return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the "+t+" morphAttribute."),null;l.morphAttributes[t].push(r)}}return l}function dy(t){let e,n,r,i=0;for(let s=0;s<t.length;++s){const a=t[s];if(a.isInterleavedBufferAttribute)return console.error("THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. InterleavedBufferAttributes are not supported."),null;if(void 0===e&&(e=a.array.constructor),e!==a.array.constructor)return console.error("THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes."),null;if(void 0===n&&(n=a.itemSize),n!==a.itemSize)return console.error("THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes."),null;if(void 0===r&&(r=a.normalized),r!==a.normalized)return console.error("THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes."),null;i+=a.array.length}const s=new e(i);let a=0;for(let e=0;e<t.length;++e)s.set(t[e].array,a),a+=t[e].array.length;return new Ii(s,n,r)}const py=function(){const t=new Qs({uniforms:{roughnessMap:{value:null},normalMap:{value:null},texelSize:{value:new jn(1,1)}},vertexShader:"\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tattribute vec3 position;\n\t\t\tattribute vec2 uv;\n\n\t\t\tvarying vec2 vUv;\n\n\t\t\tvoid main() {\n\n\t\t\t\tvUv = uv;\n\n\t\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t\t}\n\t\t",fragmentShader:"\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec2 vUv;\n\n\t\t\tuniform sampler2D roughnessMap;\n\t\t\tuniform sampler2D normalMap;\n\t\t\tuniform vec2 texelSize;\n\n\t\t\t#define ENVMAP_TYPE_CUBE_UV\n\n\t\t\tvec4 envMapTexelToLinear( vec4 a ) { return a; }\n\n\t\t\t#include <cube_uv_reflection_fragment>\n\n\t\t\tfloat roughnessToVariance( float roughness ) {\n\n\t\t\t\tfloat variance = 0.0;\n\n\t\t\t\tif ( roughness >= r1 ) {\n\n\t\t\t\t\tvariance = ( r0 - roughness ) * ( v1 - v0 ) / ( r0 - r1 ) + v0;\n\n\t\t\t\t} else if ( roughness >= r4 ) {\n\n\t\t\t\t\tvariance = ( r1 - roughness ) * ( v4 - v1 ) / ( r1 - r4 ) + v1;\n\n\t\t\t\t} else if ( roughness >= r5 ) {\n\n\t\t\t\t\tvariance = ( r4 - roughness ) * ( v5 - v4 ) / ( r4 - r5 ) + v4;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tfloat roughness2 = roughness * roughness;\n\n\t\t\t\t\tvariance = 1.79 * roughness2 * roughness2;\n\n\t\t\t\t}\n\n\t\t\t\treturn variance;\n\n\t\t\t}\n\n\t\t\tfloat varianceToRoughness( float variance ) {\n\n\t\t\t\tfloat roughness = 0.0;\n\n\t\t\t\tif ( variance >= v1 ) {\n\n\t\t\t\t\troughness = ( v0 - variance ) * ( r1 - r0 ) / ( v0 - v1 ) + r0;\n\n\t\t\t\t} else if ( variance >= v4 ) {\n\n\t\t\t\t\troughness = ( v1 - variance ) * ( r4 - r1 ) / ( v1 - v4 ) + r1;\n\n\t\t\t\t} else if ( variance >= v5 ) {\n\n\t\t\t\t\troughness = ( v4 - variance ) * ( r5 - r4 ) / ( v4 - v5 ) + r4;\n\n\t\t\t\t} else {\n\n\t\t\t\t\troughness = pow( 0.559 * variance, 0.25 ); // 0.559 = 1.0 / 1.79\n\n\t\t\t\t}\n\n\t\t\t\treturn roughness;\n\n\t\t\t}\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = texture2D( roughnessMap, vUv, - 1.0 );\n\n\t\t\t\tif ( texelSize.x == 0.0 ) return;\n\n\t\t\t\tfloat roughness = gl_FragColor.g;\n\n\t\t\t\tfloat variance = roughnessToVariance( roughness );\n\n\t\t\t\tvec3 avgNormal;\n\n\t\t\t\tfor ( float x = - 1.0; x < 2.0; x += 2.0 ) {\n\n\t\t\t\t\tfor ( float y = - 1.0; y < 2.0; y += 2.0 ) {\n\n\t\t\t\t\t\tvec2 uv = vUv + vec2( x, y ) * 0.25 * texelSize;\n\n\t\t\t\t\t\tavgNormal += normalize( texture2D( normalMap, uv, - 1.0 ).xyz - 0.5 );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tvariance += 1.0 - 0.25 * length( avgNormal );\n\n\t\t\t\tgl_FragColor.g = varianceToRoughness( variance );\n\n\t\t\t}\n\t\t",blending:M,depthTest:!1,depthWrite:!1});return t.type="RoughnessMipmapper",t}(),fy=new gs(new Bs(2,2),py),my=new qs(0,1,0,1,0,1);let gy=null,vy=null;function xy(t,e){switch(e){case tn:t.convertSRGBToLinear();break;case $e:break;default:console.warn("WARNING: LightProbeGenerator convertColorToLinear() encountered an unsupported encoding.")}return t}const yy=new WeakMap;class wy extends Du{constructor(t){super(t),this.transcoderPath="",this.transcoderBinary=null,this.transcoderPending=null,this.workerLimit=4,this.workerPool=[],this.workerNextTaskID=1,this.workerSourceURL="",this.workerConfig=null}setTranscoderPath(t){return this.transcoderPath=t,this}setWorkerLimit(t){return this.workerLimit=t,this}detectSupport(t){return this.workerConfig={astcSupported:t.extensions.has("WEBGL_compressed_texture_astc"),etc1Supported:t.extensions.has("WEBGL_compressed_texture_etc1"),etc2Supported:t.extensions.has("WEBGL_compressed_texture_etc"),dxtSupported:t.extensions.has("WEBGL_compressed_texture_s3tc"),bptcSupported:t.extensions.has("EXT_texture_compression_bptc"),pvrtcSupported:t.extensions.has("WEBGL_compressed_texture_pvrtc")||t.extensions.has("WEBKIT_WEBGL_compressed_texture_pvrtc")},this}load(t,e,n,r){const i=new Uu(this.manager);i.setResponseType("arraybuffer"),i.setWithCredentials(this.withCredentials);const s=new Nc;return i.load(t,(t=>{if(yy.has(t))return yy.get(t).promise.then(e).catch(r);this._createTexture([t]).then((function(t){s.copy(t),s.needsUpdate=!0,e&&e(s)})).catch(r)}),n,r),s}parseInternalAsync(t){const{levels:e}=t,n=new Set;for(let t=0;t<e.length;t++)n.add(e[t].data.buffer);return this._createTexture(Array.from(n),{...t,lowLevel:!0})}_createTexture(t,e={}){let n,r;const i=e;let s=0;for(let e=0;e<t.length;e++)s+=t[e].byteLength;const a=this._allocateWorker(s).then((e=>(n=e,r=this.workerNextTaskID++,new Promise(((e,s)=>{n._callbacks[r]={resolve:e,reject:s},n.postMessage({type:"transcode",id:r,buffers:t,taskConfig:i},t)}))))).then((t=>{const{mipmaps:e,width:n,height:r,format:i}=t,s=new Nc(e,n,r,i,Ct);return s.minFilter=1===e.length?Mt:At,s.magFilter=Mt,s.generateMipmaps=!1,s.needsUpdate=!0,s}));return a.catch((()=>!0)).then((()=>{n&&r&&(n._taskLoad-=s,delete n._callbacks[r])})),yy.set(t[0],{promise:a}),a}_initTranscoder(){if(!this.transcoderPending){const t=new Uu(this.manager);t.setPath(this.transcoderPath),t.setWithCredentials(this.withCredentials);const e=new Promise(((e,n)=>{t.load("basis_transcoder.js",e,void 0,n)})),n=new Uu(this.manager);n.setPath(this.transcoderPath),n.setResponseType("arraybuffer"),n.setWithCredentials(this.withCredentials);const r=new Promise(((t,e)=>{n.load("basis_transcoder.wasm",t,void 0,e)}));this.transcoderPending=Promise.all([e,r]).then((([t,e])=>{const n=wy.BasisWorker.toString(),r=["/* constants */","let _EngineFormat = "+JSON.stringify(wy.EngineFormat),"let _TranscoderFormat = "+JSON.stringify(wy.TranscoderFormat),"let _BasisFormat = "+JSON.stringify(wy.BasisFormat),"/* basis_transcoder.js */",t,"/* worker */",n.substring(n.indexOf("{")+1,n.lastIndexOf("}"))].join("\n");this.workerSourceURL=URL.createObjectURL(new Blob([r])),this.transcoderBinary=e}))}return this.transcoderPending}_allocateWorker(t){return this._initTranscoder().then((()=>{if(this.workerPool.length<this.workerLimit){const t=new Worker(this.workerSourceURL);t._callbacks={},t._taskLoad=0,t.postMessage({type:"init",config:this.workerConfig,transcoderBinary:this.transcoderBinary}),t.onmessage=function(e){const n=e.data;switch(n.type){case"transcode":t._callbacks[n.id].resolve(n);break;case"error":t._callbacks[n.id].reject(n);break;default:console.error('THREE.BasisTextureLoader: Unexpected message, "'+n.type+'"')}},this.workerPool.push(t)}else this.workerPool.sort((function(t,e){return t._taskLoad>e._taskLoad?-1:1}));const e=this.workerPool[this.workerPool.length-1];return e._taskLoad+=t,e}))}dispose(){for(let t=0;t<this.workerPool.length;t++)this.workerPool[t].terminate();return this.workerPool.length=0,this}}wy.BasisFormat={ETC1S:0,UASTC_4x4:1},wy.TranscoderFormat={ETC1:0,ETC2:1,BC1:2,BC3:3,BC4:4,BC5:5,BC7_M6_OPAQUE_ONLY:6,BC7_M5:7,PVRTC1_4_RGB:8,PVRTC1_4_RGBA:9,ASTC_4x4:10,ATC_RGB:11,ATC_RGBA_INTERPOLATED_ALPHA:12,RGBA32:13,RGB565:14,BGR565:15,RGBA4444:16},wy.EngineFormat={RGBAFormat:Gt,RGBA_ASTC_4x4_Format:he,RGBA_BPTC_Format:Te,RGBA_ETC2_EAC_Format:ce,RGBA_PVRTC_4BPPV1_Format:se,RGBA_S3TC_DXT5_Format:ne,RGB_ETC1_Format:oe,RGB_ETC2_Format:le,RGB_PVRTC_4BPPV1_Format:re,RGB_S3TC_DXT1_Format:$t},wy.BasisWorker=function(){let t,e,n;const r=_EngineFormat,i=_TranscoderFormat,s=_BasisFormat;onmessage=function(r){const i=r.data;switch(i.type){case"init":t=i.config,a=i.transcoderBinary,e=new Promise((t=>{n={wasmBinary:a,onRuntimeInitialized:t},BASIS(n)})).then((()=>{n.initializeBasis()}));break;case"transcode":e.then((()=>{try{const{width:t,height:e,hasAlpha:r,mipmaps:a,format:o}=i.taskConfig.lowLevel?function(t){const{basisFormat:e,width:r,height:i,hasAlpha:a}=t,{transcoderFormat:o,engineFormat:l}=c(e,r,i,a),f=n.getBytesPerBlockOrPixel(o);h(n.isFormatSupported(o),"THREE.BasisTextureLoader: Unsupported format.");const m=[];if(e===s.ETC1S){const e=new n.LowLevelETC1SImageTranscoder,{endpointCount:r,endpointsData:i,selectorCount:s,selectorsData:l,tablesData:c}=t.globalData;try{let n;n=e.decodePalettes(r,i,s,l),h(n,"THREE.BasisTextureLoader: decodePalettes() failed."),n=e.decodeTables(c),h(n,"THREE.BasisTextureLoader: decodeTables() failed.");for(let r=0;r<t.levels.length;r++){const i=t.levels[r],s=t.globalData.imageDescs[r],l=p(o,i.width,i.height),c=new Uint8Array(l);n=e.transcodeImage(o,c,l/f,i.data,u(o,i.width),d(o,i.height),i.width,i.height,i.index,s.rgbSliceByteOffset,s.rgbSliceByteLength,s.alphaSliceByteOffset,s.alphaSliceByteLength,s.imageFlags,a,!1,0,0),h(n,"THREE.BasisTextureLoader: transcodeImage() failed for level "+i.index+"."),m.push({data:c,width:i.width,height:i.height})}}finally{e.delete()}}else for(let e=0;e<t.levels.length;e++){const r=t.levels[e],i=p(o,r.width,r.height),s=new Uint8Array(i);h(n.transcodeUASTCImage(o,s,i/f,r.data,u(o,r.width),d(o,r.height),r.width,r.height,r.index,0,r.data.byteLength,0,a,!1,0,0,-1,-1),"THREE.BasisTextureLoader: transcodeUASTCImage() failed for level "+r.index+"."),m.push({data:s,width:r.width,height:r.height})}return{width:r,height:i,hasAlpha:a,mipmaps:m,format:l}}(i.taskConfig):function(t){const e=new n.BasisFile(new Uint8Array(t)),r=e.isUASTC()?s.UASTC_4x4:s.ETC1S,i=e.getImageWidth(0,0),a=e.getImageHeight(0,0),o=e.getNumLevels(0),l=e.getHasAlpha();function h(){e.close(),e.delete()}const{transcoderFormat:u,engineFormat:d}=c(r,i,a,l);if(!i||!a||!o)throw h(),new Error("THREE.BasisTextureLoader:\tInvalid texture");if(!e.startTranscoding())throw h(),new Error("THREE.BasisTextureLoader: .startTranscoding failed");const p=[];for(let t=0;t<o;t++){const n=e.getImageWidth(0,t),r=e.getImageHeight(0,t),i=new Uint8Array(e.getImageTranscodedSizeInBytes(0,t,u));if(!e.transcodeImage(i,0,t,u,0,l))throw h(),new Error("THREE.BasisTextureLoader: .transcodeImage failed.");p.push({data:i,width:n,height:r})}return h(),{width:i,height:a,hasAlpha:l,mipmaps:p,format:d}}(i.buffers[0]),l=[];for(let t=0;t<a.length;++t)l.push(a[t].data.buffer);self.postMessage({type:"transcode",id:i.id,width:t,height:e,hasAlpha:r,mipmaps:a,format:o},l)}catch(t){console.error(t),self.postMessage({type:"error",id:i.id,error:t.message})}}))}var a};const a=[{if:"astcSupported",basisFormat:[s.UASTC_4x4],transcoderFormat:[i.ASTC_4x4,i.ASTC_4x4],engineFormat:[r.RGBA_ASTC_4x4_Format,r.RGBA_ASTC_4x4_Format],priorityETC1S:1/0,priorityUASTC:1,needsPowerOfTwo:!1},{if:"bptcSupported",basisFormat:[s.ETC1S,s.UASTC_4x4],transcoderFormat:[i.BC7_M5,i.BC7_M5],engineFormat:[r.RGBA_BPTC_Format,r.RGBA_BPTC_Format],priorityETC1S:3,priorityUASTC:2,needsPowerOfTwo:!1},{if:"dxtSupported",basisFormat:[s.ETC1S,s.UASTC_4x4],transcoderFormat:[i.BC1,i.BC3],engineFormat:[r.RGB_S3TC_DXT1_Format,r.RGBA_S3TC_DXT5_Format],priorityETC1S:4,priorityUASTC:5,needsPowerOfTwo:!1},{if:"etc2Supported",basisFormat:[s.ETC1S,s.UASTC_4x4],transcoderFormat:[i.ETC1,i.ETC2],engineFormat:[r.RGB_ETC2_Format,r.RGBA_ETC2_EAC_Format],priorityETC1S:1,priorityUASTC:3,needsPowerOfTwo:!1},{if:"etc1Supported",basisFormat:[s.ETC1S,s.UASTC_4x4],transcoderFormat:[i.ETC1,i.ETC1],engineFormat:[r.RGB_ETC1_Format,r.RGB_ETC1_Format],priorityETC1S:2,priorityUASTC:4,needsPowerOfTwo:!1},{if:"pvrtcSupported",basisFormat:[s.ETC1S,s.UASTC_4x4],transcoderFormat:[i.PVRTC1_4_RGB,i.PVRTC1_4_RGBA],engineFormat:[r.RGB_PVRTC_4BPPV1_Format,r.RGBA_PVRTC_4BPPV1_Format],priorityETC1S:5,priorityUASTC:6,needsPowerOfTwo:!0}],o=a.sort((function(t,e){return t.priorityETC1S-e.priorityETC1S})),l=a.sort((function(t,e){return t.priorityUASTC-e.priorityUASTC}));function c(e,n,a,c){let h,u;const d=e===s.ETC1S?o:l;for(let r=0;r<d.length;r++){const i=d[r];if(t[i.if]&&i.basisFormat.includes(e)&&(!i.needsPowerOfTwo||f(n)&&f(a)))return h=i.transcoderFormat[c?1:0],u=i.engineFormat[c?1:0],{transcoderFormat:h,engineFormat:u}}return console.warn("THREE.BasisTextureLoader: No suitable compressed texture format found. Decoding to RGBA32."),h=i.RGBA32,u=r.RGBAFormat,{transcoderFormat:h,engineFormat:u}}function h(t,e){if(!t)throw new Error(e)}function u(t,e){return Math.ceil(e/n.getFormatBlockWidth(t))}function d(t,e){return Math.ceil(e/n.getFormatBlockHeight(t))}function p(t,e,r){const s=n.getBytesPerBlockOrPixel(t);if(n.formatIsUncompressed(t))return e*r*s;if(t===i.PVRTC1_4_RGB||t===i.PVRTC1_4_RGBA){const t=e+3&-4,n=r+3&-4;return(Math.max(8,t)*Math.max(8,n)*4+7)/8}return u(t,e)*d(t,r)*s}function f(t){return t<=2||0==(t&t-1)&&0!==t}};class by{constructor(t=4){this.pool=t,this.queue=[],this.workers=[],this.workersResolve=[],this.workerStatus=0}_initWorker(t){if(!this.workers[t]){const e=this.workerCreator();e.addEventListener("message",this._onMessage.bind(this,t)),this.workers[t]=e}}_getIdleWorker(){for(let t=0;t<this.pool;t++)if(!(this.workerStatus&1<<t))return t;return-1}_onMessage(t,e){const n=this.workersResolve[t];if(n&&n(e),this.queue.length){const{resolve:e,msg:n,transfer:r}=this.queue.shift();this.workersResolve[t]=e,this.workers[t].postMessage(n,r)}else this.workerStatus^=1<<t}setWorkerCreator(t){this.workerCreator=t}setWorkerLimit(t){this.pool=t}postMessage(t,e){return new Promise((n=>{const r=this._getIdleWorker();-1!==r?(this._initWorker(r),this.workerStatus|=1<<r,this.workersResolve[r]=n,this.workers[r].postMessage(t,e)):this.queue.push({resolve:n,msg:t,transfer:e})}))}dispose(){this.workers.forEach((t=>t.terminate())),this.workersResolve.length=0,this.workers.length=0,this.queue.length=0,this.workerStatus=0}}const _y=new WeakMap;let My=0;class Ty extends Du{constructor(t){super(t),this.transcoderPath="",this.transcoderBinary=null,this.transcoderPending=null,this.workerPool=new by,this.workerSourceURL="",this.workerConfig=null,"undefined"!=typeof MSC_TRANSCODER&&console.warn('THREE.KTX2Loader: Please update to latest "basis_transcoder". "msc_basis_transcoder" is no longer supported in three.js r125+.')}setTranscoderPath(t){return this.transcoderPath=t,this}setWorkerLimit(t){return this.workerPool.setWorkerLimit(t),this}detectSupport(t){return this.workerConfig={astcSupported:t.extensions.has("WEBGL_compressed_texture_astc"),etc1Supported:t.extensions.has("WEBGL_compressed_texture_etc1"),etc2Supported:t.extensions.has("WEBGL_compressed_texture_etc"),dxtSupported:t.extensions.has("WEBGL_compressed_texture_s3tc"),bptcSupported:t.extensions.has("EXT_texture_compression_bptc"),pvrtcSupported:t.extensions.has("WEBGL_compressed_texture_pvrtc")||t.extensions.has("WEBKIT_WEBGL_compressed_texture_pvrtc")},t.capabilities.isWebGL2&&(this.workerConfig.etc1Supported=!1),this}dispose(){return this.workerPool.dispose(),this.workerSourceURL&&URL.revokeObjectURL(this.workerSourceURL),this}init(){if(!this.transcoderPending){const t=new Uu(this.manager);t.setPath(this.transcoderPath),t.setWithCredentials(this.withCredentials);const e=t.loadAsync("basis_transcoder.js"),n=new Uu(this.manager);n.setPath(this.transcoderPath),n.setResponseType("arraybuffer"),n.setWithCredentials(this.withCredentials);const r=n.loadAsync("basis_transcoder.wasm");this.transcoderPending=Promise.all([e,r]).then((([t,e])=>{const n=Ty.BasisWorker.toString(),r=["/* constants */","let _EngineFormat = "+JSON.stringify(Ty.EngineFormat),"let _TranscoderFormat = "+JSON.stringify(Ty.TranscoderFormat),"let _BasisFormat = "+JSON.stringify(Ty.BasisFormat),"/* basis_transcoder.js */",t,"/* worker */",n.substring(n.indexOf("{")+1,n.lastIndexOf("}"))].join("\n");this.workerSourceURL=URL.createObjectURL(new Blob([r])),this.transcoderBinary=e,this.workerPool.setWorkerCreator((()=>{const t=new Worker(this.workerSourceURL),e=this.transcoderBinary.slice(0);return t.postMessage({type:"init",config:this.workerConfig,transcoderBinary:e},[e]),t}))})),My>0&&console.warn("THREE.KTX2Loader: Multiple active KTX2 loaders may cause performance issues. Use a single KTX2Loader instance, or call .dispose() on old instances."),My++}return this.transcoderPending}load(t,e,n,r){if(null===this.workerConfig)throw new Error("THREE.KTX2Loader: Missing initialization with `.detectSupport( renderer )`.");const i=new Uu(this.manager);i.setResponseType("arraybuffer"),i.setWithCredentials(this.withCredentials);const s=new Nc;return i.load(t,(t=>{if(_y.has(t))return _y.get(t).promise.then(e).catch(r);this._createTexture([t]).then((function(t){s.copy(t),s.needsUpdate=!0,e&&e(s)})).catch(r)}),n,r),s}_createTextureFrom(t){const{mipmaps:e,width:n,height:r,format:i,type:s,error:a,dfdTransferFn:o,dfdFlags:l}=t;if("error"===s)return Promise.reject(a);const c=new Nc(e,n,r,i,Ct);return c.minFilter=1===e.length?Mt:At,c.magFilter=Mt,c.generateMipmaps=!1,c.needsUpdate=!0,c.encoding=2===o?tn:$e,c.premultiplyAlpha=!!(1&l),c}_createTexture(t,e={}){const n=e,r=this.init().then((()=>this.workerPool.postMessage({type:"transcode",buffers:t,taskConfig:n},t))).then((t=>this._createTextureFrom(t.data)));return _y.set(t[0],{promise:r}),r}dispose(){return URL.revokeObjectURL(this.workerSourceURL),this.workerPool.dispose(),My--,this}}Ty.BasisFormat={ETC1S:0,UASTC_4x4:1},Ty.TranscoderFormat={ETC1:0,ETC2:1,BC1:2,BC3:3,BC4:4,BC5:5,BC7_M6_OPAQUE_ONLY:6,BC7_M5:7,PVRTC1_4_RGB:8,PVRTC1_4_RGBA:9,ASTC_4x4:10,ATC_RGB:11,ATC_RGBA_INTERPOLATED_ALPHA:12,RGBA32:13,RGB565:14,BGR565:15,RGBA4444:16},Ty.EngineFormat={RGBAFormat:Gt,RGBA_ASTC_4x4_Format:he,RGBA_BPTC_Format:Te,RGBA_ETC2_EAC_Format:ce,RGBA_PVRTC_4BPPV1_Format:se,RGBA_S3TC_DXT5_Format:ne,RGB_ETC1_Format:oe,RGB_ETC2_Format:le,RGB_PVRTC_4BPPV1_Format:re,RGB_S3TC_DXT1_Format:$t},Ty.BasisWorker=function(){let t,e,n;const r=_EngineFormat,i=_TranscoderFormat,s=_BasisFormat;self.addEventListener("message",(function(a){const h=a.data;switch(h.type){case"init":t=h.config,u=h.transcoderBinary,e=new Promise((t=>{n={wasmBinary:u,onRuntimeInitialized:t},BASIS(n)})).then((()=>{n.initializeBasis(),void 0===n.KTX2File&&console.warn("THREE.KTX2Loader: Please update Basis Universal transcoder.")}));break;case"transcode":e.then((()=>{try{const{width:e,height:a,hasAlpha:u,mipmaps:d,format:p,dfdTransferFn:f,dfdFlags:m}=function(e){const a=new n.KTX2File(new Uint8Array(e));function h(){a.close(),a.delete()}if(!a.isValid())throw h(),new Error("THREE.KTX2Loader:\tInvalid or unsupported .ktx2 file");const u=a.isUASTC()?s.UASTC_4x4:s.ETC1S,d=a.getWidth(),p=a.getHeight(),f=a.getLevels(),m=a.getHasAlpha(),g=a.getDFDTransferFunc(),v=a.getDFDFlags(),{transcoderFormat:x,engineFormat:y}=function(e,n,a,h){let u,d;const p=e===s.ETC1S?o:l;for(let r=0;r<p.length;r++){const i=p[r];if(t[i.if]&&i.basisFormat.includes(e)&&!(h&&i.transcoderFormat.length<2)&&(!i.needsPowerOfTwo||c(n)&&c(a)))return u=i.transcoderFormat[h?1:0],d=i.engineFormat[h?1:0],{transcoderFormat:u,engineFormat:d}}return console.warn("THREE.KTX2Loader: No suitable compressed texture format found. Decoding to RGBA32."),u=i.RGBA32,d=r.RGBAFormat,{transcoderFormat:u,engineFormat:d}}(u,d,p,m);if(!d||!p||!f)throw h(),new Error("THREE.KTX2Loader:\tInvalid texture");if(!a.startTranscoding())throw h(),new Error("THREE.KTX2Loader: .startTranscoding failed");const w=[];for(let t=0;t<f;t++){const e=a.getImageLevelInfo(t,0,0),n=e.origWidth,r=e.origHeight,i=new Uint8Array(a.getImageTranscodedSizeInBytes(t,0,0,x));if(!a.transcodeImage(i,t,0,0,x,0,-1,-1))throw h(),new Error("THREE.KTX2Loader: .transcodeImage failed.");w.push({data:i,width:n,height:r})}return h(),{width:d,height:p,hasAlpha:m,mipmaps:w,format:y,dfdTransferFn:g,dfdFlags:v}}(h.buffers[0]),g=[];for(let t=0;t<d.length;++t)g.push(d[t].data.buffer);self.postMessage({type:"transcode",id:h.id,width:e,height:a,hasAlpha:u,mipmaps:d,format:p,dfdTransferFn:f,dfdFlags:m},g)}catch(t){console.error(t),self.postMessage({type:"error",id:h.id,error:t.message})}}))}var u}));const a=[{if:"astcSupported",basisFormat:[s.UASTC_4x4],transcoderFormat:[i.ASTC_4x4,i.ASTC_4x4],engineFormat:[r.RGBA_ASTC_4x4_Format,r.RGBA_ASTC_4x4_Format],priorityETC1S:1/0,priorityUASTC:1,needsPowerOfTwo:!1},{if:"bptcSupported",basisFormat:[s.ETC1S,s.UASTC_4x4],transcoderFormat:[i.BC7_M5,i.BC7_M5],engineFormat:[r.RGBA_BPTC_Format,r.RGBA_BPTC_Format],priorityETC1S:3,priorityUASTC:2,needsPowerOfTwo:!1},{if:"dxtSupported",basisFormat:[s.ETC1S,s.UASTC_4x4],transcoderFormat:[i.BC1,i.BC3],engineFormat:[r.RGB_S3TC_DXT1_Format,r.RGBA_S3TC_DXT5_Format],priorityETC1S:4,priorityUASTC:5,needsPowerOfTwo:!1},{if:"etc2Supported",basisFormat:[s.ETC1S,s.UASTC_4x4],transcoderFormat:[i.ETC1,i.ETC2],engineFormat:[r.RGB_ETC2_Format,r.RGBA_ETC2_EAC_Format],priorityETC1S:1,priorityUASTC:3,needsPowerOfTwo:!1},{if:"etc1Supported",basisFormat:[s.ETC1S,s.UASTC_4x4],transcoderFormat:[i.ETC1],engineFormat:[r.RGB_ETC1_Format],priorityETC1S:2,priorityUASTC:4,needsPowerOfTwo:!1},{if:"pvrtcSupported",basisFormat:[s.ETC1S,s.UASTC_4x4],transcoderFormat:[i.PVRTC1_4_RGB,i.PVRTC1_4_RGBA],engineFormat:[r.RGB_PVRTC_4BPPV1_Format,r.RGBA_PVRTC_4BPPV1_Format],priorityETC1S:5,priorityUASTC:6,needsPowerOfTwo:!0}],o=a.sort((function(t,e){return t.priorityETC1S-e.priorityETC1S})),l=a.sort((function(t,e){return t.priorityUASTC-e.priorityUASTC}));function c(t){return t<=2||0==(t&t-1)&&0!==t}};const Sy=new np,Ay=new lr,Ey=new lr,Cy=new or,Py={X:new lr(1,0,0),Y:new lr(0,1,0),Z:new lr(0,0,1)},Ly={type:"change"},Ry={type:"mouseDown"},Fy={type:"mouseUp",mode:null},Dy={type:"objectChange"};class Iy extends hi{constructor(t,e){super(),void 0===e&&(console.warn('THREE.TransformControls: The second parameter "domElement" is now mandatory.'),e=document),this.visible=!1,this.domElement=e,this.domElement.style.touchAction="none";const n=new ew;this._gizmo=n,this.add(n);const r=new nw;this._plane=r,this.add(r);const i=this;function s(t,e){let s=e;Object.defineProperty(i,t,{get:function(){return void 0!==s?s:e},set:function(e){s!==e&&(s=e,r[t]=e,n[t]=e,i.dispatchEvent({type:t+"-changed",value:e}),i.dispatchEvent(Ly))}}),i[t]=e,r[t]=e,n[t]=e}s("camera",t),s("object",void 0),s("enabled",!0),s("axis",null),s("mode","translate"),s("translationSnap",null),s("rotationSnap",null),s("scaleSnap",null),s("space","world"),s("size",1),s("dragging",!1),s("showX",!0),s("showY",!0),s("showZ",!0);const a=new lr,o=new lr,l=new or,c=new or,h=new lr,u=new or,d=new lr,p=new lr,f=new lr,m=new lr;s("worldPosition",a),s("worldPositionStart",o),s("worldQuaternion",l),s("worldQuaternionStart",c),s("cameraPosition",h),s("cameraQuaternion",u),s("pointStart",d),s("pointEnd",p),s("rotationAxis",f),s("rotationAngle",0),s("eye",m),this._offset=new lr,this._startNorm=new lr,this._endNorm=new lr,this._cameraScale=new lr,this._parentPosition=new lr,this._parentQuaternion=new or,this._parentQuaternionInv=new or,this._parentScale=new lr,this._worldScaleStart=new lr,this._worldQuaternionInv=new or,this._worldScale=new lr,this._positionStart=new lr,this._quaternionStart=new or,this._scaleStart=new lr,this._getPointer=Uy.bind(this),this._onPointerDown=Oy.bind(this),this._onPointerHover=Ny.bind(this),this._onPointerMove=By.bind(this),this._onPointerUp=zy.bind(this),this.domElement.addEventListener("pointerdown",this._onPointerDown),this.domElement.addEventListener("pointermove",this._onPointerHover),this.domElement.addEventListener("pointerup",this._onPointerUp)}updateMatrixWorld(){void 0!==this.object&&(this.object.updateMatrixWorld(),null===this.object.parent?console.error("TransformControls: The attached 3D object must be a part of the scene graph."):this.object.parent.matrixWorld.decompose(this._parentPosition,this._parentQuaternion,this._parentScale),this.object.matrixWorld.decompose(this.worldPosition,this.worldQuaternion,this._worldScale),this._parentQuaternionInv.copy(this._parentQuaternion).invert(),this._worldQuaternionInv.copy(this.worldQuaternion).invert()),this.camera.updateMatrixWorld(),this.camera.matrixWorld.decompose(this.cameraPosition,this.cameraQuaternion,this._cameraScale),this.eye.copy(this.cameraPosition).sub(this.worldPosition).normalize(),super.updateMatrixWorld(this)}pointerHover(t){if(void 0===this.object||!0===this.dragging)return;Sy.setFromCamera(t,this.camera);const e=ky(this._gizmo.picker[this.mode],Sy);this.axis=e?e.object.name:null}pointerDown(t){if(void 0!==this.object&&!0!==this.dragging&&0===t.button&&null!==this.axis){Sy.setFromCamera(t,this.camera);const e=ky(this._plane,Sy,!0);e&&(this.object.updateMatrixWorld(),this.object.parent.updateMatrixWorld(),this._positionStart.copy(this.object.position),this._quaternionStart.copy(this.object.quaternion),this._scaleStart.copy(this.object.scale),this.object.matrixWorld.decompose(this.worldPositionStart,this.worldQuaternionStart,this._worldScaleStart),this.pointStart.copy(e.point).sub(this.worldPositionStart)),this.dragging=!0,Ry.mode=this.mode,this.dispatchEvent(Ry)}}pointerMove(t){const e=this.axis,n=this.mode,r=this.object;let i=this.space;if("scale"===n?i="local":"E"!==e&&"XYZE"!==e&&"XYZ"!==e||(i="world"),void 0===r||null===e||!1===this.dragging||-1!==t.button)return;Sy.setFromCamera(t,this.camera);const s=ky(this._plane,Sy,!0);if(s){if(this.pointEnd.copy(s.point).sub(this.worldPositionStart),"translate"===n)this._offset.copy(this.pointEnd).sub(this.pointStart),"local"===i&&"XYZ"!==e&&this._offset.applyQuaternion(this._worldQuaternionInv),-1===e.indexOf("X")&&(this._offset.x=0),-1===e.indexOf("Y")&&(this._offset.y=0),-1===e.indexOf("Z")&&(this._offset.z=0),"local"===i&&"XYZ"!==e?this._offset.applyQuaternion(this._quaternionStart).divide(this._parentScale):this._offset.applyQuaternion(this._parentQuaternionInv).divide(this._parentScale),r.position.copy(this._offset).add(this._positionStart),this.translationSnap&&("local"===i&&(r.position.applyQuaternion(Cy.copy(this._quaternionStart).invert()),-1!==e.search("X")&&(r.position.x=Math.round(r.position.x/this.translationSnap)*this.translationSnap),-1!==e.search("Y")&&(r.position.y=Math.round(r.position.y/this.translationSnap)*this.translationSnap),-1!==e.search("Z")&&(r.position.z=Math.round(r.position.z/this.translationSnap)*this.translationSnap),r.position.applyQuaternion(this._quaternionStart)),"world"===i&&(r.parent&&r.position.add(Ay.setFromMatrixPosition(r.parent.matrixWorld)),-1!==e.search("X")&&(r.position.x=Math.round(r.position.x/this.translationSnap)*this.translationSnap),-1!==e.search("Y")&&(r.position.y=Math.round(r.position.y/this.translationSnap)*this.translationSnap),-1!==e.search("Z")&&(r.position.z=Math.round(r.position.z/this.translationSnap)*this.translationSnap),r.parent&&r.position.sub(Ay.setFromMatrixPosition(r.parent.matrixWorld))));else if("scale"===n){if(-1!==e.search("XYZ")){let t=this.pointEnd.length()/this.pointStart.length();this.pointEnd.dot(this.pointStart)<0&&(t*=-1),Ey.set(t,t,t)}else Ay.copy(this.pointStart),Ey.copy(this.pointEnd),Ay.applyQuaternion(this._worldQuaternionInv),Ey.applyQuaternion(this._worldQuaternionInv),Ey.divide(Ay),-1===e.search("X")&&(Ey.x=1),-1===e.search("Y")&&(Ey.y=1),-1===e.search("Z")&&(Ey.z=1);r.scale.copy(this._scaleStart).multiply(Ey),this.scaleSnap&&(-1!==e.search("X")&&(r.scale.x=Math.round(r.scale.x/this.scaleSnap)*this.scaleSnap||this.scaleSnap),-1!==e.search("Y")&&(r.scale.y=Math.round(r.scale.y/this.scaleSnap)*this.scaleSnap||this.scaleSnap),-1!==e.search("Z")&&(r.scale.z=Math.round(r.scale.z/this.scaleSnap)*this.scaleSnap||this.scaleSnap))}else if("rotate"===n){this._offset.copy(this.pointEnd).sub(this.pointStart);const t=20/this.worldPosition.distanceTo(Ay.setFromMatrixPosition(this.camera.matrixWorld));"E"===e?(this.rotationAxis.copy(this.eye),this.rotationAngle=this.pointEnd.angleTo(this.pointStart),this._startNorm.copy(this.pointStart).normalize(),this._endNorm.copy(this.pointEnd).normalize(),this.rotationAngle*=this._endNorm.cross(this._startNorm).dot(this.eye)<0?1:-1):"XYZE"===e?(this.rotationAxis.copy(this._offset).cross(this.eye).normalize(),this.rotationAngle=this._offset.dot(Ay.copy(this.rotationAxis).cross(this.eye))*t):"X"!==e&&"Y"!==e&&"Z"!==e||(this.rotationAxis.copy(Py[e]),Ay.copy(Py[e]),"local"===i&&Ay.applyQuaternion(this.worldQuaternion),this.rotationAngle=this._offset.dot(Ay.cross(this.eye).normalize())*t),this.rotationSnap&&(this.rotationAngle=Math.round(this.rotationAngle/this.rotationSnap)*this.rotationSnap),"local"===i&&"E"!==e&&"XYZE"!==e?(r.quaternion.copy(this._quaternionStart),r.quaternion.multiply(Cy.setFromAxisAngle(this.rotationAxis,this.rotationAngle)).normalize()):(this.rotationAxis.applyQuaternion(this._parentQuaternionInv),r.quaternion.copy(Cy.setFromAxisAngle(this.rotationAxis,this.rotationAngle)),r.quaternion.multiply(this._quaternionStart).normalize())}this.dispatchEvent(Ly),this.dispatchEvent(Dy)}}pointerUp(t){0===t.button&&(this.dragging&&null!==this.axis&&(Fy.mode=this.mode,this.dispatchEvent(Fy)),this.dragging=!1,this.axis=null)}dispose(){this.domElement.removeEventListener("pointerdown",this._onPointerDown),this.domElement.removeEventListener("pointermove",this._onPointerHover),this.domElement.removeEventListener("pointermove",this._onPointerMove),this.domElement.removeEventListener("pointerup",this._onPointerUp),this.traverse((function(t){t.geometry&&t.geometry.dispose(),t.material&&t.material.dispose()}))}attach(t){return this.object=t,this.visible=!0,this}detach(){return this.object=void 0,this.visible=!1,this.axis=null,this}reset(){this.enabled&&this.dragging&&(this.object.position.copy(this._positionStart),this.object.quaternion.copy(this._quaternionStart),this.object.scale.copy(this._scaleStart),this.dispatchEvent(Ly),this.dispatchEvent(Dy),this.pointStart.copy(this.pointEnd))}getRaycaster(){return Sy}getMode(){return this.mode}setMode(t){this.mode=t}setTranslationSnap(t){this.translationSnap=t}setRotationSnap(t){this.rotationSnap=t}setScaleSnap(t){this.scaleSnap=t}setSize(t){this.size=t}setSpace(t){this.space=t}update(){console.warn("THREE.TransformControls: update function has no more functionality and therefore has been deprecated.")}}function Uy(t){if(this.domElement.ownerDocument.pointerLockElement)return{x:0,y:0,button:t.button};{const e=this.domElement.getBoundingClientRect();return{x:(t.clientX-e.left)/e.width*2-1,y:-(t.clientY-e.top)/e.height*2+1,button:t.button}}}function Ny(t){if(this.enabled)switch(t.pointerType){case"mouse":case"pen":this.pointerHover(this._getPointer(t))}}function Oy(t){this.enabled&&(document.pointerLockElement||this.domElement.setPointerCapture(t.pointerId),this.domElement.addEventListener("pointermove",this._onPointerMove),this.pointerHover(this._getPointer(t)),this.pointerDown(this._getPointer(t)))}function By(t){this.enabled&&this.pointerMove(this._getPointer(t))}function zy(t){this.enabled&&(this.domElement.releasePointerCapture(t.pointerId),this.domElement.removeEventListener("pointermove",this._onPointerMove),this.pointerUp(this._getPointer(t)))}function ky(t,e,n){const r=e.intersectObject(t,!0);for(let t=0;t<r.length;t++)if(r[t].object.visible||n)return r[t];return!1}Iy.prototype.isTransformControls=!0;const Hy=new Qr,Gy=new lr(0,1,0),Vy=new lr(0,0,0),Wy=new zr,Xy=new or,jy=new or,Yy=new lr,qy=new zr,Qy=new lr(1,0,0),Zy=new lr(0,1,0),Jy=new lr(0,0,1),Ky=new lr,$y=new lr,tw=new lr;class ew extends hi{constructor(){super(),this.type="TransformControlsGizmo";const t=new Ri({depthTest:!1,depthWrite:!1,fog:!1,toneMapped:!1,transparent:!0}),e=new gc({depthTest:!1,depthWrite:!1,fog:!1,toneMapped:!1,transparent:!0}),n=t.clone();n.opacity=.15;const r=e.clone();r.opacity=.5;const i=t.clone();i.color.setHex(16711680);const s=t.clone();s.color.setHex(65280);const a=t.clone();a.color.setHex(255);const o=t.clone();o.color.setHex(16711680),o.opacity=.5;const l=t.clone();l.color.setHex(65280),l.opacity=.5;const c=t.clone();c.color.setHex(255),c.opacity=.5;const h=t.clone();h.opacity=.25;const u=t.clone();u.color.setHex(16776960),u.opacity=.25,t.clone().color.setHex(16776960);const d=t.clone();d.color.setHex(7895160);const p=new zc(0,.04,.1,12);p.translate(0,.05,0);const f=new xs(.08,.08,.08);f.translate(0,.04,0);const m=new Ki;m.setAttribute("position",new Vi([0,0,0,1,0,0],3));const g=new zc(.0075,.0075,.5,3);function v(t,e){const n=new $h(t,.0075,3,64,e*Math.PI*2);return n.rotateY(Math.PI/2),n.rotateX(Math.PI/2),n}g.translate(0,.25,0);const x={X:[[new gs(p,i),[.5,0,0],[0,0,-Math.PI/2]],[new gs(p,i),[-.5,0,0],[0,0,Math.PI/2]],[new gs(g,i),[0,0,0],[0,0,-Math.PI/2]]],Y:[[new gs(p,s),[0,.5,0]],[new gs(p,s),[0,-.5,0],[Math.PI,0,0]],[new gs(g,s)]],Z:[[new gs(p,a),[0,0,.5],[Math.PI/2,0,0]],[new gs(p,a),[0,0,-.5],[-Math.PI/2,0,0]],[new gs(g,a),null,[Math.PI/2,0,0]]],XYZ:[[new gs(new qh(.1,0),h.clone()),[0,0,0]]],XY:[[new gs(new xs(.15,.15,.01),c.clone()),[.15,.15,0]]],YZ:[[new gs(new xs(.15,.15,.01),o.clone()),[0,.15,.15],[0,Math.PI/2,0]]],XZ:[[new gs(new xs(.15,.15,.01),l.clone()),[.15,0,.15],[-Math.PI/2,0,0]]]},y={X:[[new gs(new zc(.2,0,.6,4),n),[.3,0,0],[0,0,-Math.PI/2]],[new gs(new zc(.2,0,.6,4),n),[-.3,0,0],[0,0,Math.PI/2]]],Y:[[new gs(new zc(.2,0,.6,4),n),[0,.3,0]],[new gs(new zc(.2,0,.6,4),n),[0,-.3,0],[0,0,Math.PI]]],Z:[[new gs(new zc(.2,0,.6,4),n),[0,0,.3],[Math.PI/2,0,0]],[new gs(new zc(.2,0,.6,4),n),[0,0,-.3],[-Math.PI/2,0,0]]],XYZ:[[new gs(new qh(.2,0),n)]],XY:[[new gs(new xs(.2,.2,.01),n),[.15,.15,0]]],YZ:[[new gs(new xs(.2,.2,.01),n),[0,.15,.15],[0,Math.PI/2,0]]],XZ:[[new gs(new xs(.2,.2,.01),n),[.15,0,.15],[-Math.PI/2,0,0]]]},w={START:[[new gs(new qh(.01,2),r),null,null,null,"helper"]],END:[[new gs(new qh(.01,2),r),null,null,null,"helper"]],DELTA:[[new _c(function(){const t=new Ki;return t.setAttribute("position",new Vi([0,0,0,1,1,1],3)),t}(),r),null,null,null,"helper"]],X:[[new _c(m,r.clone()),[-1e3,0,0],null,[1e6,1,1],"helper"]],Y:[[new _c(m,r.clone()),[0,-1e3,0],[0,0,Math.PI/2],[1e6,1,1],"helper"]],Z:[[new _c(m,r.clone()),[0,0,-1e3],[0,-Math.PI/2,0],[1e6,1,1],"helper"]]},b={XYZE:[[new gs(v(.5,1),d),null,[0,Math.PI/2,0]]],X:[[new gs(v(.5,.5),i)]],Y:[[new gs(v(.5,.5),s),null,[0,0,-Math.PI/2]]],Z:[[new gs(v(.5,.5),a),null,[0,Math.PI/2,0]]],E:[[new gs(v(.75,1),u),null,[0,Math.PI/2,0]]]},_={AXIS:[[new _c(m,r.clone()),[-1e3,0,0],null,[1e6,1,1],"helper"]]},M={XYZE:[[new gs(new Jh(.25,10,8),n)]],X:[[new gs(new $h(.5,.1,4,24),n),[0,0,0],[0,-Math.PI/2,-Math.PI/2]]],Y:[[new gs(new $h(.5,.1,4,24),n),[0,0,0],[Math.PI/2,0,0]]],Z:[[new gs(new $h(.5,.1,4,24),n),[0,0,0],[0,0,-Math.PI/2]]],E:[[new gs(new $h(.75,.1,2,24),n)]]},T={X:[[new gs(f,i),[.5,0,0],[0,0,-Math.PI/2]],[new gs(g,i),[0,0,0],[0,0,-Math.PI/2]],[new gs(f,i),[-.5,0,0],[0,0,Math.PI/2]]],Y:[[new gs(f,s),[0,.5,0]],[new gs(g,s)],[new gs(f,s),[0,-.5,0],[0,0,Math.PI]]],Z:[[new gs(f,a),[0,0,.5],[Math.PI/2,0,0]],[new gs(g,a),[0,0,0],[Math.PI/2,0,0]],[new gs(f,a),[0,0,-.5],[-Math.PI/2,0,0]]],XY:[[new gs(new xs(.15,.15,.01),c),[.15,.15,0]]],YZ:[[new gs(new xs(.15,.15,.01),o),[0,.15,.15],[0,Math.PI/2,0]]],XZ:[[new gs(new xs(.15,.15,.01),l),[.15,0,.15],[-Math.PI/2,0,0]]],XYZ:[[new gs(new xs(.1,.1,.1),h.clone())]]},S={X:[[new gs(new zc(.2,0,.6,4),n),[.3,0,0],[0,0,-Math.PI/2]],[new gs(new zc(.2,0,.6,4),n),[-.3,0,0],[0,0,Math.PI/2]]],Y:[[new gs(new zc(.2,0,.6,4),n),[0,.3,0]],[new gs(new zc(.2,0,.6,4),n),[0,-.3,0],[0,0,Math.PI]]],Z:[[new gs(new zc(.2,0,.6,4),n),[0,0,.3],[Math.PI/2,0,0]],[new gs(new zc(.2,0,.6,4),n),[0,0,-.3],[-Math.PI/2,0,0]]],XY:[[new gs(new xs(.2,.2,.01),n),[.15,.15,0]]],YZ:[[new gs(new xs(.2,.2,.01),n),[0,.15,.15],[0,Math.PI/2,0]]],XZ:[[new gs(new xs(.2,.2,.01),n),[.15,0,.15],[-Math.PI/2,0,0]]],XYZ:[[new gs(new xs(.2,.2,.2),n),[0,0,0]]]},A={X:[[new _c(m,r.clone()),[-1e3,0,0],null,[1e6,1,1],"helper"]],Y:[[new _c(m,r.clone()),[0,-1e3,0],[0,0,Math.PI/2],[1e6,1,1],"helper"]],Z:[[new _c(m,r.clone()),[0,0,-1e3],[0,-Math.PI/2,0],[1e6,1,1],"helper"]]};function E(t){const e=new hi;for(const n in t)for(let r=t[n].length;r--;){const i=t[n][r][0].clone(),s=t[n][r][1],a=t[n][r][2],o=t[n][r][3],l=t[n][r][4];i.name=n,i.tag=l,s&&i.position.set(s[0],s[1],s[2]),a&&i.rotation.set(a[0],a[1],a[2]),o&&i.scale.set(o[0],o[1],o[2]),i.updateMatrix();const c=i.geometry.clone();c.applyMatrix4(i.matrix),i.geometry=c,i.renderOrder=1/0,i.position.set(0,0,0),i.rotation.set(0,0,0),i.scale.set(1,1,1),e.add(i)}return e}this.gizmo={},this.picker={},this.helper={},this.add(this.gizmo.translate=E(x)),this.add(this.gizmo.rotate=E(b)),this.add(this.gizmo.scale=E(T)),this.add(this.picker.translate=E(y)),this.add(this.picker.rotate=E(M)),this.add(this.picker.scale=E(S)),this.add(this.helper.translate=E(w)),this.add(this.helper.rotate=E(_)),this.add(this.helper.scale=E(A)),this.picker.translate.visible=!1,this.picker.rotate.visible=!1,this.picker.scale.visible=!1}updateMatrixWorld(t){const e="local"===("scale"===this.mode?"local":this.space)?this.worldQuaternion:jy;this.gizmo.translate.visible="translate"===this.mode,this.gizmo.rotate.visible="rotate"===this.mode,this.gizmo.scale.visible="scale"===this.mode,this.helper.translate.visible="translate"===this.mode,this.helper.rotate.visible="rotate"===this.mode,this.helper.scale.visible="scale"===this.mode;let n=[];n=n.concat(this.picker[this.mode].children),n=n.concat(this.gizmo[this.mode].children),n=n.concat(this.helper[this.mode].children);for(let t=0;t<n.length;t++){const r=n[t];let i;if(r.visible=!0,r.rotation.set(0,0,0),r.position.copy(this.worldPosition),i=this.camera.isOrthographicCamera?(this.camera.top-this.camera.bottom)/this.camera.zoom:this.worldPosition.distanceTo(this.cameraPosition)*Math.min(1.9*Math.tan(Math.PI*this.camera.fov/360)/this.camera.zoom,7),r.scale.set(1,1,1).multiplyScalar(i*this.size/4),"helper"!==r.tag){if(r.quaternion.copy(e),"translate"===this.mode||"scale"===this.mode){const t=.99,n=.2;"X"===r.name&&Math.abs(Gy.copy(Qy).applyQuaternion(e).dot(this.eye))>t&&(r.scale.set(1e-10,1e-10,1e-10),r.visible=!1),"Y"===r.name&&Math.abs(Gy.copy(Zy).applyQuaternion(e).dot(this.eye))>t&&(r.scale.set(1e-10,1e-10,1e-10),r.visible=!1),"Z"===r.name&&Math.abs(Gy.copy(Jy).applyQuaternion(e).dot(this.eye))>t&&(r.scale.set(1e-10,1e-10,1e-10),r.visible=!1),"XY"===r.name&&Math.abs(Gy.copy(Jy).applyQuaternion(e).dot(this.eye))<n&&(r.scale.set(1e-10,1e-10,1e-10),r.visible=!1),"YZ"===r.name&&Math.abs(Gy.copy(Qy).applyQuaternion(e).dot(this.eye))<n&&(r.scale.set(1e-10,1e-10,1e-10),r.visible=!1),"XZ"===r.name&&Math.abs(Gy.copy(Zy).applyQuaternion(e).dot(this.eye))<n&&(r.scale.set(1e-10,1e-10,1e-10),r.visible=!1)}else"rotate"===this.mode&&(Xy.copy(e),Gy.copy(this.eye).applyQuaternion(Cy.copy(e).invert()),-1!==r.name.search("E")&&r.quaternion.setFromRotationMatrix(Wy.lookAt(this.eye,Vy,Zy)),"X"===r.name&&(Cy.setFromAxisAngle(Qy,Math.atan2(-Gy.y,Gy.z)),Cy.multiplyQuaternions(Xy,Cy),r.quaternion.copy(Cy)),"Y"===r.name&&(Cy.setFromAxisAngle(Zy,Math.atan2(Gy.x,Gy.z)),Cy.multiplyQuaternions(Xy,Cy),r.quaternion.copy(Cy)),"Z"===r.name&&(Cy.setFromAxisAngle(Jy,Math.atan2(Gy.y,Gy.x)),Cy.multiplyQuaternions(Xy,Cy),r.quaternion.copy(Cy)));r.visible=r.visible&&(-1===r.name.indexOf("X")||this.showX),r.visible=r.visible&&(-1===r.name.indexOf("Y")||this.showY),r.visible=r.visible&&(-1===r.name.indexOf("Z")||this.showZ),r.visible=r.visible&&(-1===r.name.indexOf("E")||this.showX&&this.showY&&this.showZ),r.material._color=r.material._color||r.material.color.clone(),r.material._opacity=r.material._opacity||r.material.opacity,r.material.color.copy(r.material._color),r.material.opacity=r.material._opacity,this.enabled&&this.axis&&(r.name===this.axis||this.axis.split("").some((function(t){return r.name===t})))&&(r.material.color.setHex(16776960),r.material.opacity=1)}else r.visible=!1,"AXIS"===r.name?(r.position.copy(this.worldPositionStart),r.visible=!!this.axis,"X"===this.axis&&(Cy.setFromEuler(Hy.set(0,0,0)),r.quaternion.copy(e).multiply(Cy),Math.abs(Gy.copy(Qy).applyQuaternion(e).dot(this.eye))>.9&&(r.visible=!1)),"Y"===this.axis&&(Cy.setFromEuler(Hy.set(0,0,Math.PI/2)),r.quaternion.copy(e).multiply(Cy),Math.abs(Gy.copy(Zy).applyQuaternion(e).dot(this.eye))>.9&&(r.visible=!1)),"Z"===this.axis&&(Cy.setFromEuler(Hy.set(0,Math.PI/2,0)),r.quaternion.copy(e).multiply(Cy),Math.abs(Gy.copy(Jy).applyQuaternion(e).dot(this.eye))>.9&&(r.visible=!1)),"XYZE"===this.axis&&(Cy.setFromEuler(Hy.set(0,Math.PI/2,0)),Gy.copy(this.rotationAxis),r.quaternion.setFromRotationMatrix(Wy.lookAt(Vy,Gy,Zy)),r.quaternion.multiply(Cy),r.visible=this.dragging),"E"===this.axis&&(r.visible=!1)):"START"===r.name?(r.position.copy(this.worldPositionStart),r.visible=this.dragging):"END"===r.name?(r.position.copy(this.worldPosition),r.visible=this.dragging):"DELTA"===r.name?(r.position.copy(this.worldPositionStart),r.quaternion.copy(this.worldQuaternionStart),Ay.set(1e-10,1e-10,1e-10).add(this.worldPositionStart).sub(this.worldPosition).multiplyScalar(-1),Ay.applyQuaternion(this.worldQuaternionStart.clone().invert()),r.scale.copy(Ay),r.visible=this.dragging):(r.quaternion.copy(e),this.dragging?r.position.copy(this.worldPositionStart):r.position.copy(this.worldPosition),this.axis&&(r.visible=-1!==this.axis.search(r.name)))}super.updateMatrixWorld(t)}}ew.prototype.isTransformControlsGizmo=!0;class nw extends gs{constructor(){super(new Bs(1e5,1e5,2,2),new Ri({visible:!1,wireframe:!0,side:w,transparent:!0,opacity:.1,toneMapped:!1})),this.type="TransformControlsPlane"}updateMatrixWorld(t){let e=this.space;switch(this.position.copy(this.worldPosition),"scale"===this.mode&&(e="local"),Ky.copy(Qy).applyQuaternion("local"===e?this.worldQuaternion:jy),$y.copy(Zy).applyQuaternion("local"===e?this.worldQuaternion:jy),tw.copy(Jy).applyQuaternion("local"===e?this.worldQuaternion:jy),Gy.copy($y),this.mode){case"translate":case"scale":switch(this.axis){case"X":Gy.copy(this.eye).cross(Ky),Yy.copy(Ky).cross(Gy);break;case"Y":Gy.copy(this.eye).cross($y),Yy.copy($y).cross(Gy);break;case"Z":Gy.copy(this.eye).cross(tw),Yy.copy(tw).cross(Gy);break;case"XY":Yy.copy(tw);break;case"YZ":Yy.copy(Ky);break;case"XZ":Gy.copy(tw),Yy.copy($y);break;case"XYZ":case"E":Yy.set(0,0,0)}break;default:Yy.set(0,0,0)}0===Yy.length()?this.quaternion.copy(this.cameraQuaternion):(qy.lookAt(Ay.set(0,0,0),Yy,Gy),this.quaternion.setFromRotationMatrix(qy)),super.updateMatrixWorld(t)}}function rw(t=class{}){return class extends t{constructor(t){super(t),this.isBoxComponent=!0,this.childrenPos={}}getInnerWidth(){const t=this.getContentDirection();switch(t){case"row":case"row-reverse":return this.width-(2*this.padding||0)||this.getChildrenSideSum("width");case"column":case"column-reverse":return this.getHighestChildSizeOn("width");default:console.error(`Invalid contentDirection : ${t}`)}}getInnerHeight(){const t=this.getContentDirection();switch(t){case"row":case"row-reverse":return this.getHighestChildSizeOn("height");case"column":case"column-reverse":return this.height-(2*this.padding||0)||this.getChildrenSideSum("height");default:console.error(`Invalid contentDirection : ${t}`)}}getChildrenSideSum(t){return this.children.reduce(((e,n)=>{if(!n.isBoxComponent)return e;const r=2*n.margin||0;return e+("width"===t?n.getWidth()+r:n.getHeight()+r)}),0)}setPosFromParentRecords(){this.getUIParent()&&this.getUIParent().childrenPos[this.id]&&(this.position.x=this.getUIParent().childrenPos[this.id].x,this.position.y=this.getUIParent().childrenPos[this.id].y)}computeChildrenPosition(){if(this.children.length>0){let t,e;switch(this.getContentDirection()){case"row":t=this.getInnerWidth()/2,this.setChildrenXPos(-t),this.alignChildrenOnY();break;case"row-reverse":t=this.getInnerWidth()/2,this.setChildrenXPos(t),this.alignChildrenOnY();break;case"column":e=this.getInnerHeight()/2,this.setChildrenYPos(e),this.alignChildrenOnX();break;case"column-reverse":e=this.getInnerHeight()/2,this.setChildrenYPos(-e),this.alignChildrenOnX()}}}setChildrenXPos(t){const e=this.getJustifyContent();if("center"!==e&&"start"!==e&&"end"!==e&&console.warn(`justifiyContent === '${e}' is not supported`),this.children.reduce(((e,n)=>{if(!n.isBoxComponent)return e;const r=n.id,i=n.getWidth(),s=n.margin||0;return e+=s*-Math.sign(t),this.childrenPos[r]={x:e+i/2*-Math.sign(t),y:0},e+-Math.sign(t)*(i+s)}),t),"end"===e||"center"===e){let n=2*t-this.getChildrenSideSum("width")*Math.sign(t);"center"===e&&(n/=2),this.children.forEach((t=>{t.isBoxComponent&&(this.childrenPos[t.id].x-=n)}))}}setChildrenYPos(t){const e=this.getJustifyContent();if(this.children.reduce(((e,n)=>{if(!n.isBoxComponent)return e;const r=n.id,i=n.getHeight(),s=n.margin||0;return e+=s*-Math.sign(t),this.childrenPos[r]={x:0,y:e+i/2*-Math.sign(t)},e+-Math.sign(t)*(i+s)}),t),"end"===e||"center"===e){let n=2*t-this.getChildrenSideSum("height")*Math.sign(t);"center"===e&&(n/=2),this.children.forEach((t=>{t.isBoxComponent&&(this.childrenPos[t.id].y-=n)}))}}alignChildrenOnX(){const t=this.getAlignContent(),e=this.getWidth()/2-(this.padding||0);"center"!==t&&"right"!==t&&"left"!==t&&console.warn(`alignContent === '${t}' is not supported on this direction.`),this.children.forEach((n=>{if(!n.isBoxComponent)return;let r;"right"===t?r=e-n.getWidth()/2-(n.margin||0):"left"===t&&(r=-e+n.getWidth()/2+(n.margin||0)),this.childrenPos[n.id].x=r||0}))}alignChildrenOnY(){const t=this.getAlignContent(),e=this.getHeight()/2-(this.padding||0);"center"!==t&&"top"!==t&&"bottom"!==t&&console.warn(`alignContent === '${t}' is not supported on this direction.`),this.children.forEach((n=>{if(!n.isBoxComponent)return;let r;"top"===t?r=e-n.getHeight()/2-(n.margin||0):"bottom"===t&&(r=-e+n.getHeight()/2+(n.margin||0)),this.childrenPos[n.id].y=r||0}))}getHighestChildSizeOn(t){return this.children.reduce(((e,n)=>{if(!n.isBoxComponent)return e;const r=n.margin||0,i="width"===t?n.getWidth()+2*r:n.getHeight()+2*r;return Math.max(e,i)}),0)}getWidth(){return this.width||this.getInnerWidth()+(2*this.padding||0)}getHeight(){return this.height||this.getInnerHeight()+(2*this.padding||0)}}}function iw(t=class{}){return class extends t{computeInlinesPosition(){const t=this.getWidth()-(2*this.padding||0),e=[[]];this.children.filter((t=>!!t.isInline)).reduce(((n,r)=>{if(!r.inlines)return;const i=r.isText?r.getLetterSpacing()*r.getFontSize():0,s=r.inlines.reduce(((n,r,s,a)=>{const o=r.kerning?r.kerning:0,l=r.xoffset?r.xoffset:0,c=r.xadvance?r.xadvance:r.width,h=this.distanceToNextBreak(a,s,i);return n+c+l+o>t||"mandatory"===r.lineBreak||this.shouldFriendlyBreak(a[s-1],n,h,t)?(e.push([r]),r.offsetX=l,r.width>0?c+l+i:0):(e[e.length-1].push(r),r.offsetX=n+l+o,n+c+o+i)}),n);return s}),0);const n=this.getHeight()-(2*this.padding||0),r=this.getJustifyContent(),i=this.getAlignContent(),s=this.getInterLine();e.forEach((t=>{t.lineHeight=t.reduce(((t,e)=>{const n=void 0!==e.lineHeight?e.lineHeight:e.height;return Math.max(t,n)}),0),t.lineBase=t.reduce(((t,e)=>{const n=void 0!==e.lineBase?e.lineBase:e.height;return Math.max(t,n)}),0),t.width=t.reduce(((t,e)=>{const n=e.kerning?e.kerning:0,r=e.xoffset?e.xoffset:0;return t+(e.xadvance?e.xadvance:e.width)+r+n}),0)}));let a=e.reduce(((t,e,n,r)=>{const i=e.lineHeight-e.lineBase;return e.forEach((n=>{n.offsetY=t-e.lineHeight+i+r[0].lineHeight})),t-e.lineHeight-s}),0)+s;a=Math.abs(a);const o=(()=>{switch(r){case"start":return n/2-e[0].lineHeight;case"end":return a-e[0].lineHeight-n/2+(e[e.length-1].lineHeight-e[e.length-1].lineHeight);case"center":return a/2-e[0].lineHeight;default:console.warn(`justifyContent: '${r}' is not valid`)}})();e.forEach((t=>{t.forEach((t=>{t.offsetY+=o}))})),e.forEach((e=>{const n=(()=>{switch(i){case"left":return-t/2;case"right":return-e.width+t/2;case"center":return-e.width/2;default:console.warn(`alignContent: '${i}' is not valid`)}})();e.forEach((t=>{t.offsetX+=n}))}))}distanceToNextBreak(t,e,n,r){if(r=r||0,!t[e])return r;const i=t[e],s=i.kerning?i.kerning:0,a=i.xoffset?i.xoffset:0,o=i.xadvance?i.xadvance:i.width;return i.lineBreak?r+o:this.distanceToNextBreak(t,e+1,n,r+o+n+a+s)}shouldFriendlyBreak(t,e,n,r){return!(!t||!t.glyph)&&(!(e+n<r)&&this.getBreakOn().indexOf(t.glyph)>-1)}}}nw.prototype.isTransformControlsPlane=!0;const sw=new Uu,aw=[],ow={},lw=new Hu,cw=[],hw={},uw={};function dw(t){if(t._kernings)return;const e={};for(let n=0;n<t.kernings.length;n++){const r=t.kernings[n];0!==r.amount&&(e[String.fromCharCode(r.first,r.second)]=r.amount)}t._kernings=e}const pw={setFontFamily:function(t,e){"string"==typeof e?function(t,e){-1===aw.indexOf(e)&&(aw.push(e),sw.load(e,(t=>{const n=JSON.parse(t);dw(n),ow[e]=n;for(const t of Object.keys(uw))e===uw[t].jsonURL&&uw[t].component._updateFontFamily(n)}))),uw[t.id]||(uw[t.id]={component:t}),uw[t.id].jsonURL=e,ow[e]&&t._updateFontFamily(ow[e])}(t,e):(uw[t.id]||(uw[t.id]={component:t}),dw(e),uw[t.id].json=e,t._updateFontFamily(e))},setFontTexture:function(t,e){-1===cw.indexOf(e)&&(cw.push(e),lw.load(e,(t=>{hw[e]=t;for(const n of Object.keys(uw))e===uw[n].textureURL&&uw[n].component._updateFontTexture(t)}))),uw[t.id]||(uw[t.id]={component:t}),uw[t.id].textureURL=e,hw[e]&&t._updateFontTexture(hw[e])},getFontOf:function t(e){const n=uw[e.id];return!n&&e.getUIParent()?t(e.getUIParent()):n},addFont:function(t,e,n){aw.push(t),ow[t]=e,dw(e),n&&(cw.push(t),hw[t]=n)}};class fw{static requestUpdate(t,e,n,r){t.traverse((t=>{t.isUI&&(this.requestedUpdates[t.id]?(e&&(this.requestedUpdates[t.id].updateParsing=!0),n&&(this.requestedUpdates[t.id].updateLayout=!0),r&&(this.requestedUpdates[t.id].updateInner=!0)):this.requestedUpdates[t.id]={updateParsing:e,updateLayout:n,updateInner:r,needCallback:e||n||r})}))}static register(t){this.components.includes(t)||this.components.push(t)}static disposeOf(t){const e=this.components.indexOf(t);e>-1&&this.components.splice(e,1)}static update(){if(Object.keys(this.requestedUpdates).length>0){const t=this.components.filter((t=>!t.getUIParent()));t.forEach((t=>this.traverseParsing(t))),t.forEach((t=>this.traverseUpdates(t)))}}static traverseParsing(t){const e=this.requestedUpdates[t.id];e&&e.updateParsing&&(t.parseParams(),e.updateParsing=!1),t.getUIChildren().forEach((t=>this.traverseParsing(t)))}static traverseUpdates(t){const e=this.requestedUpdates[t.id];e&&e.updateLayout&&(e.updateLayout=!1,t.updateLayout()),e&&e.updateInner&&(e.updateInner=!1,t.updateInner()),e&&e.needCallback&&t.onAfterUpdate(),delete this.requestedUpdates[t.id],t.getUIChildren().forEach((t=>{this.traverseUpdates(t)}))}}fw.components=[],fw.requestedUpdates={};const mw={container:null,fontFamily:null,fontSize:.05,fontKerning:"normal",offset:.01,interLine:.01,breakOn:"- ,.:?!",contentDirection:"column",alignContent:"center",justifyContent:"start",fontTexture:null,textType:"MSDF",fontColor:new Li(16777215),fontOpacity:1,borderRadius:.01,borderWidth:0,borderColor:new Li("black"),backgroundSize:"cover",backgroundColor:new Li(2236962),backgroundWhiteColor:new Li(16777215),backgroundOpacity:.8,backgroundOpaqueOpacity:1,backgroundTexture:function(){const t=document.createElement("canvas").getContext("2d");t.canvas.width=1,t.canvas.height=1,t.fillStyle="#ffffff",t.fillRect(0,0,1,1);const e=new Oc(t.canvas);return e.isDefault=!0,e}(),hiddenOverflow:!1,letterSpacing:0};function gw(t=class{}){return class extends t{constructor(t){super(t),this.states={},this.currentState=void 0,this.isUI=!0,this.autoLayout=!0}getClippingPlanes(){const t=[];if(this.parent&&this.parent.isUI){if(this.isBlock&&this.parent.getHiddenOverflow()){const e=this.parent.getHeight()/2-(this.parent.padding||0),n=this.parent.getWidth()/2-(this.parent.padding||0),r=[new Fs(new lr(0,1,0),e),new Fs(new lr(0,-1,0),e),new Fs(new lr(1,0,0),n),new Fs(new lr(-1,0,0),n)];r.forEach((t=>{t.applyMatrix4(this.parent.matrixWorld)})),t.push(...r)}this.parent.parent&&this.parent.parent.isUI&&t.push(...this.parent.getClippingPlanes())}return t}getUIChildren(){return this.children.filter((t=>t.isUI))}getUIParent(){return this.parent&&this.parent.isUI?this.parent:null}getHighestParent(){return this.getUIParent()?this.parent.getHighestParent():this}_getProperty(t){return void 0===this[t]&&this.getUIParent()?this.parent._getProperty(t):this[t]?this[t]:mw[t]}getFontSize(){return this._getProperty("fontSize")}getFontKerning(){return this._getProperty("fontKerning")}getLetterSpacing(){return this._getProperty("letterSpacing")}getFontTexture(){return this._getProperty("fontTexture")}getFontFamily(){return this._getProperty("fontFamily")}getBreakOn(){return this._getProperty("breakOn")}getTextType(){return this._getProperty("textType")}getFontColor(){return this._getProperty("fontColor")}getFontOpacity(){return this._getProperty("fontOpacity")}getBorderRadius(){return this._getProperty("borderRadius")}getBorderWidth(){return this._getProperty("borderWidth")}getBorderColor(){return this._getProperty("borderColor")}getBorderOpacity(){return this._getProperty("borderOpacity")}getContainer(){return!this.threeOBJ&&this.parent?this.parent.getContainer():this.threeOBJ?this:mw.container}getParentsNumber(t){return t=t||0,this.getUIParent()?this.parent.getParentsNumber(t+1):t}getBackgroundOpacity(){return this.backgroundOpacity||0===this.backgroundOpacity?this.backgroundOpacity:mw.backgroundOpacity}getBackgroundColor(){return this.backgroundColor||mw.backgroundColor}getBackgroundTexture(){return this.backgroundTexture||mw.backgroundTexture}getAlignContent(){return this.alignContent||mw.alignContent}getContentDirection(){return this.contentDirection||mw.contentDirection}getJustifyContent(){return this.justifyContent||mw.justifyContent}getInterLine(){return void 0===this.interLine?mw.interLine:this.interLine}getOffset(){return void 0===this.offset?mw.offset:this.offset}getBackgroundSize(){return void 0===this.backgroundSize?mw.backgroundSize:this.backgroundSize}getHiddenOverflow(){return void 0===this.hiddenOverflow?mw.hiddenOverflow:this.hiddenOverflow}add(){for(const t of Object.keys(arguments))arguments[t].isInline&&this.update(null,!0);return super.add(...arguments)}remove(){for(const t of Object.keys(arguments))arguments[t].isInline&&this.update(null,!0);return super.remove(...arguments)}update(t,e,n){fw.requestUpdate(this,t,e,n)}onAfterUpdate(){}_updateFontFamily(t){this.fontFamily=t,this.traverse((t=>{t.isUI&&t.update(!0,!0,!1)})),this.getHighestParent().update(!1,!0,!1)}_updateFontTexture(t){this.fontTexture=t,this.getHighestParent().update(!1,!0,!1)}set(t){let e,n,r;if(fw.register(this),t&&JSON.stringify(t)!==JSON.stringify({})){for(const i of Object.keys(t))switch(i){case"content":case"fontSize":case"fontKerning":this.isText&&(e=!0),n=!0,this[i]=t[i];break;case"width":case"height":case"padding":this.isInlineBlock&&(e=!0),n=!0,this[i]=t[i];break;case"letterSpacing":case"interLine":case"margin":case"contentDirection":case"justifyContent":case"alignContent":case"textType":case"src":n=!0,this[i]=t[i];break;case"fontColor":case"fontOpacity":case"offset":case"backgroundColor":case"backgroundOpacity":case"backgroundTexture":case"backgroundSize":case"borderRadius":case"borderWidth":case"borderColor":case"borderOpacity":r=!0,this[i]=t[i];break;case"hiddenOverflow":this[i]=t[i]}t.fontFamily&&(pw.setFontFamily(this,t.fontFamily),n=!1),t.fontTexture&&(pw.setFontTexture(this,t.fontTexture),n=!1),this.update(e,n,r),n&&this.getHighestParent().update(!1,!0,!1)}}setupState(t){this.states[t.state]={attributes:t.attributes,onSet:t.onSet}}setState(t){const e=this.states[t];e?t!==this.currentState&&(this.currentState=t,e.onSet&&e.onSet(),e.attributes&&this.set(e.attributes)):console.warn(`state "${t}" does not exist within this component`)}clear(){this.traverse((t=>{fw.disposeOf(t),t.material&&t.material.dispose(),t.geometry&&t.geometry.dispose()}))}}}function vw(t=class{}){return class extends t{getBackgroundUniforms(){let t,e;const n=this.getBackgroundTexture();return this.tSize.set(n.image.width,n.image.height),n.isDefault?(t=this.getBackgroundColor(),e=this.getBackgroundOpacity()):(t=this.backgroundColor||mw.backgroundWhiteColor,e=this.backgroundOpacity||0===this.backgroundOpacity?this.backgroundOpacity:mw.backgroundOpaqueOpacity),{texture:n,color:t,opacity:e,backgroundMapping:(()=>{switch(this.getBackgroundSize()){case"stretch":return 0;case"contain":return 1;case"cover":return 2}})(),borderRadius:this.getBorderRadius(),borderWidth:this.getBorderWidth(),borderColor:this.getBorderColor(),borderOpacity:this.getBorderOpacity(),size:this.size,tSize:this.tSize}}updateBackgroundMaterial(){if(this.backgroundUniforms){const t=this.getBackgroundUniforms();this.backgroundUniforms.u_texture.value=t.texture,this.backgroundUniforms.u_color.value=t.color,this.backgroundUniforms.u_opacity.value=t.opacity,this.backgroundUniforms.u_backgroundMapping.value=t.backgroundMapping,this.backgroundUniforms.u_size.value=t.size,this.backgroundUniforms.u_tSize.value=t.tSize,Array.isArray(t.borderRadius)?(this.backgroundUniforms.u_borderRadiusTopLeft.value=t.borderRadius[0],this.backgroundUniforms.u_borderRadiusTopRight.value=t.borderRadius[1],this.backgroundUniforms.u_borderRadiusBottomRight.value=t.borderRadius[2],this.backgroundUniforms.u_borderRadiusBottomLeft.value=t.borderRadius[3]):(this.backgroundUniforms.u_borderRadiusTopLeft.value=t.borderRadius,this.backgroundUniforms.u_borderRadiusTopRight.value=t.borderRadius,this.backgroundUniforms.u_borderRadiusBottomRight.value=t.borderRadius,this.backgroundUniforms.u_borderRadiusBottomLeft.value=t.borderRadius),this.backgroundUniforms.u_borderWidth.value=t.borderWidth,this.backgroundUniforms.u_borderColor.value=t.borderColor,this.backgroundUniforms.u_borderOpacity.value=t.borderOpacity}}updateTextMaterial(){this.textUniforms&&(this.textUniforms.u_texture.value=this.getFontTexture(),this.textUniforms.u_color.value=this.getFontColor(),this.textUniforms.u_opacity.value=this.getFontOpacity())}updateClippingPlanes(t){const e=void 0!==t?t:this.getClippingPlanes();JSON.stringify(e)!==JSON.stringify(this.clippingPlanes)&&(this.clippingPlanes=e,this.fontMaterial&&(this.fontMaterial.clippingPlanes=this.clippingPlanes),this.backgroundMaterial&&(this.backgroundMaterial.clippingPlanes=this.clippingPlanes))}getBackgroundMaterial(){const t=this.getBackgroundUniforms();if(!this.backgroundMaterial||!this.backgroundUniforms)return this.backgroundMaterial=this._makeBackgroundMaterial(t),this.backgroundMaterial;let e;return e=Array.isArray(t.borderRadius)?t.borderRadius[0]!==this.backgroundUniforms.u_borderRadiusTopLeft.value||t.borderRadius[1]!==this.backgroundUniforms.u_borderRadiusTopRight.value||t.borderRadius[2]!==this.backgroundUniforms.u_borderRadiusBottomRight.value||t.borderRadius[3]!==this.backgroundUniforms.u_borderRadiusBottomLeft.value:t.borderRadius!==this.backgroundUniforms.u_borderRadiusTopLeft.value||t.borderRadius!==this.backgroundUniforms.u_borderRadiusTopRight.value||t.borderRadius!==this.backgroundUniforms.u_borderRadiusBottomRight.value||t.borderRadius!==this.backgroundUniforms.u_borderRadiusBottomLeft.value,(t.texture!==this.backgroundUniforms.u_texture.value||t.color!==this.backgroundUniforms.u_color.value||t.opacity!==this.backgroundUniforms.u_opacity.value||t.backgroundMapping!==this.backgroundUniforms.u_backgroundMapping.value||e||t.borderWidth!==this.backgroundUniforms.u_borderWidth.value||t.borderColor!==this.backgroundUniforms.u_borderColor.value||t.borderOpacity!==this.backgroundUniforms.u_borderOpacity.value||t.size!==this.backgroundUniforms.u_size.value||t.tSize!==this.backgroundUniforms.u_tSize.value)&&this.updateBackgroundMaterial(),this.backgroundMaterial}getFontMaterial(){const t={u_texture:this.getFontTexture(),u_color:this.getFontColor(),u_opacity:this.getFontOpacity()};return this.fontMaterial&&this.textUniforms?t.u_texture===this.textUniforms.u_texture.value&&t.u_color===this.textUniforms.u_color.value&&t.u_opacity===this.textUniforms.u_opacity.value||this.updateTextMaterial():this.fontMaterial=this._makeTextMaterial(t),this.fontMaterial}_makeTextMaterial(t){return this.textUniforms={u_texture:{value:t.u_texture},u_color:{value:t.u_color},u_opacity:{value:t.u_opacity}},new _s({uniforms:this.textUniforms,transparent:!0,clipping:!0,vertexShader:xw,fragmentShader:yw,extensions:{derivatives:!0}})}_makeBackgroundMaterial(t){return this.backgroundUniforms={u_texture:{value:t.texture},u_color:{value:t.color},u_opacity:{value:t.opacity},u_backgroundMapping:{value:t.backgroundMapping},u_borderWidth:{value:t.borderWidth},u_borderColor:{value:t.borderColor},u_borderRadiusTopLeft:{value:0},u_borderRadiusTopRight:{value:0},u_borderRadiusBottomRight:{value:0},u_borderRadiusBottomLeft:{value:0},u_borderOpacity:{value:t.borderOpacity},u_size:{value:t.size},u_tSize:{value:t.tSize}},Array.isArray(t.borderRadius)?(this.backgroundUniforms.u_borderRadiusTopLeft.values=t.borderRadius[0],this.backgroundUniforms.u_borderRadiusTopRight.values=t.borderRadius[1],this.backgroundUniforms.u_borderRadiusBottomRight.values=t.borderRadius[2],this.backgroundUniforms.u_borderRadiusBottomLeft.values=t.borderRadius[3]):(this.backgroundUniforms.u_borderRadiusTopLeft.values=t.borderRadius,this.backgroundUniforms.u_borderRadiusTopRight.values=t.borderRadius,this.backgroundUniforms.u_borderRadiusBottomRight.values=t.borderRadius,this.backgroundUniforms.u_borderRadiusBottomLeft.values=t.borderRadius),new _s({uniforms:this.backgroundUniforms,transparent:!0,clipping:!0,vertexShader:ww,fragmentShader:bw,extensions:{derivatives:!0}})}}}const xw="\n\tvarying vec2 vUv;\n\n\t#include <clipping_planes_pars_vertex>\n\n\tvoid main() {\n\n\t\tvUv = uv;\n\t\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\t\tgl_Position = projectionMatrix * mvPosition;\n\t\tgl_Position.z -= 0.00001;\n\n\t\t#include <clipping_planes_vertex>\n\n\t}\n",yw="\n\tuniform sampler2D u_texture;\n\tuniform vec3 u_color;\n\tuniform float u_opacity;\n\n\tvarying vec2 vUv;\n\n\t#include <clipping_planes_pars_fragment>\n\n\tfloat median(float r, float g, float b) {\n\t\treturn max(min(r, g), min(max(r, g), b));\n\t}\n\n\tvoid main() {\n\n\t\tvec3 textureSample = texture2D( u_texture, vUv ).rgb;\n\t\tfloat sigDist = median( textureSample.r, textureSample.g, textureSample.b ) - 0.5;\n\t\tfloat alpha = clamp( sigDist / fwidth( sigDist ) + 0.5, 0.0, 1.0 );\n\t\talpha = min( alpha, u_opacity );\n\t\t\n\t\tif( alpha < 0.02) discard;\n\t\t\n\t\tgl_FragColor = vec4( u_color, alpha );\n        // gl_FragColor = vec4( 1.0 );\n\t\n\t\t#include <clipping_planes_fragment>\n\n\t}\n",ww="\n\tvarying vec2 vUv;\n\n\t#include <clipping_planes_pars_vertex>\n\n\tvoid main() {\n\n\t\tvUv = uv;\n\t\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\t\tgl_Position = projectionMatrix * mvPosition;\n\n\t\t#include <clipping_planes_vertex>\n\n\t}\n",bw="\n\tuniform sampler2D u_texture;\n\tuniform vec3 u_color;\n\tuniform float u_opacity;\n\n    uniform float u_borderRadiusTopLeft;\n    uniform float u_borderRadiusTopRight;\n    uniform float u_borderRadiusBottomLeft;\n    uniform float u_borderRadiusBottomRight;\n    uniform float u_borderWidth;\n    uniform vec3 u_borderColor;\n    uniform float u_borderOpacity;\n    uniform vec2 u_size;\n    uniform vec2 u_tSize;\n    uniform int u_backgroundMapping;\n\n\tvarying vec2 vUv;\n\n\t#include <clipping_planes_pars_fragment>\n\n    float getEdgeDist() {\n        vec2 ndc = vec2( vUv.x * 2.0 - 1.0, vUv.y * 2.0 - 1.0 );\n        vec2 planeSpaceCoord = vec2( u_size.x * 0.5 * ndc.x, u_size.y * 0.5 * ndc.y );\n        vec2 corner = u_size * 0.5;\n        vec2 offsetCorner = corner - abs( planeSpaceCoord );\n        float innerRadDist = min( offsetCorner.x, offsetCorner.y ) * -1.0;\n        if (vUv.x < 0.5 && vUv.y >= 0.5) {\n            float roundedDist = length( max( abs( planeSpaceCoord ) - u_size * 0.5 + u_borderRadiusTopLeft, 0.0 ) ) - u_borderRadiusTopLeft;\n            float s = step( innerRadDist * -1.0, u_borderRadiusTopLeft );\n            return mix( innerRadDist, roundedDist, s );\n        }\n        if (vUv.x >= 0.5 && vUv.y >= 0.5) {\n            float roundedDist = length( max( abs( planeSpaceCoord ) - u_size * 0.5 + u_borderRadiusTopRight, 0.0 ) ) - u_borderRadiusTopRight;\n            float s = step( innerRadDist * -1.0, u_borderRadiusTopRight );\n            return mix( innerRadDist, roundedDist, s );\n        }\n        if (vUv.x >= 0.5 && vUv.y < 0.5) {\n            float roundedDist = length( max( abs( planeSpaceCoord ) - u_size * 0.5 + u_borderRadiusBottomRight, 0.0 ) ) - u_borderRadiusBottomRight;\n            float s = step( innerRadDist * -1.0, u_borderRadiusBottomRight );\n            return mix( innerRadDist, roundedDist, s );\n        }\n        if (vUv.x < 0.5 && vUv.y < 0.5) {\n            float roundedDist = length( max( abs( planeSpaceCoord ) - u_size * 0.5 + u_borderRadiusBottomLeft, 0.0 ) ) - u_borderRadiusBottomLeft;\n            float s = step( innerRadDist * -1.0, u_borderRadiusBottomLeft );\n            return mix( innerRadDist, roundedDist, s );\n        }\n    }\n\n    vec4 sampleTexture() {\n        float textureRatio = u_tSize.x / u_tSize.y;\n        float panelRatio = u_size.x / u_size.y;\n        vec2 uv = vUv;\n        if ( u_backgroundMapping == 1 ) { // contain\n            if ( textureRatio < panelRatio ) { // repeat on X\n                float newX = uv.x * ( panelRatio / textureRatio );\n                newX += 0.5 - 0.5 * ( panelRatio / textureRatio );\n                uv.x = newX;\n            } else { // repeat on Y\n                float newY = uv.y * ( textureRatio / panelRatio );\n                newY += 0.5 - 0.5 * ( textureRatio / panelRatio );\n                uv.y = newY;\n            }\n        } else if ( u_backgroundMapping == 2 ) { // cover\n            if ( textureRatio < panelRatio ) { // stretch on Y\n                float newY = uv.y * ( textureRatio / panelRatio );\n                newY += 0.5 - 0.5 * ( textureRatio / panelRatio );\n                uv.y = newY;\n            } else { // stretch on X\n                float newX = uv.x * ( panelRatio / textureRatio );\n                newX += 0.5 - 0.5 * ( panelRatio / textureRatio );\n                uv.x = newX;\n            }\n        }\n        return texture2D( u_texture, uv ).rgba;\n    }\n\n\tvoid main() {\n        float edgeDist = getEdgeDist();\n        if ( edgeDist > 0.0 ) discard;\n\t\tvec4 textureSample = sampleTexture();\n        float blendedOpacity = u_opacity * textureSample.a;\n        vec3 blendedColor = textureSample.rgb * u_color;\n        if ( edgeDist * -1.0 < u_borderWidth ) {\n        gl_FragColor = vec4( u_borderColor, u_borderOpacity );\n        } else {\n\t\tgl_FragColor = vec4( blendedColor, blendedOpacity );\n\t\t}\n\t\t#include <clipping_planes_fragment>\n\t}\n";class _w extends gs{constructor(t){super(new Bs,t),this.castShadow=!0,this.receiveShadow=!0,this.name="MeshUI-Frame"}}let Mw=null;function Tw(...t){let e=Mw||class{};Mw=null;let n,r=t.length;for(;--r>=0;)n=t[r],e=n(e);return e}Tw.withBase=t=>(Mw=t,Tw);class Sw extends(Tw.withBase(hi)(rw,iw,vw,gw)){constructor(t){super(t),this.isBlock=!0,this.size=new jn(0,0),this.tSize=new jn(1,1),this.frame=new _w(this.getBackgroundMaterial()),this.frame.onBeforeRender=()=>{this.updateClippingPlanes&&this.updateClippingPlanes()},this.add(this.frame),this.set(t)}parseParams(){}updateLayout(){const t=this.getWidth(),e=this.getHeight();t&&e?(this.size.set(t,e),this.frame.scale.set(t,e,1),this.frame&&this.updateBackgroundMaterial(),this.frame.renderOrder=this.getParentsNumber(),this.autoLayout&&this.setPosFromParentRecords(),this.children.find((t=>t.isInline))&&this.computeInlinesPosition(),this.computeChildrenPosition(),this.getUIParent()&&(this.position.z=this.getOffset())):console.warn("Block got no dimension from its parameters or from children parameters")}updateInner(){this.getUIParent()&&(this.position.z=this.getOffset()),this.frame&&this.updateBackgroundMaterial()}}function Aw(t=class{}){return class extends t{constructor(t){super(t),this.isInline=!0}}}class Ew extends Bs{constructor(t,e){const n=t.glyph,r=t.fontSize;super(r,r),null===n.match(/\s/g)?(-1===e.info.charset.indexOf(n)&&console.error(`The character '${n}' is not included in the font characters set.`),this.mapUVs(e,n),this.transformGeometry(e,r,n,t)):(this.nullifyUVs(),this.scale(0,0,1),this.translate(0,r/2,0))}mapUVs(t,e){const n=t.chars.find((t=>t.char===e)),r=t.common,i=n.x/r.scaleW,s=(n.x+n.width)/r.scaleW,a=1-(n.y+n.height)/r.scaleH,o=1-n.y/r.scaleH,l=this.attributes.uv;for(let t=0;t<l.count;t++){let e=l.getX(t),n=l.getY(t);[e,n]=(()=>{switch(t){case 0:return[i,o];case 1:return[s,o];case 2:return[i,a];case 3:return[s,a]}})(),l.setXY(t,e,n)}}nullifyUVs(){const t=this.attributes.uv;for(let e=0;e<t.count;e++)t.setXY(e,0,0)}transformGeometry(t,e,n,r){const i=t.chars.find((t=>t.char===n)),s=t.common,a=i.height/s.lineHeight,o=i.width*a/i.height;this.scale(o,a,1),this.translate(r.width/2,r.height/2-r.anchor,0)}}const Cw={getGlyphDimensions:function(t){const e=t.font,n=t.fontSize,r=t.glyph,i=n/e.info.size,s=e.chars.find((t=>t.char===r));let a=s?s.width*i:n/3,o=s?s.height*i:0;0===a&&(a=n),0===o&&(o=.7*n),"\n"===r&&(a=0);let l=s?s.xadvance*i:a,c=s?s.xoffset*i:0;return{width:a,height:o,anchor:s?(s.yoffset+s.height-e.common.base)*n/e.common.lineHeight:0,xadvance:l,xoffset:c}},getGlyphPairKerning:function(t,e){const n=t._kernings;return n[e]?n[e]:0},buildText:function(){const t=[];this.inlines.forEach(((e,n)=>{t[n]=new Ew(e,this.getFontFamily()),t[n].translate(e.offsetX,e.offsetY,0)}));const e=uy(t);return new gs(e,this.getFontMaterial())}};function Pw(t=class{}){return class extends t{createText(){const t=this,e=(()=>{if("MSDF"===this.getTextType())return Cw.buildText.call(this);console.warn(`'${this.getTextType()}' is not a supported text type.\nSee https://github.com/felixmariotto/three-mesh-ui/wiki/Using-a-custom-text-type`)})();return e.renderOrder=1/0,e.onBeforeRender=function(){t.updateClippingPlanes&&t.updateClippingPlanes()},e}getGlyphDimensions(t){if("MSDF"===t.textType)return Cw.getGlyphDimensions(t);console.warn(`'${t.textType}' is not a supported text type.\nSee https://github.com/felixmariotto/three-mesh-ui/wiki/Using-a-custom-text-type`)}getGlyphPairKerning(t,e,n){if("MSDF"===t)return Cw.getGlyphPairKerning(e,n);console.warn(`'${t}' is not a supported text type.\nSee https://github.com/felixmariotto/three-mesh-ui/wiki/Using-a-custom-text-type`)}}}const Lw=function t(e){e.children.forEach((n=>{n.children.length>0&&t(n),e.remove(n),fw.disposeOf(n),n.material&&n.material.dispose(),n.geometry&&n.geometry.dispose()})),e.children=[]};class Rw extends(Tw.withBase(hi)(Aw,Pw,vw,gw)){constructor(t){super(t),this.isText=!0,this.set(t)}parseParams(){const t=this.content,e=this.getFontFamily(),n=this.getFontSize(),r=this.getBreakOn(),i=this.getTextType();if(!e||"string"==typeof e)return void(pw.getFontOf(this)||console.warn("no font was found"));if(!this.content)return void(this.inlines=null);if(!i)return void console.error("You must provide a 'textType' attribute so three-mesh-ui knows how to render your text.\n See https://github.com/felixmariotto/three-mesh-ui/wiki/Using-a-custom-text-type");const s=Array.from?Array.from(t):String(t).split(""),a=n/e.info.size,o=e.common.lineHeight*a,l=e.common.base*a,c=s.map((t=>{const s=this.getGlyphDimensions({textType:i,glyph:t,font:e,fontSize:n});let a=null;return(r.includes(t)||t.match(/\s/g))&&(a="possible"),t.match(/\n/g)&&(a="mandatory"),{height:s.height,width:s.width,anchor:s.anchor,xadvance:s.xadvance,xoffset:s.xoffset,lineBreak:a,glyph:t,fontSize:n,lineHeight:o,lineBase:l}}));if("none"!==this.getFontKerning())for(let t=1;t<c.length;t++){const r=c[t],s=c[t-1].glyph+c[t].glyph,a=this.getGlyphPairKerning(i,e,s);r.kerning=a*(n/e.info.size)}this.inlines=c}updateLayout(){Lw(this),this.inlines&&(this.textContent=this.createText(),this.add(this.textContent)),this.position.z=this.getOffset()}updateInner(){this.position.z=this.getOffset(),this.textContent&&this.updateTextMaterial()}}class Fw extends(Tw.withBase(hi)(Aw,rw,iw,vw,gw)){constructor(t){super(t),this.isInlineBlock=!0,this.size=new jn(1,1),this.tSize=new jn(1,1),this.frame=new _w(this.getBackgroundMaterial()),this.frame.onBeforeRender=()=>{this.updateClippingPlanes&&this.updateClippingPlanes()},this.add(this.frame),this.set(t)}parseParams(){this.width||console.warn("inlineBlock has no width. Set to 0.3 by default"),this.height||console.warn("inlineBlock has no height. Set to 0.3 by default"),this.inlines=[{height:this.height||.3,width:this.width||.3,anchor:0,lineBreak:"possible"}]}updateLayout(){const t=this.getWidth(),e=this.getHeight();if(this.inlines){const t=this.inlines[0];this.position.set(t.width/2,t.height/2,0),this.position.x+=t.offsetX,this.position.y+=t.offsetY}this.size.set(t,e),this.frame.scale.set(t,e,1),this.frame&&this.updateBackgroundMaterial(),this.frame.renderOrder=this.getParentsNumber(),this.children.find((t=>t.isInline))&&this.computeInlinesPosition(),this.computeChildrenPosition(),this.position.z=this.getOffset()}updateInner(){this.position.z=this.getOffset(),this.frame&&this.updateBackgroundMaterial()}}const Dw=[[[{width:.1,chars:[{lowerCase:"a",upperCase:"A"}]},{width:.1,chars:[{lowerCase:"z",upperCase:"Z"}]},{width:.1,chars:[{lowerCase:"e",upperCase:"E"}]},{width:.1,chars:[{lowerCase:"r",upperCase:"R"}]},{width:.1,chars:[{lowerCase:"t",upperCase:"T"}]},{width:.1,chars:[{lowerCase:"y",upperCase:"Y"}]},{width:.1,chars:[{lowerCase:"u",upperCase:"U"}]},{width:.1,chars:[{lowerCase:"i",upperCase:"I"}]},{width:.1,chars:[{lowerCase:"o",upperCase:"O"}]},{width:.1,chars:[{lowerCase:"p",upperCase:"P"}]}],[{width:.1,chars:[{lowerCase:"q",upperCase:"Q"}]},{width:.1,chars:[{lowerCase:"s",upperCase:"S"}]},{width:.1,chars:[{lowerCase:"d",upperCase:"D"}]},{width:.1,chars:[{lowerCase:"f",upperCase:"F"}]},{width:.1,chars:[{lowerCase:"g",upperCase:"G"}]},{width:.1,chars:[{lowerCase:"h",upperCase:"H"}]},{width:.1,chars:[{lowerCase:"j",upperCase:"J"}]},{width:.1,chars:[{lowerCase:"k",upperCase:"K"}]},{width:.1,chars:[{lowerCase:"l",upperCase:"L"}]},{width:.1,chars:[{lowerCase:"m",upperCase:"M"}]}],[{width:.2,command:"shift",chars:[{icon:"shift"}]},{width:.1,chars:[{lowerCase:"w",upperCase:"W"}]},{width:.1,chars:[{lowerCase:"x",upperCase:"X"}]},{width:.1,chars:[{lowerCase:"c",upperCase:"C"}]},{width:.1,chars:[{lowerCase:"v",upperCase:"V"}]},{width:.1,chars:[{lowerCase:"b",upperCase:"B"}]},{width:.1,chars:[{lowerCase:"n",upperCase:"N"}]},{width:.2,command:"backspace",chars:[{icon:"backspace"}]}],[{width:.2,command:"switch",chars:[{lowerCase:".?12"}]},{width:.1,chars:[{lowerCase:","}]},{width:.4,command:"space",chars:[{icon:"space"}]},{width:.1,chars:[{lowerCase:"."}]},{width:.2,command:"enter",chars:[{icon:"enter"}]}]],[[{width:.1,chars:[{lowerCase:"1"}]},{width:.1,chars:[{lowerCase:"2"}]},{width:.1,chars:[{lowerCase:"3"}]},{width:.1,chars:[{lowerCase:"4"}]},{width:.1,chars:[{lowerCase:"5"}]},{width:.1,chars:[{lowerCase:"6"}]},{width:.1,chars:[{lowerCase:"7"}]},{width:.1,chars:[{lowerCase:"8"}]},{width:.1,chars:[{lowerCase:"9"}]},{width:.1,chars:[{lowerCase:"0"}]}],[{width:.1,chars:[{lowerCase:"@"}]},{width:.1,chars:[{lowerCase:"#"}]},{width:.1,chars:[{lowerCase:"|"}]},{width:.1,chars:[{lowerCase:"_"}]},{width:.1,chars:[{lowerCase:"&"}]},{width:.1,chars:[{lowerCase:"-"}]},{width:.1,chars:[{lowerCase:"+"}]},{width:.1,chars:[{lowerCase:"("}]},{width:.1,chars:[{lowerCase:")"}]},{width:.1,chars:[{lowerCase:"/"}]}],[{width:.1,chars:[{lowerCase:"="}]},{width:.1,chars:[{lowerCase:"*"}]},{width:.1,chars:[{lowerCase:'"'}]},{width:.1,chars:[{lowerCase:"'"}]},{width:.1,chars:[{lowerCase:":"}]},{width:.1,chars:[{lowerCase:";"}]},{width:.1,chars:[{lowerCase:"!"}]},{width:.1,chars:[{lowerCase:"?"}]},{width:.2,command:"backspace",chars:[{icon:"backspace"}]}],[{width:.2,command:"switch",chars:[{lowerCase:".?12"}]},{width:.1,chars:[{lowerCase:","}]},{width:.4,command:"space",chars:[{icon:"space"}]},{width:.1,chars:[{lowerCase:"."}]},{width:.2,command:"enter",chars:[{icon:"enter"}]}]]],Iw=[[[{width:.1,chars:[{lowerCase:"q",upperCase:"Q"}]},{width:.1,chars:[{lowerCase:"w",upperCase:"W"}]},{width:.1,chars:[{lowerCase:"e",upperCase:"E"}]},{width:.1,chars:[{lowerCase:"r",upperCase:"R"}]},{width:.1,chars:[{lowerCase:"t",upperCase:"T"}]},{width:.1,chars:[{lowerCase:"y",upperCase:"Y"}]},{width:.1,chars:[{lowerCase:"u",upperCase:"U"}]},{width:.1,chars:[{lowerCase:"i",upperCase:"I"}]},{width:.1,chars:[{lowerCase:"o",upperCase:"O"}]},{width:.1,chars:[{lowerCase:"p",upperCase:"P"}]}],[{width:.1,chars:[{lowerCase:"a",upperCase:"A"}]},{width:.1,chars:[{lowerCase:"s",upperCase:"S"}]},{width:.1,chars:[{lowerCase:"d",upperCase:"D"}]},{width:.1,chars:[{lowerCase:"f",upperCase:"F"}]},{width:.1,chars:[{lowerCase:"g",upperCase:"G"}]},{width:.1,chars:[{lowerCase:"h",upperCase:"H"}]},{width:.1,chars:[{lowerCase:"j",upperCase:"J"}]},{width:.1,chars:[{lowerCase:"k",upperCase:"K"}]},{width:.1,chars:[{lowerCase:"l",upperCase:"L"}]}],[{width:.15,command:"shift",chars:[{icon:"shift"}]},{width:.1,chars:[{lowerCase:"z",upperCase:"Z"}]},{width:.1,chars:[{lowerCase:"x",upperCase:"X"}]},{width:.1,chars:[{lowerCase:"c",upperCase:"C"}]},{width:.1,chars:[{lowerCase:"v",upperCase:"V"}]},{width:.1,chars:[{lowerCase:"b",upperCase:"B"}]},{width:.1,chars:[{lowerCase:"n",upperCase:"N"}]},{width:.1,chars:[{lowerCase:"m",upperCase:"M"}]},{width:.15,command:"backspace",chars:[{icon:"backspace"}]}],[{width:.2,command:"switch",chars:[{lowerCase:".?12"}]},{width:.1,chars:[{lowerCase:","}]},{width:.4,command:"space",chars:[{icon:"space"}]},{width:.1,chars:[{lowerCase:"."}]},{width:.2,command:"enter",chars:[{icon:"enter"}]}]],[[{width:.1,chars:[{lowerCase:"1"}]},{width:.1,chars:[{lowerCase:"2"}]},{width:.1,chars:[{lowerCase:"3"}]},{width:.1,chars:[{lowerCase:"4"}]},{width:.1,chars:[{lowerCase:"5"}]},{width:.1,chars:[{lowerCase:"6"}]},{width:.1,chars:[{lowerCase:"7"}]},{width:.1,chars:[{lowerCase:"8"}]},{width:.1,chars:[{lowerCase:"9"}]},{width:.1,chars:[{lowerCase:"0"}]}],[{width:.1,chars:[{lowerCase:"@"}]},{width:.1,chars:[{lowerCase:"#"}]},{width:.1,chars:[{lowerCase:"|"}]},{width:.1,chars:[{lowerCase:"_"}]},{width:.1,chars:[{lowerCase:"&"}]},{width:.1,chars:[{lowerCase:"-"}]},{width:.1,chars:[{lowerCase:"+"}]},{width:.1,chars:[{lowerCase:"("}]},{width:.1,chars:[{lowerCase:")"}]},{width:.1,chars:[{lowerCase:"/"}]}],[{width:.1,chars:[{lowerCase:"="}]},{width:.1,chars:[{lowerCase:"*"}]},{width:.1,chars:[{lowerCase:'"'}]},{width:.1,chars:[{lowerCase:"'"}]},{width:.1,chars:[{lowerCase:":"}]},{width:.1,chars:[{lowerCase:";"}]},{width:.1,chars:[{lowerCase:"!"}]},{width:.1,chars:[{lowerCase:"?"}]},{width:.2,command:"backspace",chars:[{icon:"backspace"}]}],[{width:.2,command:"switch",chars:[{lowerCase:".?12"}]},{width:.1,chars:[{lowerCase:","}]},{width:.4,command:"space",chars:[{icon:"space"}]},{width:.1,chars:[{lowerCase:"."}]},{width:.2,command:"enter",chars:[{icon:"enter"}]}]]],Uw=[[[{width:1/12,chars:[{lowerCase:"й",upperCase:"Й"},{lowerCase:"q",upperCase:"Q"}]},{width:1/12,chars:[{lowerCase:"ц",upperCase:"Ц"},{lowerCase:"w",upperCase:"W"}]},{width:1/12,chars:[{lowerCase:"у",upperCase:"У"},{lowerCase:"e",upperCase:"E"}]},{width:1/12,chars:[{lowerCase:"к",upperCase:"К"},{lowerCase:"r",upperCase:"R"}]},{width:1/12,chars:[{lowerCase:"е",upperCase:"Е"},{lowerCase:"t",upperCase:"T"}]},{width:1/12,chars:[{lowerCase:"н",upperCase:"Н"},{lowerCase:"y",upperCase:"Y"}]},{width:1/12,chars:[{lowerCase:"г",upperCase:"Г"},{lowerCase:"u",upperCase:"U"}]},{width:1/12,chars:[{lowerCase:"ш",upperCase:"Ш"},{lowerCase:"i",upperCase:"I"}]},{width:1/12,chars:[{lowerCase:"щ",upperCase:"Щ"},{lowerCase:"o",upperCase:"O"}]},{width:1/12,chars:[{lowerCase:"з",upperCase:"З"},{lowerCase:"p",upperCase:"P"}]},{width:1/12,chars:[{lowerCase:"х",upperCase:"Х"},{lowerCase:"{",upperCase:"["}]},{width:1/12,chars:[{lowerCase:"ъ",upperCase:"Ъ"},{lowerCase:"}",upperCase:"]"}]}],[{width:1/12,chars:[{lowerCase:"ф",upperCase:"Ф"},{lowerCase:"a",upperCase:"A"}]},{width:1/12,chars:[{lowerCase:"ы",upperCase:"Ы"},{lowerCase:"s",upperCase:"S"}]},{width:1/12,chars:[{lowerCase:"в",upperCase:"В"},{lowerCase:"d",upperCase:"D"}]},{width:1/12,chars:[{lowerCase:"а",upperCase:"А"},{lowerCase:"f",upperCase:"F"}]},{width:1/12,chars:[{lowerCase:"п",upperCase:"П"},{lowerCase:"g",upperCase:"G"}]},{width:1/12,chars:[{lowerCase:"р",upperCase:"Р"},{lowerCase:"h",upperCase:"H"}]},{width:1/12,chars:[{lowerCase:"о",upperCase:"О"},{lowerCase:"j",upperCase:"J"}]},{width:1/12,chars:[{lowerCase:"л",upperCase:"Л"},{lowerCase:"k",upperCase:"K"}]},{width:1/12,chars:[{lowerCase:"д",upperCase:"Д"},{lowerCase:"l",upperCase:"L"}]},{width:1/12,chars:[{lowerCase:"ж",upperCase:"Ж"},{lowerCase:":",upperCase:";"}]},{width:1/12,chars:[{lowerCase:"э",upperCase:"Э"},{lowerCase:'"',upperCase:"'"}]},{width:1/12,chars:[{lowerCase:"ё",upperCase:"Ё"},{lowerCase:"|",upperCase:"\\"}]}],[{width:.125,command:"shift",chars:[{icon:"shift"}]},{width:1/12,chars:[{lowerCase:"я",upperCase:"Я"},{lowerCase:"z",upperCase:"Z"}]},{width:1/12,chars:[{lowerCase:"ч",upperCase:"Ч"},{lowerCase:"x",upperCase:"X"}]},{width:1/12,chars:[{lowerCase:"с",upperCase:"С"},{lowerCase:"c",upperCase:"C"}]},{width:1/12,chars:[{lowerCase:"м",upperCase:"М"},{lowerCase:"v",upperCase:"V"}]},{width:1/12,chars:[{lowerCase:"и",upperCase:"И"},{lowerCase:"b",upperCase:"B"}]},{width:1/12,chars:[{lowerCase:"т",upperCase:"Т"},{lowerCase:"n",upperCase:"N"}]},{width:1/12,chars:[{lowerCase:"ь",upperCase:"Ь"},{lowerCase:"m",upperCase:"M"}]},{width:1/12,chars:[{lowerCase:"б",upperCase:"Б"},{lowerCase:",",upperCase:""}]},{width:1/12,chars:[{lowerCase:"ю",upperCase:"Ю"},{lowerCase:".",upperCase:""}]},{width:.125,command:"backspace",chars:[{icon:"backspace"}]}],[{width:.15,command:"switch-set",chars:[{lowerCase:"eng"}]},{width:.15,command:"switch",chars:[{lowerCase:".?12"}]},{width:.4,command:"space",chars:[{icon:"space"}]},{width:.1,chars:[{lowerCase:"?"}]},{width:.2,command:"enter",chars:[{icon:"enter"}]}]],[[{width:.1,chars:[{lowerCase:"1"}]},{width:.1,chars:[{lowerCase:"2"}]},{width:.1,chars:[{lowerCase:"3"}]},{width:.1,chars:[{lowerCase:"4"}]},{width:.1,chars:[{lowerCase:"5"}]},{width:.1,chars:[{lowerCase:"6"}]},{width:.1,chars:[{lowerCase:"7"}]},{width:.1,chars:[{lowerCase:"8"}]},{width:.1,chars:[{lowerCase:"9"}]},{width:.1,chars:[{lowerCase:"0"}]}],[{width:.1,chars:[{lowerCase:"@"}]},{width:.1,chars:[{lowerCase:"#"}]},{width:.1,chars:[{lowerCase:"|"}]},{width:.1,chars:[{lowerCase:"_"}]},{width:.1,chars:[{lowerCase:"&"}]},{width:.1,chars:[{lowerCase:"-"}]},{width:.1,chars:[{lowerCase:"+"}]},{width:.1,chars:[{lowerCase:"("}]},{width:.1,chars:[{lowerCase:")"}]},{width:.1,chars:[{lowerCase:"/"}]}],[{width:.1,chars:[{lowerCase:"="}]},{width:.1,chars:[{lowerCase:"*"}]},{width:.1,chars:[{lowerCase:'"'}]},{width:.1,chars:[{lowerCase:"'"}]},{width:.1,chars:[{lowerCase:":"}]},{width:.1,chars:[{lowerCase:";"}]},{width:.1,chars:[{lowerCase:"!"}]},{width:.1,chars:[{lowerCase:"?"}]},{width:.2,command:"backspace",chars:[{icon:"backspace"}]}],[{width:.3,command:"switch",chars:[{lowerCase:"АБВ"}]},{width:.4,command:"space",chars:[{icon:"space"}]},{width:.1,chars:[{lowerCase:"."}]},{width:.2,command:"enter",chars:[{icon:"enter"}]}]]],Nw=[[[{width:1/11,chars:[{lowerCase:"q",upperCase:"Q"}]},{width:1/11,chars:[{lowerCase:"w",upperCase:"W"}]},{width:1/11,chars:[{lowerCase:"e",upperCase:"E"}]},{width:1/11,chars:[{lowerCase:"r",upperCase:"R"}]},{width:1/11,chars:[{lowerCase:"t",upperCase:"T"}]},{width:1/11,chars:[{lowerCase:"z",upperCase:"Z"}]},{width:1/11,chars:[{lowerCase:"u",upperCase:"U"}]},{width:1/11,chars:[{lowerCase:"i",upperCase:"I"}]},{width:1/11,chars:[{lowerCase:"o",upperCase:"O"}]},{width:1/11,chars:[{lowerCase:"p",upperCase:"P"}]},{width:1/11,chars:[{lowerCase:"ü",upperCase:"Ü"}]}],[{width:1/11,chars:[{lowerCase:"a",upperCase:"A"}]},{width:1/11,chars:[{lowerCase:"s",upperCase:"S"}]},{width:1/11,chars:[{lowerCase:"d",upperCase:"D"}]},{width:1/11,chars:[{lowerCase:"f",upperCase:"F"}]},{width:1/11,chars:[{lowerCase:"g",upperCase:"G"}]},{width:1/11,chars:[{lowerCase:"h",upperCase:"H"}]},{width:1/11,chars:[{lowerCase:"j",upperCase:"J"}]},{width:1/11,chars:[{lowerCase:"k",upperCase:"K"}]},{width:1/11,chars:[{lowerCase:"l",upperCase:"L"}]},{width:1/11,chars:[{lowerCase:"ö",upperCase:"Ö"}]},{width:1/11,chars:[{lowerCase:"ä",upperCase:"Ä"}]}],[{width:2/11,command:"shift",chars:[{icon:"shift"}]},{width:1/11,chars:[{lowerCase:"y",upperCase:"Y"}]},{width:1/11,chars:[{lowerCase:"x",upperCase:"X"}]},{width:1/11,chars:[{lowerCase:"c",upperCase:"C"}]},{width:1/11,chars:[{lowerCase:"v",upperCase:"V"}]},{width:1/11,chars:[{lowerCase:"b",upperCase:"B"}]},{width:1/11,chars:[{lowerCase:"n",upperCase:"N"}]},{width:1/11,chars:[{lowerCase:"m",upperCase:"M"}]},{width:2/11,command:"backspace",chars:[{icon:"backspace"}]}],[{width:.2,command:"switch",chars:[{lowerCase:".?12"}]},{width:.1,chars:[{lowerCase:","}]},{width:.4,command:"space",chars:[{icon:"space"}]},{width:.1,chars:[{lowerCase:"."}]},{width:.2,command:"enter",chars:[{icon:"enter"}]}]],[[{width:.1,chars:[{lowerCase:"1"}]},{width:.1,chars:[{lowerCase:"2"}]},{width:.1,chars:[{lowerCase:"3"}]},{width:.1,chars:[{lowerCase:"4"}]},{width:.1,chars:[{lowerCase:"5"}]},{width:.1,chars:[{lowerCase:"6"}]},{width:.1,chars:[{lowerCase:"7"}]},{width:.1,chars:[{lowerCase:"8"}]},{width:.1,chars:[{lowerCase:"9"}]},{width:.1,chars:[{lowerCase:"0"}]}],[{width:.1,chars:[{lowerCase:"@"}]},{width:.1,chars:[{lowerCase:"#"}]},{width:.1,chars:[{lowerCase:"|"}]},{width:.1,chars:[{lowerCase:"_"}]},{width:.1,chars:[{lowerCase:"&"}]},{width:.1,chars:[{lowerCase:"-"}]},{width:.1,chars:[{lowerCase:"+"}]},{width:.1,chars:[{lowerCase:"("}]},{width:.1,chars:[{lowerCase:")"}]},{width:.1,chars:[{lowerCase:"/"}]}],[{width:.1,chars:[{lowerCase:"="}]},{width:.1,chars:[{lowerCase:"*"}]},{width:.1,chars:[{lowerCase:'"'}]},{width:.1,chars:[{lowerCase:"'"}]},{width:.1,chars:[{lowerCase:":"}]},{width:.1,chars:[{lowerCase:";"}]},{width:.1,chars:[{lowerCase:"!"}]},{width:.1,chars:[{lowerCase:"?"}]},{width:.2,command:"backspace",chars:[{icon:"backspace"}]}],[{width:.2,command:"switch",chars:[{lowerCase:".?12"}]},{width:.1,chars:[{lowerCase:","}]},{width:.4,command:"space",chars:[{icon:"space"}]},{width:.1,chars:[{lowerCase:"."}]},{width:.2,command:"enter",chars:[{icon:"enter"}]}]]],Ow=[[[{width:.1,chars:[{lowerCase:"q",upperCase:"Q"}]},{width:.1,chars:[{lowerCase:"w",upperCase:"W"}]},{width:.1,chars:[{lowerCase:"e",upperCase:"E"}]},{width:.1,chars:[{lowerCase:"r",upperCase:"R"}]},{width:.1,chars:[{lowerCase:"t",upperCase:"T"}]},{width:.1,chars:[{lowerCase:"y",upperCase:"Y"}]},{width:.1,chars:[{lowerCase:"u",upperCase:"U"}]},{width:.1,chars:[{lowerCase:"i",upperCase:"I"}]},{width:.1,chars:[{lowerCase:"o",upperCase:"O"}]},{width:.1,chars:[{lowerCase:"p",upperCase:"P"}]}],[{width:.1,chars:[{lowerCase:"a",upperCase:"A"}]},{width:.1,chars:[{lowerCase:"s",upperCase:"S"}]},{width:.1,chars:[{lowerCase:"d",upperCase:"D"}]},{width:.1,chars:[{lowerCase:"f",upperCase:"F"}]},{width:.1,chars:[{lowerCase:"g",upperCase:"G"}]},{width:.1,chars:[{lowerCase:"h",upperCase:"H"}]},{width:.1,chars:[{lowerCase:"j",upperCase:"J"}]},{width:.1,chars:[{lowerCase:"k",upperCase:"K"}]},{width:.1,chars:[{lowerCase:"l",upperCase:"L"}]},{width:.1,chars:[{lowerCase:"ñ",upperCase:"Ñ"}]}],[{width:.15,command:"shift",chars:[{icon:"shift"}]},{width:.1,chars:[{lowerCase:"z",upperCase:"Z"}]},{width:.1,chars:[{lowerCase:"x",upperCase:"X"}]},{width:.1,chars:[{lowerCase:"c",upperCase:"C"}]},{width:.1,chars:[{lowerCase:"v",upperCase:"V"}]},{width:.1,chars:[{lowerCase:"b",upperCase:"B"}]},{width:.1,chars:[{lowerCase:"n",upperCase:"N"}]},{width:.1,chars:[{lowerCase:"m",upperCase:"M"}]},{width:.15,command:"backspace",chars:[{icon:"backspace"}]}],[{width:.2,command:"switch",chars:[{lowerCase:".?12"}]},{width:.1,chars:[{lowerCase:","}]},{width:.4,command:"space",chars:[{icon:"space"}]},{width:.1,chars:[{lowerCase:"."}]},{width:.2,command:"enter",chars:[{icon:"enter"}]}]],[[{width:.1,chars:[{lowerCase:"1"}]},{width:.1,chars:[{lowerCase:"2"}]},{width:.1,chars:[{lowerCase:"3"}]},{width:.1,chars:[{lowerCase:"4"}]},{width:.1,chars:[{lowerCase:"5"}]},{width:.1,chars:[{lowerCase:"6"}]},{width:.1,chars:[{lowerCase:"7"}]},{width:.1,chars:[{lowerCase:"8"}]},{width:.1,chars:[{lowerCase:"9"}]},{width:.1,chars:[{lowerCase:"0"}]}],[{width:.1,chars:[{lowerCase:"@"}]},{width:.1,chars:[{lowerCase:"#"}]},{width:.1,chars:[{lowerCase:"|"}]},{width:.1,chars:[{lowerCase:"_"}]},{width:.1,chars:[{lowerCase:"&"}]},{width:.1,chars:[{lowerCase:"-"}]},{width:.1,chars:[{lowerCase:"+"}]},{width:.1,chars:[{lowerCase:"("}]},{width:.1,chars:[{lowerCase:")"}]},{width:.1,chars:[{lowerCase:"/"}]}],[{width:.1,chars:[{lowerCase:"="}]},{width:.1,chars:[{lowerCase:"*"}]},{width:.1,chars:[{lowerCase:'"'}]},{width:.1,chars:[{lowerCase:"'"}]},{width:.1,chars:[{lowerCase:":"}]},{width:.1,chars:[{lowerCase:";"}]},{width:.1,chars:[{lowerCase:"!"}]},{width:.1,chars:[{lowerCase:"?"}]},{width:.2,command:"backspace",chars:[{icon:"backspace"}]}],[{width:.2,command:"switch",chars:[{lowerCase:".?12"}]},{width:.1,chars:[{lowerCase:","}]},{width:.4,command:"space",chars:[{icon:"space"}]},{width:.1,chars:[{lowerCase:"."}]},{width:.2,command:"enter",chars:[{icon:"enter"}]}]]],Bw=[[[{width:.1,chars:[{lowerCase:";",upperCase:":"},{lowerCase:"q",upperCase:"Q"}]},{width:.1,chars:[{lowerCase:"ς",upperCase:"ς"},{lowerCase:"w",upperCase:"W"}]},{width:.1,chars:[{lowerCase:"ε",upperCase:"Ε"},{lowerCase:"e",upperCase:"E"}]},{width:.1,chars:[{lowerCase:"ρ",upperCase:"Ρ"},{lowerCase:"r",upperCase:"R"}]},{width:.1,chars:[{lowerCase:"τ",upperCase:"Τ"},{lowerCase:"t",upperCase:"T"}]},{width:.1,chars:[{lowerCase:"υ",upperCase:"Υ"},{lowerCase:"y",upperCase:"Y"}]},{width:.1,chars:[{lowerCase:"θ",upperCase:"Θ"},{lowerCase:"u",upperCase:"U"}]},{width:.1,chars:[{lowerCase:"ι",upperCase:"Ι"},{lowerCase:"i",upperCase:"I"}]},{width:.1,chars:[{lowerCase:"ο",upperCase:"Ο"},{lowerCase:"o",upperCase:"O"}]},{width:.1,chars:[{lowerCase:"π",upperCase:"Π"},{lowerCase:"p",upperCase:"P"}]}],[{width:.1,chars:[{lowerCase:"α",upperCase:"Α"},{lowerCase:"a",upperCase:"A"}]},{width:.1,chars:[{lowerCase:"σ",upperCase:"Σ"},{lowerCase:"s",upperCase:"S"}]},{width:.1,chars:[{lowerCase:"δ",upperCase:"Δ"},{lowerCase:"d",upperCase:"D"}]},{width:.1,chars:[{lowerCase:"φ",upperCase:"Φ"},{lowerCase:"f",upperCase:"F"}]},{width:.1,chars:[{lowerCase:"γ",upperCase:"Γ"},{lowerCase:"g",upperCase:"G"}]},{width:.1,chars:[{lowerCase:"η",upperCase:"Η"},{lowerCase:"h",upperCase:"H"}]},{width:.1,chars:[{lowerCase:"ξ",upperCase:"Ξ"},{lowerCase:"j",upperCase:"J"}]},{width:.1,chars:[{lowerCase:"κ",upperCase:"Κ"},{lowerCase:"k",upperCase:"K"}]},{width:.1,chars:[{lowerCase:"λ",upperCase:"Λ"},{lowerCase:"l",upperCase:"L"}]}],[{width:.15,command:"shift",chars:[{icon:"shift"}]},{width:.1,chars:[{lowerCase:"ζ",upperCase:"Ζ"},{lowerCase:"z",upperCase:"Z"}]},{width:.1,chars:[{lowerCase:"χ",upperCase:"Χ"},{lowerCase:"x",upperCase:"X"}]},{width:.1,chars:[{lowerCase:"ψ",upperCase:"Ψ"},{lowerCase:"c",upperCase:"C"}]},{width:.1,chars:[{lowerCase:"ω",upperCase:"Ω"},{lowerCase:"v",upperCase:"V"}]},{width:.1,chars:[{lowerCase:"β",upperCase:"Β"},{lowerCase:"b",upperCase:"B"}]},{width:.1,chars:[{lowerCase:"ν",upperCase:"Ν"},{lowerCase:"n",upperCase:"N"}]},{width:.1,chars:[{lowerCase:"μ",upperCase:"Μ"},{lowerCase:"m",upperCase:"M"}]},{width:.15,command:"backspace",chars:[{icon:"backspace"}]}],[{width:.15,command:"switch-set",chars:[{lowerCase:"eng"}]},{width:.15,command:"switch",chars:[{lowerCase:".?12"}]},{width:.4,command:"space",chars:[{icon:"space"}]},{width:.1,chars:[{lowerCase:"?"}]},{width:.2,command:"enter",chars:[{icon:"enter"}]}]],[[{width:.1,chars:[{lowerCase:"1"}]},{width:.1,chars:[{lowerCase:"2"}]},{width:.1,chars:[{lowerCase:"3"}]},{width:.1,chars:[{lowerCase:"4"}]},{width:.1,chars:[{lowerCase:"5"}]},{width:.1,chars:[{lowerCase:"6"}]},{width:.1,chars:[{lowerCase:"7"}]},{width:.1,chars:[{lowerCase:"8"}]},{width:.1,chars:[{lowerCase:"9"}]},{width:.1,chars:[{lowerCase:"0"}]}],[{width:.1,chars:[{lowerCase:"@"}]},{width:.1,chars:[{lowerCase:"#"}]},{width:.1,chars:[{lowerCase:"|"}]},{width:.1,chars:[{lowerCase:"_"}]},{width:.1,chars:[{lowerCase:"&"}]},{width:.1,chars:[{lowerCase:"-"}]},{width:.1,chars:[{lowerCase:"+"}]},{width:.1,chars:[{lowerCase:"("}]},{width:.1,chars:[{lowerCase:")"}]},{width:.1,chars:[{lowerCase:"/"}]}],[{width:.1,chars:[{lowerCase:"="}]},{width:.1,chars:[{lowerCase:"*"}]},{width:.1,chars:[{lowerCase:'"'}]},{width:.1,chars:[{lowerCase:"'"}]},{width:.1,chars:[{lowerCase:":"}]},{width:.1,chars:[{lowerCase:";"}]},{width:.1,chars:[{lowerCase:"!"}]},{width:.1,chars:[{lowerCase:"?"}]},{width:.2,command:"backspace",chars:[{icon:"backspace"}]}],[{width:.2,command:"switch",chars:[{lowerCase:".?12"}]},{width:.1,chars:[{lowerCase:","}]},{width:.4,command:"space",chars:[{icon:"space"}]},{width:.1,chars:[{lowerCase:"."}]},{width:.2,command:"enter",chars:[{icon:"enter"}]}]]],zw=[[[{width:1/11,chars:[{lowerCase:"q",upperCase:"Q"}]},{width:1/11,chars:[{lowerCase:"w",upperCase:"W"}]},{width:1/11,chars:[{lowerCase:"e",upperCase:"E"}]},{width:1/11,chars:[{lowerCase:"r",upperCase:"R"}]},{width:1/11,chars:[{lowerCase:"t",upperCase:"T"}]},{width:1/11,chars:[{lowerCase:"y",upperCase:"Y"}]},{width:1/11,chars:[{lowerCase:"u",upperCase:"U"}]},{width:1/11,chars:[{lowerCase:"i",upperCase:"I"}]},{width:1/11,chars:[{lowerCase:"o",upperCase:"O"}]},{width:1/11,chars:[{lowerCase:"p",upperCase:"P"}]},{width:1/11,chars:[{lowerCase:"å",upperCase:"Å"}]}],[{width:1/11,chars:[{lowerCase:"a",upperCase:"A"}]},{width:1/11,chars:[{lowerCase:"s",upperCase:"S"}]},{width:1/11,chars:[{lowerCase:"d",upperCase:"D"}]},{width:1/11,chars:[{lowerCase:"f",upperCase:"F"}]},{width:1/11,chars:[{lowerCase:"g",upperCase:"G"}]},{width:1/11,chars:[{lowerCase:"h",upperCase:"H"}]},{width:1/11,chars:[{lowerCase:"j",upperCase:"J"}]},{width:1/11,chars:[{lowerCase:"k",upperCase:"K"}]},{width:1/11,chars:[{lowerCase:"l",upperCase:"L"}]},{width:1/11,chars:[{lowerCase:"æ",upperCase:"Æ"}]},{width:1/11,chars:[{lowerCase:"ø",upperCase:"Ø"}]}],[{width:2/11,command:"shift",chars:[{icon:"shift"}]},{width:1/11,chars:[{lowerCase:"z",upperCase:"Z"}]},{width:1/11,chars:[{lowerCase:"x",upperCase:"X"}]},{width:1/11,chars:[{lowerCase:"c",upperCase:"C"}]},{width:1/11,chars:[{lowerCase:"v",upperCase:"V"}]},{width:1/11,chars:[{lowerCase:"b",upperCase:"B"}]},{width:1/11,chars:[{lowerCase:"n",upperCase:"N"}]},{width:1/11,chars:[{lowerCase:"m",upperCase:"M"}]},{width:2/11,command:"backspace",chars:[{icon:"backspace"}]}],[{width:.2,command:"switch",chars:[{lowerCase:".?12"}]},{width:.1,chars:[{lowerCase:","}]},{width:.4,command:"space",chars:[{icon:"space"}]},{width:.1,chars:[{lowerCase:"."}]},{width:.2,command:"enter",chars:[{icon:"enter"}]}]],[[{width:.1,chars:[{lowerCase:"1"}]},{width:.1,chars:[{lowerCase:"2"}]},{width:.1,chars:[{lowerCase:"3"}]},{width:.1,chars:[{lowerCase:"4"}]},{width:.1,chars:[{lowerCase:"5"}]},{width:.1,chars:[{lowerCase:"6"}]},{width:.1,chars:[{lowerCase:"7"}]},{width:.1,chars:[{lowerCase:"8"}]},{width:.1,chars:[{lowerCase:"9"}]},{width:.1,chars:[{lowerCase:"0"}]}],[{width:.1,chars:[{lowerCase:"@"}]},{width:.1,chars:[{lowerCase:"#"}]},{width:.1,chars:[{lowerCase:"|"}]},{width:.1,chars:[{lowerCase:"_"}]},{width:.1,chars:[{lowerCase:"&"}]},{width:.1,chars:[{lowerCase:"-"}]},{width:.1,chars:[{lowerCase:"+"}]},{width:.1,chars:[{lowerCase:"("}]},{width:.1,chars:[{lowerCase:")"}]},{width:.1,chars:[{lowerCase:"/"}]}],[{width:.1,chars:[{lowerCase:"="}]},{width:.1,chars:[{lowerCase:"*"}]},{width:.1,chars:[{lowerCase:'"'}]},{width:.1,chars:[{lowerCase:"'"}]},{width:.1,chars:[{lowerCase:":"}]},{width:.1,chars:[{lowerCase:";"}]},{width:.1,chars:[{lowerCase:"!"}]},{width:.1,chars:[{lowerCase:"?"}]},{width:.2,command:"backspace",chars:[{icon:"backspace"}]}],[{width:.2,command:"switch",chars:[{lowerCase:".?12"}]},{width:.1,chars:[{lowerCase:","}]},{width:.4,command:"space",chars:[{icon:"space"}]},{width:.1,chars:[{lowerCase:"."}]},{width:.2,command:"enter",chars:[{icon:"enter"}]}]]],kw=new Hu;class Hw extends(Tw.withBase(hi)(rw,gw)){constructor(t){let e;if(t||(t={}),t.width||(t.width=1),t.height||(t.height=.4),t.margin||(t.margin=.003),t.padding||(t.padding=.01),super(t),this.currentPanel=0,this.isLowerCase=!0,this.charsetCount=1,t.language||navigator.language)switch(t.language||navigator.language){case"fr":case"fr-CH":case"fr-CA":e=Dw;break;case"ru":this.charsetCount=2,e=Uw;break;case"de":case"de-DE":case"de-AT":case"de-LI":case"de-CH":e=Nw;break;case"es":case"es-419":case"es-AR":case"es-CL":case"es-CO":case"es-ES":case"es-CR":case"es-US":case"es-HN":case"es-MX":case"es-PE":case"es-UY":case"es-VE":e=Ow;break;case"el":this.charsetCount=2,e=Bw;break;case"nord":e=zw;break;default:e=Iw}else e=Iw;this.keys=[],this.panels=e.map((e=>{const n=t.height/e.length-2*t.margin,r=new Sw({width:t.width+2*t.padding,height:t.height+2*t.padding,offset:0,padding:t.padding,fontFamily:t.fontFamily,fontTexture:t.fontTexture,backgroundColor:t.backgroundColor,backgroundOpacity:t.backgroundOpacity});return r.charset=0,r.add(...e.map((e=>{const i=new Sw({width:t.width,height:n,margin:t.margin,contentDirection:"row",justifyContent:"center"});i.frame.visible=!1;const s=[];return e.forEach((e=>{const i=new Sw({width:t.width*e.width-2*t.margin,height:n,margin:t.margin,justifyContent:"center",offset:0}),a=e.chars[r.charset].lowerCase||e.chars[r.charset].icon||"undif";if("enter"===a&&t.enterTexture||"shift"===a&&t.shiftTexture||"backspace"===a&&t.backspaceTexture){const e=(()=>{switch(a){case"backspace":return t.backspaceTexture;case"enter":return t.enterTexture;case"shift":return t.shiftTexture;default:console.warn("There is no icon image for this key")}})();kw.load(e,(t=>{i.add(new Fw({width:.65*i.width,height:.65*i.height,backgroundSize:"contain",backgroundTexture:t}))}))}else i.add(new Rw({content:a,offset:0}));i.type="Key",i.info=e,i.info.input=a,i.panel=r,s.push(i),this.keys.push(i)})),i.add(...s),i}))),r})),this.add(this.panels[0]),this.set(t)}setNextPanel(){this.panels.forEach((t=>{this.remove(t)})),this.currentPanel=(this.currentPanel+1)%this.panels.length,this.add(this.panels[this.currentPanel]),this.update(!0,!0,!0)}setNextCharset(){this.panels[this.currentPanel].charset=(this.panels[this.currentPanel].charset+1)%this.charsetCount,this.keys.forEach((t=>{if(!this.panels[this.currentPanel].getObjectById(t.id))return;const e=t.info.chars[t.panel.charset]||t.info.chars[0],n=this.isLowerCase||!e.upperCase?e.lowerCase:e.upperCase,r=t.children.find((t=>t.isText));r&&(t.info.input=n,r.set({content:n}),r.update(!0,!0,!0))}))}toggleCase(){this.isLowerCase=!this.isLowerCase,this.keys.forEach((t=>{const e=t.info.chars[t.panel.charset]||t.info.chars[0],n=this.isLowerCase||!e.upperCase?e.lowerCase:e.upperCase,r=t.children.find((t=>t.isText));r&&(t.info.input=n,r.set({content:n}),r.update(!0,!0,!0))}))}parseParams(){}updateLayout(){}updateInner(){}}const Gw={Block:Sw,Text:Rw,InlineBlock:Fw,Keyboard:Hw,FontLibrary:pw,update:()=>fw.update()};void 0!==n.g&&(n.g.ThreeMeshUI=Gw);const Vw=Gw,Ww=0,Xw=1,jw=2,Yw=0,qw=1,Qw=2,Zw=1.25,Jw=32,Kw=65535,$w=Math.pow(2,-24);class tb{constructor(){}}function eb(t,e,n){return n.min.x=e[t],n.min.y=e[t+1],n.min.z=e[t+2],n.max.x=e[t+3],n.max.y=e[t+4],n.max.z=e[t+5],n}function nb(t){let e=-1,n=-1/0;for(let r=0;r<3;r++){const i=t[r+3]-t[r];i>n&&(n=i,e=r)}return e}function rb(t,e){e.set(t)}function ib(t,e,n){let r,i;for(let s=0;s<3;s++){const a=s+3;r=t[s],i=e[s],n[s]=r<i?r:i,r=t[a],i=e[a],n[a]=r>i?r:i}}function sb(t,e,n){for(let r=0;r<3;r++){const i=e[t+2*r],s=e[t+2*r+1],a=i-s,o=i+s;a<n[r]&&(n[r]=a),o>n[r+3]&&(n[r+3]=o)}}function ab(t){const e=t[3]-t[0],n=t[4]-t[1],r=t[5]-t[2];return 2*(e*n+n*r+r*e)}function ob(t,e,n,r,i=null){let s=1/0,a=1/0,o=1/0,l=-1/0,c=-1/0,h=-1/0,u=1/0,d=1/0,p=1/0,f=-1/0,m=-1/0,g=-1/0;const v=null!==i;for(let r=6*e,i=6*(e+n);r<i;r+=6){const e=t[r+0],n=t[r+1],i=e-n,x=e+n;i<s&&(s=i),x>l&&(l=x),v&&e<u&&(u=e),v&&e>f&&(f=e);const y=t[r+2],w=t[r+3],b=y-w,_=y+w;b<a&&(a=b),_>c&&(c=_),v&&y<d&&(d=y),v&&y>m&&(m=y);const M=t[r+4],T=t[r+5],S=M-T,A=M+T;S<o&&(o=S),A>h&&(h=A),v&&M<p&&(p=M),v&&M>g&&(g=M)}r[0]=s,r[1]=a,r[2]=o,r[3]=l,r[4]=c,r[5]=h,v&&(i[0]=u,i[1]=d,i[2]=p,i[3]=f,i[4]=m,i[5]=g)}const lb=(t,e)=>t.candidate-e.candidate,cb=new Array(32).fill().map((()=>({count:0,bounds:new Float32Array(6),rightCacheBounds:new Float32Array(6),leftCacheBounds:new Float32Array(6),candidate:0}))),hb=new Float32Array(6);class ub{constructor(){this.min=1/0,this.max=-1/0}setFromPointsField(t,e){let n=1/0,r=-1/0;for(let i=0,s=t.length;i<s;i++){const s=t[i][e];n=s<n?s:n,r=s>r?s:r}this.min=n,this.max=r}setFromPoints(t,e){let n=1/0,r=-1/0;for(let i=0,s=e.length;i<s;i++){const s=e[i],a=t.dot(s);n=a<n?a:n,r=a>r?a:r}this.min=n,this.max=r}isSeparated(t){return this.min>t.max||t.min>this.max}}ub.prototype.setFromBox=function(){const t=new lr;return function(e,n){const r=n.min,i=n.max;let s=1/0,a=-1/0;for(let n=0;n<=1;n++)for(let o=0;o<=1;o++)for(let l=0;l<=1;l++){t.x=r.x*n+i.x*(1-n),t.y=r.y*o+i.y*(1-o),t.z=r.z*l+i.z*(1-l);const c=e.dot(t);s=Math.min(c,s),a=Math.max(c,a)}this.min=s,this.max=a}}(),new ub;const db=function(){const t=new lr,e=new lr,n=new lr;return function(r,i,s){const a=r.start,o=t,l=i.start,c=e;n.subVectors(a,l),t.subVectors(r.end,i.start),e.subVectors(i.end,i.start);const h=n.dot(c),u=c.dot(o),d=c.dot(c),p=n.dot(o),f=o.dot(o)*d-u*u;let m,g;m=0!==f?(h*u-p*d)/f:0,g=(h+m*u)/d,s.x=m,s.y=g}}(),pb=function(){const t=new jn,e=new lr,n=new lr;return function(r,i,s,a){db(r,i,t);let o=t.x,l=t.y;if(o>=0&&o<=1&&l>=0&&l<=1)return r.at(o,s),void i.at(l,a);if(o>=0&&o<=1)return l<0?i.at(0,a):i.at(1,a),void r.closestPointToPoint(a,!0,s);if(l>=0&&l<=1)return o<0?r.at(0,s):r.at(1,s),void i.closestPointToPoint(s,!0,a);{let t,c;t=o<0?r.start:r.end,c=l<0?i.start:i.end;const h=e,u=n;return r.closestPointToPoint(c,!0,e),i.closestPointToPoint(t,!0,n),h.distanceToSquared(c)<=u.distanceToSquared(t)?(s.copy(h),void a.copy(c)):(s.copy(t),void a.copy(u))}}}(),fb=function(){const t=new lr,e=new lr,n=new Fs,r=new up;return function(i,s){const{radius:a,center:o}=i,{a:l,b:c,c:h}=s;if(r.start=l,r.end=c,r.closestPointToPoint(o,!0,t).distanceTo(o)<=a)return!0;if(r.start=l,r.end=h,r.closestPointToPoint(o,!0,t).distanceTo(o)<=a)return!0;if(r.start=c,r.end=h,r.closestPointToPoint(o,!0,t).distanceTo(o)<=a)return!0;const u=s.getPlane(n);if(Math.abs(u.distanceToPoint(o))<=a){const t=u.projectPoint(o,e);if(s.containsPoint(t))return!0}return!1}}();class mb extends bi{constructor(...t){super(...t),this.isSeparatingAxisTriangle=!0,this.satAxes=new Array(4).fill().map((()=>new lr)),this.satBounds=new Array(4).fill().map((()=>new ub)),this.points=[this.a,this.b,this.c],this.sphere=new Lr,this.plane=new Fs,this.needsUpdate=!1}intersectsSphere(t){return fb(t,this)}update(){const t=this.a,e=this.b,n=this.c,r=this.points,i=this.satAxes,s=this.satBounds,a=i[0],o=s[0];this.getNormal(a),o.setFromPoints(a,r);const l=i[1],c=s[1];l.subVectors(t,e),c.setFromPoints(l,r);const h=i[2],u=s[2];h.subVectors(e,n),u.setFromPoints(h,r);const d=i[3],p=s[3];d.subVectors(n,t),p.setFromPoints(d,r),this.sphere.setFromPoints(this.points),this.plane.setFromNormalAndCoplanarPoint(a,t),this.needsUpdate=!1}}mb.prototype.closestPointToSegment=function(){const t=new lr,e=new lr,n=new up;return function(r,i=null,s=null){const{start:a,end:o}=r,l=this.points;let c,h=1/0;for(let a=0;a<3;a++){const o=(a+1)%3;n.start.copy(l[a]),n.end.copy(l[o]),pb(n,r,t,e),c=t.distanceToSquared(e),c<h&&(h=c,i&&i.copy(t),s&&s.copy(e))}return this.closestPointToPoint(a,t),c=a.distanceToSquared(t),c<h&&(h=c,i&&i.copy(t),s&&s.copy(a)),this.closestPointToPoint(o,t),c=o.distanceToSquared(t),c<h&&(h=c,i&&i.copy(t),s&&s.copy(o)),Math.sqrt(h)}}(),mb.prototype.intersectsTriangle=function(){const t=new mb,e=new Array(3),n=new Array(3),r=new ub,i=new ub,s=new lr,a=new lr,o=new lr,l=new lr,c=new up,h=new up,u=new up;return function(d,p=null){this.needsUpdate&&this.update(),d.isSeparatingAxisTriangle?d.needsUpdate&&d.update():(t.copy(d),t.update(),d=t);const f=this.satBounds,m=this.satAxes;n[0]=d.a,n[1]=d.b,n[2]=d.c;for(let t=0;t<4;t++){const e=f[t],i=m[t];if(r.setFromPoints(i,n),e.isSeparated(r))return!1}const g=d.satBounds,v=d.satAxes;e[0]=this.a,e[1]=this.b,e[2]=this.c;for(let t=0;t<4;t++){const n=g[t],i=v[t];if(r.setFromPoints(i,e),n.isSeparated(r))return!1}for(let t=0;t<4;t++){const a=m[t];for(let t=0;t<4;t++){const o=v[t];if(s.crossVectors(a,o),r.setFromPoints(s,e),i.setFromPoints(s,n),r.isSeparated(i))return!1}}if(p){const t=this.plane,e=d.plane;if(Math.abs(t.normal.dot(e.normal))>1-1e-10)console.warn("SeparatingAxisTriangle.intersectsTriangle: Triangles are coplanar which does not support an output edge. Setting edge to 0, 0, 0."),p.start.set(0,0,0),p.end.set(0,0,0);else{const n=this.points;let r=!1;for(let t=0;t<3;t++){const i=n[t],s=n[(t+1)%3];if(c.start.copy(i),c.end.copy(s),e.intersectLine(c,r?h.start:h.end)){if(r)break;r=!0}}const i=d.points;let s=!1;for(let e=0;e<3;e++){const n=i[e],r=i[(e+1)%3];if(c.start.copy(n),c.end.copy(r),t.intersectLine(c,s?u.start:u.end)){if(s)break;s=!0}}if(h.delta(a),u.delta(o),a.dot(o)<0){let t=u.start;u.start=u.end,u.end=t}l.subVectors(h.start,u.start),l.dot(a)>0?p.start.copy(h.start):p.start.copy(u.start),l.subVectors(h.end,u.end),l.dot(a)<0?p.end.copy(h.end):p.end.copy(u.end)}}return!0}}(),mb.prototype.distanceToPoint=function(){const t=new lr;return function(e){return this.closestPointToPoint(e,t),e.distanceTo(t)}}(),mb.prototype.distanceToTriangle=function(){const t=new lr,e=new lr,n=["a","b","c"],r=new up,i=new up;return function(s,a=null,o=null){const l=a||o?r:null;if(this.intersectsTriangle(s,l))return(a||o)&&(a&&l.getCenter(a),o&&l.getCenter(o)),0;let c=1/0;for(let e=0;e<3;e++){let r;const i=n[e],l=s[i];this.closestPointToPoint(l,t),r=l.distanceToSquared(t),r<c&&(c=r,a&&a.copy(t),o&&o.copy(l));const h=this[i];s.closestPointToPoint(h,t),r=h.distanceToSquared(t),r<c&&(c=r,a&&a.copy(h),o&&o.copy(t))}for(let l=0;l<3;l++){const h=n[l],u=n[(l+1)%3];r.set(this[h],this[u]);for(let l=0;l<3;l++){const h=n[l],u=n[(l+1)%3];i.set(s[h],s[u]),pb(r,i,t,e);const d=t.distanceToSquared(e);d<c&&(c=d,a&&a.copy(t),o&&o.copy(e))}}return Math.sqrt(c)}}();class gb extends ur{constructor(...t){super(...t),this.isOrientedBox=!0,this.matrix=new zr,this.invMatrix=new zr,this.points=new Array(8).fill().map((()=>new lr)),this.satAxes=new Array(3).fill().map((()=>new lr)),this.satBounds=new Array(3).fill().map((()=>new ub)),this.alignedSatBounds=new Array(3).fill().map((()=>new ub)),this.needsUpdate=!1}set(t,e,n){super.set(t,e),this.matrix=n,this.needsUpdate=!0}copy(t){super.copy(t),this.matrix.copy(t.matrix),this.needsUpdate=!0}}gb.prototype.update=function(){const t=this.matrix,e=this.min,n=this.max,r=this.points;for(let i=0;i<=1;i++)for(let s=0;s<=1;s++)for(let a=0;a<=1;a++){const o=r[1*i|2*s|4*a];o.x=i?n.x:e.x,o.y=s?n.y:e.y,o.z=a?n.z:e.z,o.applyMatrix4(t)}const i=this.satBounds,s=this.satAxes,a=r[0];for(let t=0;t<3;t++){const e=s[t],n=i[t],o=r[1<<t];e.subVectors(a,o),n.setFromPoints(e,r)}const o=this.alignedSatBounds;o[0].setFromPointsField(r,"x"),o[1].setFromPointsField(r,"y"),o[2].setFromPointsField(r,"z"),this.invMatrix.copy(this.matrix).invert(),this.needsUpdate=!1},gb.prototype.intersectsBox=function(){const t=new ub;return function(e){this.needsUpdate&&this.update();const n=e.min,r=e.max,i=this.satBounds,s=this.satAxes,a=this.alignedSatBounds;if(t.min=n.x,t.max=r.x,a[0].isSeparated(t))return!1;if(t.min=n.y,t.max=r.y,a[1].isSeparated(t))return!1;if(t.min=n.z,t.max=r.z,a[2].isSeparated(t))return!1;for(let n=0;n<3;n++){const r=s[n],a=i[n];if(t.setFromBox(r,e),a.isSeparated(t))return!1}return!0}}(),gb.prototype.intersectsTriangle=function(){const t=new mb,e=new Array(3),n=new ub,r=new ub,i=new lr;return function(s){this.needsUpdate&&this.update(),s.isSeparatingAxisTriangle?s.needsUpdate&&s.update():(t.copy(s),t.update(),s=t);const a=this.satBounds,o=this.satAxes;e[0]=s.a,e[1]=s.b,e[2]=s.c;for(let t=0;t<3;t++){const r=a[t],i=o[t];if(n.setFromPoints(i,e),r.isSeparated(n))return!1}const l=s.satBounds,c=s.satAxes,h=this.points;for(let t=0;t<3;t++){const e=l[t],r=c[t];if(n.setFromPoints(r,h),e.isSeparated(n))return!1}for(let t=0;t<3;t++){const s=o[t];for(let t=0;t<4;t++){const a=c[t];if(i.crossVectors(s,a),n.setFromPoints(i,e),r.setFromPoints(i,h),n.isSeparated(r))return!1}}return!0}}(),gb.prototype.closestPointToPoint=function(t,e){return this.needsUpdate&&this.update(),e.copy(t).applyMatrix4(this.invMatrix).clamp(this.min,this.max).applyMatrix4(this.matrix),e},gb.prototype.distanceToPoint=function(){const t=new lr;return function(e){return this.closestPointToPoint(e,t),e.distanceTo(t)}}(),gb.prototype.distanceToBox=function(){const t=["x","y","z"],e=new Array(12).fill().map((()=>new up)),n=new Array(12).fill().map((()=>new up)),r=new lr,i=new lr;return function(s,a=0,o=null,l=null){if(this.needsUpdate&&this.update(),this.intersectsBox(s))return(o||l)&&(s.getCenter(i),this.closestPointToPoint(i,r),s.closestPointToPoint(r,i),o&&o.copy(r),l&&l.copy(i)),0;const c=a*a,h=s.min,u=s.max,d=this.points;let p=1/0;for(let t=0;t<8;t++){const e=d[t];i.copy(e).clamp(h,u);const n=e.distanceToSquared(i);if(n<p&&(p=n,o&&o.copy(e),l&&l.copy(i),n<c))return Math.sqrt(n)}let f=0;for(let r=0;r<3;r++)for(let i=0;i<=1;i++)for(let s=0;s<=1;s++){const a=(r+1)%3,o=(r+2)%3,l=1<<r|i<<a|s<<o,c=d[i<<a|s<<o],p=d[l];e[f].set(c,p);const m=t[r],g=t[a],v=t[o],x=n[f],y=x.start,w=x.end;y[m]=h[m],y[g]=i?h[g]:u[g],y[v]=s?h[v]:u[g],w[m]=u[m],w[g]=i?h[g]:u[g],w[v]=s?h[v]:u[g],f++}for(let t=0;t<=1;t++)for(let e=0;e<=1;e++)for(let n=0;n<=1;n++){i.x=t?u.x:h.x,i.y=e?u.y:h.y,i.z=n?u.z:h.z,this.closestPointToPoint(i,r);const s=i.distanceToSquared(r);if(s<p&&(p=s,o&&o.copy(r),l&&l.copy(i),s<c))return Math.sqrt(s)}for(let t=0;t<12;t++){const s=e[t];for(let t=0;t<12;t++){const e=n[t];pb(s,e,r,i);const a=r.distanceToSquared(i);if(a<p&&(p=a,o&&o.copy(r),l&&l.copy(i),a<c))return Math.sqrt(a)}}return Math.sqrt(p)}}();const vb=new lr,xb=new lr,yb=new lr,wb=new jn,bb=new jn,_b=new jn,Mb=new lr;function Tb(t,e,n,r,i){const s=3*r,a=t.index.getX(s),o=t.index.getX(s+1),l=t.index.getX(s+2),c=function(t,e,n,r,i,s,a){vb.fromBufferAttribute(e,r),xb.fromBufferAttribute(e,i),yb.fromBufferAttribute(e,s);const o=function(t,e,n,r,i,s){let a;return a=s===y?t.intersectTriangle(r,n,e,!0,i):t.intersectTriangle(e,n,r,s!==w,i),null===a?null:{distance:t.origin.distanceTo(i),point:i.clone()}}(t,vb,xb,yb,Mb,a);if(o){n&&(wb.fromBufferAttribute(n,r),bb.fromBufferAttribute(n,i),_b.fromBufferAttribute(n,s),o.uv=bi.getUV(Mb,vb,xb,yb,wb,bb,_b,new jn));const t={a:r,b:i,c:s,normal:new lr,materialIndex:0};bi.getNormal(vb,xb,yb,t.normal),o.face=t,o.faceIndex=r}return o}(n,t.attributes.position,t.attributes.uv,a,o,l,e);return c?(c.faceIndex=r,i&&i.push(c),c):null}function Sb(t,e,n){return null===t?null:(t.point.applyMatrix4(e.matrixWorld),t.distance=t.point.distanceTo(n.ray.origin),t.object=e,t.distance<n.near||t.distance>n.far?null:t)}function Ab(t,e,n,r){const i=t.a,s=t.b,a=t.c;let o=e,l=e+1,c=e+2;n&&(o=n.getX(e),l=n.getX(e+1),c=n.getX(e+2)),i.x=r.getX(o),i.y=r.getY(o),i.z=r.getZ(o),s.x=r.getX(l),s.y=r.getY(l),s.z=r.getZ(l),a.x=r.getX(c),a.y=r.getY(c),a.z=r.getZ(c)}function Eb(t,e,n,r,i,s,a){const o=n.index,l=n.attributes.position;for(let n=t,c=e+t;n<c;n++)if(Ab(a,3*n,o,l),a.needsUpdate=!0,r(a,n,i,s))return!0;return!1}const Cb=new lr,Pb=new lr,Lb=new lr,Rb=new jn,Fb=new jn,Db=new jn;function Ib(t,e,n,r){const i=e.getIndex().array,s=e.getAttribute("position"),a=e.getAttribute("uv"),o=i[3*n],l=i[3*n+1],c=i[3*n+2];Cb.fromBufferAttribute(s,o),Pb.fromBufferAttribute(s,l),Lb.fromBufferAttribute(s,c);let h=0;const u=e.groups,d=3*n;for(let t=0,e=u.length;t<e;t++){const e=u[t],{start:n,count:r}=e;if(d>=n&&d<n+r){h=e.materialIndex;break}}let p=null;return a&&(Rb.fromBufferAttribute(a,o),Fb.fromBufferAttribute(a,l),Db.fromBufferAttribute(a,c),p=r&&r.uv?r.uv:new jn,bi.getUV(t,Cb,Pb,Lb,Rb,Fb,Db,p)),r?(r.face||(r.face={}),r.face.a=o,r.face.b=l,r.face.c=c,r.face.materialIndex=h,r.face.normal||(r.face.normal=new lr),bi.getNormal(Cb,Pb,Lb,r.face.normal),r.uv||(r.uv=new jn),r.uv.copy(p),r):{face:{a:o,b:l,c,materialIndex:h,normal:bi.getNormal(Cb,Pb,Lb,new lr)},uv:p}}class Ub{constructor(t){this._getNewPrimitive=t,this._primitives=[]}getPrimitive(){const t=this._primitives;return 0===t.length?this._getNewPrimitive():t.pop()}releasePrimitive(t){this._primitives.push(t)}}function Nb(t,e){return 65535===e[t+15]}function Ob(t,e){return e[t+6]}function Bb(t,e){return e[t+14]}function zb(t){return t+8}function kb(t,e){return e[t+6]}function Hb(t,e){return e[t+7]}const Gb=new ur,Vb=new lr,Wb=["x","y","z"];function Xb(t,e,n,r,i){let s=2*t,a=Kb,o=$b,l=t_;if(Nb(s,o))!function(t,e,n,r,i,s){for(let a=r,o=r+i;a<o;a++)Tb(t,e,n,a,s)}(e,n,r,Ob(t,l),Bb(s,o),i);else{const s=zb(t);Qb(s,a,r,Vb)&&Xb(s,e,n,r,i);const o=kb(t,l);Qb(o,a,r,Vb)&&Xb(o,e,n,r,i)}}function jb(t,e,n,r){let i=2*t,s=Kb,a=$b,o=t_;if(Nb(i,a))return function(t,e,n,r,i){let s=1/0,a=null;for(let o=r,l=r+i;o<l;o++){const r=Tb(t,e,n,o);r&&r.distance<s&&(a=r,s=r.distance)}return a}(e,n,r,Ob(t,o),Bb(i,a));{const i=Hb(t,o),a=Wb[i],l=r.direction[a]>=0;let c,h;l?(c=zb(t),h=kb(t,o)):(c=kb(t,o),h=zb(t));const u=Qb(c,s,r,Vb)?jb(c,e,n,r):null;if(u){const t=u.point[a];if(l?t<=s[h+i]:t>=s[h+i+3])return u}const d=Qb(h,s,r,Vb)?jb(h,e,n,r):null;return u&&d?u.distance<=d.distance?u:d:u||d||null}}const Yb=function(){let t,e;const n=[],r=new Ub((()=>new ur));return function(...s){t=r.getPrimitive(),e=r.getPrimitive(),n.push(t,e);const a=i(...s);r.releasePrimitive(t),r.releasePrimitive(e),n.pop(),n.pop();const o=n.length;return o>0&&(e=n[o-1],t=n[o-2]),a};function i(n,r,s,a,o=null,l=0,c=0){function h(t){let e=2*t,n=$b,r=t_;for(;!Nb(e,n);)e=2*(t=zb(t));return Ob(t,r)}function u(t){let e=2*t,n=$b,r=t_;for(;!Nb(e,n);)e=2*(t=kb(t,r));return Ob(t,r)+Bb(e,n)}let d=2*n,p=Kb,f=$b,m=t_;if(Nb(d,f)){const e=Ob(n,m),r=Bb(d,f);return eb(n,p,t),a(e,r,!1,c,l+n,t)}{const d=zb(n),g=kb(n,m);let v,x,y,w,b=d,_=g;if(o&&(y=t,w=e,eb(b,p,y),eb(_,p,w),v=o(y),x=o(w),x<v)){b=g,_=d;const t=v;v=x,x=t,y=w}y||(y=t,eb(b,p,y));const M=s(y,Nb(2*b,f),v,c+1,l+b);let T;if(M===Qw){const t=h(b);T=a(t,u(b)-t,!0,c+1,l+b,y)}else T=M&&i(b,r,s,a,o,l,c+1);if(T)return!0;w=e,eb(_,p,w);const S=s(w,Nb(2*_,f),x,c+1,l+_);let A;if(S===Qw){const t=h(_);A=a(t,u(_)-t,!0,c+1,l+_,w)}else A=S&&i(_,r,s,a,o,l,c+1);return!!A}}}(),qb=function(){const t=new mb,e=new mb,n=new zr,r=new gb,i=new gb;return function s(a,o,l,c,h=null){let u=2*a,d=Kb,p=$b,f=t_;if(null===h&&(l.boundingBox||l.computeBoundingBox(),r.set(l.boundingBox.min,l.boundingBox.max,c),h=r),!Nb(u,p)){const t=a+8,e=f[a+6];return eb(t,d,Gb),h.intersectsBox(Gb)&&s(t,o,l,c,h)?!0:(eb(e,d,Gb),!(!h.intersectsBox(Gb)||!s(e,o,l,c,h)))}{const r=o,s=r.index,h=r.attributes.position,m=l.index,g=l.attributes.position,v=Ob(a,f),x=Bb(u,p);if(n.copy(c).invert(),l.boundsTree){eb(a,d,i),i.matrix.copy(n),i.needsUpdate=!0;const t=l.boundsTree.shapecast({intersectsBounds:t=>i.intersectsBox(t),intersectsTriangle:t=>{t.a.applyMatrix4(c),t.b.applyMatrix4(c),t.c.applyMatrix4(c),t.needsUpdate=!0;for(let n=3*v,r=3*(x+v);n<r;n+=3)if(Ab(e,n,s,h),e.needsUpdate=!0,t.intersectsTriangle(e))return!0;return!1}});return t}for(let r=3*v,i=x+3*v;r<i;r+=3){Ab(t,r,s,h),t.a.applyMatrix4(n),t.b.applyMatrix4(n),t.c.applyMatrix4(n),t.needsUpdate=!0;for(let n=0,r=m.count;n<r;n+=3)if(Ab(e,n,m,g),e.needsUpdate=!0,t.intersectsTriangle(e))return!0}}}}();function Qb(t,e,n,r){return eb(t,e,Gb),n.intersectBox(Gb,r)}const Zb=[];let Jb,Kb,$b,t_;function e_(t){Jb&&Zb.push(Jb),Jb=t,Kb=new Float32Array(t),$b=new Uint16Array(t),t_=new Uint32Array(t)}function n_(){Jb=null,Kb=null,$b=null,t_=null,Zb.length&&e_(Zb.pop())}const r_=Symbol("skip tree generation"),i_=new ur,s_=new ur,a_=new zr,o_=new gb,l_=new gb,c_=new lr,h_=new lr,u_=new lr,d_=new lr,p_=new lr,f_=new ur,m_=new Ub((()=>new mb));class g_{static serialize(t,e={}){if(e.isBufferGeometry)return console.warn("MeshBVH.serialize: The arguments for the function have changed. See documentation for new signature."),g_.serialize(arguments[0],{cloneBuffers:void 0===arguments[2]||arguments[2]});e={cloneBuffers:!0,...e};const n=t.geometry,r=t._roots,i=n.getIndex();let s;return s=e.cloneBuffers?{roots:r.map((t=>t.slice())),index:i.array.slice()}:{roots:r,index:i.array},s}static deserialize(t,e,n={}){if("boolean"==typeof n)return console.warn("MeshBVH.deserialize: The arguments for the function have changed. See documentation for new signature."),g_.deserialize(arguments[0],arguments[1],{setIndex:void 0===arguments[2]||arguments[2]});n={setIndex:!0,...n};const{index:r,roots:i}=t,s=new g_(e,{...n,[r_]:!0});if(s._roots=i,n.setIndex){const n=e.getIndex();if(null===n){const n=new Ii(t.index,1,!1);e.setIndex(n)}else n.array!==r&&(n.array.set(r),n.needsUpdate=!0)}return s}constructor(t,e={}){if(!t.isBufferGeometry)throw new Error("MeshBVH: Only BufferGeometries are supported.");if(t.index&&t.index.isInterleavedBufferAttribute)throw new Error("MeshBVH: InterleavedBufferAttribute is not supported for the index attribute.");if((e=Object.assign({strategy:Ww,maxDepth:40,maxLeafTris:10,verbose:!0,useSharedArrayBuffer:!1,setBoundingBox:!0,onProgress:null,[r_]:!1},e)).useSharedArrayBuffer&&"undefined"==typeof SharedArrayBuffer)throw new Error("MeshBVH: SharedArrayBuffer is not available.");this._roots=null,e[r_]||(this._roots=function(t,e){const n=function(t,e){function n(t){d&&d(t/p)}function r(e,i,d,p=null,m=0){if(!f&&m>=l&&(f=!0,c&&(console.warn(`MeshBVH: Max depth of ${l} reached when generating BVH. Consider increasing maxDepth.`),console.warn(t))),d<=h||m>=l)return n(i),e.offset=i,e.count=d,e;const g=function(t,e,n,r,i,s){let a=-1,o=0;if(s===Ww)a=nb(e),-1!==a&&(o=(e[a]+e[a+3])/2);else if(s===Xw)a=nb(t),-1!==a&&(o=function(t,e,n,r){let i=0;for(let s=e,a=e+n;s<a;s++)i+=t[6*s+2*r];return i/n}(n,r,i,a));else if(s===jw){const s=ab(t);let l=Zw*i;const c=6*r,h=6*(r+i);for(let t=0;t<3;t++){const r=e[t],u=(e[t+3]-r)/32;if(i<8){const e=[...cb];e.length=i;let r=0;for(let i=c;i<h;i+=6,r++){const s=e[r];s.candidate=n[i+2*t],s.count=0;const{bounds:a,leftCacheBounds:o,rightCacheBounds:l}=s;for(let t=0;t<3;t++)l[t]=1/0,l[t+3]=-1/0,o[t]=1/0,o[t+3]=-1/0,a[t]=1/0,a[t+3]=-1/0;sb(i,n,a)}e.sort(lb);let u=i;for(let t=0;t<u;t++){const n=e[t];for(;t+1<u&&e[t+1].candidate===n.candidate;)e.splice(t+1,1),u--}for(let r=c;r<h;r+=6){const i=n[r+2*t];for(let t=0;t<u;t++){const s=e[t];i>=s.candidate?sb(r,n,s.rightCacheBounds):(sb(r,n,s.leftCacheBounds),s.count++)}}for(let n=0;n<u;n++){const r=e[n],c=r.count,h=i-r.count,u=r.leftCacheBounds,d=r.rightCacheBounds;let p=0;0!==c&&(p=ab(u)/s);let f=0;0!==h&&(f=ab(d)/s);const m=1+Zw*(p*c+f*h);m<l&&(a=t,l=m,o=r.candidate)}}else{for(let t=0;t<32;t++){const e=cb[t];e.count=0,e.candidate=r+u+t*u;const n=e.bounds;for(let t=0;t<3;t++)n[t]=1/0,n[t+3]=-1/0}for(let e=c;e<h;e+=6){let i=~~((n[e+2*t]-r)/u);i>=32&&(i=31);const s=cb[i];s.count++,sb(e,n,s.bounds)}const e=cb[31];rb(e.bounds,e.rightCacheBounds);for(let t=30;t>=0;t--){const e=cb[t],n=cb[t+1];ib(e.bounds,n.rightCacheBounds,e.rightCacheBounds)}let d=0;for(let e=0;e<31;e++){const n=cb[e],r=n.count,c=n.bounds,h=cb[e+1].rightCacheBounds;0!==r&&(0===d?rb(c,hb):ib(c,hb,hb)),d+=r;let u=0,p=0;0!==d&&(u=ab(hb)/s);const f=i-d;0!==f&&(p=ab(h)/s);const m=1+Zw*(u*d+p*f);m<l&&(a=t,l=m,o=n.candidate)}}}}else console.warn(`MeshBVH: Invalid build strategy value ${s} used.`);return{axis:a,pos:o}}(e.boundingData,p,a,i,d,u);if(-1===g.axis)return n(i),e.offset=i,e.count=d,e;const v=function(t,e,n,r,i){let s=n,a=n+r-1;const o=i.pos,l=2*i.axis;for(;;){for(;s<=a&&e[6*s+l]<o;)s++;for(;s<=a&&e[6*a+l]>=o;)a--;if(!(s<a))return s;for(let n=0;n<3;n++){let r=t[3*s+n];t[3*s+n]=t[3*a+n],t[3*a+n]=r;let i=e[6*s+2*n+0];e[6*s+2*n+0]=e[6*a+2*n+0],e[6*a+2*n+0]=i;let o=e[6*s+2*n+1];e[6*s+2*n+1]=e[6*a+2*n+1],e[6*a+2*n+1]=o}s++,a--}}(o,a,i,d,g);if(v===i||v===i+d)n(i),e.offset=i,e.count=d;else{e.splitAxis=g.axis;const t=new tb,n=i,o=v-i;e.left=t,t.boundingData=new Float32Array(6),ob(a,n,o,t.boundingData,s),r(t,n,o,s,m+1);const l=new tb,c=v,h=d-o;e.right=l,l.boundingData=new Float32Array(6),ob(a,c,h,l.boundingData,s),r(l,c,h,s,m+1)}return e}!function(t,e){if(!t.index){const n=t.attributes.position.count,r=e.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer;let i;i=n>65535?new Uint32Array(new r(4*n)):new Uint16Array(new r(2*n)),t.setIndex(new Ii(i,1));for(let t=0;t<n;t++)i[t]=t}}(t,e);const i=new Float32Array(6),s=new Float32Array(6),a=function(t,e){const n=t.attributes.position,r=n.array,i=t.index.array,s=i.length/3,a=new Float32Array(6*s),o=n.offset||0;let l=3;n.isInterleavedBufferAttribute&&(l=n.data.stride);for(let t=0;t<s;t++){const n=3*t,s=6*t,c=i[n+0]*l+o,h=i[n+1]*l+o,u=i[n+2]*l+o;for(let t=0;t<3;t++){const n=r[c+t],i=r[h+t],o=r[u+t];let l=n;i<l&&(l=i),o<l&&(l=o);let d=n;i>d&&(d=i),o>d&&(d=o);const p=(d-l)/2,f=2*t;a[s+f+0]=l+p,a[s+f+1]=p+(Math.abs(l)+p)*$w,l<e[t]&&(e[t]=l),d>e[t+3]&&(e[t+3]=d)}}return a}(t,i),o=t.index.array,l=e.maxDepth,c=e.verbose,h=e.maxLeafTris,u=e.strategy,d=e.onProgress,p=t.index.count/3;let f=!1;const m=[],g=function(t){if(!t.groups||!t.groups.length)return[{offset:0,count:t.index.count/3}];const e=[],n=new Set;for(const e of t.groups)n.add(e.start),n.add(e.start+e.count);const r=Array.from(n.values()).sort(((t,e)=>t-e));for(let t=0;t<r.length-1;t++){const n=r[t],i=r[t+1];e.push({offset:n/3,count:(i-n)/3})}return e}(t);if(1===g.length){const t=g[0],e=new tb;e.boundingData=i,function(t,e,n,r){let i=1/0,s=1/0,a=1/0,o=-1/0,l=-1/0,c=-1/0;for(let r=6*e,h=6*(e+n);r<h;r+=6){const e=t[r+0];e<i&&(i=e),e>o&&(o=e);const n=t[r+2];n<s&&(s=n),n>l&&(l=n);const h=t[r+4];h<a&&(a=h),h>c&&(c=h)}r[0]=i,r[1]=s,r[2]=a,r[3]=o,r[4]=l,r[5]=c}(a,t.offset,t.count,s),r(e,t.offset,t.count,s),m.push(e)}else for(let t of g){const e=new tb;e.boundingData=new Float32Array(6),ob(a,t.offset,t.count,e.boundingData,s),r(e,t.offset,t.count,s),m.push(e)}return m}(t,e);let r,i,s;const a=[],o=e.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer;for(let t=0;t<n.length;t++){const e=n[t];let h=l(e);const u=new o(Jw*h);r=new Float32Array(u),i=new Uint32Array(u),s=new Uint16Array(u),c(0,e),a.push(u)}return a;function l(t){return t.count?1:1+l(t.left)+l(t.right)}function c(t,e){const n=t/4,a=t/2,o=!!e.count,l=e.boundingData;for(let t=0;t<6;t++)r[n+t]=l[t];if(o){const r=e.offset,o=e.count;return i[n+6]=r,s[a+14]=o,s[a+15]=Kw,t+Jw}{const r=e.left,s=e.right,a=e.splitAxis;let o;if(o=c(t+Jw,r),o/4>Math.pow(2,32))throw new Error("MeshBVH: Cannot store child pointer greater than 32 bits.");return i[n+6]=o/4,o=c(o,s),i[n+7]=a,o}}}(t,e),!t.boundingBox&&e.setBoundingBox&&(t.boundingBox=this.getBoundingBox(new ur))),this.geometry=t}refit(t=null){t&&Array.isArray(t)&&(t=new Set(t));const e=this.geometry,n=e.index.array,r=e.attributes.position,i=r.array,s=r.offset||0;let a,o,l,c,h=3;r.isInterleavedBufferAttribute&&(h=r.data.stride);let u=0;const d=this._roots;for(let t=0,e=d.length;t<e;t++)a=d[t],o=new Uint32Array(a),l=new Uint16Array(a),c=new Float32Array(a),p(0,u),u+=a.byteLength;function p(e,r,a=!1){const u=2*e;if(l[u+15]===Kw){const t=o[e+6];let r=1/0,a=1/0,d=1/0,p=-1/0,f=-1/0,m=-1/0;for(let e=3*t,o=3*(t+l[u+14]);e<o;e++){const t=n[e]*h+s,o=i[t+0],l=i[t+1],c=i[t+2];o<r&&(r=o),o>p&&(p=o),l<a&&(a=l),l>f&&(f=l),c<d&&(d=c),c>m&&(m=c)}return(c[e+0]!==r||c[e+1]!==a||c[e+2]!==d||c[e+3]!==p||c[e+4]!==f||c[e+5]!==m)&&(c[e+0]=r,c[e+1]=a,c[e+2]=d,c[e+3]=p,c[e+4]=f,c[e+5]=m,!0)}{const n=e+8,i=o[e+6],s=n+r,l=i+r;let h=a,u=!1,d=!1;t?h||(u=t.has(s),d=t.has(l),h=!u&&!d):(u=!0,d=!0);const f=h||d;let m=!1;(h||u)&&(m=p(n,r,h));let g=!1;f&&(g=p(i,r,h));const v=m||g;if(v)for(let t=0;t<3;t++){const r=n+t,s=i+t,a=c[r],o=c[r+3],l=c[s],h=c[s+3];c[e+t]=a<l?a:l,c[e+t+3]=o>h?o:h}return v}}}traverse(t,e=0){const n=this._roots[e],r=new Uint32Array(n),i=new Uint16Array(n);!function e(s,a=0){const o=2*s,l=i[o+15]===Kw;if(l){const e=r[s+6],c=i[o+14];t(a,l,new Float32Array(n,4*s,6),e,c)}else{const i=s+8,o=r[s+6],c=r[s+7];t(a,l,new Float32Array(n,4*s,6),c)||(e(i,a+1),e(o,a+1))}}(0)}raycast(t,e=x){const n=this._roots,r=this.geometry,i=[],s=e.isMaterial,a=Array.isArray(e),o=r.groups,l=s?e.side:e;for(let s=0,c=n.length;s<c;s++){const c=a?e[o[s].materialIndex].side:l,h=i.length;if(e_(n[s]),Xb(0,r,c,t,i),n_(),a){const t=o[s].materialIndex;for(let e=h,n=i.length;e<n;e++)i[e].face.materialIndex=t}}return i}raycastFirst(t,e=x){const n=this._roots,r=this.geometry,i=e.isMaterial,s=Array.isArray(e);let a=null;const o=r.groups,l=i?e.side:e;for(let i=0,c=n.length;i<c;i++){const c=s?e[o[i].materialIndex].side:l;e_(n[i]);const h=jb(0,r,c,t);n_(),null!=h&&(null==a||h.distance<a.distance)&&(a=h,s&&(h.face.materialIndex=o[i].materialIndex))}return a}intersectsGeometry(t,e){const n=this.geometry;let r=!1;for(const i of this._roots)if(e_(i),r=qb(0,n,t,e),n_(),r)break;return r}shapecast(t,e,n){const r=this.geometry;if(t instanceof Function){if(e){const t=e;e=(e,n,r,i)=>{const s=3*n;return t(e,s,s+1,s+2,r,i)}}t={boundsTraverseOrder:n,intersectsBounds:t,intersectsTriangle:e,intersectsRange:null},console.warn("MeshBVH: Shapecast function signature has changed and now takes an object of callbacks as a second argument. See docs for new signature.")}const i=m_.getPrimitive();let{boundsTraverseOrder:s,intersectsBounds:a,intersectsRange:o,intersectsTriangle:l}=t;if(o&&l){const t=o;o=(e,n,s,a,o)=>!!t(e,n,s,a,o)||Eb(e,n,r,l,s,a,i)}else o||(o=l?(t,e,n,s)=>Eb(t,e,r,l,n,s,i):(t,e,n)=>n);let c=!1,h=0;for(const t of this._roots){if(e_(t),c=Yb(0,r,a,o,s,h),n_(),c)break;h+=t.byteLength}return m_.releasePrimitive(i),c}bvhcast(t,e,n){let{intersectsRanges:r,intersectsTriangles:i}=n;const s=this.geometry.index,a=this.geometry.attributes.position,o=t.geometry.index,l=t.geometry.attributes.position;a_.copy(e).invert();const c=m_.getPrimitive(),h=m_.getPrimitive();if(i){function t(t,n,r,u,d,p,f,m){for(let g=r,v=r+u;g<v;g++){Ab(h,3*g,o,l),h.a.applyMatrix4(e),h.b.applyMatrix4(e),h.c.applyMatrix4(e),h.needsUpdate=!0;for(let e=t,r=t+n;e<r;e++)if(Ab(c,3*e,s,a),c.needsUpdate=!0,i(c,h,e,g,d,p,f,m))return!0}return!1}if(r){const e=r;r=function(n,r,i,s,a,o,l,c){return!!e(n,r,i,s,a,o,l,c)||t(n,r,i,s,a,o,l,c)}}else r=t}this.getBoundingBox(s_),s_.applyMatrix4(e);const u=this.shapecast({intersectsBounds:t=>s_.intersectsBox(t),intersectsRange:(e,n,i,s,a,o)=>(i_.copy(o),i_.applyMatrix4(a_),t.shapecast({intersectsBounds:t=>i_.intersectsBox(t),intersectsRange:(t,i,o,l,c)=>r(e,n,t,i,s,a,l,c)}))});return m_.releasePrimitive(c),m_.releasePrimitive(h),u}intersectsBox(t,e){return o_.set(t.min,t.max,e),o_.needsUpdate=!0,this.shapecast({intersectsBounds:t=>o_.intersectsBox(t),intersectsTriangle:t=>o_.intersectsTriangle(t)})}intersectsSphere(t){return this.shapecast({intersectsBounds:e=>t.intersectsBox(e),intersectsTriangle:e=>e.intersectsSphere(t)})}closestPointToGeometry(t,e,n={},r={},i=0,s=1/0){t.boundingBox||t.computeBoundingBox(),o_.set(t.boundingBox.min,t.boundingBox.max,e),o_.needsUpdate=!0;const a=this.geometry,o=a.attributes.position,l=a.index,c=t.attributes.position,h=t.index,u=m_.getPrimitive(),d=m_.getPrimitive();let p=h_,f=u_,m=null,g=null;r&&(m=d_,g=p_);let v=1/0,x=null,y=null;return a_.copy(e).invert(),l_.matrix.copy(a_),this.shapecast({boundsTraverseOrder:t=>o_.distanceToBox(t,Math.min(v,s)),intersectsBounds:(t,e,n)=>n<v&&n<s&&(e&&(l_.min.copy(t.min),l_.max.copy(t.max),l_.needsUpdate=!0),!0),intersectsRange:(n,r)=>{if(t.boundsTree)return t.boundsTree.shapecast({boundsTraverseOrder:t=>l_.distanceToBox(t,Math.min(v,s)),intersectsBounds:(t,e,n)=>n<v&&n<s,intersectsRange:(t,s)=>{for(let a=3*t,w=3*(t+s);a<w;a+=3){Ab(d,a,h,c),d.a.applyMatrix4(e),d.b.applyMatrix4(e),d.c.applyMatrix4(e),d.needsUpdate=!0;for(let t=3*n,e=3*(n+r);t<e;t+=3){Ab(u,t,l,o),u.needsUpdate=!0;const e=u.distanceToTriangle(d,p,m);if(e<v&&(f.copy(p),g&&g.copy(m),v=e,x=t/3,y=a/3),e<i)return!0}}}});for(let t=0,s=h?h.count:c.count;t<s;t+=3){Ab(d,t,h,c),d.a.applyMatrix4(e),d.b.applyMatrix4(e),d.c.applyMatrix4(e),d.needsUpdate=!0;for(let e=3*n,s=3*(n+r);e<s;e+=3){Ab(u,e,l,o),u.needsUpdate=!0;const n=u.distanceToTriangle(d,p,m);if(n<v&&(f.copy(p),g&&g.copy(m),v=n,x=e/3,y=t/3),n<i)return!0}}}}),m_.releasePrimitive(u),m_.releasePrimitive(d),v===1/0?null:(n.point?n.point.copy(f):n.point=f.clone(),n.distance=v,n.faceIndex=x,r&&(r.point?r.point.copy(g):r.point=g.clone(),r.point.applyMatrix4(a_),f.applyMatrix4(a_),r.distance=f.sub(r.point).length(),r.faceIndex=y),n)}closestPointToPoint(t,e={},n=0,r=1/0){const i=n*n,s=r*r;let a=1/0,o=null;if(this.shapecast({boundsTraverseOrder:e=>(c_.copy(t).clamp(e.min,e.max),c_.distanceToSquared(t)),intersectsBounds:(t,e,n)=>n<a&&n<s,intersectsTriangle:(e,n)=>{e.closestPointToPoint(t,c_);const r=t.distanceToSquared(c_);return r<a&&(h_.copy(c_),a=r,o=n),r<i}}),a===1/0)return null;const l=Math.sqrt(a);return e.point?e.point.copy(h_):e.point=h_.clone(),e.distance=l,e.faceIndex=o,e}getBoundingBox(t){return t.makeEmpty(),this._roots.forEach((e=>{eb(0,new Float32Array(e),f_),t.union(f_)})),t}}const v_=g_.prototype.raycast;g_.prototype.raycast=function(...t){if(t[0].isMesh){console.warn('MeshBVH: The function signature and results frame for "raycast" has changed. See docs for new signature.');const[e,n,r,i]=t;return v_.call(this,r,e.material).forEach((t=>{(t=Sb(t,e,n))&&i.push(t)})),i}return v_.apply(this,t)};const x_=g_.prototype.raycastFirst;g_.prototype.raycastFirst=function(...t){if(t[0].isMesh){console.warn('MeshBVH: The function signature and results frame for "raycastFirst" has changed. See docs for new signature.');const[e,n,r]=t;return Sb(x_.call(this,r,e.material),e,n)}return x_.apply(this,t)};const y_=g_.prototype.closestPointToPoint;g_.prototype.closestPointToPoint=function(...t){if(t[0].isMesh){console.warn('MeshBVH: The function signature and results frame for "closestPointToPoint" has changed. See docs for new signature.'),t.unshift();const e=t[1],n={};return t[1]=n,y_.apply(this,t),e&&e.copy(n.point),n.distance}return y_.apply(this,t)};const w_=g_.prototype.closestPointToGeometry;g_.prototype.closestPointToGeometry=function(...t){const e=t[2],n=t[3];if(e&&e.isVector3||n&&n.isVector3){console.warn('MeshBVH: The function signature and results frame for "closestPointToGeometry" has changed. See docs for new signature.');const r={},i={},s=t[1];return t[2]=r,t[3]=i,w_.apply(this,t),e&&e.copy(r.point),n&&n.copy(i.point).applyMatrix4(s),r.distance}return w_.apply(this,t)};const b_=g_.prototype.refit;g_.prototype.refit=function(...t){const e=t[0],n=t[1];if(n&&(n instanceof Set||Array.isArray(n))){console.warn('MeshBVH: The function signature for "refit" has changed. See docs for new signature.');const t=new Set;n.forEach((e=>t.add(e))),e&&e.forEach((e=>t.add(e))),b_.call(this,t)}else b_.apply(this,t)},["intersectsGeometry","shapecast","intersectsBox","intersectsSphere"].forEach((t=>{const e=g_.prototype[t];g_.prototype[t]=function(...n){return(null===n[0]||n[0].isMesh)&&(n.shift(),console.warn(`MeshBVH: The function signature for "${t}" has changed and no longer takes Mesh. See docs for new signature.`)),e.apply(this,n)}}));const __=new ur;class M_ extends hi{get isMesh(){return!this.displayEdges}get isLineSegments(){return this.displayEdges}get isLine(){return this.displayEdges}constructor(t,e,n=10,r=0){super(),this.material=e,this.geometry=new Ki,this.name="MeshBVHRootVisualizer",this.depth=n,this.displayParents=!1,this.mesh=t,this.displayEdges=!0,this._group=r}raycast(){}update(){const t=this.geometry,e=this.mesh.geometry.boundsTree,n=this._group;if(t.dispose(),this.visible=!1,e){const r=this.depth-1,i=this.displayParents;let s=0;e.traverse(((t,e)=>{if(t===r||e)return s++,!0;i&&s++}),n);let a=0;const o=new Float32Array(24*s);let l,c;e.traverse(((t,e,n)=>{const s=t===r||e;if(s||i){eb(0,n,__);const{min:t,max:e}=__;for(let n=-1;n<=1;n+=2){const r=n<0?t.x:e.x;for(let n=-1;n<=1;n+=2){const i=n<0?t.y:e.y;for(let n=-1;n<=1;n+=2){const s=n<0?t.z:e.z;o[a+0]=r,o[a+1]=i,o[a+2]=s,a+=3}}}return s}}),n),c=this.displayEdges?new Uint8Array([0,4,1,5,2,6,3,7,0,2,1,3,4,6,5,7,0,1,2,3,4,5,6,7]):new Uint8Array([0,1,2,2,1,3,4,6,5,6,7,5,1,4,5,0,4,1,2,3,6,3,7,6,0,2,4,2,6,4,1,5,3,3,5,7]),l=o.length>65535?new Uint32Array(c.length*s):new Uint16Array(c.length*s);const h=c.length;for(let t=0;t<s;t++){const e=8*t,n=t*h;for(let t=0;t<h;t++)l[n+t]=e+c[t]}t.setIndex(new Ii(l,1,!1)),t.setAttribute("position",new Ii(o,3,!1)),this.visible=!0}}}class T_ extends wl{get color(){return this.edgeMaterial.color}get opacity(){return this.edgeMaterial.opacity}set opacity(t){this.edgeMaterial.opacity=t,this.meshMaterial.opacity=t}constructor(t,e=10){super(),this.name="MeshBVHVisualizer",this.depth=e,this.mesh=t,this.displayParents=!1,this.displayEdges=!0,this._roots=[];const n=new gc({color:65416,transparent:!0,opacity:.3,depthWrite:!1}),r=new Ri({color:65416,transparent:!0,opacity:.3,depthWrite:!1});r.color=n.color,this.edgeMaterial=n,this.meshMaterial=r,this.update()}update(){const t=this.mesh.geometry.boundsTree,e=t?t._roots.length:0;for(;this._roots.length>e;)this._roots.pop();for(let t=0;t<e;t++){if(t>=this._roots.length){const e=new M_(this.mesh,this.edgeMaterial,this.depth,t);this.add(e),this._roots.push(e)}const e=this._roots[t];e.depth=this.depth,e.mesh=this.mesh,e.displayParents=this.displayParents,e.displayEdges=this.displayEdges,e.material=this.displayEdges?this.edgeMaterial:this.meshMaterial,e.update()}}updateMatrixWorld(...t){this.position.copy(this.mesh.position),this.rotation.copy(this.mesh.rotation),this.scale.copy(this.mesh.scale),super.updateMatrixWorld(...t)}copy(t){this.depth=t.depth,this.mesh=t.mesh}clone(){return new T_(this.mesh,this.depth)}dispose(){this.edgeMaterial.dispose(),this.meshMaterial.dispose();const t=this.children;for(let e=0,n=t.length;e<n;e++)t[e].geometry.dispose()}}const S_=new ur,A_=new ur,E_=new lr;function C_(t){switch(typeof t){case"number":return 8;case"string":return 2*t.length;case"boolean":return 4;default:return 0}}function P_(t){return t._roots.map(((e,n)=>function(t,e){const n={nodeCount:0,leafNodeCount:0,depth:{min:1/0,max:-1/0},tris:{min:1/0,max:-1/0},splits:[0,0,0],surfaceAreaScore:0};return t.traverse(((t,e,r,i,s)=>{const a=r[3]-r[0],o=r[4]-r[1],l=r[5]-r[2],c=2*(a*o+o*l+l*a);n.nodeCount++,e?(n.leafNodeCount++,n.depth.min=Math.min(t,n.depth.min),n.depth.max=Math.max(t,n.depth.max),n.tris.min=Math.min(s,n.tris.min),n.tris.max=Math.max(s,n.tris.max),n.surfaceAreaScore+=c*Zw*s):(n.splits[i]++,n.surfaceAreaScore+=1*c)}),e),n.tris.min===1/0&&(n.tris.min=0,n.tris.max=0),n.depth.min===1/0&&(n.depth.min=0,n.depth.max=0),n}(t,n)))}function L_(t){const e=new Set,n=[t];let r=0;for(;n.length;){const t=n.pop();if(!e.has(t)){e.add(t);for(let e in t){if(!t.hasOwnProperty(e))continue;r+=C_(e);const i=t[e];!i||"object"!=typeof i&&"function"!=typeof i?r+=C_(i):/(Uint|Int|Float)(8|16|32)Array/.test(i.constructor.name)||i instanceof ArrayBuffer?r+=i.byteLength:n.push(i)}}}return r}function R_(t){const e=t.geometry,n=[],r=e.index,i=e.getAttribute("position");let s=!0;return t.traverse(((t,e,a,o,l)=>{const c={depth:t,isLeaf:e,boundingData:a,offset:o,count:l};n[t]=c,eb(0,a,S_);const h=n[t-1];if(e)for(let t=3*o,e=3*(o+l);t<e;t+=3){const e=r.getX(t),n=r.getX(t+1),a=r.getX(t+2);let o;E_.fromBufferAttribute(i,e),o=S_.containsPoint(E_),E_.fromBufferAttribute(i,n),o=o&&S_.containsPoint(E_),E_.fromBufferAttribute(i,a),o=o&&S_.containsPoint(E_),console.assert(o,"Leaf bounds does not fully contain triangle."),s=s&&o}if(h){eb(0,a,A_);const t=A_.containsBox(S_);console.assert(t,"Parent bounds does not fully contain child."),s=s&&t}})),s}function F_(t){const e=[];return t.traverse(((t,n,r,i,s)=>{const a={bounds:eb(0,r,new ur)};n?(a.count=s,a.offset=i):(a.left=null,a.right=null),e[t]=a;const o=e[t-1];o&&(null===o.left?o.left=a:o.right=a)})),e[0]}const D_=new Br,I_=new zr,U_=gs.prototype.raycast;function N_(t,e){if(this.geometry.boundsTree){if(void 0===this.material)return;I_.copy(this.matrixWorld).invert(),D_.copy(t.ray).applyMatrix4(I_);const n=this.geometry.boundsTree;if(!0===t.firstHitOnly){const r=Sb(n.raycastFirst(D_,this.material),this,t);r&&e.push(r)}else{const r=n.raycast(D_,this.material);for(let n=0,i=r.length;n<i;n++){const i=Sb(r[n],this,t);i&&e.push(i)}}}else U_.call(this,t,e)}function O_(t){return this.boundsTree=new g_(this,t),this.boundsTree}function B_(){this.boundsTree=null}function z_(t){switch(t){case 1:return qt;case 2:return Zt;case 3:return Jt;case 4:return Kt}}class k_ extends ac{constructor(){super(),this.minFilter=xt,this.magFilter=xt,this.generateMipmaps=!1,this.overrideItemSize=null,this._forcedType=null}updateFrom(t){const e=this.overrideItemSize,n=t.itemSize,r=t.count;if(null!==e){if(n*r%e!=0)throw new Error("VertexAttributeTexture: overrideItemSize must divide evenly into buffer length.");t.itemSize=e,t.count=r*n/e}const i=t.itemSize,s=t.count,a=t.normalized,o=t.array.constructor,l=o.BYTES_PER_ELEMENT;let c,h,u,d,p=this._forcedType;if(null===p)switch(o){case Float32Array:p=It;break;case Uint8Array:case Uint16Array:case Uint32Array:p=Dt;break;case Int8Array:case Int16Array:case Int32Array:p=Ft}let f=function(t){switch(t){case 1:return"R";case 2:return"RG";case 3:return"RGB";case 4:return"RGBA"}throw new Error}(i);switch(p){case It:u=1,h=function(t){switch(t){case 1:return Yt;case 2:return Qt;case 3:return Ht;case 4:return Gt}}(i),a&&1===l?(d=o,f+="8",o===Uint8Array?c=Ct:(c=Pt,f+="_SNORM")):(d=Float32Array,f+="32F",c=It);break;case Ft:f+=8*l+"I",u=a?Math.pow(2,8*o.BYTES_PER_ELEMENT-1):1,h=z_(i),1===l?(d=Int8Array,c=Pt):2===l?(d=Int16Array,c=Lt):(d=Int32Array,c=Ft);break;case Dt:f+=8*l+"UI",u=a?Math.pow(2,8*o.BYTES_PER_ELEMENT-1):1,h=z_(i),1===l?(d=Uint8Array,c=Ct):2===l?(d=Uint16Array,c=Rt):(d=Uint32Array,c=Dt)}const m=Math.ceil(Math.sqrt(s)),g=new d(i*m*m);for(let e=0;e<s;e++){const n=i*e;g[n]=t.getX(e)/u,i>=2&&(g[n+1]=t.getY(e)/u),i>=3&&(g[n+2]=t.getZ(e)/u),i>=4&&(g[n+3]=t.getW(e)/u)}this.internalFormat=f,this.format=h,this.type=c,this.image.width=m,this.image.height=m,this.image.data=g,this.needsUpdate=!0,t.itemSize=n,t.count=r}}class H_ extends k_{constructor(){super(),this._forcedType=Dt}}class G_ extends k_{constructor(){super(),this._forcedType=Ft}}class V_ extends k_{constructor(){super(),this._forcedType=It}}class W_{constructor(){this.autoDispose=!0,this.index=new H_,this.position=new V_,this.bvhBounds=new ac,this.bvhContents=new ac,this.index.overrideItemSize=3}updateFrom(t){const{geometry:e}=t;!function(t,e,n){const r=t._roots;if(1!==r.length)throw new Error("MeshBVHUniformStruct: Multi-root BVHs not supported.");const i=r[0],s=new Uint16Array(i),a=new Uint32Array(i),o=new Float32Array(i),l=i.byteLength/Jw,c=2*Math.ceil(Math.sqrt(l/2)),h=new Float32Array(3*c*c),u=Math.ceil(Math.sqrt(l)),d=new Uint32Array(2*u*u);for(let t=0;t<l;t++){const e=t*Jw/4,n=2*e,r=e;for(let e=0;e<6;e++)h[6*t+e]=o[r+e];if(Nb(n,s)){const r=Bb(n,s),i=Ob(e,a),o=4294901760|r;d[2*t+0]=o,d[2*t+1]=i}else{const n=4*kb(e,a)/Jw,r=Hb(e,a);d[2*t+0]=r,d[2*t+1]=n}}e.image.data=h,e.image.width=c,e.image.height=c,e.format=Ht,e.type=It,e.internalFormat="RGB32F",e.minFilter=xt,e.magFilter=xt,e.generateMipmaps=!1,e.needsUpdate=!0,n.image.data=d,n.image.width=u,n.image.height=u,n.format=Zt,n.type=Dt,n.internalFormat="RG32UI",n.minFilter=xt,n.magFilter=xt,n.generateMipmaps=!1,n.needsUpdate=!0}(t,this.bvhBounds,this.bvhContents),this.index.updateFrom(e.index),this.position.updateFrom(e.attributes.position)}dispose(){const{index:t,position:e,bvhBounds:n,bvhContents:r}=this;t&&t.dispose(),e&&e.dispose(),n&&n.dispose(),r&&r.dispose()}}const X_="\n#ifndef TRI_INTERSECT_EPSILON\n#define TRI_INTERSECT_EPSILON 1e-5\n#endif\n\n#ifndef INFINITY\n#define INFINITY 1e20\n#endif\n\nstruct BVH {\n\n\tusampler2D index;\n\tsampler2D position;\n\n\tsampler2D bvhBounds;\n\tusampler2D bvhContents;\n\n};\n\n// Note that a struct cannot be used for the hit record including faceIndices, faceNormal, barycoord,\n// side, and dist because on some mobile GPUS (such as Adreno) numbers are afforded less precision specifically\n// when in a struct leading to inaccurate hit results. See KhronosGroup/WebGL#3351 for more details.\n",j_="\n\nuvec4 uTexelFetch1D( usampler2D tex, uint index ) {\n\n\tuint width = uint( textureSize( tex, 0 ).x );\n\tuvec2 uv;\n\tuv.x = index % width;\n\tuv.y = index / width;\n\n\treturn texelFetch( tex, ivec2( uv ), 0 );\n\n}\n\nivec4 iTexelFetch1D( isampler2D tex, uint index ) {\n\n\tuint width = uint( textureSize( tex, 0 ).x );\n\tuvec2 uv;\n\tuv.x = index % width;\n\tuv.y = index / width;\n\n\treturn texelFetch( tex, ivec2( uv ), 0 );\n\n}\n\nvec4 texelFetch1D( sampler2D tex, uint index ) {\n\n\tuint width = uint( textureSize( tex, 0 ).x );\n\tuvec2 uv;\n\tuv.x = index % width;\n\tuv.y = index / width;\n\n\treturn texelFetch( tex, ivec2( uv ), 0 );\n\n}\n\nvec4 textureSampleBarycoord( sampler2D tex, vec3 barycoord, uvec3 faceIndices ) {\n\n\treturn\n\t\tbarycoord.x * texelFetch1D( tex, faceIndices.x ) +\n\t\tbarycoord.y * texelFetch1D( tex, faceIndices.y ) +\n\t\tbarycoord.z * texelFetch1D( tex, faceIndices.z );\n\n}\n\nvoid ndcToCameraRay(\n\tvec2 coord, mat4 cameraWorld, mat4 invProjectionMatrix,\n\tout vec3 rayOrigin, out vec3 rayDirection\n) {\n\n\t// get camera look direction and near plane for camera clipping\n\tvec4 lookDirection = cameraWorld * vec4( 0.0, 0.0, - 1.0, 0.0 );\n\tvec4 nearVector = invProjectionMatrix * vec4( 0.0, 0.0, - 1.0, 1.0 );\n\tfloat near = abs( nearVector.z / nearVector.w );\n\n\t// get the camera direction and position from camera matrices\n\tvec4 origin = cameraWorld * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec4 direction = invProjectionMatrix * vec4( coord, 0.5, 1.0 );\n\tdirection /= direction.w;\n\tdirection = cameraWorld * direction - origin;\n\n\t// slide the origin along the ray until it sits at the near clip plane position\n\torigin.xyz += direction.xyz * near / dot( direction, lookDirection );\n\n\trayOrigin = origin.xyz;\n\trayDirection = direction.xyz;\n\n}\n\nfloat intersectsBounds( vec3 rayOrigin, vec3 rayDirection, vec3 boundsMin, vec3 boundsMax ) {\n\n\t// https://www.reddit.com/r/opengl/comments/8ntzz5/fast_glsl_ray_box_intersection/\n\t// https://tavianator.com/2011/ray_box.html\n\tvec3 invDir = 1.0 / rayDirection;\n\n\t// find intersection distances for each plane\n\tvec3 tMinPlane = invDir * ( boundsMin - rayOrigin );\n\tvec3 tMaxPlane = invDir * ( boundsMax - rayOrigin );\n\n\t// get the min and max distances from each intersection\n\tvec3 tMinHit = min( tMaxPlane, tMinPlane );\n\tvec3 tMaxHit = max( tMaxPlane, tMinPlane );\n\n\t// get the furthest hit distance\n\tvec2 t = max( tMinHit.xx, tMinHit.yz );\n\tfloat t0 = max( t.x, t.y );\n\n\t// get the minimum hit distance\n\tt = min( tMaxHit.xx, tMaxHit.yz );\n\tfloat t1 = min( t.x, t.y );\n\n\t// set distance to 0.0 if the ray starts inside the box\n\tfloat dist = max( t0, 0.0 );\n\n\treturn t1 >= dist ? dist : INFINITY;\n\n}\n\nbool intersectsTriangle(\n\tvec3 rayOrigin, vec3 rayDirection, vec3 a, vec3 b, vec3 c,\n\tout vec3 barycoord, out vec3 norm, out float dist, out float side\n) {\n\n\t// https://stackoverflow.com/questions/42740765/intersection-between-line-and-triangle-in-3d\n\tvec3 edge1 = b - a;\n\tvec3 edge2 = c - a;\n\tnorm = cross( edge1, edge2 );\n\n\tfloat det = - dot( rayDirection, norm );\n\tfloat invdet = 1.0 / det;\n\n\tvec3 AO = rayOrigin - a;\n\tvec3 DAO = cross( AO, rayDirection );\n\n\tvec4 uvt;\n\tuvt.x = dot( edge2, DAO ) * invdet;\n\tuvt.y = - dot( edge1, DAO ) * invdet;\n\tuvt.z = dot( AO, norm ) * invdet;\n\tuvt.w = 1.0 - uvt.x - uvt.y;\n\n\t// set the hit information\n\tbarycoord = uvt.wxy; // arranged in A, B, C order\n\tdist = uvt.z;\n\tside = sign( det );\n\tnorm = side * normalize( norm );\n\n\t// add an epsilon to avoid misses between triangles\n\tuvt += vec4( TRI_INTERSECT_EPSILON );\n\n\treturn all( greaterThanEqual( uvt, vec4( 0.0 ) ) );\n\n}\n\nbool intersectTriangles(\n\tBVH bvh, vec3 rayOrigin, vec3 rayDirection, uint offset, uint count,\n\tinout float minDistance,\n\n\t// output variables\n\tout uvec4 faceIndices, out vec3 faceNormal, out vec3 barycoord,\n\tout float side, out float dist\n) {\n\n\tbool found = false;\n\tvec3 localBarycoord, localNormal;\n\tfloat localDist, localSide;\n\tfor ( uint i = offset, l = offset + count; i < l; i ++ ) {\n\n\t\tuvec3 indices = uTexelFetch1D( bvh.index, i ).xyz;\n\t\tvec3 a = texelFetch1D( bvh.position, indices.x ).rgb;\n\t\tvec3 b = texelFetch1D( bvh.position, indices.y ).rgb;\n\t\tvec3 c = texelFetch1D( bvh.position, indices.z ).rgb;\n\n\t\tif (\n\t\t\tintersectsTriangle( rayOrigin, rayDirection, a, b, c, localBarycoord, localNormal, localDist, localSide )\n\t\t\t&& localDist < minDistance\n\t\t) {\n\n\t\t\tfound = true;\n\t\t\tminDistance = localDist;\n\n\t\t\tfaceIndices = uvec4( indices.xyz, i );\n\t\t\tfaceNormal = localNormal;\n\n\t\t\tside = localSide;\n\t\t\tbarycoord = localBarycoord;\n\t\t\tdist = localDist;\n\n\t\t}\n\n\t}\n\n\treturn found;\n\n}\n\nfloat intersectsBVHNodeBounds( vec3 rayOrigin, vec3 rayDirection, BVH bvh, uint currNodeIndex ) {\n\n\tvec3 boundsMin = texelFetch1D( bvh.bvhBounds, currNodeIndex * 2u + 0u ).xyz;\n\tvec3 boundsMax = texelFetch1D( bvh.bvhBounds, currNodeIndex * 2u + 1u ).xyz;\n\treturn intersectsBounds( rayOrigin, rayDirection, boundsMin, boundsMax );\n\n}\n\nbool bvhIntersectFirstHit(\n\tBVH bvh, vec3 rayOrigin, vec3 rayDirection,\n\n\t// output variables\n\tout uvec4 faceIndices, out vec3 faceNormal, out vec3 barycoord,\n\tout float side, out float dist\n) {\n\n\t// stack needs to be twice as long as the deepest tree we expect because\n\t// we push both the left and right child onto the stack every traversal\n\tint ptr = 0;\n\tuint stack[ 60 ];\n\tstack[ 0 ] = 0u;\n\n\tfloat triangleDistance = 1e20;\n\tbool found = false;\n\twhile ( ptr > - 1 && ptr < 60 ) {\n\n\t\tuint currNodeIndex = stack[ ptr ];\n\t\tptr --;\n\n\t\t// check if we intersect the current bounds\n\t\tfloat boundsHitDistance = intersectsBVHNodeBounds( rayOrigin, rayDirection, bvh, currNodeIndex );\n\t\tif ( boundsHitDistance == INFINITY || boundsHitDistance > triangleDistance ) {\n\n\t\t\tcontinue;\n\n\t\t}\n\n\t\tuvec2 boundsInfo = uTexelFetch1D( bvh.bvhContents, currNodeIndex ).xy;\n\t\tbool isLeaf = bool( boundsInfo.x & 0xffff0000u );\n\n\t\tif ( isLeaf ) {\n\n\t\t\tuint count = boundsInfo.x & 0x0000ffffu;\n\t\t\tuint offset = boundsInfo.y;\n\n\t\t\tfound = intersectTriangles(\n\t\t\t\tbvh, rayOrigin, rayDirection, offset, count, triangleDistance,\n\t\t\t\tfaceIndices, faceNormal, barycoord, side, dist\n\t\t\t) || found;\n\n\t\t} else {\n\n\t\t\tuint leftIndex = currNodeIndex + 1u;\n\t\t\tuint splitAxis = boundsInfo.x & 0x0000ffffu;\n\t\t\tuint rightIndex = boundsInfo.y;\n\n\t\t\tbool leftToRight = rayDirection[ splitAxis ] >= 0.0;\n\t\t\tuint c1 = leftToRight ? leftIndex : rightIndex;\n\t\t\tuint c2 = leftToRight ? rightIndex : leftIndex;\n\n\t\t\t// set c2 in the stack so we traverse it later. We need to keep track of a pointer in\n\t\t\t// the stack while we traverse. The second pointer added is the one that will be\n\t\t\t// traversed first\n\t\t\tptr ++;\n\t\t\tstack[ ptr ] = c2;\n\n\t\t\tptr ++;\n\t\t\tstack[ ptr ] = c1;\n\n\t\t}\n\n\t}\n\n\treturn found;\n\n}\n\n",Y_={};var q_=n(470);function Q_(t){let e;try{e=new URL(t,"http://fakehost.com/")}catch(t){return null}const n=e.pathname.split("/").pop(),r=n.lastIndexOf(".");return-1===r||r===n.length-1?null:n.substring(r+1)}class Z_{constructor(){this.maxSize=800,this.minSize=600,this.unloadPercent=.05,this.itemSet=new Map,this.itemList=[],this.usedSet=new Set,this.callbacks=new Map,this.unloadPriorityCallback=null;const t=this.itemSet;this.defaultPriorityCallback=e=>t.get(e)}isFull(){return this.itemSet.size>=this.maxSize}add(t,e){const n=this.itemSet;if(n.has(t))return!1;if(this.isFull())return!1;const r=this.usedSet,i=this.itemList,s=this.callbacks;return i.push(t),r.add(t),n.set(t,Date.now()),s.set(t,e),!0}remove(t){const e=this.usedSet,n=this.itemSet,r=this.itemList,i=this.callbacks;if(n.has(t)){i.get(t)(t);const s=r.indexOf(t);return r.splice(s,1),e.delete(t),n.delete(t),i.delete(t),!0}return!1}markUsed(t){const e=this.itemSet,n=this.usedSet;e.has(t)&&!n.has(t)&&(e.set(t,Date.now()),n.add(t))}markAllUnused(){this.usedSet.clear()}unloadUnusedContent(){const t=this.unloadPercent,e=this.minSize,n=this.itemList,r=this.itemSet,i=this.usedSet,s=this.callbacks,a=n.length-i.size,o=n.length-e,l=this.unloadPriorityCallback||this.defaultPriorityCallback;if(o>0&&a>0){n.sort(((t,e)=>{const n=i.has(t),r=i.has(e);return n&&r?0:n||r?n?1:-1:l(e)-l(t)}));const c=Math.min(o,a),h=Math.max(e*t,c*t);let u=Math.min(h,a);u=Math.ceil(u);const d=n.splice(0,u);for(let t=0,e=d.length;t<e;t++){const e=d[t];s.get(e)(e),r.delete(e),s.delete(e)}}}scheduleUnload(t=!0){var e;this.scheduled||(this.scheduled=!0,e=()=>{this.scheduled=!1,this.unloadUnusedContent(),t&&this.markAllUnused()},Promise.resolve().then(e))}}class J_{constructor(){this.maxJobs=6,this.items=[],this.callbacks=new Map,this.currJobs=0,this.scheduled=!1,this.autoUpdate=!0,this.priorityCallback=()=>{throw new Error("PriorityQueue: PriorityCallback function not defined.")},this.schedulingCallback=t=>{requestAnimationFrame(t)},this._runjobs=()=>{this.tryRunJobs(),this.scheduled=!1}}sort(){const t=this.priorityCallback;this.items.sort(t)}add(t,e){return new Promise(((n,r)=>{const i=this.items,s=this.callbacks;i.push(t),s.set(t,((...t)=>e(...t).then(n).catch(r))),this.autoUpdate&&this.scheduleJobRun()}))}remove(t){const e=this.items,n=this.callbacks,r=e.indexOf(t);-1!==r&&(e.splice(r,1),n.delete(t))}tryRunJobs(){this.sort();const t=this.items,e=this.callbacks,n=this.maxJobs;let r=this.currJobs;for(;n>r&&t.length>0;){r++;const n=t.pop(),i=e.get(n);e.delete(n),i(n).then((()=>{this.currJobs--,this.autoUpdate&&this.scheduleJobRun()})).catch((()=>{this.currJobs--,this.autoUpdate&&this.scheduleJobRun()}))}this.currJobs=r}scheduleJobRun(){this.scheduled||(this.schedulingCallback(this._runjobs),this.scheduled=!0)}}function K_(t){return 3===t||4===t}function $_(t,e){return t.__lastFrameVisited===e&&t.__used}function tM(t,e){t.__lastFrameVisited!==e&&(t.__lastFrameVisited=e,t.__used=!1,t.__inFrustum=!1,t.__isLeaf=!1,t.__visible=!1,t.__active=!1,t.__error=1/0,t.__distanceFromCamera=1/0,t.__childrenWereVisible=!1,t.__allChildrenLoaded=!1)}function eM(t,e,n){if(tM(t,e),t.__used=!0,n.markUsed(t),t.__contentEmpty){const r=t.children;for(let t=0,i=r.length;t<i;t++)eM(r[t],e,n)}}function nM(t,e,n){if(!t.__contentEmpty||t.__externalTileSet&&!K_(t.__loadingState))n.requestTileContents(t);else{const r=t.children;for(let t=0,i=r.length;t<i;t++){const i=r[t];i.__depthFromRenderedParent=e,nM(i,e,n)}}}function rM(t,e=null,n=null,r=null,i=0){if(e&&e(t,r,i))return void(n&&n(t,r,i));const s=t.children;for(let r=0,a=s.length;r<a;r++)rM(s[r],e,n,t,i+1);n&&n(t,r,i)}function iM(t,e){const n=e.stats,r=e.frameCount,i=e.errorTarget,s=e.maxDepth,a=e.loadSiblings,o=e.lruCache,l=e.stopAtEmptyTiles;if(tM(t,r),!1===e.tileInView(t))return!1;if(t.__used=!0,o.markUsed(t),t.__inFrustum=!0,n.inFrustum++,(l||!t.__contentEmpty)&&!t.__externalTileSet){if(e.calculateError(t),t.__error<=i)return!0;if(e.maxDepth>0&&t.__depth+1>=s)return!0}let c=!1;const h=t.children;for(let t=0,n=h.length;t<n;t++){const n=iM(h[t],e);c=c||n}if(c&&a)for(let t=0,e=h.length;t<e;t++)eM(h[t],r,o);return!0}function sM(t,e){const n=e.stats,r=e.frameCount;if(!$_(t,r))return;n.used++;const i=t.children;let s=!1;for(let t=0,e=i.length;t<e;t++){const e=i[t];s=s||$_(e,r)}if(s){let n=!1,s=!0;for(let t=0,a=i.length;t<a;t++){const a=i[t];if(sM(a,e),n=n||a.__wasSetVisible||a.__childrenWereVisible,$_(a,r)){const t=a.__allChildrenLoaded||!a.__contentEmpty&&K_(a.__loadingState)||a.__externalTileSet&&4===a.__loadingState;s=s&&t}}t.__childrenWereVisible=n,t.__allChildrenLoaded=s}else t.__isLeaf=!0}function aM(t,e){const n=e.stats,r=e.frameCount;if(!$_(t,r))return;const i=t.parent,s=i?i.__depthFromRenderedParent:-1;t.__depthFromRenderedParent=s;const a=e.lruCache;if(t.__isLeaf)return t.__depthFromRenderedParent++,void(3===t.__loadingState?(t.__inFrustum&&(t.__visible=!0,n.visible++),t.__active=!0,n.active++):a.isFull()||t.__contentEmpty&&!t.__externalTileSet||e.requestTileContents(t));const o=(e.errorTarget+1)*e.errorThreshold,l=t.__error<=o,c=l||"ADD"===t.refine,h=!t.__contentEmpty,u=h||t.__externalTileSet,d=K_(t.__loadingState)&&u,p=t.__childrenWereVisible,f=t.children;let m=t.__allChildrenLoaded;if(c&&h&&t.__depthFromRenderedParent++,c&&!d&&!a.isFull()&&u&&e.requestTileContents(t),(l&&!m&&!p&&d||"ADD"===t.refine&&d)&&(t.__inFrustum&&(t.__visible=!0,n.visible++),t.__active=!0,n.active++),"ADD"!==t.refine&&l&&!m&&d)for(let n=0,i=f.length;n<i;n++){const i=f[n];$_(i,r)&&!a.isFull()&&(i.__depthFromRenderedParent=t.__depthFromRenderedParent+1,nM(i,i.__depthFromRenderedParent,e))}else for(let t=0,n=f.length;t<n;t++){const n=f[t];$_(n,r)&&aM(n,e)}}function oM(t,e){const n=$_(t,e.frameCount);if(n||t.__usedLastFrame){let r=!1,i=!1;n&&(r=t.__active,i=e.displayActiveTiles&&t.__active||t.__visible),t.__contentEmpty||3!==t.__loadingState||(t.__wasSetActive!==r&&e.setTileActive(t,r),t.__wasSetVisible!==i&&e.setTileVisible(t,i)),t.__wasSetActive=r,t.__wasSetVisible=i,t.__usedLastFrame=n;const s=t.children;for(let t=0,n=s.length;t<n;t++)oM(s[t],e)}}const lM=(t,e)=>t.__depth!==e.__depth?t.__depth>e.__depth?-1:1:t.__inFrustum!==e.__inFrustum?t.__inFrustum?1:-1:t.__used!==e.__used?t.__used?1:-1:t.__error!==e.__error?t.__error>e.__error?1:-1:t.__distanceFromCamera!==e.__distanceFromCamera?t.__distanceFromCamera>e.__distanceFromCamera?-1:1:0,cM=t=>1/(t.__depthFromRenderedParent+1);class hM{get rootTileSet(){const t=this.tileSets[this.rootURL];return!t||t instanceof Promise?null:t}get root(){const t=this.rootTileSet;return t?t.root:null}constructor(t){this.tileSets={},this.rootURL=t,this.fetchOptions={},this.preprocessURL=null;const e=new Z_;e.unloadPriorityCallback=cM;const n=new J_;n.maxJobs=4,n.priorityCallback=lM;const r=new J_;r.maxJobs=1,r.priorityCallback=lM,this.lruCache=e,this.downloadQueue=n,this.parseQueue=r,this.stats={parsing:0,downloading:0,failed:0,inFrustum:0,used:0,active:0,visible:0},this.frameCount=0,this.errorTarget=6,this.errorThreshold=1/0,this.loadSiblings=!0,this.displayActiveTiles=!1,this.maxDepth=1/0,this.stopAtEmptyTiles=!0}traverse(t,e){const n=this.tileSets[this.rootURL];n&&n.root&&rM(n.root,t,e)}update(){const t=this.stats,e=this.lruCache,n=this.tileSets,r=n[this.rootURL];if(!(this.rootURL in n))return void this.loadRootTileSet(this.rootURL);if(!r||!r.root)return;const i=r.root;t.inFrustum=0,t.used=0,t.active=0,t.visible=0,this.frameCount++,iM(i,this),sM(i,this),aM(i,this),oM(i,this),e.scheduleUnload()}parseTile(t,e,n){return null}disposeTile(t){}preprocessNode(t,e,n){if(t.content&&(!("uri"in t.content)&&"url"in t.content&&(t.content.uri=t.content.url,delete t.content.url),t.content.uri&&(t.content.uri=function(...t){const e=/^[a-zA-Z]+:\/\//;let n=-1;for(let r=0,i=t.length;r<i;r++)e.test(t[r])&&(n=r);if(-1===n)return q_.join(...t).replace(/\\/g,"/");{const r=n<=0?t:t.slice(n),i=r[0].match(e)[0];return r[0]=r[0].substring(i.length),(i+q_.join(...r)).replace(/\\/g,"/")}}(n,t.content.uri)),t.content.boundingVolume&&!("box"in t.content.boundingVolume||"sphere"in t.content.boundingVolume||"region"in t.content.boundingVolume)&&delete t.content.boundingVolume),t.parent=e,t.children=t.children||[],t.content&&t.content.uri){const e=Q_(t.content.uri),n=Boolean(e&&"json"===e.toLowerCase());t.__externalTileSet=n,t.__contentEmpty=n}else t.__externalTileSet=!1,t.__contentEmpty=!0;t.__distanceFromCamera=1/0,t.__error=1/0,t.__inFrustum=!1,t.__isLeaf=!1,t.__usedLastFrame=!1,t.__used=!1,t.__wasSetVisible=!1,t.__visible=!1,t.__childrenWereVisible=!1,t.__allChildrenLoaded=!1,t.__wasSetActive=!1,t.__active=!1,t.__loadingState=0,t.__loadIndex=0,t.__loadAbort=null,t.__depthFromRenderedParent=-1,null===e?(t.__depth=0,t.refine=t.refine||"REPLACE"):(t.__depth=e.__depth+1,t.refine=t.refine||e.refine)}setTileActive(t,e){}setTileVisible(t,e){}calculateError(t){return 0}tileInView(t){return!0}fetchTileSet(t,e,n=null){return fetch(t,e).then((e=>{if(e.ok)return e.json();throw new Error(`TilesRenderer: Failed to load tileset "${t}" with status ${e.status} : ${e.statusText}`)})).then((e=>{const r=e.asset.version;console.assert("1.0"===r||"0.0"===r,'asset.version is expected to be a string of "1.0" or "0.0"');const i=q_.dirname(t);return rM(e.root,((t,e)=>this.preprocessNode(t,e,i)),null,n,n?n.__depth:0),e}))}loadRootTileSet(t){const e=this.tileSets;if(t in e)return e[t]instanceof Error?Promise.reject(e[t]):Promise.resolve(e[t]);{const n=this.fetchTileSet(t,this.fetchOptions).then((n=>{e[t]=n}));return n.catch((n=>{console.error(n),e[t]=n})),e[t]=n,n}}requestTileContents(t){if(0!==t.__loadingState)return;const e=this.stats,n=this.lruCache,r=this.downloadQueue,i=this.parseQueue,s=t.__externalTileSet;n.add(t,(t=>{1===t.__loadingState?(t.__loadAbort.abort(),t.__loadAbort=null):s?t.children.length=0:this.disposeTile(t),1===t.__loadingState?e.downloading--:2===t.__loadingState&&e.parsing--,t.__loadingState=0,t.__loadIndex++,i.remove(t),r.remove(t)})),t.__loadIndex++;const a=t.__loadIndex,o=new AbortController,l=o.signal;e.downloading++,t.__loadAbort=o,t.__loadingState=1;const c=s=>{t.__loadIndex===a&&("AbortError"!==s.name?(i.remove(t),r.remove(t),2===t.__loadingState?e.parsing--:1===t.__loadingState&&e.downloading--,e.failed++,console.error(`TilesRenderer : Failed to load tile at url "${t.content.uri}".`),console.error(s),t.__loadingState=4):n.remove(t))};s?r.add(t,(t=>{if(t.__loadIndex!==a)return Promise.resolve();const e=this.preprocessURL?this.preprocessURL(t.content.uri):t.content.uri;return this.fetchTileSet(e,Object.assign({signal:l},this.fetchOptions),t)})).then((n=>{t.__loadIndex===a&&(e.downloading--,t.__loadAbort=null,t.__loadingState=3,t.children.push(n.root))})).catch(c):r.add(t,(t=>{if(t.__loadIndex!==a)return Promise.resolve();const e=this.preprocessURL?this.preprocessURL(t.content.uri):t.content.uri;return fetch(e,Object.assign({signal:l},this.fetchOptions))})).then((e=>{if(t.__loadIndex===a){if(e.ok)return e.arrayBuffer();throw new Error(`Failed to load model with error code ${e.status}`)}})).then((n=>{if(t.__loadIndex===a)return e.downloading--,e.parsing++,t.__loadAbort=null,t.__loadingState=2,i.add(t,(t=>{if(t.__loadIndex!==a)return Promise.resolve();const e=Q_(t.content.uri);return this.parseTile(n,t,e)}))})).then((()=>{t.__loadIndex===a&&(e.parsing--,t.__loadingState=3,t.__wasSetVisible&&this.setTileVisible(t,!0),t.__wasSetActive&&this.setTileActive(t,!0))})).catch(c)}dispose(){const t=this.lruCache;this.traverse((e=>{t.remove(e)}))}}function uM(t){return(new TextDecoder).decode(t)}class dM{constructor(t,e,n,r){this.buffer=t,this.binOffset=e+n,this.binLength=r;let i=null;if(0!==n){const r=new Uint8Array(t,e,n);i=JSON.parse(uM(r))}else i={};this.header=i}getKeys(){return Object.keys(this.header)}getData(t,e,n=null,r=null){const i=this.header;if(!(t in i))return null;const s=i[t];if(s instanceof Object){if(Array.isArray(s))return s;{const{buffer:i,binOffset:a,binLength:o}=this,l=s.byteOffset||0,c=s.type||r,h=s.componentType||n;if("type"in s&&r&&s.type!==r)throw new Error("FeatureTable: Specified type does not match expected type.");let u,d;switch(c){case"SCALAR":u=1;break;case"VEC2":u=2;break;case"VEC3":u=3;break;case"VEC4":u=4;break;default:throw new Error(`FeatureTable : Feature type not provided for "${t}".`)}const p=a+l,f=e*u;switch(h){case"BYTE":d=new Int8Array(i,p,f);break;case"UNSIGNED_BYTE":d=new Uint8Array(i,p,f);break;case"SHORT":d=new Int16Array(i,p,f);break;case"UNSIGNED_SHORT":d=new Uint16Array(i,p,f);break;case"INT":d=new Int32Array(i,p,f);break;case"UNSIGNED_INT":d=new Uint32Array(i,p,f);break;case"FLOAT":d=new Float32Array(i,p,f);break;case"DOUBLE":d=new Float64Array(i,p,f);break;default:throw new Error(`FeatureTable : Feature component type not provided for "${t}".`)}if(p+f*d.BYTES_PER_ELEMENT>a+o)throw new Error("FeatureTable: Feature data read outside binary body length.");return d}}return s}}class pM extends dM{constructor(t,e,n,r,i){super(t,n,r,i),this.batchSize=e}getData(t,e=null,n=null){return super.getData(t,this.batchSize,n,e)}}class fM{constructor(){this.fetchOptions={},this.workingPath=""}load(t){return fetch(t,this.fetchOptions).then((e=>{if(!e.ok)throw new Error(`Failed to load file "${t}" with status ${e.status} : ${e.statusText}`);return e.arrayBuffer()})).then((e=>(""===this.workingPath&&(this.workingPath=this.workingPathForURL(t)),this.parse(e))))}resolveExternalURL(t){return/^[^\\/]/.test(t)?this.workingPath+"/"+t:t}workingPathForURL(t){const e=t.split(/[\\/]/g);return e.pop(),e.join("/")+"/"}parse(t){throw new Error("LoaderBase: Parse not implemented.")}}class mM extends fM{parse(t){const e=new DataView(t),n=String.fromCharCode(e.getUint8(0))+String.fromCharCode(e.getUint8(1))+String.fromCharCode(e.getUint8(2))+String.fromCharCode(e.getUint8(3));console.assert("b3dm"===n);const r=e.getUint32(4,!0);console.assert(1===r);const i=e.getUint32(8,!0);console.assert(i===t.byteLength);const s=e.getUint32(12,!0),a=e.getUint32(16,!0),o=e.getUint32(20,!0),l=e.getUint32(24,!0),c=t.slice(28,28+s+a),h=new dM(c,0,s,a),u=28+s+a,d=t.slice(u,u+o+l),p=new pM(d,h.getData("BATCH_LENGTH"),0,o,l),f=u+o+l;return{version:r,featureTable:h,batchTable:p,glbBytes:new Uint8Array(t,f,i-f)}}}class gM extends mM{constructor(t=Fu){super(),this.manager=t}parse(t){const e=super.parse(t),n=e.glbBytes.slice().buffer;return new Promise(((t,r)=>{const i=this.manager,s=this.fetchOptions,a=i.getHandler("path.gltf")||new Mm(i);"include"===s.credentials&&"cors"===s.mode&&a.setCrossOrigin("use-credentials"),"credentials"in s&&a.setWithCredentials("include"===s.credentials),s.headers&&a.setRequestHeader(s.headers);let o=this.workingPath;/[\\/]$/.test(o)||(o+="/"),a.parse(n,o,(n=>{const{batchTable:r,featureTable:i}=e,{scene:s}=n,a=i.getData("RTC_CENTER");a&&(s.position.x+=a[0],s.position.y+=a[1],s.position.z+=a[2]),n.batchTable=r,n.featureTable=i,s.batchTable=r,s.featureTable=i,t(n)}),r)}))}}class vM extends fM{parse(t){const e=new DataView(t),n=String.fromCharCode(e.getUint8(0))+String.fromCharCode(e.getUint8(1))+String.fromCharCode(e.getUint8(2))+String.fromCharCode(e.getUint8(3));console.assert("pnts"===n);const r=e.getUint32(4,!0);console.assert(1===r);const i=e.getUint32(8,!0);console.assert(i===t.byteLength);const s=e.getUint32(12,!0),a=e.getUint32(16,!0),o=e.getUint32(20,!0),l=e.getUint32(24,!0),c=t.slice(28,28+s+a),h=new dM(c,0,s,a),u=28+s+a,d=t.slice(u,u+o+l),p=new pM(d,h.getData("BATCH_LENGTH")||h.getData("POINTS_LENGTH"),0,o,l);return Promise.resolve({version:r,featureTable:h,batchTable:p})}}class xM extends vM{constructor(t=Fu){super(),this.manager=t}parse(t){return super.parse(t).then((t=>{const{featureTable:e}=t,n=e.getData("POINTS_LENGTH"),r=e.getData("POSITION",n,"FLOAT","VEC3"),i=e.getData("RGB",n,"UNSIGNED_BYTE","VEC3");["RTC_CENTER","QUANTIZED_VOLUME_OFFSET","QUANTIZED_VOLUME_SCALE","CONSTANT_RGBA","BATCH_LENGTH","POSITION_QUANTIZED","RGBA","RGB565","NORMAL","NORMAL_OCT16P"].forEach((t=>{t in e.header&&console.warn(`PNTSLoader: Unsupported FeatureTable feature "${t}" detected.`)}));const s=new Ki;s.setAttribute("position",new Ii(r,3,!1));const a=new Ec;a.size=2,a.sizeAttenuation=!1,null!==i&&(s.setAttribute("color",new Ii(i,3,!0)),a.vertexColors=!0);const o=new Fc(s,a);t.scene=o,t.scene.featureTable=e;const l=e.getData("RTC_CENTER");return l&&(t.scene.position.x+=l[0],t.scene.position.y+=l[1],t.scene.position.z+=l[2]),t}))}}class yM extends fM{parse(t){const e=new DataView(t),n=String.fromCharCode(e.getUint8(0))+String.fromCharCode(e.getUint8(1))+String.fromCharCode(e.getUint8(2))+String.fromCharCode(e.getUint8(3));console.assert("i3dm"===n);const r=e.getUint32(4,!0);console.assert(1===r);const i=e.getUint32(8,!0);console.assert(i===t.byteLength);const s=e.getUint32(12,!0),a=e.getUint32(16,!0),o=e.getUint32(20,!0),l=e.getUint32(24,!0),c=e.getUint32(28,!0),h=t.slice(32,32+s+a),u=new dM(h,0,s,a),d=32+s+a,p=t.slice(d,d+o+l),f=new pM(p,u.getData("INSTANCES_LENGTH"),0,o,l),m=d+o+l,g=new Uint8Array(t,m,i-m);let v=null,x=null;if(c)v=g,x=Promise.resolve();else{const t=this.resolveExternalURL(uM(g));x=fetch(t,this.fetchOptions).then((e=>{if(!e.ok)throw new Error(`I3DMLoaderBase : Failed to load file "${t}" with status ${e.status} : ${e.statusText}`);return e.arrayBuffer()})).then((t=>{v=new Uint8Array(t)}))}return x.then((()=>({version:r,featureTable:u,batchTable:f,glbBytes:v})))}}const wM=new lr,bM=new lr,_M=new lr,MM=new lr,TM=new or,SM=new lr,AM=new zr;class EM extends yM{constructor(t=Fu){super(),this.manager=t}resolveExternalURL(t){return this.manager.resolveURL(super.resolveExternalURL(t))}parse(t){return super.parse(t).then((t=>{const{featureTable:e,batchTable:n}=t,r=t.glbBytes.slice().buffer;return new Promise(((t,i)=>{const s=this.fetchOptions,a=this.manager,o=a.getHandler("path.gltf")||new Mm(a);"include"===s.credentials&&"cors"===s.mode&&o.setCrossOrigin("use-credentials"),"credentials"in s&&o.setWithCredentials("include"===s.credentials),s.headers&&o.setRequestHeader(s.headers);let l=this.workingPath;/[\\/]$/.test(l)||(l+="/"),o.parse(r,l,(r=>{const i=e.getData("INSTANCES_LENGTH"),s=e.getData("POSITION",i,"FLOAT","VEC3"),a=e.getData("NORMAL_UP",i,"FLOAT","VEC3"),o=e.getData("NORMAL_RIGHT",i,"FLOAT","VEC3"),l=e.getData("SCALE_NON_UNIFORM",i,"FLOAT","VEC3"),c=e.getData("SCALE",i,"FLOAT","SCALAR");["RTC_CENTER","QUANTIZED_VOLUME_OFFSET","QUANTIZED_VOLUME_SCALE","EAST_NORTH_UP","POSITION_QUANTIZED","NORMAL_UP_OCT32P","NORMAL_RIGHT_OCT32P"].forEach((t=>{t in e.header&&console.warn(`I3DMLoader: Unsupported FeatureTable feature "${t}" detected.`)}));const h=new Map,u=[];r.scene.traverse((t=>{if(t.isMesh){const{geometry:e,material:n}=t,r=new mc(e,n,i);r.position.copy(t.position),r.rotation.copy(t.rotation),r.scale.copy(t.scale),u.push(r),h.set(t,r)}}));const d=new lr;for(let t=0;t<i;t++)d.x+=s[3*t+0]/i,d.y+=s[3*t+1]/i,d.z+=s[3*t+2]/i;h.forEach(((t,e)=>{const n=e.parent;n&&(n.remove(e),n.add(t),t.updateMatrixWorld(),t.position.copy(d).applyMatrix4(t.matrixWorld))}));for(let t=0;t<i;t++){MM.set(s[3*t+0]-d.x,s[3*t+1]-d.y,s[3*t+2]-d.z),a?(bM.set(a[3*t+0],a[3*t+1],a[3*t+2]),_M.set(o[3*t+0],o[3*t+1],o[3*t+2]),wM.crossVectors(_M,bM).normalize(),AM.makeBasis(_M,bM,wM),TM.setFromRotationMatrix(AM)):TM.set(0,0,0,1),c?SM.setScalar(c[t]):l?SM.set(l[3*t+0],l[3*t+1],l[3*t+2]):SM.set(1,1,1),AM.compose(MM,TM,SM);for(let e=0,n=u.length;e<n;e++)u[e].setMatrixAt(t,AM)}r.batchTable=n,r.featureTable=e,r.scene.batchTable=n,r.scene.featureTable=e,t(r)}),i)}))}))}}class CM extends fM{parse(t){const e=new DataView(t),n=String.fromCharCode(e.getUint8(0))+String.fromCharCode(e.getUint8(1))+String.fromCharCode(e.getUint8(2))+String.fromCharCode(e.getUint8(3));console.assert("cmpt"===n,'CMPTLoader: The magic bytes equal "cmpt".');const r=e.getUint32(4,!0);console.assert(1===r,'CMPTLoader: The version listed in the header is "1".');const i=e.getUint32(8,!0);console.assert(i===t.byteLength,"CMPTLoader: The contents buffer length listed in the header matches the file.");const s=e.getUint32(12,!0),a=[];let o=16;for(let e=0;e<s;e++){const e=new DataView(t,o,12),n=String.fromCharCode(e.getUint8(0))+String.fromCharCode(e.getUint8(1))+String.fromCharCode(e.getUint8(2))+String.fromCharCode(e.getUint8(3)),r=e.getUint32(4,!0),i=e.getUint32(8,!0),s=new Uint8Array(t,o,i);a.push({type:n,buffer:s,version:r}),o+=i}return{version:r,tiles:a}}}class PM extends CM{constructor(t=Fu){super(),this.manager=t}parse(t){const e=super.parse(t),n=this.manager,r=[];for(const t in e.tiles){const{type:i,buffer:s}=e.tiles[t];switch(i){case"b3dm":{const t=s.slice(),e=new gM(n);e.workingPath=this.workingPath,e.fetchOptions=this.fetchOptions;const i=e.parse(t.buffer);r.push(i);break}case"pnts":{const t=s.slice(),e=new xM(n);e.workingPath=this.workingPath,e.fetchOptions=this.fetchOptions;const i=e.parse(t.buffer);r.push(i);break}case"i3dm":{const t=s.slice(),e=new EM(n);e.workingPath=this.workingPath,e.fetchOptions=this.fetchOptions;const i=e.parse(t.buffer);r.push(i);break}}}return Promise.all(r).then((t=>{const e=new wl;return t.forEach((t=>{e.add(t.scene)})),{tiles:t,scene:e}}))}}class LM extends fM{constructor(t=Fu){super(),this.manager=t}parse(t){return new Promise(((e,n)=>{const r=this.manager,i=this.fetchOptions;let s=r.getHandler("path.gltf")||r.getHandler("path.glb");s||(s=new Mm(r),"include"===i.credentials&&"cors"===i.mode&&s.setCrossOrigin("use-credentials"),"credentials"in i&&s.setWithCredentials("include"===i.credentials),i.headers&&s.setRequestHeader(i.headers));const a=s.resourcePath||s.path||this.workingPath;s.parse(t,a,(t=>{e(t)}),n)}))}}const RM=new zr;class FM extends wl{constructor(t){super(),this.name="TilesRenderer.TilesGroup",this.tilesRenderer=t}raycast(t,e){this.tilesRenderer.optimizeRaycast&&this.tilesRenderer.raycast(t,e)}updateMatrixWorld(t){if(this.matrixAutoUpdate&&this.updateMatrix(),this.matrixWorldNeedsUpdate||t){null===this.parent?RM.copy(this.matrix):RM.multiplyMatrices(this.parent.matrixWorld,this.matrix),this.matrixWorldNeedsUpdate=!1;const t=RM.elements,e=this.matrixWorld.elements;let n=!1;for(let r=0;r<16;r++){const i=t[r],s=e[r];if(Math.abs(i-s)>Number.EPSILON){n=!0;break}}if(n){this.matrixWorld.copy(RM);const t=this.children;for(let e=0,n=t.length;e<n;e++)t[e].updateMatrixWorld()}}}}const DM=new Lr,IM=new zr,UM=new lr,NM=new lr,OM=new Br,BM=[];function zM(t,e){return t.distance-e.distance}function kM(t,e,n){t.traverse((t=>{Object.getPrototypeOf(t).raycast.call(t,e,n)}))}function HM(t,e,n,r){if(n.has(t)){if(kM(t.cached.scene,r,BM),BM.length>0){BM.length>1&&BM.sort(zM);const t=BM[0];return BM.length=0,t}return null}const i=[],s=t.children;for(let t=0,n=s.length;t<n;t++){const n=s[t],a=n.cached,o=e.matrixWorld;IM.copy(o);const l=a.sphere;if(l&&(DM.copy(l),DM.applyMatrix4(IM),!r.ray.intersectsSphere(DM)))continue;const c=a.box,h=a.boxTransform;if(c){if(IM.multiply(h).invert(),OM.copy(r.ray),OM.applyMatrix4(IM),!OM.intersectBox(c,UM))continue;{let t;NM.setFromMatrixScale(IM),t=NM.x,Math.abs(Math.max(NM.x-NM.y,NM.x-NM.z))>1e-6&&console.warn("ThreeTilesRenderer : Non uniform scale used for tile which may cause issues when raycasting.");let e={distance:1/0,tile:null};i.push(e),e.distance=UM.distanceToSquared(OM.origin)*t*t,e.tile=n}}}i.sort(zM);let a=1/0,o=null;for(let t=0,s=i.length;t<s;t++){const s=i[t];if(s.distance>a)break;{const t=s.tile,i=t.cached.scene;let l=null;if(n.has(t)?(kM(i,r,BM),BM.length>0&&(BM.length>1&&BM.sort(zM),l=BM[0])):l=HM(t,e,n,r),l){const t=l.distance*l.distance;t<a&&(a=t,o=l),BM.length=0}}}return o}function GM(t,e,n,r,i){const s=t.cached,a=e.matrixWorld;IM.copy(a);const o=s.sphere;if(o&&(DM.copy(o),DM.applyMatrix4(IM),!r.ray.intersectsSphere(DM)))return;const l=s.box,c=s.boxTransform;if(l&&(IM.multiply(c).invert(),OM.copy(r.ray).applyMatrix4(IM),!OM.intersectsBox(l)))return;const h=s.scene;if(n.has(t))return void kM(h,r,i);const u=t.children;for(let t=0,s=u.length;t<s;t++)GM(u[t],e,n,r,i)}const VM=Symbol("INITIAL_FRUSTUM_CULLED"),WM=new zr,XM=new zr,jM=new lr,YM=new lr,qM=new lr,QM=new lr,ZM=new lr(1,0,0),JM=new lr(0,1,0);function KM(t,e){t.traverse((t=>{t.frustumCulled=t[VM]&&e}))}class $M extends hM{get autoDisableRendererCulling(){return this._autoDisableRendererCulling}set autoDisableRendererCulling(t){this._autoDisableRendererCulling!==t&&(super._autoDisableRendererCulling=t,this.forEachLoadedModel((e=>{KM(e,!t)})))}constructor(...t){super(...t),this.group=new FM(this),this.cameras=[],this.cameraMap=new Map,this.cameraInfo=[],this.activeTiles=new Set,this.visibleTiles=new Set,this._autoDisableRendererCulling=!0,this.optimizeRaycast=!0,this.onLoadTileSet=null,this.onLoadModel=null,this.onDisposeModel=null,this.onTileVisibilityChange=null;const e=new Ru;e.setURLModifier((t=>this.preprocessURL?this.preprocessURL(t):t)),this.manager=e;const n=this;this._overridenRaycast=function(t,e){n.optimizeRaycast||Object.getPrototypeOf(this).raycast.call(this,t,e)}}getBounds(t){if(!this.root)return!1;const e=this.root.cached,n=e.box,r=e.boxTransform;return!!n&&(t.copy(n),t.applyMatrix4(r),!0)}getOrientedBounds(t,e){if(!this.root)return!1;const n=this.root.cached,r=n.box,i=n.boxTransform;return!!r&&(t.copy(r),e.copy(i),!0)}getBoundingSphere(t){if(!this.root)return!1;const e=this.root.cached.sphere;return!!e&&(t.copy(e),!0)}forEachLoadedModel(t){this.traverse((e=>{const n=e.cached.scene;n&&t(n,e)}))}raycast(t,e){if(this.root)if(t.firstHitOnly){const n=HM(this.root,this.group,this.activeTiles,t);n&&e.push(n)}else GM(this.root,this.group,this.activeTiles,t,e)}hasCamera(t){return this.cameraMap.has(t)}setCamera(t){const e=this.cameras,n=this.cameraMap;return!n.has(t)&&(n.set(t,new jn),e.push(t),!0)}setResolution(t,e,n){const r=this.cameraMap;return!!r.has(t)&&(e instanceof jn?r.get(t).copy(e):r.get(t).set(e,n),!0)}setResolutionFromRenderer(t,e){const n=this.cameraMap;if(!n.has(t))return!1;const r=n.get(t);return e.getSize(r),r.multiplyScalar(e.getPixelRatio()),!0}deleteCamera(t){const e=this.cameras,n=this.cameraMap;if(n.has(t)){const r=e.indexOf(t);return e.splice(r,1),n.delete(t),!0}return!1}fetchTileSet(t,...e){const n=super.fetchTileSet(t,...e);return n.then((e=>{this.onLoadTileSet&&Promise.resolve().then((()=>{this.onLoadTileSet(e,t)}))})),n}update(){const t=this.group,e=this.cameras,n=this.cameraMap,r=this.cameraInfo;if(0===e.length)return void console.warn("TilesRenderer: no cameras defined. Cannot update 3d tiles.");for(;r.length>e.length;)r.pop();for(;r.length<e.length;)r.push({frustum:new Us,isOrthographic:!1,sseDenominator:-1,position:new lr,invScale:-1,pixelSize:0});let i;XM.copy(t.matrixWorld).invert(),jM.setFromMatrixScale(XM),i=jM.x,Math.abs(Math.max(jM.x-jM.y,jM.x-jM.z))>1e-6&&console.warn("ThreeTilesRenderer : Non uniform scale used for tile which may cause issues when calculating screen space error.");for(let s=0,a=r.length;s<a;s++){const a=e[s],o=r[s],l=o.frustum,c=o.position,h=n.get(a);0!==h.width&&0!==h.height||console.warn("TilesRenderer: resolution for camera error calculation is not set.");const u=a.projectionMatrix.elements;if(o.isOrthographic=1===u[15],o.isOrthographic){const t=2/u[0],e=2/u[5];o.pixelSize=Math.max(e/h.height,t/h.width)}else o.sseDenominator=2/u[5]/h.height;o.invScale=i,WM.copy(t.matrixWorld),WM.premultiply(a.matrixWorldInverse),WM.premultiply(a.projectionMatrix),l.setFromProjectionMatrix(WM),c.set(0,0,0),c.applyMatrix4(a.matrixWorld),c.applyMatrix4(XM)}super.update()}preprocessNode(t,e,n){super.preprocessNode(t,e,n);const r=new zr;if(t.transform){const e=t.transform;for(let t=0;t<16;t++)r.elements[t]=e[t]}else r.identity();e&&r.premultiply(e.cached.transform);const i=(new zr).copy(r).invert();let s=null,a=null,o=null;if("box"in t.boundingVolume){const e=t.boundingVolume.box;s=new ur,a=new zr,o=new zr,YM.set(e[3],e[4],e[5]),qM.set(e[6],e[7],e[8]),QM.set(e[9],e[10],e[11]);const n=YM.length(),i=qM.length(),l=QM.length();YM.normalize(),qM.normalize(),QM.normalize(),0===n&&YM.crossVectors(qM,QM),0===i&&qM.crossVectors(YM,QM),0===l&&QM.crossVectors(YM,qM),a.set(YM.x,qM.x,QM.x,e[0],YM.y,qM.y,QM.y,e[1],YM.z,qM.z,QM.z,e[2],0,0,0,1),a.premultiply(r),o.copy(a).invert(),s.min.set(-n,-i,-l),s.max.set(n,i,l)}let l=null;if("sphere"in t.boundingVolume){const e=t.boundingVolume.sphere;l=new Lr,l.center.set(e[0],e[1],e[2]),l.radius=e[3],l.applyMatrix4(r)}else if("box"in t.boundingVolume){const e=t.boundingVolume.box;l=new Lr,s.getBoundingSphere(l),l.center.set(e[0],e[1],e[2]),l.applyMatrix4(r)}"region"in t.boundingVolume&&console.warn("ThreeTilesRenderer: region bounding volume not supported."),t.cached={loadIndex:0,transform:r,transformInverse:i,active:!1,inFrustum:[],box:s,boxTransform:a,boxTransformInverse:o,sphere:l,region:null,scene:null,geometry:null,material:null}}parseTile(t,e,n){e._loadIndex=e._loadIndex||0,e._loadIndex++;const r=e.content.uri.split(/[\\\/]/g);r.pop();const i=r.join("/"),s=this.fetchOptions,a=this.manager,o=e._loadIndex;let l=null;switch(n){case"b3dm":{const e=new gM(a);e.workingPath=i,e.fetchOptions=s,l=e.parse(t).then((t=>t.scene));break}case"pnts":{const e=new xM(a);e.workingPath=i,e.fetchOptions=s,l=e.parse(t).then((t=>t.scene));break}case"i3dm":{const e=new EM(a);e.workingPath=i,e.fetchOptions=s,l=e.parse(t).then((t=>t.scene));break}case"cmpt":{const e=new PM(a);e.workingPath=i,e.fetchOptions=s,l=e.parse(t).then((t=>t.scene));break}case"gltf":case"glb":const e=new LM(a);e.workingPath=i,e.fetchOptions=s,l=e.parse(t).then((t=>t.scene));break;default:console.warn(`TilesRenderer: Content type "${n}" not supported.`),l=Promise.resolve(null)}return l.then((t=>{if(e._loadIndex!==o)return;const r=this.rootTileSet.asset&&this.rootTileSet.asset.gltfUpAxis||"y",i=e.cached,s=i.transform;switch(r.toLowerCase()){case"x":WM.makeRotationAxis(JM,-Math.PI/2);break;case"y":WM.makeRotationAxis(ZM,Math.PI/2);break;case"z":WM.identity()}t.updateMatrix(),"pnts"!==n&&t.matrix.multiply(WM),t.matrix.premultiply(s),t.matrix.decompose(t.position,t.quaternion,t.scale),t.traverse((t=>{t[VM]=t.frustumCulled})),KM(t,!this.autoDisableRendererCulling),i.scene=t,t.traverse((t=>{t.raycast=this._overridenRaycast}));const a=[],l=[],c=[];t.traverse((t=>{if(t.geometry&&l.push(t.geometry),t.material){const e=t.material;a.push(t.material);for(const t in e){const n=e[t];n&&n.isTexture&&c.push(n)}}})),i.materials=a,i.geometry=l,i.textures=c,this.onLoadModel&&this.onLoadModel(t,e)}))}disposeTile(t){const e=t.cached;if(e.scene){const n=e.materials,r=e.geometry,i=e.textures;for(let t=0,e=r.length;t<e;t++)r[t].dispose();for(let t=0,e=n.length;t<e;t++)n[t].dispose();for(let t=0,e=i.length;t<e;t++)i[t].dispose();this.onDisposeModel&&this.onDisposeModel(e.scene,t),e.scene=null,e.materials=null,e.textures=null,e.geometry=null}t._loadIndex++}setTileVisible(t,e){const n=t.cached.scene,r=this.visibleTiles,i=this.group;e?(i.add(n),r.add(t),n.updateMatrixWorld(!0)):(i.remove(n),r.delete(t)),this.onTileVisibilityChange&&this.onTileVisibilityChange(n,t,e)}setTileActive(t,e){const n=this.activeTiles;e?n.add(t):n.delete(t)}calculateError(t){const e=t.cached,n=e.inFrustum,r=this.cameras,i=this.cameraInfo,s=t.boundingVolume;if("box"in s||"sphere"in s){const s=e.sphere,a=e.box,o=e.boxTransformInverse,l=e.transformInverse,c=a&&o;let h=-1/0,u=1/0;for(let e=0,d=r.length;e<d;e++){if(!n[e])continue;const r=i[e],d=r.invScale;let p;if(r.isOrthographic){const e=r.pixelSize;p=t.geometricError/(e*d)}else{let e;jM.copy(r.position),c?(jM.applyMatrix4(o),e=a.distanceToPoint(jM)):(jM.applyMatrix4(l),e=Math.max(s.distanceToPoint(jM),0));const n=e*d,i=r.sseDenominator;p=t.geometricError/(n*i),u=Math.min(u,n)}h=Math.max(h,p)}t.__distanceFromCamera=u,t.__error=h}else"region"in s&&console.warn("ThreeTilesRenderer : Region bounds not supported.")}tileInView(t){const e=t.cached,n=e.sphere,r=e.inFrustum;if(n){const t=this.cameraInfo;let e=!1;for(let i=0,s=t.length;i<s;i++)t[i].frustum.intersectsSphere(n)?(e=!0,r[i]=!0):r[i]=!1;return e}return!0}}const tT=new lr,eT=["x","y","z"];class nT extends Sc{constructor(t,e=16776960,n=40){const r=new Ki,i=[];for(let t=0;t<3;t++){const e=eT[t],r=eT[(t+1)%3];tT.set(0,0,0);for(let t=0;t<n;t++){let s;s=2*Math.PI*t/(n-1),tT[e]=Math.sin(s),tT[r]=Math.cos(s),i.push(tT.x,tT.y,tT.z),s=2*Math.PI*(t+1)/(n-1),tT[e]=Math.sin(s),tT[r]=Math.cos(s),i.push(tT.x,tT.y,tT.z)}}r.setAttribute("position",new Ii(new Float32Array(i),3)),r.computeBoundingSphere(),super(r,new gc({color:e,toneMapped:!1})),this.sphere=t,this.type="SphereHelper"}updateMatrixWorld(t){const e=this.sphere;this.position.copy(e.center),this.scale.setScalar(e.radius),super.updateMatrixWorld(t)}}const rT=Symbol("ORIGINAL_MATERIAL"),iT=Symbol("HAS_RANDOM_COLOR"),sT=Symbol("HAS_RANDOM_NODE_COLOR");function aT(){}const oT=0,lT=1,cT=2,hT=3,uT=4,dT=5,pT=6,fT=7,mT=8,gT=9;class vT extends $M{constructor(...t){super(...t);const e=this.group,n=new wl;n.name="DebugTilesRenderer.boxGroup",e.add(n);const r=new wl;r.name="DebugTilesRenderer.sphereGroup",e.add(r),this.displayBoxBounds=!1,this.displaySphereBounds=!1,this.colorMode=oT,this.customColorCallback=null,this.boxGroup=n,this.sphereGroup=r,this.maxDebugDepth=-1,this.maxDebugDistance=-1,this.maxDebugError=-1,this.getDebugColor=(t,e)=>{e.setRGB(t,t,t)},this.extremeDebugDepth=-1,this.extremeDebugError=-1}initExtremes(){let t=-1;this.traverse((e=>{t=Math.max(t,e.__depth)}));let e=-1;this.traverse((t=>{e=Math.max(e,t.geometricError)})),this.extremeDebugDepth=t,this.extremeDebugError=e}fetchTileSet(...t){const e=super.fetchTileSet(...t);return e.then((()=>{Promise.resolve().then((()=>{this.initExtremes()}))})).catch((()=>{})),e}getTileInformationFromActiveObject(t){let e=null;return this.activeTiles.forEach((n=>{if(e)return!0;const r=n.cached.scene;r&&r.traverse((r=>{r===t&&(e=n)}))})),e?{distanceToCamera:e.__distanceFromCamera,geometricError:e.geometricError,screenSpaceError:e.__error,depth:e.__depth,isLeaf:e.__isLeaf}:null}update(){if(super.update(),!this.root)return;this.boxGroup.visible=this.displayBoxBounds,this.sphereGroup.visible=this.displaySphereBounds;let t=-1;t=-1===this.maxDebugDepth?this.extremeDebugDepth:this.maxDebugDepth;let e=-1;e=-1===this.maxDebugError?this.extremeDebugError:this.maxDebugError;let n=-1;n=-1===this.maxDebugDistance?this.root.cached.sphere.radius:this.maxDebugDistance;const r=this.errorTarget,i=this.colorMode;this.visibleTiles.forEach((s=>{const a=s.cached.scene;let o,l,c;i===fT&&(o=Math.random(),l=.5+.5*Math.random(),c=.375+.25*Math.random()),a.traverse((a=>{i===mT&&(o=Math.random(),l=.5+.5*Math.random(),c=.375+.25*Math.random());const h=a.material;if(h){const u=a[rT];if(i===oT&&h!==u)a.material.dispose(),a.material=a[rT];else if(i!==oT&&h===u)if(a.isPoints){const t=new Ec;t.size=u.size,t.sizeAttenuation=u.sizeAttenuation,a.material=t}else a.material=new au,a.material.flatShading=!0;switch(i!==fT&&delete a.material[iT],i!==mT&&delete a.material[sT],i){case uT:{const e=s.__depth/t;this.getDebugColor(e,a.material.color);break}case dT:{const e=s.__depthFromRenderedParent/t;this.getDebugColor(e,a.material.color);break}case lT:{const t=s.__error/r;t>1?a.material.color.setRGB(1,0,0):this.getDebugColor(t,a.material.color);break}case cT:{const t=Math.min(s.geometricError/e,1);this.getDebugColor(t,a.material.color);break}case hT:{const t=Math.min(s.__distanceFromCamera/n,1);this.getDebugColor(t,a.material.color);break}case pT:s.children&&0!==s.children.length?this.getDebugColor(0,a.material.color):this.getDebugColor(1,a.material.color);break;case mT:a.material[sT]||(a.material.color.setHSL(o,l,c),a.material[sT]=!0);break;case fT:a.material[iT]||(a.material.color.setHSL(o,l,c),a.material[iT]=!0);break;case gT:this.customColorCallback?this.customColorCallback(s,a):console.warn("DebugTilesRenderer: customColorCallback not defined")}}}))}))}setTileVisible(t,e){super.setTileVisible(t,e);const n=t.cached,r=this.sphereGroup,i=this.boxGroup,s=n.boxHelperGroup,a=n.sphereHelper;e?(s&&(i.add(s),s.updateMatrixWorld(!0)),a&&(r.add(a),a.updateMatrixWorld(!0))):(s&&i.remove(s),a&&r.remove(a))}parseTile(t,e,n){return super.parseTile(t,e,n).then((()=>{const t=e.cached,n=t.scene;if(n){if(t.box&&t.boxTransform){const n=t.box,r=t.boxTransform,i=new wl;i.name="DebugTilesRenderer.boxHelperGroup",i.matrix.copy(r),i.matrixAutoUpdate=!1;const s=new Np(n,function(t){if(!Y_[t]){const e=Math.random(),n=.5+.5*Math.random(),r=.375+.25*Math.random();Y_[t]=(new Li).setHSL(e,n,r)}return Y_[t]}(e.__depth));s.raycast=aT,i.add(s),t.boxHelperGroup=i,this.visibleTiles.has(e)&&this.displayBoxBounds&&(this.boxGroup.add(i),i.updateMatrixWorld(!0))}if(t.sphere){const n=t.sphere,r=new nT(n);r.raycast=aT,t.sphereHelper=r,this.visibleTiles.has(e)&&this.displaySphereBounds&&(this.sphereGroup.add(r),r.updateMatrixWorld(!0))}n.traverse((t=>{const e=t.material;e&&(t[rT]=e)}))}}))}disposeTile(t){super.disposeTile(t);const e=t.cached;e.boxHelperGroup&&(e.boxHelperGroup.children[0].geometry.dispose(),delete e.boxHelperGroup),e.sphereHelper&&(e.sphereHelper.geometry.dispose(),delete e.sphereHelper)}}Ki.prototype.computeBoundsTree=O_,Ki.prototype.disposeBoundsTree=B_,gs.prototype.raycast=N_,t.OrbitControls=class extends Dn{constructor(t,e){super(),void 0===e&&console.warn('THREE.OrbitControls: The second parameter "domElement" is now mandatory.'),e===document&&console.error('THREE.OrbitControls: "document" should not be used as the target "domElement". Please use "renderer.domElement" instead.'),this.object=t,this.domElement=e,this.domElement.style.touchAction="none",this.enabled=!0,this.target=new lr,this.minDistance=0,this.maxDistance=1/0,this.minZoom=0,this.maxZoom=1/0,this.minPolarAngle=0,this.maxPolarAngle=Math.PI,this.minAzimuthAngle=-1/0,this.maxAzimuthAngle=1/0,this.enableDamping=!1,this.dampingFactor=.05,this.enableZoom=!0,this.zoomSpeed=1,this.enableRotate=!0,this.rotateSpeed=1,this.enablePan=!0,this.panSpeed=1,this.screenSpacePanning=!0,this.keyPanSpeed=7,this.autoRotate=!1,this.autoRotateSpeed=2,this.keys={LEFT:"ArrowLeft",UP:"ArrowUp",RIGHT:"ArrowRight",BOTTOM:"ArrowDown"},this.mouseButtons={LEFT:l.ROTATE,MIDDLE:l.DOLLY,RIGHT:l.PAN},this.touches={ONE:c.ROTATE,TWO:c.DOLLY_PAN},this.target0=this.target.clone(),this.position0=this.object.position.clone(),this.zoom0=this.object.zoom,this._domElementKeyEvents=null,this.getPolarAngle=function(){return a.phi},this.getAzimuthalAngle=function(){return a.theta},this.getDistance=function(){return this.object.position.distanceTo(this.target)},this.listenToKeyEvents=function(t){t.addEventListener("keydown",X),this._domElementKeyEvents=t},this.saveState=function(){n.target0.copy(n.target),n.position0.copy(n.object.position),n.zoom0=n.object.zoom},this.reset=function(){n.target.copy(n.target0),n.object.position.copy(n.position0),n.object.zoom=n.zoom0,n.object.updateProjectionMatrix(),n.dispatchEvent(wm),n.update(),i=r.NONE},this.update=function(){const e=new lr,l=(new or).setFromUnitVectors(t.up,new lr(0,1,0)),c=l.clone().invert(),p=new lr,f=new or,m=2*Math.PI;return function(){const t=n.object.position;e.copy(t).sub(n.target),e.applyQuaternion(l),a.setFromVector3(e),n.autoRotate&&i===r.NONE&&S(2*Math.PI/60/60*n.autoRotateSpeed),n.enableDamping?(a.theta+=o.theta*n.dampingFactor,a.phi+=o.phi*n.dampingFactor):(a.theta+=o.theta,a.phi+=o.phi);let g=n.minAzimuthAngle,v=n.maxAzimuthAngle;return isFinite(g)&&isFinite(v)&&(g<-Math.PI?g+=m:g>Math.PI&&(g-=m),v<-Math.PI?v+=m:v>Math.PI&&(v-=m),a.theta=g<=v?Math.max(g,Math.min(v,a.theta)):a.theta>(g+v)/2?Math.max(g,a.theta):Math.min(v,a.theta)),a.phi=Math.max(n.minPolarAngle,Math.min(n.maxPolarAngle,a.phi)),a.makeSafe(),a.radius*=h,a.radius=Math.max(n.minDistance,Math.min(n.maxDistance,a.radius)),!0===n.enableDamping?n.target.addScaledVector(u,n.dampingFactor):n.target.add(u),e.setFromSpherical(a),e.applyQuaternion(c),t.copy(n.target).add(e),n.object.lookAt(n.target),!0===n.enableDamping?(o.theta*=1-n.dampingFactor,o.phi*=1-n.dampingFactor,u.multiplyScalar(1-n.dampingFactor)):(o.set(0,0,0),u.set(0,0,0)),h=1,!!(d||p.distanceToSquared(n.object.position)>s||8*(1-f.dot(n.object.quaternion))>s)&&(n.dispatchEvent(wm),p.copy(n.object.position),f.copy(n.object.quaternion),d=!1,!0)}}(),this.dispose=function(){n.domElement.removeEventListener("contextmenu",j),n.domElement.removeEventListener("pointerdown",k),n.domElement.removeEventListener("pointercancel",V),n.domElement.removeEventListener("wheel",W),n.domElement.removeEventListener("pointermove",H),n.domElement.removeEventListener("pointerup",G),null!==n._domElementKeyEvents&&n._domElementKeyEvents.removeEventListener("keydown",X)};const n=this,r={NONE:-1,ROTATE:0,DOLLY:1,PAN:2,TOUCH_ROTATE:3,TOUCH_PAN:4,TOUCH_DOLLY_PAN:5,TOUCH_DOLLY_ROTATE:6};let i=r.NONE;const s=1e-6,a=new sp,o=new sp;let h=1;const u=new lr;let d=!1;const p=new jn,f=new jn,m=new jn,g=new jn,v=new jn,x=new jn,y=new jn,w=new jn,b=new jn,_=[],M={};function T(){return Math.pow(.95,n.zoomSpeed)}function S(t){o.theta-=t}function A(t){o.phi-=t}const E=function(){const t=new lr;return function(e,n){t.setFromMatrixColumn(n,0),t.multiplyScalar(-e),u.add(t)}}(),C=function(){const t=new lr;return function(e,r){!0===n.screenSpacePanning?t.setFromMatrixColumn(r,1):(t.setFromMatrixColumn(r,0),t.crossVectors(n.object.up,t)),t.multiplyScalar(e),u.add(t)}}(),P=function(){const t=new lr;return function(e,r){const i=n.domElement;if(n.object.isPerspectiveCamera){const s=n.object.position;t.copy(s).sub(n.target);let a=t.length();a*=Math.tan(n.object.fov/2*Math.PI/180),E(2*e*a/i.clientHeight,n.object.matrix),C(2*r*a/i.clientHeight,n.object.matrix)}else n.object.isOrthographicCamera?(E(e*(n.object.right-n.object.left)/n.object.zoom/i.clientWidth,n.object.matrix),C(r*(n.object.top-n.object.bottom)/n.object.zoom/i.clientHeight,n.object.matrix)):(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."),n.enablePan=!1)}}();function L(t){n.object.isPerspectiveCamera?h/=t:n.object.isOrthographicCamera?(n.object.zoom=Math.max(n.minZoom,Math.min(n.maxZoom,n.object.zoom*t)),n.object.updateProjectionMatrix(),d=!0):(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),n.enableZoom=!1)}function R(t){n.object.isPerspectiveCamera?h*=t:n.object.isOrthographicCamera?(n.object.zoom=Math.max(n.minZoom,Math.min(n.maxZoom,n.object.zoom/t)),n.object.updateProjectionMatrix(),d=!0):(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),n.enableZoom=!1)}function F(t){p.set(t.clientX,t.clientY)}function D(t){g.set(t.clientX,t.clientY)}function I(){if(1===_.length)p.set(_[0].pageX,_[0].pageY);else{const t=.5*(_[0].pageX+_[1].pageX),e=.5*(_[0].pageY+_[1].pageY);p.set(t,e)}}function U(){if(1===_.length)g.set(_[0].pageX,_[0].pageY);else{const t=.5*(_[0].pageX+_[1].pageX),e=.5*(_[0].pageY+_[1].pageY);g.set(t,e)}}function N(){const t=_[0].pageX-_[1].pageX,e=_[0].pageY-_[1].pageY,n=Math.sqrt(t*t+e*e);y.set(0,n)}function O(t){if(1==_.length)f.set(t.pageX,t.pageY);else{const e=Q(t),n=.5*(t.pageX+e.x),r=.5*(t.pageY+e.y);f.set(n,r)}m.subVectors(f,p).multiplyScalar(n.rotateSpeed);const e=n.domElement;S(2*Math.PI*m.x/e.clientHeight),A(2*Math.PI*m.y/e.clientHeight),p.copy(f)}function B(t){if(1===_.length)v.set(t.pageX,t.pageY);else{const e=Q(t),n=.5*(t.pageX+e.x),r=.5*(t.pageY+e.y);v.set(n,r)}x.subVectors(v,g).multiplyScalar(n.panSpeed),P(x.x,x.y),g.copy(v)}function z(t){const e=Q(t),r=t.pageX-e.x,i=t.pageY-e.y,s=Math.sqrt(r*r+i*i);w.set(0,s),b.set(0,Math.pow(w.y/y.y,n.zoomSpeed)),L(b.y),y.copy(w)}function k(t){!1!==n.enabled&&(0===_.length&&(n.domElement.setPointerCapture(t.pointerId),n.domElement.addEventListener("pointermove",H),n.domElement.addEventListener("pointerup",G)),function(t){_.push(t)}(t),"touch"===t.pointerType?function(t){switch(q(t),_.length){case 1:switch(n.touches.ONE){case c.ROTATE:if(!1===n.enableRotate)return;I(),i=r.TOUCH_ROTATE;break;case c.PAN:if(!1===n.enablePan)return;U(),i=r.TOUCH_PAN;break;default:i=r.NONE}break;case 2:switch(n.touches.TWO){case c.DOLLY_PAN:if(!1===n.enableZoom&&!1===n.enablePan)return;n.enableZoom&&N(),n.enablePan&&U(),i=r.TOUCH_DOLLY_PAN;break;case c.DOLLY_ROTATE:if(!1===n.enableZoom&&!1===n.enableRotate)return;n.enableZoom&&N(),n.enableRotate&&I(),i=r.TOUCH_DOLLY_ROTATE;break;default:i=r.NONE}break;default:i=r.NONE}i!==r.NONE&&n.dispatchEvent(bm)}(t):function(t){let e;switch(t.button){case 0:e=n.mouseButtons.LEFT;break;case 1:e=n.mouseButtons.MIDDLE;break;case 2:e=n.mouseButtons.RIGHT;break;default:e=-1}switch(e){case l.DOLLY:if(!1===n.enableZoom)return;!function(t){y.set(t.clientX,t.clientY)}(t),i=r.DOLLY;break;case l.ROTATE:if(t.ctrlKey||t.metaKey||t.shiftKey){if(!1===n.enablePan)return;D(t),i=r.PAN}else{if(!1===n.enableRotate)return;F(t),i=r.ROTATE}break;case l.PAN:if(t.ctrlKey||t.metaKey||t.shiftKey){if(!1===n.enableRotate)return;F(t),i=r.ROTATE}else{if(!1===n.enablePan)return;D(t),i=r.PAN}break;default:i=r.NONE}i!==r.NONE&&n.dispatchEvent(bm)}(t))}function H(t){!1!==n.enabled&&("touch"===t.pointerType?function(t){switch(q(t),i){case r.TOUCH_ROTATE:if(!1===n.enableRotate)return;O(t),n.update();break;case r.TOUCH_PAN:if(!1===n.enablePan)return;B(t),n.update();break;case r.TOUCH_DOLLY_PAN:if(!1===n.enableZoom&&!1===n.enablePan)return;!function(t){n.enableZoom&&z(t),n.enablePan&&B(t)}(t),n.update();break;case r.TOUCH_DOLLY_ROTATE:if(!1===n.enableZoom&&!1===n.enableRotate)return;!function(t){n.enableZoom&&z(t),n.enableRotate&&O(t)}(t),n.update();break;default:i=r.NONE}}(t):function(t){if(!1!==n.enabled)switch(i){case r.ROTATE:if(!1===n.enableRotate)return;!function(t){f.set(t.clientX,t.clientY),m.subVectors(f,p).multiplyScalar(n.rotateSpeed);const e=n.domElement;S(2*Math.PI*m.x/e.clientHeight),A(2*Math.PI*m.y/e.clientHeight),p.copy(f),n.update()}(t);break;case r.DOLLY:if(!1===n.enableZoom)return;!function(t){w.set(t.clientX,t.clientY),b.subVectors(w,y),b.y>0?L(T()):b.y<0&&R(T()),y.copy(w),n.update()}(t);break;case r.PAN:if(!1===n.enablePan)return;!function(t){v.set(t.clientX,t.clientY),x.subVectors(v,g).multiplyScalar(n.panSpeed),P(x.x,x.y),g.copy(v),n.update()}(t)}}(t))}function G(t){Y(t),0===_.length&&(n.domElement.releasePointerCapture(t.pointerId),n.domElement.removeEventListener("pointermove",H),n.domElement.removeEventListener("pointerup",G)),n.dispatchEvent(_m),i=r.NONE}function V(t){Y(t)}function W(t){!1!==n.enabled&&!1!==n.enableZoom&&i===r.NONE&&(t.preventDefault(),n.dispatchEvent(bm),function(t){t.deltaY<0?R(T()):t.deltaY>0&&L(T()),n.update()}(t),n.dispatchEvent(_m))}function X(t){!1!==n.enabled&&!1!==n.enablePan&&function(t){let e=!1;switch(t.code){case n.keys.UP:P(0,n.keyPanSpeed),e=!0;break;case n.keys.BOTTOM:P(0,-n.keyPanSpeed),e=!0;break;case n.keys.LEFT:P(n.keyPanSpeed,0),e=!0;break;case n.keys.RIGHT:P(-n.keyPanSpeed,0),e=!0}e&&(t.preventDefault(),n.update())}(t)}function j(t){!1!==n.enabled&&t.preventDefault()}function Y(t){delete M[t.pointerId];for(let e=0;e<_.length;e++)if(_[e].pointerId==t.pointerId)return void _.splice(e,1)}function q(t){let e=M[t.pointerId];void 0===e&&(e=new jn,M[t.pointerId]=e),e.set(t.pageX,t.pageY)}function Q(t){const e=t.pointerId===_[0].pointerId?_[1]:_[0];return M[e.pointerId]}n.domElement.addEventListener("contextmenu",j),n.domElement.addEventListener("pointerdown",k),n.domElement.addEventListener("pointercancel",V),n.domElement.addEventListener("wheel",W,{passive:!1}),this.update()}},t.EffectComposer=class{constructor(t,e){if(this.renderer=t,void 0===e){const n={minFilter:Mt,magFilter:Mt,format:Gt},r=t.getSize(new jn);this._pixelRatio=t.getPixelRatio(),this._width=r.width,this._height=r.height,(e=new ir(this._width*this._pixelRatio,this._height*this._pixelRatio,n)).texture.name="EffectComposer.rt1"}else this._pixelRatio=1,this._width=e.width,this._height=e.height;this.renderTarget1=e,this.renderTarget2=e.clone(),this.renderTarget2.texture.name="EffectComposer.rt2",this.writeBuffer=this.renderTarget1,this.readBuffer=this.renderTarget2,this.renderToScreen=!0,this.passes=[],void 0===If&&console.error("THREE.EffectComposer relies on CopyShader"),void 0===zf&&console.error("THREE.EffectComposer relies on ShaderPass"),this.copyPass=new zf(If),this.clock=new Sd}swapBuffers(){const t=this.readBuffer;this.readBuffer=this.writeBuffer,this.writeBuffer=t}addPass(t){this.passes.push(t),t.setSize(this._width*this._pixelRatio,this._height*this._pixelRatio)}insertPass(t,e){this.passes.splice(e,0,t),t.setSize(this._width*this._pixelRatio,this._height*this._pixelRatio)}removePass(t){const e=this.passes.indexOf(t);-1!==e&&this.passes.splice(e,1)}isLastEnabledPass(t){for(let e=t+1;e<this.passes.length;e++)if(this.passes[e].enabled)return!1;return!0}render(t){void 0===t&&(t=this.clock.getDelta());const e=this.renderer.getRenderTarget();let n=!1;for(let e=0,r=this.passes.length;e<r;e++){const r=this.passes[e];if(!1!==r.enabled){if(r.renderToScreen=this.renderToScreen&&this.isLastEnabledPass(e),r.render(this.renderer,this.writeBuffer,this.readBuffer,t,n),r.needsSwap){if(n){const e=this.renderer.getContext(),n=this.renderer.state.buffers.stencil;n.setFunc(e.NOTEQUAL,1,4294967295),this.copyPass.render(this.renderer,this.writeBuffer,this.readBuffer,t),n.setFunc(e.EQUAL,1,4294967295)}this.swapBuffers()}void 0!==kf&&(r instanceof kf?n=!0:r instanceof Hf&&(n=!1))}}this.renderer.setRenderTarget(e)}reset(t){if(void 0===t){const e=this.renderer.getSize(new jn);this._pixelRatio=this.renderer.getPixelRatio(),this._width=e.width,this._height=e.height,(t=this.renderTarget1.clone()).setSize(this._width*this._pixelRatio,this._height*this._pixelRatio)}this.renderTarget1.dispose(),this.renderTarget2.dispose(),this.renderTarget1=t,this.renderTarget2=t.clone(),this.writeBuffer=this.renderTarget1,this.readBuffer=this.renderTarget2}setSize(t,e){this._width=t,this._height=e;const n=this._width*this._pixelRatio,r=this._height*this._pixelRatio;this.renderTarget1.setSize(n,r),this.renderTarget2.setSize(n,r);for(let t=0;t<this.passes.length;t++)this.passes[t].setSize(n,r)}setPixelRatio(t){this._pixelRatio=t,this.setSize(this._width,this._height)}},t.RenderPass=class extends Uf{constructor(t,e,n,r,i){super(),this.scene=t,this.camera=e,this.overrideMaterial=n,this.clearColor=r,this.clearAlpha=void 0!==i?i:0,this.clear=!0,this.clearDepth=!1,this.needsSwap=!1,this._oldClearColor=new Li}render(t,e,n){const r=t.autoClear;let i,s;t.autoClear=!1,void 0!==this.overrideMaterial&&(s=this.scene.overrideMaterial,this.scene.overrideMaterial=this.overrideMaterial),this.clearColor&&(t.getClearColor(this._oldClearColor),i=t.getClearAlpha(),t.setClearColor(this.clearColor,this.clearAlpha)),this.clearDepth&&t.clearDepth(),t.setRenderTarget(this.renderToScreen?null:n),this.clear&&t.clear(t.autoClearColor,t.autoClearDepth,t.autoClearStencil),t.render(this.scene,this.camera),this.clearColor&&t.setClearColor(this._oldClearColor,i),void 0!==this.overrideMaterial&&(this.scene.overrideMaterial=s),t.autoClear=r}},t.ShaderPass=zf,t.FXAAShader=Vf,t.SMAAPass=class extends Uf{constructor(t,e){super(),this.edgesRT=new ir(t,e,{depthBuffer:!1,generateMipmaps:!1,minFilter:Mt,format:Ht}),this.edgesRT.texture.name="SMAAPass.edges",this.weightsRT=new ir(t,e,{depthBuffer:!1,generateMipmaps:!1,minFilter:Mt,format:Gt}),this.weightsRT.texture.name="SMAAPass.weights";const n=this,r=new Image;r.src=this.getAreaTexture(),r.onload=function(){n.areaTexture.needsUpdate=!0},this.areaTexture=new er,this.areaTexture.name="SMAAPass.area",this.areaTexture.image=r,this.areaTexture.format=Ht,this.areaTexture.minFilter=Mt,this.areaTexture.generateMipmaps=!1,this.areaTexture.flipY=!1;const i=new Image;i.src=this.getSearchTexture(),i.onload=function(){n.searchTexture.needsUpdate=!0},this.searchTexture=new er,this.searchTexture.name="SMAAPass.search",this.searchTexture.image=i,this.searchTexture.magFilter=xt,this.searchTexture.minFilter=xt,this.searchTexture.generateMipmaps=!1,this.searchTexture.flipY=!1,void 0===Wf&&console.error("THREE.SMAAPass relies on SMAAShader"),this.uniformsEdges=bs.clone(Wf.uniforms),this.uniformsEdges.resolution.value.set(1/t,1/e),this.materialEdges=new _s({defines:Object.assign({},Wf.defines),uniforms:this.uniformsEdges,vertexShader:Wf.vertexShader,fragmentShader:Wf.fragmentShader}),this.uniformsWeights=bs.clone(Xf.uniforms),this.uniformsWeights.resolution.value.set(1/t,1/e),this.uniformsWeights.tDiffuse.value=this.edgesRT.texture,this.uniformsWeights.tArea.value=this.areaTexture,this.uniformsWeights.tSearch.value=this.searchTexture,this.materialWeights=new _s({defines:Object.assign({},Xf.defines),uniforms:this.uniformsWeights,vertexShader:Xf.vertexShader,fragmentShader:Xf.fragmentShader}),this.uniformsBlend=bs.clone(jf.uniforms),this.uniformsBlend.resolution.value.set(1/t,1/e),this.uniformsBlend.tDiffuse.value=this.weightsRT.texture,this.materialBlend=new _s({uniforms:this.uniformsBlend,vertexShader:jf.vertexShader,fragmentShader:jf.fragmentShader}),this.needsSwap=!1,this.fsQuad=new Bf(null)}render(t,e,n){this.uniformsEdges.tDiffuse.value=n.texture,this.fsQuad.material=this.materialEdges,t.setRenderTarget(this.edgesRT),this.clear&&t.clear(),this.fsQuad.render(t),this.fsQuad.material=this.materialWeights,t.setRenderTarget(this.weightsRT),this.clear&&t.clear(),this.fsQuad.render(t),this.uniformsBlend.tColor.value=n.texture,this.fsQuad.material=this.materialBlend,this.renderToScreen?(t.setRenderTarget(null),this.fsQuad.render(t)):(t.setRenderTarget(e),this.clear&&t.clear(),this.fsQuad.render(t))}setSize(t,e){this.edgesRT.setSize(t,e),this.weightsRT.setSize(t,e),this.materialEdges.uniforms.resolution.value.set(1/t,1/e),this.materialWeights.uniforms.resolution.value.set(1/t,1/e),this.materialBlend.uniforms.resolution.value.set(1/t,1/e)}getAreaTexture(){return"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAKAAAAIwCAIAAACOVPcQAACBeklEQVR42u39W4xlWXrnh/3WWvuciIzMrKxrV8/0rWbY0+SQFKcb4owIkSIFCjY9AC1BT/LYBozRi+EX+cV+8IMsYAaCwRcBwjzMiw2jAWtgwC8WR5Q8mDFHZLNHTarZGrLJJllt1W2qKrsumZWZcTvn7L3W54e1vrXX3vuciLPPORFR1XE2EomorB0nVuz//r71re/y/1eMvb4Cb3N11xV/PP/2v4UBAwJG/7H8urx6/25/Gf8O5hypMQ0EEEQwAqLfoN/Z+97f/SW+/NvcgQk4sGBJK6H7N4PFVL+K+e0N11yNfkKvwUdwdlUAXPHHL38oa15f/i/46Ih6SuMSPmLAYAwyRKn7dfMGH97jaMFBYCJUgotIC2YAdu+LyW9vvubxAP8kAL8H/koAuOKP3+q6+xGnd5kdYCeECnGIJViwGJMAkQKfDvB3WZxjLKGh8VSCCzhwEWBpMc5/kBbjawT4HnwJfhr+pPBIu7uu+OOTo9vsmtQcniMBGkKFd4jDWMSCRUpLjJYNJkM+IRzQ+PQvIeAMTrBS2LEiaiR9b/5PuT6Ap/AcfAFO4Y3dA3DFH7/VS+M8k4baEAQfMI4QfbVDDGIRg7GKaIY52qAjTAgTvGBAPGIIghOCYAUrGFNgzA7Q3QhgCwfwAnwe5vDejgG44o/fbm1C5ZlYQvQDARPAIQGxCWBM+wWl37ZQESb4gImexGMDouhGLx1Cst0Saa4b4AqO4Hk4gxo+3DHAV/nx27p3JziPM2pVgoiia5MdEzCGULprIN7gEEeQ5IQxEBBBQnxhsDb5auGmAAYcHMA9eAAz8PBol8/xij9+C4Djlim4gJjWcwZBhCBgMIIYxGAVIkH3ZtcBuLdtRFMWsPGoY9rN+HoBji9VBYdwD2ZQg4cnO7OSq/z4rU5KKdwVbFAjNojCQzTlCLPFSxtamwh2jMUcEgg2Wm/6XgErIBhBckQtGN3CzbVacERgCnfgLswhnvqf7QyAq/z4rRZm1YglYE3affGITaZsdIe2FmMIpnOCap25I6jt2kCwCW0D1uAD9sZctNGXcQIHCkINDQgc78aCr+zjtw3BU/ijdpw3zhCwcaONwBvdeS2YZKkJNJsMPf2JKEvC28RXxxI0ASJyzQCjCEQrO4Q7sFArEzjZhaFc4cdv+/JFdKULM4px0DfUBI2hIsy06BqLhGTQEVdbfAIZXYMPesq6VoCHICzUyjwInO4Y411//LYLs6TDa9wvg2CC2rElgAnpTBziThxaL22MYhzfkghz6GAs2VHbbdM91VZu1MEEpupMMwKyVTb5ij9+u4VJG/5EgEMMmFF01cFai3isRbKbzb+YaU/MQbAm2XSMoUPAmvZzbuKYRIFApbtlrfFuUGd6vq2hXNnH78ZLh/iFhsQG3T4D1ib7k5CC6vY0DCbtrohgLEIClXiGtl10zc0CnEGIhhatLBva7NP58Tvw0qE8yWhARLQ8h4+AhQSP+I4F5xoU+VilGRJs6wnS7ruti/4KvAY/CfdgqjsMy4pf8fodQO8/gnuX3f/3xi3om1/h7THr+co3x93PP9+FBUfbNUjcjEmhcrkT+8K7ml7V10Jo05mpIEFy1NmCJWx9SIKKt+EjAL4Ez8EBVOB6havuT/rByPvHXK+9zUcfcbb254+9fydJknYnRr1oGfdaiAgpxu1Rx/Rek8KISftx3L+DfsLWAANn8Hvw0/AFeAGO9DFV3c6D+CcWbL8Dj9e7f+T1k8AZv/d7+PXWM/Z+VvdCrIvuAKO09RpEEQJM0Ci6+B4xhTWr4cZNOvhktabw0ta0rSJmqz3Yw5/AKXwenod7cAhTmBSPKf6JBdvH8IP17h95pXqw50/+BFnj88fev4NchyaK47OPhhtI8RFSvAfDSNh0Ck0p2gLxGkib5NJj/JWCr90EWQJvwBzO4AHcgztwAFN1evHPUVGwfXON+0debT1YeGON9Yy9/63X+OguiwmhIhQhD7l4sMqlG3D86Suc3qWZ4rWjI1X7u0Ytw6x3rIMeIOPDprfe2XzNgyj6PahhBjO4C3e6puDgXrdg+/5l948vF3bqwZetZ+z9Rx9zdIY5pInPK4Nk0t+l52xdK2B45Qd87nM8fsD5EfUhIcJcERw4RdqqH7Yde5V7m1vhNmtedkz6EDzUMF/2jJYWbC+4fzzA/Y+/8PPH3j9dcBAPIRP8JLXd5BpAu03aziOL3VVHZzz3CXWDPWd+SH2AnxIqQoTZpo9Ckc6HIrFbAbzNmlcg8Ag8NFDDAhbJvTBZXbC94P7t68EXfv6o+21gUtPETU7bbkLxvNKRFG2+KXzvtObonPP4rBvsgmaKj404DlshFole1Glfh02fE7bYR7dZ82oTewIBGn1Md6CG6YUF26X376oevOLzx95vhUmgblI6LBZwTCDY7vMq0op5WVXgsObOXJ+1x3qaBl9j1FeLxbhU9w1F+Wiba6s1X/TBz1LnUfuYDi4r2C69f1f14BWfP+p+W2GFKuC9phcELMYRRLur9DEZTUdEH+iEqWdaM7X4WOoPGI+ZYD2+wcQ+y+ioHUZ9dTDbArzxmi/bJI9BND0Ynd6lBdve/butBw8+f/T9D3ABa3AG8W3VPX4hBin+bj8dMMmSpp5pg7fJ6xrBFE2WQQEWnV8Qg3FbAWzYfM1rREEnmvkN2o1+acG2d/9u68GDzx91v3mAjb1zkpqT21OipPKO0b9TO5W0nTdOmAQm0TObts3aBKgwARtoPDiCT0gHgwnbArzxmtcLc08HgF1asN0C4Ms/fvD5I+7PhfqyXE/b7RbbrGyRQRT9ARZcwAUmgdoz0ehJ9Fn7QAhUjhDAQSw0bV3T3WbNa59jzmiP6GsWbGXDX2ytjy8+f9T97fiBPq9YeLdBmyuizZHaqXITnXiMUEEVcJ7K4j3BFPurtB4bixW8wTpweL8DC95szWMOqucFYGsWbGU7p3TxxxefP+r+oTVktxY0v5hbq3KiOKYnY8ddJVSBxuMMVffNbxwIOERShst73HZ78DZrHpmJmH3K6sGz0fe3UUj0eyRrSCGTTc+rjVNoGzNSv05srAxUBh8IhqChiQgVNIIBH3AVPnrsnXQZbLTm8ammv8eVXn/vWpaTem5IXRlt+U/LA21zhSb9cye6jcOfCnOwhIAYXAMVTUNV0QhVha9xjgA27ODJbLbmitt3tRN80lqG6N/khgot4ZVlOyO4WNg3OIMzhIZQpUEHieg2im6F91hB3I2tubql6BYNN9Hj5S7G0G2tahslBWKDnOiIvuAEDzakDQKDNFQT6gbn8E2y4BBubM230YIpBnDbMa+y3dx0n1S0BtuG62lCCXwcY0F72T1VRR3t2ONcsmDjbmzNt9RFs2LO2hQNyb022JisaI8rAWuw4HI3FuAIhZdOGIcdjLJvvObqlpqvWTJnnQbyi/1M9O8UxWhBs//H42I0q1Yb/XPGONzcmm+ri172mHKvZBpHkJaNJz6v9jxqiklDj3U4CA2ugpAaYMWqNXsdXbmJNd9egCnJEsphXNM+MnK3m0FCJ5S1kmJpa3DgPVbnQnPGWIDspW9ozbcO4K/9LkfaQO2KHuqlfFXSbdNzcEcwoqNEFE9zcIXu9/6n/ym/BC/C3aJLzEKPuYVlbFnfhZ8kcWxV3dbv4bKl28566wD+8C53aw49lTABp9PWbsB+knfc/Li3eVizf5vv/xmvnPKg5ihwKEwlrcHqucuVcVOxEv8aH37E3ZqpZypUulrHEtIWKUr+txHg+ojZDGlwnqmkGlzcVi1dLiNSJiHjfbRNOPwKpx9TVdTn3K05DBx4psIk4Ei8aCkJahRgffk4YnEXe07T4H2RR1u27E6wfQsBDofUgjFUFnwC2AiVtA+05J2zpiDK2Oa0c5fmAecN1iJzmpqFZxqYBCYhFTCsUNEmUnIcZ6aEA5rQVhEywG6w7HSW02XfOoBlQmjwulOFQAg66SvJblrTEX1YtJ3uG15T/BH1OfOQeuR8g/c0gdpT5fx2SKbs9EfHTKdM8A1GaJRHLVIwhcGyydZsbifAFVKl5EMKNU2Hryo+06BeTgqnxzYjThVySDikbtJPieco75lYfKAJOMEZBTjoITuWHXXZVhcUDIS2hpiXHV9Ku4u44bN5OYLDOkJo8w+xJSMbhBRHEdEs9JZUCkQrPMAvaHyLkxgkEHxiNkx/x2YB0mGsQ8EUWj/stW5YLhtS5SMu+/YBbNPDCkGTUybN8krRLBGPlZkVOA0j+a1+rkyQKWGaPHPLZOkJhioQYnVZ2hS3zVxMtgC46KuRwbJNd9nV2PHgb36F194ecf/Yeu2vAFe5nm/bRBFrnY4BauE8ERmZRFUn0k8hbftiVYSKMEme2dJCJSCGYAlNqh87bXOPdUkGy24P6d1ll21MBqqx48Fvv8ZHH8HZFY7j/uAq1xMJUFqCSUlJPmNbIiNsmwuMs/q9CMtsZsFO6SprzCS1Z7QL8xCQClEelpjTduDMsmWD8S1PT152BtvmIGvUeDA/yRn83u/x0/4qxoPHjx+PXY9pqX9bgMvh/Nz9kpP4pOe1/fYf3axUiMdHLlPpZCNjgtNFAhcHEDxTumNONhHrBduW+vOyY++70WWnPXj98eA4kOt/mj/5E05l9+O4o8ePx67HFqyC+qSSnyselqjZGaVK2TadbFLPWAQ4NBhHqDCCV7OTpo34AlSSylPtIdd2AJZlyzYQrDJ5lcWGNceD80CunPLGGzsfD+7wRb95NevJI5docQ3tgCyr5bGnyaPRlmwNsFELViOOx9loebGNq2moDOKpHLVP5al2cymWHbkfzGXL7kfRl44H9wZy33tvt+PB/Xnf93e+nh5ZlU18wCiRUa9m7kib9LYuOk+hudQNbxwm0AQqbfloimaB2lM5fChex+ylMwuTbfmXQtmWlenZljbdXTLuOxjI/fDDHY4Hjx8/Hrse0zXfPFxbUN1kKqSCCSk50m0Ajtx3ub9XHBKHXESb8iO6E+qGytF4nO0OG3SXzbJlhxBnKtKyl0NwybjvYCD30aMdjgePHz8eu56SVTBbgxJMliQ3Oauwg0QHxXE2Ez/EIReLdQj42Gzb4CLS0YJD9xUx7bsi0vJi5mUbW1QzL0h0PFk17rtiIPfJk52MB48fPx67npJJwyrBa2RCCQRTbGZSPCxTPOiND4G2pYyOQ4h4jINIJh5wFU1NFZt+IsZ59LSnDqBjZ2awbOku+yInunLcd8VA7rNnOxkPHj9+PGY9B0MWJJNozOJmlglvDMXDEozdhQWbgs/U6oBanGzLrdSNNnZFjOkmbi5bNt1lX7JLLhn3vXAg9/h4y/Hg8ePHI9dzQMEkWCgdRfYykYKnkP7D4rIujsujaKPBsB54vE2TS00ccvFY/Tth7JXeq1hz+qgVy04sAJawTsvOknHfCwdyT062HA8eP348Zj0vdoXF4pilKa2BROed+9fyw9rWRXeTFXESMOanvDZfJuJaSXouQdMdDJZtekZcLLvEeK04d8m474UDuaenW44Hjx8/Xns9YYqZpszGWB3AN/4VHw+k7WSFtJ3Qicuqb/NlVmgXWsxh570xg2UwxUw3WfO6B5nOuO8aA7lnZxuPB48fPx6znm1i4bsfcbaptF3zNT78eFPtwi1OaCNOqp1x3zUGcs/PN++AGD1+fMXrSVm2baTtPhPahbPhA71wIHd2bXzRa69nG+3CraTtPivahV/55tXWg8fyRY/9AdsY8VbSdp8V7cKrrgdfM//z6ILQFtJ2nxHtwmuoB4/kf74+gLeRtvvMaBdeSz34+vifx0YG20jbfTa0C6+tHrwe//NmOG0L8EbSdp8R7cLrrQe/996O+ai3ujQOskpTNULa7jOjXXj99eCd8lHvoFiwsbTdZ0a78PrrwTvlo966pLuRtB2fFe3Cm6oHP9kNH/W2FryxtN1nTLvwRurBO+Kj3pWXHidtx2dFu/Bm68Fb81HvykuPlrb7LGkX3mw9eGs+6h1Y8MbSdjegXcguQLjmevDpTQLMxtJ2N6NdyBZu9AbrwVvwUW+LbteULUpCdqm0HTelXbhNPe8G68Gb8lFvVfYfSNuxvrTdTWoXbozAzdaDZzfkorOj1oxVxlIMlpSIlpLrt8D4hrQL17z+c3h6hU/wv4Q/utps4+bm+6P/hIcf0JwQ5oQGPBL0eKPTYEXTW+eL/2DKn73J9BTXYANG57hz1cEMviVf/4tf5b/6C5pTQkMIWoAq7hTpOJjtAM4pxKu5vg5vXeUrtI09/Mo/5H+4z+Mp5xULh7cEm2QbRP2tFIKR7WM3fPf/jZ3SWCqLM2l4NxID5zB72HQXv3jj/8mLR5xXNA5v8EbFQEz7PpRfl1+MB/hlAN65qgDn3wTgH13hK7T59bmP+NIx1SHHU84nLOITt3iVz8mNO+lPrjGAnBFqmioNn1mTyk1ta47R6d4MrX7tjrnjYUpdUbv2rVr6YpVfsGG58AG8Ah9eyUN8CX4WfgV+G8LVWPDGb+Zd4cU584CtqSbMKxauxTg+dyn/LkVgA+IR8KHtejeFKRtTmLLpxN6mYVLjYxwXf5x2VofiZcp/lwKk4wGOpYDnoIZPdg/AAbwMfx0+ge9dgZvYjuqKe4HnGnykYo5TvJbG0Vj12JagRhwKa44H95ShkZa5RyLGGdfYvG7aw1TsF6iapPAS29mNS3NmsTQZCmgTzFwgL3upCTgtBTRwvGMAKrgLn4evwin8+afJRcff+8izUGUM63GOOuAs3tJkw7J4kyoNreqrpO6cYLQeFUd7TTpr5YOTLc9RUUogUOVJQ1GYJaFLAW0oTmKyYS46ZooP4S4EON3xQ5zC8/CX4CnM4c1PE8ApexpoYuzqlP3d4S3OJP8ZDK7cKWNaTlqmgDiiHwl1YsE41w1zT4iRTm3DBqxvOUsbMKKDa/EHxagtnta072ejc3DOIh5ojvh8l3tk1JF/AV6FU6jh3U8HwEazLgdCLYSQ+MYiAI2ltomkzttUb0gGHdSUUgsIYjTzLG3mObX4FBRaYtpDVNZrih9TgTeYOBxsEnN1gOCTM8Bsw/ieMc75w9kuAT6A+/AiHGvN/+Gn4KRkiuzpNNDYhDGFndWRpE6SVfm8U5bxnSgVV2jrg6JCKmneqey8VMFgq2+AM/i4L4RUbfSi27lNXZ7R7W9RTcq/q9fk4Xw3AMQd4I5ifAZz8FcVtm9SAom/dyN4lczJQW/kC42ZrHgcCoIf1oVMKkVItmMBi9cOeNHGLqOZk+QqQmrbc5YmYgxELUUN35z2iohstgfLIFmcMV7s4CFmI74L9+EFmGsi+tGnAOD4Yk9gIpo01Y4cA43BWGygMdr4YZekG3OBIUXXNukvJS8tqa06e+lSDCtnqqMFu6hWHXCF+WaYt64m9QBmNxi7Ioy7D+fa1yHw+FMAcPt7SysFLtoG4PXAk7JOA3aAxBRqUiAdU9Yp5lK3HLSRFtOim0sa8euEt08xvKjYjzeJ2GU7YawexrnKI9tmobInjFXCewpwriY9+RR4aaezFhMhGCppKwom0ChrgFlKzyPKkGlTW1YQrE9HJqu8hKGgMc6hVi5QRq0PZxNfrYNgE64utmRv6KKHRpxf6VDUaOvNP5jCEx5q185My/7RKz69UQu2im5k4/eownpxZxNLwiZ1AZTO2ZjWjkU9uaB2HFn6Q3u0JcsSx/qV9hTEApRzeBLDJQXxYmTnq7bdLa3+uqFrxLJ5w1TehnNHx5ECvCh2g2c3hHH5YsfdaSKddztfjQ6imKFGSyFwlLzxEGPp6r5IevVjk1AMx3wMqi1NxDVjLBiPs9tbsCkIY5we5/ML22zrCScFxnNtzsr9Wcc3CnD+pYO+4VXXiDE0oc/vQQ/fDK3oPESJMYXNmJa/DuloJZkcTpcYE8lIH8Dz8DJMiynNC86Mb2lNaaqP/+L7f2fcE/yP7/Lde8xfgSOdMxvOixZf/9p3+M4hT1+F+zApxg9XfUvYjc8qX2lfOOpK2gNRtB4flpFu9FTKCp2XJRgXnX6olp1zyYjTKJSkGmLE2NjUr1bxFM4AeAAHBUFIeSLqXR+NvH/M9fOnfHzOD2vCSyQJKzfgsCh+yi/Mmc35F2fUrw7miW33W9hBD1vpuUojFphIyvg7aTeoymDkIkeW3XLHmguMzbIAJejN6B5MDrhipE2y6SoFRO/AK/AcHHZHNIfiWrEe/C6cr3f/yOvrQKB+zMM55/GQdLDsR+ifr5Fiuu+/y+M78LzOE5dsNuXC3PYvYWd8NXvphLSkJIasrlD2/HOqQ+RjcRdjKTGWYhhVUm4yxlyiGPuMsZR7sMCHUBeTuNWA7if+ifXgc/hovftHXs/DV+Fvwe+f8shzMiMcweFgBly3//vwJfg5AN4450fn1Hd1Rm1aBLu22Dy3y3H2+OqMemkbGZ4jozcDjJf6596xOLpC0eMTHbKnxLxH27uZ/bMTGs2jOaMOY4m87CfQwF0dw53oa1k80JRuz/XgS+8fX3N9Af4qPIMfzKgCp4H5TDGe9GGeFPzSsZz80SlPTxXjgwJmC45njzgt2vbQ4b4OAdUK4/vWhO8d8v6EE8fMUsfakXbPpFJeLs2ubM/qdm/la3WP91uWhxXHjoWhyRUq2iJ/+5mA73zwIIo+LoZ/SgvIRjAd1IMvvn98PfgOvAJfhhm8scAKVWDuaRaK8aQ9f7vuPDH6Bj47ZXau7rqYJ66mTDwEDU6lLbCjCK0qTXyl5mnDoeNRxanj3FJbaksTk0faXxHxLrssgPkWB9LnA/MFleXcJozzjwsUvUG0X/QCve51qkMDXp9mtcyOy3rwBfdvVJK7D6/ACSzg3RoruIq5UDeESfEmVclDxnniU82vxMLtceD0hGZWzBNPMM/jSPne2OVatiTKUpY5vY7gc0LdUAWeWM5tH+O2I66AOWw9xT2BuyRVLGdoDHUsVRXOo/c+ZdRXvFfnxWyIV4upFLCl9eAL7h8Zv0QH8Ry8pA2cHzQpGesctVA37ZtklBTgHjyvdSeKY/RZw/kJMk0Y25cSNRWSigQtlULPTw+kzuJPeYEkXjQRpoGZobYsLF79pyd1dMRHInbgFTZqNLhDqiIsTNpoex2WLcy0/X6rHcdMMQvFSd5dWA++4P7xv89deACnmr36uGlL69bRCL6BSZsS6c0TU2TKK5gtWCzgAOOwQcurqk9j8whvziZSMLcq5hbuwBEsYjopUBkqw1yYBGpLA97SRElEmx5MCInBY5vgLk94iKqSWmhIGmkJ4Bi9m4L645J68LyY4wsFYBfUg5feP/6gWWm58IEmKQM89hq7KsZNaKtP5TxxrUZZVkNmMJtjbKrGxLNEbHPJxhqy7lAmbC32ZqeF6lTaknRWcYaFpfLUBh/rwaQycCCJmW15Kstv6jRHyJFry2C1ahkkIW0LO75s61+owxK1y3XqweX9m5YLM2DPFeOjn/iiqCKJ+yKXF8t5Yl/kNsqaSCryxPq5xWTFIaP8KSW0RYxqupaUf0RcTNSSdJZGcKYdYA6kdtrtmyBckfKXwqk0pHpUHlwWaffjNRBYFPUDWa8e3Lt/o0R0CdisKDM89cX0pvRHEfM8ca4t0s2Xx4kgo91MPQJ/0c9MQYq0co8MBh7bz1fio0UUHLR4aAIOvOmoYO6kwlEVODSSTliWtOtH6sPkrtctF9ZtJ9GIerBskvhdVS5cFNv9s1BU0AbdUgdK4FG+dRnjFmDTzniRMdZO1QhzMK355vigbdkpz9P6qjUGE5J2qAcXmwJ20cZUiAD0z+pGMx6xkzJkmEf40Hr4qZfVg2XzF9YOyoV5BjzVkUJngKf8lgNYwKECEHrCNDrWZzMlflS3yBhr/InyoUgBc/lKT4pxVrrC6g1YwcceK3BmNxZcAtz3j5EIpqguh9H6wc011YN75cKDLpFDxuwkrPQmUwW4KTbj9mZTwBwLq4aQMUZbHm1rylJ46dzR0dua2n3RYCWZsiHROeywyJGR7mXKlpryyCiouY56sFkBWEnkEB/raeh/Sw4162KeuAxMQpEkzy5alMY5wamMsWKKrtW2WpEWNnReZWONKWjrdsKZarpFjqCslq773PLmEhM448Pc3+FKr1+94vv/rfw4tEcu+lKTBe4kZSdijBrykwv9vbCMPcLQTygBjzVckSLPRVGslqdunwJ4oegtFOYb4SwxNgWLCmD7T9kVjTv5YDgpo0XBmN34Z/rEHp0sgyz7lngsrm4lvMm2Mr1zNOJYJ5cuxuQxwMGJq/TP5emlb8fsQBZviK4t8hFL+zbhtlpwaRSxQRWfeETjuauPsdGxsBVdO7nmP4xvzSoT29pRl7kGqz+k26B3Oy0YNV+SXbbQas1ctC/GarskRdFpKczVAF1ZXnLcpaMuzVe6lZ2g/1ndcvOVgRG3sdUAY1bKD6achijMPdMxV4muKVorSpiDHituH7rSTs7n/4y5DhRXo4FVBN4vO/zbAcxhENzGbHCzU/98Mcx5e7a31kWjw9FCe/zNeYyQjZsWb1uc7U33pN4Mji6hCLhivqfa9Ss6xLg031AgfesA/l99m9fgvnaF9JoE6bYKmkGNK3aPbHB96w3+DnxFm4hs0drLsk7U8kf/N/CvwQNtllna0rjq61sH8L80HAuvwH1tvBy2ChqWSCaYTaGN19sTvlfzFD6n+iKTbvtayfrfe9ueWh6GJFoxLdr7V72a5ZpvHcCPDzma0wTO4EgbLyedxstO81n57LYBOBzyfsOhUKsW1J1BB5vr/tz8RyqOFylQP9Tvst2JALsC5lsH8PyQ40DV4ANzYa4dedNiKNR1s+x2wwbR7q4/4cTxqEk4LWDebfisuo36JXLiWFjOtLrlNWh3K1rRS4xvHcDNlFnNmWBBAl5SWaL3oPOfnvbr5pdjVnEaeBJSYjuLEkyLLsWhKccadmOphZkOPgVdalj2QpSmfOsADhMWE2ZBu4+EEJI4wKTAuCoC4xwQbWXBltpxbjkXJtKxxabo9e7tyhlgb6gNlSbUpMh+l/FaqzVwewGu8BW1Zx7pTpQDJUjb8tsUTW6+GDXbMn3mLbXlXJiGdggxFAoUrtPS3wE4Nk02UZG2OOzlk7fRs7i95QCLo3E0jtrjnM7SR3uS1p4qtS2nJ5OwtQVHgOvArLBFijZUV9QtSl8dAY5d0E0hM0w3HS2DpIeB6m/A1+HfhJcGUq4sOxH+x3f5+VO+Ds9rYNI7zPXOYWPrtf8bYMx6fuOAX5jzNR0PdsuON+X1f7EERxMJJoU6GkTEWBvVolVlb5lh3tKCg6Wx1IbaMDdJ+9sUCc5KC46hKGCk3IVOS4TCqdBNfUs7Kd4iXf2RjnT/LLysJy3XDcHLh/vde3x8DoGvwgsa67vBk91G5Pe/HbOe7xwym0NXbtiuuDkGO2IJDh9oQvJ4cY4vdoqLDuoH9Zl2F/ofsekn8lkuhIlhQcffUtSjytFyp++p6NiE7Rqx/lodgKVoceEp/CP4FfjrquZaTtj2AvH5K/ywpn7M34K/SsoYDAdIN448I1/0/wveW289T1/lX5xBzc8N5IaHr0XMOQdHsIkDuJFifj20pBm5jzwUv9e2FhwRsvhAbalCIuIw3bhJihY3p6nTFFIZgiSYjfTf3aXuOjmeGn4bPoGvwl+CFzTRczBIuHBEeImHc37/lGfwZR0cXzVDOvaKfNHvwe+suZ771K/y/XcBlsoN996JpBhoE2toYxOznNEOS5TJc6Id5GEXLjrWo+LEWGNpPDU4WAwsIRROu+1vM+0oW37z/MBN9kqHnSArwPfgFJ7Cq/Ai3Ie7g7ncmI09v8sjzw9mzOAEXoIHxURueaAce5V80f/DOuuZwHM8vsMb5wBzOFWM7wymTXPAEvm4vcFpZ2ut0VZRjkiP2MlmLd6DIpbGSiHOjdnUHN90hRYmhTnmvhzp1iKDNj+b7t5hi79lWGwQ+HN9RsfFMy0FXbEwhfuczKgCbyxYwBmcFhhvo/7a44v+i3XWcwDP86PzpGQYdWh7csP5dBvZ1jNzdxC8pBGuxqSW5vw40nBpj5JhMwvOzN0RWqERHMr4Lv1kWX84xLR830G3j6yqZ1a8UstTlW+qJPOZ+sZ7xZPKTJLhiNOAFd6tk+jrTH31ncLOxid8+nzRb128HhUcru/y0Wn6iT254YPC6FtVSIMoW2sk727AhvTtrWKZTvgsmckfXYZWeNRXx/3YQ2OUxLDrbHtN11IwrgXT6c8dATDwLniYwxzO4RzuQqTKSC5gAofMZ1QBK3zQ4JWobFbcvJm87FK+6JXrKahLn54m3p+McXzzYtP8VF/QpJuh1OwieElEoI1pRxPS09FBrkq2tWCU59+HdhNtTIqKm8EBrw2RTOEDpG3IKo2Y7mFdLm3ZeVjYwVw11o/oznceMve4CgMfNym/utA/d/ILMR7gpXzRy9eDsgLcgbs8O2Va1L0zzIdwGGemTBuwROHeoMShkUc7P+ISY3KH5ZZeWqO8mFTxQYeXTNuzvvK5FGPdQfuu00DwYFY9dyhctEt+OJDdnucfpmyhzUJzfsJjr29l8S0bXBfwRS9ZT26tmMIdZucch5ZboMz3Nio3nIOsYHCGoDT4kUA9MiXEp9Xsui1S8th/kbWIrMBxDGLodWUQIWcvnXy+9M23xPiSMOiRPqM+YMXkUN3gXFrZJwXGzUaMpJfyRS9ZT0lPe8TpScuRlbMHeUmlaKDoNuy62iWNTWNFYjoxFzuJs8oR+RhRx7O4SVNSXpa0ZJQ0K1LAHDQ+D9IepkMXpcsq5EVCvClBUIzDhDoyKwDw1Lc59GbTeORivugw1IcuaEOaGWdNm+Ps5fQ7/tm0DjMegq3yM3vb5j12qUId5UZD2oxDSEWOZMSqFl/W+5oynWDa/aI04tJRQ2eTXusg86SQVu/nwSYwpW6wLjlqIzwLuxGIvoAvul0PS+ZNz0/akp/pniO/8JDnGyaCkzbhl6YcqmK/69prxPqtpx2+Km9al9sjL+rwMgHw4jE/C8/HQ3m1vBuL1fldbzd8mOueVJ92syqdEY4KJjSCde3mcRw2TA6szxedn+zwhZMps0XrqEsiUjnC1hw0TELC2Ek7uAAdzcheXv1BYLagspxpzSAoZZUsIzIq35MnFQ9DOrlNB30jq3L4pkhccKUAA8/ocvN1Rzx9QyOtERs4CVsJRK/DF71kPYrxYsGsm6RMh4cps5g1DOmM54Ly1ii0Hd3Y/BMk8VWFgBVmhqrkJCPBHAolwZaWzLR9Vb7bcWdX9NyUYE+uB2BKfuaeBUcjDljbYVY4DdtsVWvzRZdWnyUzDpjNl1Du3aloAjVJTNDpcIOVVhrHFF66lLfJL1zJr9PQ2nFJSBaKoDe+sAvLufZVHVzYh7W0h/c6AAZ+7Tvj6q9j68G/cTCS/3n1vLKHZwNi+P+pS0WkZNMBMUl+LDLuiE4omZy71r3UFMwNJV+VJ/GC5ixVUkBStsT4gGKh0Gm4Oy3qvq7Lbmq24nPdDuDR9deR11XzP4vFu3TYzfnIyiSVmgizUYGqkIXNdKTY9pgb9D2Ix5t0+NHkVzCdU03suWkkVZAoCONCn0T35gAeW38de43mf97sMOpSvj4aa1KYUm58USI7Wxxes03bAZdRzk6UtbzMaCQ6IxO0dy7X+XsjoD16hpsBeGz9dfzHj+R/Hp8nCxZRqkEDTaCKCSywjiaoMJ1TITE9eg7Jqnq8HL6gDwiZb0u0V0Rr/rmvqjxKuaLCX7ZWXTvAY+uvm3z8CP7nzVpngqrJpZKwWnCUjIviYVlirlGOzPLI3SMVyp/elvBUjjDkNhrtufFFErQ8pmdSlbK16toBHlt/HV8uHMX/vEGALkV3RJREiSlopxwdMXOZPLZ+ix+kAHpMKIk8UtE1ygtquttwxNhphrIZ1IBzjGF3IIGxGcBj6q8bHJBG8T9vdsoWrTFEuebEZuVxhhClH6P5Zo89OG9fwHNjtNQTpD0TG9PJLEYqvEY6Rlxy+ZZGfL0Aj62/bnQCXp//eeM4KzfQVJbgMQbUjlMFIm6TpcfWlZje7NBSV6IsEVmumWIbjiloUzQX9OzYdo8L1wjw2PrrpimONfmfNyzKklrgnEkSzT5QWYQW40YShyzqsRmMXbvVxKtGuYyMKaU1ugenLDm5Ily4iT14fP11Mx+xJv+zZ3MvnfdFqxU3a1W/FTB4m3Qfsyc1XUcdVhDeUDZXSFHHLQj/Y5jtC7ZqM0CXGwB4bP11i3LhOvzPGygYtiUBiwQV/4wFO0majijGsafHyRLu0yG6q35cL1rOpVxr2s5cM2jJYMCdc10Aj6q/blRpWJ//+dmm5psMl0KA2+AFRx9jMe2WbC4jQxnikd4DU8TwUjRVacgdlhmr3bpddzuJ9zXqr2xnxJfzP29RexdtjDVZqzkqa6PyvcojGrfkXiJ8SEtml/nYskicv0ivlxbqjemwUjMw5evdg8fUX9nOiC/lf94Q2i7MURk9nW1MSj5j8eAyV6y5CN2S6qbnw3vdA1Iwq+XOSCl663udN3IzLnrt+us25cI1+Z83SXQUldqQq0b5XOT17bGpLd6ssN1VMPf8c+jG8L3NeCnMdF+Ra3fRa9dft39/LuZ/3vwHoHrqGmQFafmiQw6eyzMxS05K4bL9uA+SKUQzCnSDkqOGokXyJvbgJ/BHI+qvY69//4rl20NsmK2ou2dTsyIALv/91/8n3P2Aao71WFGi8KKv1fRC5+J67Q/507/E/SOshqN5TsmYIjVt+kcjAx98iz/4SaojbIV1rexE7/C29HcYD/DX4a0rBOF5VTu7omsb11L/AWcVlcVZHSsqGuXLLp9ha8I//w3Mv+T4Ew7nTBsmgapoCrNFObIcN4pf/Ob/mrvHTGqqgAupL8qWjWPS9m/31jAe4DjA+4+uCoQoT/zOzlrNd3qd4SdphFxsUvYwGWbTWtISc3wNOWH+kHBMfc6kpmpwPgHWwqaSUG2ZWWheYOGQGaHB+eQ/kn6b3pOgLV+ODSn94wDvr8Bvb70/LLuiPPEr8OGVWfDmr45PZyccEmsVXZGe1pRNX9SU5+AVQkNTIVPCHF/jGmyDC9j4R9LfWcQvfiETmgMMUCMN1uNCakkweZsowdYobiMSlnKA93u7NzTXlSfe+SVbfnPQXmg9LpYAQxpwEtONyEyaueWM4FPjjyjG3uOaFmBTWDNgBXGEiQpsaWhnAqIijB07Dlsy3fUGeP989xbWkyf+FF2SNEtT1E0f4DYYVlxFlbaSMPIRMk/3iMU5pME2SIWJvjckciebkQuIRRyhUvkHg/iUljG5kzVog5hV7vIlCuBrmlhvgPfNHQM8lCf+FEGsYbMIBC0qC9a0uuy2wLXVbLBaP5kjHokCRxapkQyzI4QEcwgYHRZBp+XEFTqXFuNVzMtjXLJgX4gAid24Hjwc4N3dtVSe+NNiwTrzH4WVUOlDobUqr1FuAgYllc8pmzoVrELRHSIW8ViPxNy4xwjBpyR55I6J220qQTZYR4guvUICJiSpr9gFFle4RcF/OMB7BRiX8sSfhpNSO3lvEZCQfLUVTKT78Ek1LRLhWN+yLyTnp8qWUZ46b6vxdRGXfHVqx3eI75YaLa4iNNiK4NOW7wPW6lhbSOF9/M9qw8e/aoB3d156qTzxp8pXx5BKAsYSTOIIiPkp68GmTq7sZtvyzBQaRLNxIZ+paozHWoLFeExIhRBrWitHCAHrCF7/thhD8JhYz84wg93QRV88wLuLY8zF8sQ36qF1J455bOlgnELfshKVxYOXKVuKx0jaj22sczTQqPqtV/XDgpswmGTWWMSDw3ssyUunLLrVPGjYRsH5ggHeHSWiV8kT33ycFSfMgkoOK8apCye0J6VW6GOYvffgU9RWsukEi2kUV2nl4dOYUzRik9p7bcA4ggdJ53LxKcEe17B1R8eqAd7dOepV8sTXf5lhejoL85hUdhDdknPtKHFhljOT+bdq0hxbm35p2nc8+Ja1Iw+tJykgp0EWuAAZYwMVwac5KzYMslhvgHdHRrxKnvhTYcfKsxTxtTETkjHO7rr3zjoV25lAQHrqpV7bTiy2aXMmUhTBnKS91jhtR3GEoF0oLnWhWNnYgtcc4N0FxlcgT7yz3TgNIKkscx9jtV1ZKpWW+Ub1tc1eOv5ucdgpx+FJy9pgbLE7xDyXb/f+hLHVGeitHOi6A7ybo3sF8sS7w7cgdk0nJaOn3hLj3uyD0Zp5pazFIUXUpuTTU18d1EPkDoX8SkmWTnVIozEdbTcZjoqxhNHf1JrSS/AcvHjZ/SMHhL/7i5z+POsTUh/8BvNfYMTA8n+yU/MlTZxSJDRStqvEuLQKWwDctMTQogUDyQRoTQG5Kc6oQRE1yV1jCA7ri7jdZyK0sYTRjCR0Hnnd+y7nHxNgTULqw+8wj0mQKxpYvhjm9uSUxg+TTy7s2GtLUGcywhXSKZN275GsqlclX90J6bRI1aouxmgL7Q0Nen5ziM80SqMIo8cSOo+8XplT/5DHNWsSUr/6lLN/QQ3rDyzLruEW5enpf7KqZoShEduuSFOV7DLX7Ye+GmXb6/hnNNqKsVXuMDFpb9Y9eH3C6NGEzuOuI3gpMH/I6e+zDiH1fXi15t3vA1czsLws0TGEtmPEJdiiFPwlwKbgLHAFk4P6ZyPdymYYHGE0dutsChQBl2JcBFlrEkY/N5bQeXQ18gjunuMfMfsBlxJSx3niO485fwO4fGD5T/+3fPQqkneWVdwnw/3bMPkW9Wbqg+iC765Zk+xcT98ibKZc2EdgHcLoF8cSOo/Oc8fS+OyEULF4g4sJqXVcmfMfsc7A8v1/yfGXmL9I6Fn5pRwZhsPv0TxFNlAfZCvG+Oohi82UC5f/2IsJo0cTOm9YrDoKhFPEUr/LBYTUNht9zelHXDqwfPCIw4owp3mOcIQcLttWXFe3VZ/j5H3cIc0G6oPbCR+6Y2xF2EC5cGUm6wKC5tGEzhsWqw5hNidUiKX5gFWE1GXh4/Qplw4sVzOmx9QxU78g3EF6wnZlEN4FzJ1QPSLEZz1KfXC7vd8ssGdIbNUYpVx4UapyFUHzJoTOo1McSkeNn1M5MDQfs4qQuhhX5vQZFw8suwWTcyYTgioISk2YdmkhehG4PkE7w51inyAGGaU+uCXADabGzJR1fn3lwkty0asIo8cROm9Vy1g0yDxxtPvHDAmpu+PKnM8Ix1wwsGw91YJqhteaWgjYBmmQiebmSpwKKzE19hx7jkzSWOm66oPbzZ8Yj6kxVSpYjVAuvLzYMCRo3oTQecOOjjgi3NQ4l9K5/hOGhNTdcWVOTrlgYNkEXINbpCkBRyqhp+LdRB3g0OU6rMfW2HPCFFMV9nSp+uB2woepdbLBuJQyaw/ZFysXrlXwHxI0b0LovEkiOpXGA1Ijagf+KUNC6rKNa9bQnLFqYNkEnMc1uJrg2u64ELPBHpkgWbmwKpJoDhMwNbbGzAp7Yg31wS2T5rGtzit59PrKhesWG550CZpHEzpv2NGRaxlNjbMqpmEIzygJqQfjypycs2pg2cS2RY9r8HUqkqdEgKTWtWTKoRvOBPDYBltja2SO0RGjy9UHtxwRjA11ujbKF+ti5cIR9eCnxUg6owidtyoU5tK4NLji5Q3HCtiyF2IqLGYsHViOXTXOYxucDqG0HyttqYAKqYo3KTY1ekyDXRAm2AWh9JmsVh/ccg9WJ2E8YjG201sPq5ULxxX8n3XLXuMInbft2mk80rRGjCGctJ8/GFdmEQ9Ug4FlE1ll1Y7jtiraqm5Fe04VV8lvSVBL8hiPrfFVd8+7QH3Qbu2ipTVi8cvSGivc9cj8yvH11YMHdNSERtuOslM97feYFOPKzGcsI4zW0YGAbTAOaxCnxdfiYUmVWslxiIblCeAYr9VYR1gM7GmoPrilunSxxeT3DN/2eBQ9H11+nk1adn6VK71+5+Jfct4/el10/7KBZfNryUunWSCPxPECk1rdOv1WVSrQmpC+Tl46YD3ikQYcpunSQgzVB2VHFhxHVGKDgMEY5GLlQnP7FMDzw7IacAWnO6sBr12u+XanW2AO0wQ8pknnFhsL7KYIqhkEPmEXFkwaN5KQphbkUmG72wgw7WSm9RiL9QT925hkjiVIIhphFS9HKI6/8QAjlpXqg9W2C0apyaVDwKQwrwLY3j6ADR13ZyUNByQXHQu6RY09Hu6zMqXRaNZGS/KEJs0cJEe9VH1QdvBSJv9h09eiRmy0V2uJcqHcShcdvbSNg5fxkenkVprXM9rDVnX24/y9MVtncvbKY706anNl3ASll9a43UiacVquXGhvq4s2FP62NGKfQLIQYu9q1WmdMfmUrDGt8eDS0cXozH/fjmUH6Jruvm50hBDSaEU/2Ru2LEN/dl006TSc/g7tfJERxGMsgDUEr104pfWH9lQaN+M4KWQjwZbVc2rZVNHsyHal23wZtIs2JJqtIc/WLXXRFCpJkfE9jvWlfFbsNQ9pP5ZBS0zKh4R0aMFj1IjTcTnvi0Zz2rt7NdvQb2mgbju1plsH8MmbnEk7KbK0b+wC2iy3aX3szW8xeZvDwET6hWZYwqTXSSG+wMETKum0Dq/q+x62gt2ua2ppAo309TRk9TPazfV3qL9H8z7uhGqGqxNVg/FKx0HBl9OVUORn8Q8Jx9gFttGQUDr3tzcXX9xGgN0EpzN9mdZ3GATtPhL+CjxFDmkeEU6x56kqZRusLzALXVqkCN7zMEcqwjmywDQ6OhyUe0Xao1Qpyncrg6wKp9XfWDsaZplElvQ/b3sdweeghorwBDlHzgk1JmMc/wiERICVy2VJFdMjFuLQSp3S0W3+sngt2njwNgLssFGVQdJ0tu0KH4ky1LW4yrbkuaA6Iy9oz/qEMMXMMDWyIHhsAyFZc2peV9hc7kiKvfULxCl9iddfRK1f8kk9qvbdOoBtOg7ZkOZ5MsGrSHsokgLXUp9y88smniwWyuFSIRVmjplga3yD8Uij5QS1ZiM4U3Qw5QlSm2bXjFe6jzzBFtpg+/YBbLAWG7OPynNjlCw65fukGNdkJRf7yM1fOxVzbxOJVocFoYIaGwH22mIQkrvu1E2nGuebxIgW9U9TSiukPGU+Lt++c3DJPKhyhEEbXCQLUpae2exiKy6tMPe9mDRBFCEMTWrtwxN8qvuGnt6MoihKWS5NSyBhbH8StXoAz8PLOrRgLtOT/+4vcu+7vDLnqNvztOq7fmd8sMmY9Xzn1zj8Dq8+XVdu2Nv0IIySgEdQo3xVHps3Q5i3fLFsV4aiqzAiBhbgMDEd1uh8qZZ+lwhjkgokkOIv4xNJmyncdfUUzgB4oFMBtiu71Xumpz/P+cfUP+SlwFExwWW62r7b+LSPxqxn/gvMZ5z9C16t15UbNlq+jbGJtco7p8wbYlL4alSyfWdeuu0j7JA3JFNuVAwtst7F7FhWBbPFNKIUORndWtLraFLmMu7KFVDDOzqkeaiN33YAW/r76wR4XDN/yN1z7hejPau06EddkS/6XThfcz1fI/4K736fO48vlxt2PXJYFaeUkFS8U15XE3428xdtn2kc8GQlf1vkIaNRRnOMvLTWrZbElEHeLWi1o0dlKPAh1MVgbbVquPJ5+Cr8LU5/H/+I2QlHIU2ClXM9G8v7Rr7oc/hozfUUgsPnb3D+I+7WF8kNO92GY0SNvuxiE+2Bt8prVJTkzE64sfOstxuwfxUUoyk8VjcTlsqe2qITSFoSj6Epd4KsT6BZOWmtgE3hBfir8IzZDwgV4ZTZvD8VvPHERo8v+vL1DASHTz/i9OlKueHDjK5Rnx/JB1Vb1ioXdBra16dmt7dgik10yA/FwJSVY6XjA3oy4SqM2frqDPPSRMex9qs3XQtoWxMj7/Er8GWYsXgjaVz4OYumP2+9kbxvny/6kvWsEBw+fcb5bInc8APdhpOSs01tEqIkoiZjbAqKMruLbJYddHuHFRIyJcbdEdbl2sVLaySygunutBg96Y2/JjKRCdyHV+AEFtTvIpbKIXOamknYSiB6KV/0JetZITgcjjk5ZdaskBtWO86UF0ap6ozGXJk2WNiRUlCPFir66lzdm/SLSuK7EUdPz8f1z29Skq6F1fXg8+5UVR6bszncP4Tn4KUkkdJ8UFCY1zR1i8RmL/qQL3rlei4THG7OODlnKko4oI01kd3CaM08Ia18kC3GNoVaO9iDh+hWxSyTXFABXoau7Q6q9OxYg/OVEMw6jdbtSrJ9cBcewGmaZmg+bvkUnUUaGr+ZfnMH45Ivevl61hMcXsxYLFTu1hTm2zViCp7u0o5l+2PSUh9bDj6FgYypufBDhqK2+oXkiuHFHR3zfj+9PtA8oR0xnqX8qn+sx3bFODSbbF0X8EUvWQ8jBIcjo5bRmLOljDNtcqNtOe756h3l0VhKa9hDd2l1eqmsnh0MNMT/Cqnx6BInumhLT8luljzQ53RiJeA/0dxe5NK0o2fA1+GLXr6eNQWHNUOJssQaTRlGpLHKL9fD+IrQzTOMZS9fNQD4AnRNVxvTdjC+fJdcDDWQcyB00B0t9BDwTxXgaAfzDZ/DBXzRnfWMFRwuNqocOmX6OKNkY63h5n/fFcB28McVHqnXZVI27K0i4rDLNE9lDKV/rT+udVbD8dFFu2GGZ8mOt0kAXcoX3ZkIWVtw+MNf5NjR2FbivROHmhV1/pj2egv/fMGIOWTIWrV3Av8N9imV9IWml36H6cUjqEWNv9aNc+veb2sH46PRaHSuMBxvtW+twxctq0z+QsHhux8Q7rCY4Ct8lqsx7c6Sy0dl5T89rIeEuZKoVctIk1hNpfavER6yyH1Vvm3MbsUHy4ab4hWr/OZPcsRBphnaV65/ZcdYPNNwsjN/djlf9NqCw9U5ExCPcdhKxUgLSmfROpLp4WSUr8ojdwbncbvCf+a/YzRaEc6QOvXcGO256TXc5Lab9POvB+AWY7PigWYjzhifbovuunzRawsO24ZqQQAqguBtmpmPB7ysXJfyDDaV/aPGillgz1MdQg4u5MYaEtBNNHFjkRlSpd65lp4hd2AVPTfbV7FGpyIOfmNc/XVsPfg7vzaS/3nkvLL593ANLvMuRMGpQIhiF7kUEW9QDpAUbTWYBcbp4WpacHHY1aacqQyjGZS9HI3yCBT9kUZJhVOD+zUDvEH9ddR11fzPcTDQ5TlgB0KwqdXSavk9BC0pKp0WmcuowSw07VXmXC5guzSa4p0UvRw2lbDiYUx0ExJJRzWzi6Gm8cnEkfXXsdcG/M/jAJa0+bmCgdmQ9CYlNlSYZOKixmRsgiFxkrmW4l3KdFKv1DM8tk6WxPYJZhUUzcd8Kdtgrw/gkfXXDT7+avmfVak32qhtkg6NVdUS5wgkru1YzIkSduTW1FDwVWV3JQVJVuieTc0y4iDpFwc7/BvSalvKdQM8sv662cevz/+8sQVnjVAT0W2wLllw1JiMhJRxgDjCjLQsOzSFSgZqx7lAW1JW0e03yAD3asC+GD3NbQhbe+mN5GXH1F83KDOM4n/e5JIuH4NpdQARrFPBVptUNcjj4cVMcFSRTE2NpR1LEYbYMmfWpXgP9KejaPsLUhuvLCsVXznAG9dfx9SR1ud/3hZdCLHb1GMdPqRJgqDmm76mHbvOXDtiO2QPUcKo/TWkQ0i2JFXpBoo7vij1i1Lp3ADAo+qvG3V0rM//vFnnTE4hxd5Ka/Cor5YEdsLVJyKtDgVoHgtW11pWSjolPNMnrlrVj9Fv2Qn60twMwKPqr+N/wvr8z5tZcDsDrv06tkqyzESM85Ycv6XBWA2birlNCXrI6VbD2lx2L0vQO0QVTVVLH4SE67fgsfVXv8n7sz7/85Z7cMtbE6f088wSaR4kCkCm10s6pKbJhfqiUNGLq+0gLWC6eUAZFPnLjwqtKd8EwGvWX59t7iPW4X/eAN1svgRVSY990YZg06BD1ohLMtyFTI4pKTJsS9xREq9EOaPWiO2gpms7397x6nQJkbh+Fz2q/rqRROX6/M8bJrqlVW4l6JEptKeUFuMYUbtCQ7CIttpGc6MY93x1r1vgAnRXvY5cvwWPqb9uWQm+lP95QxdNMeWhOq1x0Db55C7GcUv2ZUuN6n8iKzsvOxibC//Yfs9Na8r2Rlz02vXXDT57FP/zJi66/EJSmsJKa8QxnoqW3VLQ+jZVUtJwJ8PNX1NQCwfNgdhhHD9on7PdRdrdGPF28rJr1F+3LBdeyv+8yYfLoMYet1vX4upNAjVvwOUWnlNXJXlkzk5Il6kqeoiL0C07qno+/CYBXq/+utlnsz7/Mzvy0tmI4zm4ag23PRN3t/CWryoUVJGm+5+K8RJ0V8Hc88/XHUX/HfiAq7t+BH+x6v8t438enWmdJwFA6ZINriLGKv/95f8lT9/FnyA1NMVEvQyaXuu+gz36f/DD73E4pwqpLcvm/o0Vle78n//+L/NPvoefp1pTJye6e4A/D082FERa5/opeH9zpvh13cNm19/4v/LDe5xMWTi8I0Ta0qKlK27AS/v3/r+/x/2GO9K2c7kVMonDpq7//jc5PKCxeNPpFVzaRr01wF8C4Pu76hXuX18H4LduTr79guuFD3n5BHfI+ZRFhY8w29TYhbbLi/bvBdqKE4fUgg1pBKnV3FEaCWOWyA+m3WpORZr/j+9TKJtW8yBTF2/ZEODI9/QavHkVdGFp/Pjn4Q+u5hXapsP5sOH+OXXA1LiKuqJxiMNbhTkbdJTCy4llEt6NnqRT4dhg1V3nbdrm6dYMecA1yTOL4PWTE9L5VzPFlLBCvlG58AhehnN4uHsAYinyJ+AZ/NkVvELbfOBUuOO5syBIEtiqHU1k9XeISX5bsimrkUUhnGDxourN8SgUsCZVtKyGbyGzHXdjOhsAvOAswSRyIBddRdEZWP6GZhNK/yjwew9ehBo+3jEADu7Ay2n8mDc+TS7awUHg0OMzR0LABhqLD4hJEh/BEGyBdGlSJoXYXtr+3HS4ijzVpgi0paWXtdruGTknXBz+11qT1Q2inxaTzQCO46P3lfLpyS4fou2PH/PupwZgCxNhGlj4IvUuWEsTkqMWm6i4xCSMc9N1RDQoCVcuGItJ/MRWefais+3synowi/dESgJjkilnWnBTGvRWmaw8oR15257t7CHmCf8HOn7cwI8+NQBXMBEmAa8PMRemrNCEhLGEhDQKcGZWS319BX9PFBEwGTbRBhLbDcaV3drFcDqk5kCTd2JF1Wp0HraqBx8U0wwBTnbpCadwBA/gTH/CDrcCs93LV8E0YlmmcyQRQnjBa8JESmGUfIjK/7fkaDJpmD2QptFNVJU1bbtIAjjWQizepOKptRjbzR9Kag6xZmMLLjHOtcLT3Tx9o/0EcTT1XN3E45u24AiwEypDJXihKjQxjLprEwcmRKclaDNZCVqr/V8mYWyFADbusiY5hvgFoU2vio49RgJLn5OsReRFN6tabeetiiy0V7KFHT3HyZLx491u95sn4K1QQSPKM9hNT0wMVvAWbzDSVdrKw4zRjZMyJIHkfq1VAVCDl/bUhNKlGq0zGr05+YAceXVPCttVk0oqjVwMPt+BBefx4yPtGVkUsqY3CHDPiCM5ngupUwCdbkpd8kbPrCWHhkmtIKLEetF2499eS1jZlIPGYnlcPXeM2KD9vLS0bW3ktYNqUllpKLn5ZrsxlIzxvDu5eHxzGLctkZLEY4PgSOg2IUVVcUONzUDBEpRaMoXNmUc0tFZrTZquiLyKxrSm3DvIW9Fil+AkhXu5PhEPx9mUNwqypDvZWdKlhIJQY7vn2OsnmBeOWnYZ0m1iwbbw1U60by5om47iHRV6fOgzjMf/DAZrlP40Z7syxpLK0lJ0gqaAK1c2KQKu7tabTXkLFz0sCftuwX++MyNeNn68k5Buq23YQhUh0SNTJa1ioQ0p4nUG2y0XilF1JqODqdImloPS4Bp111DEWT0jJjVv95uX9BBV7eB3bUWcu0acSVM23YZdd8R8UbQUxJ9wdu3oMuhdt929ME+mh6JXJ8di2RxbTi6TbrDquqV4aUKR2iwT6aZbyOwEXN3DUsWr8Hn4EhwNyHuXHh7/pdaUjtR7vnDh/d8c9xD/s5f501eQ1+CuDiCvGhk1AN/4Tf74RfxPwD3toLarR0zNtsnPzmS64KIRk861dMWCU8ArasG9T9H0ZBpsDGnjtAOM2+/LuIb2iIUGXNgl5ZmKD/Tw8TlaAuihaFP5yrw18v4x1898zIdP+DDAX1bM3GAMvPgRP/cJn3zCW013nrhHkrITyvYuwOUkcHuKlRSW5C6rzIdY4ppnF7J8aAJbQepgbJYBjCY9usGXDKQxq7RZfh9eg5d1UHMVATRaD/4BHK93/1iAgYZ/+jqPn8Dn4UExmWrpa3+ZOK6MvM3bjwfzxNWA2dhs8+51XHSPJiaAhGSpWevEs5xHLXcEGFXYiCONySH3fPWq93JIsBiSWvWyc3CAN+EcXoT7rCSANloPPoa31rt/5PUA/gp8Q/jDD3hyrjzlR8VkanfOvB1XPubt17vzxAfdSVbD1pzAnfgyF3ycadOTOTXhpEUoLC1HZyNGW3dtmjeXgr2r56JNmRwdNNWaQVBddd6rh4MhviEB9EFRD/7RGvePvCbwAL4Mx/D6M541hHO4D3e7g6PafdcZVw689z7NGTwo5om7A8sPhccT6qKcl9NJl9aM/9kX+e59Hh1yPqGuCCZxuITcsmNaJ5F7d0q6J3H48TO1/+M57085q2icdu2U+W36Ldllz9Agiv4YGljoEN908EzvDOrBF98/vtJwCC/BF2AG75xxEmjmMIcjxbjoaxqOK3/4hPOZzhMPBpYPG44CM0dTVm1LjLtUWWVz1Bcf8tEx0zs8O2A2YVHRxKYOiy/aOVoAaMu0i7ubu43njjmd4ibMHU1sIDHaQNKrZND/FZYdk54oCXetjq7E7IVl9eAL7t+oHnwXXtLx44czzoRFHBztYVwtH1d+NOMkupZ5MTM+gUmq90X+Bh9zjRlmaQ+m7YMqUL/veemcecAtOJ0yq1JnVlN27di2E0+Klp1tAJ4KRw1eMI7aJjsO3R8kPSI3fUFXnIOfdQe86sIIVtWDL7h//Ok6vj8vwDk08NEcI8zz7OhBy+WwalzZeZ4+0XniRfst9pAJqQHDGLzVQ2pheZnnv1OWhwO43/AgcvAEXEVVpa4db9sGvNK8wjaENHkfFQ4Ci5i7dqnQlPoLQrHXZDvO3BIXZbJOBrOaEbML6sFL798I4FhKihjHMsPjBUZYCMFr6nvaArxqXPn4lCa+cHfSa2cP27g3Z3ziYTRrcbQNGLQmGF3F3cBdzzzX7AILx0IB9rbwn9kx2G1FW3Inic+ZLIsVvKR8Zwfj0l1fkqo8LWY1M3IX14OX3r9RKTIO+d9XzAI8qRPGPn/4NC2n6o4rN8XJ82TOIvuVA8zLKUHRFgBCetlDZlqR1gLKjS39xoE7Bt8UvA6BxuEDjU3tFsEijgA+615tmZkXKqiEENrh41iLDDZNq4pKTWR3LZfnos81LOuNa15cD956vLMsJd1rqYp51gDUQqMYm2XsxnUhD2jg1DM7SeuJxxgrmpfISSXVIJIS5qJJSvJPEQ49DQTVIbYWJ9QWa/E2+c/oPK1drmC7WSfJRNKBO5Yjvcp7Gc3dmmI/Xh1kDTEuiSnWqQf37h+fTMhGnDf6dsS8SQfQWlqqwXXGlc/PEZ/SC5mtzIV0nAshlQdM/LvUtYutrEZ/Y+EAFtq1k28zQhOwLr1AIeANzhF8t9qzTdZf2qRKO6MWE9ohBYwibbOmrFtNmg3mcS+tB28xv2uKd/agYCvOP+GkSc+0lr7RXzyufL7QbkUpjLjEWFLqOIkAGu2B0tNlO9Eau2W1qcOUvVRgKzypKIQZ5KI3q0MLzqTNRYqiZOqmtqloIRlmkBHVpHmRYV6/HixbO6UC47KOFJnoMrVyr7wYz+SlW6GUaghYbY1I6kkxA2W1fSJokUdSh2LQ1GAimRGm0MT+uu57H5l7QgOWxERpO9moLRPgTtquWCfFlGlIjQaRly9odmzMOWY+IBO5tB4sW/0+VWGUh32qYk79EidWKrjWuiLpiVNGFWFRJVktyeXWmbgBBzVl8anPuXyNJlBJOlKLTgAbi/EYHVHxWiDaVR06GnHQNpJcWcK2jJtiCfG2sEHLzuI66sGrMK47nPIInPnu799935aOK2cvmvubrE38ZzZjrELCmXM2hM7UcpXD2oC3+ECVp7xtIuxptJ0jUr3sBmBS47TVxlvJ1Sqb/E0uLdvLj0lLr29ypdd/eMX3f6lrxGlKwKQxEGvw0qHbkbwrF3uHKwVENbIV2wZ13kNEF6zD+x24aLNMfDTCbDPnEikZFyTNttxWBXDaBuM8KtI2rmaMdUY7cXcUPstqTGvBGSrFWIpNMfbdea990bvAOC1YX0qbc6smDS1mPxSJoW4fwEXvjMmhlijDRq6qale6aJEuFGoppYDoBELQzLBuh/mZNx7jkinv0EtnUp50lO9hbNK57lZaMAWuWR5Yo9/kYwcYI0t4gWM47Umnl3YmpeBPqSyNp3K7s2DSAS/39KRuEN2bS4xvowV3dFRMx/VFcp2Yp8w2nTO9hCXtHG1kF1L4KlrJr2wKfyq77R7MKpFKzWlY9UkhYxyHWW6nBWPaudvEAl3CGcNpSXPZ6R9BbBtIl6cHL3gIBi+42CYXqCx1gfGWe7Ap0h3luyXdt1MKy4YUT9xSF01G16YEdWsouW9mgDHd3veyA97H+Ya47ZmEbqMY72oPztCGvK0onL44AvgC49saZKkWRz4veWljE1FHjbRJaWv6ZKKtl875h4CziFCZhG5rx7tefsl0aRT1bMHZjm8dwL/6u7wCRysaQblQoG5yAQN5zpatMNY/+yf8z+GLcH/Qn0iX2W2oEfXP4GvwQHuIL9AYGnaO3zqAX6946nkgqZNnUhx43DIdQtMFeOPrgy/y3Yd85HlJWwjLFkU3kFwq28xPnuPhMWeS+tDLV9Otllq7pQCf3uXJDN9wFDiUTgefHaiYbdfi3b3u8+iY6TnzhgehI1LTe8lcd7s1wJSzKbahCRxKKztTLXstGAiu3a6rPuQs5pk9TWAan5f0BZmGf7Ylxzzk/A7PAs4QPPPAHeFQ2hbFHszlgZuKZsJcUmbDC40sEU403cEjczstOEypa+YxevL4QBC8oRYqWdK6b7sK25tfE+oDZgtOQ2Jg8T41HGcBE6fTWHn4JtHcu9S7uYgU5KSCkl/mcnq+5/YBXOEr6lCUCwOTOM1taOI8mSxx1NsCXBEmLKbMAg5MkwbLmpBaFOPrNSlO2HnLiEqW3tHEwd8AeiQLmn+2gxjC3k6AxREqvKcJbTEzlpLiw4rNZK6oJdidbMMGX9FULKr0AkW+2qDEPBNNm5QAt2Ik2nftNWHetubosHLo2nG4vQA7GkcVCgVCgaDixHqo9UUn1A6OshapaNR/LPRYFV8siT1cCtJE0k/3WtaNSuUZYKPnsVIW0xXWnMUxq5+En4Kvw/MqQmVXnAXj9Z+9zM98zM/Agy7F/qqj2Nh67b8HjFnPP3iBn/tkpdzwEJX/whIcQUXOaikeliCRGUk7tiwF0rItwMEhjkZ309hikFoRAmLTpEXWuHS6y+am/KB/fM50aLEhGnSMwkpxzOov4H0AvgovwJ1iGzDLtJn/9BU+fAINfwUe6FHSLhu83viV/+/HrOePX+STT2B9uWGbrMHHLldRBlhS/CJQmcRxJFqZica01XixAZsYiH1uolZxLrR/SgxVIJjkpQP4PE9sE59LKLr7kltSBogS5tyszzH8Fvw8/AS8rNOg0xUS9fIaHwb+6et8Q/gyvKRjf5OusOzGx8evA/BP4IP11uN/grca5O0lcsPLJ5YjwI4QkJBOHa0WdMZYGxPbh2W2nR9v3WxEWqgp/G3+6VZbRLSAAZ3BhdhAaUL33VUSw9yjEsvbaQ9u4A/gGXwZXoEHOuU1GSj2chf+Mo+f8IcfcAxfIKVmyunRbYQVnoevwgfw3TXXcw++xNuP4fhyueEUNttEduRVaDttddoP0eSxLe2LENk6itYxlrxBNBYrNNKSQmeaLcm9c8UsaB5WyO6675yyQIAWSDpBVoA/gxmcwEvwoDv0m58UE7gHn+fJOa8/Ywan8EKRfjsopF83eCglX/Sfr7OeaRoQfvt1CGvIDccH5BCvw1sWIzRGC/66t0VTcLZQZtm6PlAasbOJ9iwWtUo7biktTSIPxnR24jxP1ZKaqq+2RcXM9OrBAm/AAs7hDJ5bNmGb+KIfwCs8a3jnjBrOFeMjHSCdbKr+2uOLfnOd9eiA8Hvvwwq54VbP2OqwkB48Ytc4YEOiH2vTXqodabfWEOzso4qxdbqD5L6tbtNPECqbhnA708DZH4QOJUXqScmUlks7Ot6FBuZw3n2mEbaUX7kDzxHOOQk8nKWMzAzu6ZZ8sOFw4RK+6PcuXo9tB4SbMz58ApfKDXf3szjNIIbGpD5TKTRxGkEMLjLl+K3wlWXBsCUxIDU+jbOiysESqAy1MGUJpXgwbTWzNOVEziIXZrJ+VIztl1PUBxTSo0dwn2bOmfDRPD3TRTGlfbCJvO9KvuhL1hMHhB9wPuPRLGHcdOWG2xc0U+5bQtAJT0nRTewXL1pgk2+rZAdeWmz3jxAqfNQQdzTlbF8uJ5ecEIWvTkevAHpwz7w78QujlD/Lr491bD8/1vhM2yrUQRrWXNQY4fGilfctMWYjL72UL/qS9eiA8EmN88nbNdour+PBbbAjOjIa4iBhfFg6rxeKdEGcL6p3EWR1Qq2Qkhs2DrnkRnmN9tG2EAqmgPw6hoL7Oza7B+3SCrR9tRftko+Lsf2F/mkTndN2LmzuMcKTuj/mX2+4Va3ki16+nnJY+S7MefpkidxwnV+4wkXH8TKnX0tsYzYp29DOOoSW1nf7nTh2akYiWmcJOuTidSaqESrTYpwjJJNVGQr+rLI7WsqerHW6Kp/oM2pKuV7T1QY9gjqlZp41/WfKpl56FV/0kvXQFRyeQ83xaTu5E8p5dNP3dUF34ihyI3GSpeCsywSh22ZJdWto9winhqifb7VRvgktxp13vyjrS0EjvrRfZ62uyqddSWaWYlwTPAtJZ2oZ3j/Sgi/mi+6vpzesfAcWNA0n8xVyw90GVFGuZjTXEQy+6GfLGLMLL523f5E0OmxVjDoOuRiH91RKU+vtoCtH7TgmvBLvtFXWLW15H9GTdVw8ow4IlRLeHECN9ym1e9K0I+Cbnhgv4Yu+aD2HaQJ80XDqOzSGAV4+4yCqBxrsJAX6ZTIoX36QnvzhhzzMfFW2dZVLOJfo0zbce5OvwXMFaZ81mOnlTVXpDZsQNuoYWveketKb5+6JOOsgX+NTm7H49fUTlx+WLuWL7qxnOFh4BxpmJx0p2gDzA/BUARuS6phR+pUsY7MMboAHx5xNsSVfVZcYSwqCKrqon7zM+8ecCkeS4nm3rINuaWvVNnMRI1IRpxTqx8PZUZ0Br/UEduo3B3hNvmgZfs9gQPj8vIOxd2kndir3awvJ6BLvoUuOfFWNYB0LR1OQJoUySKb9IlOBx74q1+ADC2G6rOdmFdJcD8BkfualA+BdjOOzP9uUhGUEX/TwhZsUduwRr8wNuXKurCixLBgpQI0mDbJr9dIqUuV+92ngkJZ7xduCk2yZKbfWrH1VBiTg9VdzsgRjW3CVXCvAwDd+c1z9dWw9+B+8MJL/eY15ZQ/HqvTwVdsZn5WQsgRRnMaWaecu3jFvMBEmgg+FJFZsnSl0zjB9OqPYaBD7qmoVyImFvzi41usesV0julaAR9dfR15Xzv9sEruRDyk1nb+QaLU67T885GTls6YgcY+UiMa25M/pwGrbCfzkvR3e0jjtuaFtnwuagHTSb5y7boBH119HXhvwP487jJLsLJ4XnUkHX5sLbS61dpiAXRoZSCrFJ+EjpeU3puVfitngYNo6PJrAigKktmwjyQdZpfq30mmtulaAx9Zfx15Xzv+cyeuiBFUs9zq8Kq+XB9a4PVvph3GV4E3y8HENJrN55H1X2p8VyqSKwVusJDKzXOZzplWdzBUFK9e+B4+uv468xvI/b5xtSAkBHQaPvtqWzllVvEOxPbuiE6+j2pvjcKsbvI7txnRErgfH7LdXqjq0IokKzga14GzQ23SSbCQvO6r+Or7SMIr/efOkkqSdMnj9mBx2DRsiY29Uj6+qK9ZrssCKaptR6HKURdwUYeUWA2kPzVKQO8ku2nU3Anhs/XWkBx3F/7wJtCTTTIKftthue1ty9xvNYLY/zo5KSbIuKbXpbEdSyeRyYdAIwKY2neyoc3+k1XUaufYga3T9daMUx/r8z1s10ITknIO0kuoMt+TB8jK0lpayqqjsJ2qtXAYwBU932zinimgmd6mTRDnQfr88q36NAI+tv24E8Pr8zxtasBqx0+xHH9HhlrwsxxNUfKOHQaZBITNf0uccj8GXiVmXAuPEAKSdN/4GLHhs/XWj92dN/uetNuBMnVR+XWDc25JLjo5Mg5IZIq226tmCsip2zZliL213YrTlL2hcFjpCduyim3M7/eB16q/blQsv5X/esDRbtJeabLIosWy3ycavwLhtxdWzbMmHiBTiVjJo6lCLjXZsi7p9PEPnsq6X6wd4bP11i0rD5fzPm/0A6brrIsllenZs0lCJlU4abakR59enZKrKe3BZihbTxlyZ2zl1+g0wvgmA166/bhwDrcn/7Ddz0eWZuJvfSESug6NzZsox3Z04FIxz0mUjMwVOOVTq1CQ0AhdbBGVdjG/CgsfUX7esJl3K/7ytWHRv683praW/8iDOCqWLLhpljDY1ZpzK75QiaZoOTpLKl60auHS/97oBXrv+umU9+FL+5+NtLFgjqVLCdbmj7pY5zPCPLOHNCwXGOcLquOhi8CmCWvbcuO73XmMUPab+ug3A6/A/78Bwe0bcS2+tgHn4J5pyS2WbOck0F51Vq3LcjhLvZ67p1ABbaL2H67bg78BfjKi/jr3+T/ABV3ilLmNXTI2SpvxWBtt6/Z//D0z/FXaGbSBgylzlsEGp+5//xrd4/ae4d8DUUjlslfIYS3t06HZpvfQtvv0N7AHWqtjP2pW08QD/FLy//da38vo8PNlKHf5y37Dxdfe/oj4kVIgFq3koLReSR76W/bx//n9k8jonZxzWTANVwEniDsg87sOSd/z7//PvMp3jQiptGVWFX2caezzAXwfgtzYUvbr0iozs32c3Uge7varH+CNE6cvEYmzbPZ9hMaYDdjK4V2iecf6EcEbdUDVUARda2KzO/JtCuDbNQB/iTeL0EG1JSO1jbXS+nLxtPMDPw1fh5+EPrgSEKE/8Gry5A73ui87AmxwdatyMEBCPNOCSKUeRZ2P6Myb5MRvgCHmA9ywsMifU+AYXcB6Xa5GibUC5TSyerxyh0j6QgLVpdyhfArRTTLqQjwe4HOD9s92D4Ap54odXAPBWLAwB02igG5Kkc+piN4lvODIFGAZgT+EO4Si1s7fjSR7vcQETUkRm9O+MXyo9OYhfe4xt9STQ2pcZRLayCV90b4D3jR0DYAfyxJ+eywg2IL7NTMXna7S/RpQ63JhWEM8U41ZyQGjwsVS0QBrEKLu8xwZsbi4wLcCT+OGidPIOCe1PiSc9Qt+go+vYqB7cG+B9d8cAD+WJPz0Am2gxXgU9IneOqDpAAXOsOltVuMzpdakJXrdPCzXiNVUpCeOos5cxnpQT39G+XVLhs1osQVvJKPZyNq8HDwd4d7pNDuWJPxVX7MSzqUDU6gfadKiNlUFTzLeFHHDlzO4kpa7aiKhBPGKwOqxsBAmYkOIpipyXcQSPlRTf+Tii0U3EJGaZsDER2qoB3h2hu0qe+NNwUooYU8y5mILbJe6OuX+2FTKy7bieTDAemaQyQ0CPthljSWO+xmFDIYiESjM5xKd6Ik5lvLq5GrQ3aCMLvmCA9wowLuWJb9xF59hVVP6O0CrBi3ZjZSNOvRy+I6klNVRJYRBaEzdN+imiUXQ8iVF8fsp+W4JXw7WISW7fDh7lptWkCwZ4d7QTXyBPfJMYK7SijjFppGnlIVJBJBYj7eUwtiP1IBXGI1XCsjNpbjENVpSAJ2hq2LTywEly3hUYazt31J8w2+aiLx3g3fohXixPfOMYm6zCGs9LVo9MoW3MCJE7R5u/WsOIjrqBoHUO0bJE9vxBpbhsd3+Nb4/vtPCZ4oZYCitNeYuC/8UDvDvy0qvkiW/cgqNqRyzqSZa/s0mqNGjtKOoTm14zZpUauiQgVfqtQiZjq7Q27JNaSK5ExRcrGCXO1FJYh6jR6CFqK7bZdQZ4t8g0rSlPfP1RdBtqaa9diqtzJkQ9duSryi2brQXbxDwbRUpFMBHjRj8+Nt7GDKgvph9okW7LX47gu0SpGnnFQ1S1lYldOsC7hYteR574ZuKs7Ei1lBsfdz7IZoxzzCVmmVqaSySzQbBVAWDek+N4jh9E/4VqZrJjPwiv9BC1XcvOWgO8275CVyBPvAtTVlDJfZkaZGU7NpqBogAj/xEHkeAuJihWYCxGN6e8+9JtSegFXF1TrhhLGP1fak3pebgPz192/8gB4d/6WT7+GdYnpH7hH/DJzzFiYPn/vjW0SgNpTNuPIZoAEZv8tlGw4+RLxy+ZjnKa5NdFoC7UaW0aduoYse6+bXg1DLg6UfRYwmhGEjqPvF75U558SANrElK/+MdpXvmqBpaXOa/MTZaa1DOcSiLaw9j0NNNst3c+63c7EKTpkvKHzu6bPbP0RkuHAVcbRY8ijP46MIbQeeT1mhA+5PV/inyDdQipf8LTvMXbwvoDy7IruDNVZKTfV4CTSRUYdybUCnGU7KUTDxLgCknqUm5aAW6/1p6eMsOYsphLzsHrE0Y/P5bQedx1F/4yPHnMB3/IOoTU9+BL8PhtjuFKBpZXnYNJxTuv+2XqolKR2UQgHhS5novuxVySJhBNRF3SoKK1XZbbXjVwWNyOjlqWJjrWJIy+P5bQedyldNScP+HZ61xKSK3jyrz+NiHG1hcOLL/+P+PDF2gOkekKGiNWKgJ+8Z/x8Iv4DdQHzcpZyF4v19I27w9/yPGDFQvmEpKtqv/TLiWMfn4sofMm9eAH8Ao0zzh7h4sJqYtxZd5/D7hkYPneDzl5idlzNHcIB0jVlQ+8ULzw/nc5/ojzl2juE0apD7LRnJxe04dMz2iOCFNtGFpTuXA5AhcTRo8mdN4kz30nVjEC4YTZQy4gpC7GlTlrePKhGsKKgeXpCYeO0MAd/GH7yKQUlXPLOasOH3FnSphjHuDvEu4gB8g66oNbtr6eMbFIA4fIBJkgayoXriw2XEDQPJrQeROAlY6aeYOcMf+IVYTU3XFlZufMHinGywaW3YLpObVBAsbjF4QJMsVUSayjk4voPsHJOQfPWDhCgDnmDl6XIRerD24HsGtw86RMHOLvVSHrKBdeVE26gKB5NKHzaIwLOmrqBWJYZDLhASG16c0Tn+CdRhWDgWXnqRZUTnPIHuMJTfLVpkoYy5CzylHVTGZMTwkGAo2HBlkQplrJX6U+uF1wZz2uwS1SQ12IqWaPuO4baZaEFBdukksJmkcTOm+YJSvoqPFzxFA/YUhIvWxcmSdPWTWwbAKVp6rxTtPFUZfKIwpzm4IoMfaYQLWgmlG5FME2gdBgm+J7J+rtS/XBbaVLsR7bpPQnpMFlo2doWaVceHk9+MkyguZNCJ1He+kuHTWyQAzNM5YSUg/GlTk9ZunAsg1qELVOhUSAK0LABIJHLKbqaEbHZLL1VA3VgqoiOKXYiS+HRyaEKgsfIqX64HYWbLRXy/qWoylIV9gudL1OWBNgBgTNmxA6b4txDT4gi3Ri7xFSLxtXpmmYnzAcWDZgY8d503LFogz5sbonDgkKcxGsWsE1OI+rcQtlgBBCSOKD1mtqYpIU8cTvBmAT0yZe+zUzeY92fYjTtGipXLhuR0ePoHk0ofNWBX+lo8Z7pAZDk8mEw5L7dVyZZoE/pTewbI6SNbiAL5xeygW4xPRuLCGbhcO4RIeTMFYHEJkYyEO9HmJfXMDEj/LaH781wHHZEtqSQ/69UnGpzH7LKIAZEDSPJnTesJTUa+rwTepI9dLJEawYV+ZkRn9g+QirD8vF8Mq0jFQ29js6kCS3E1+jZIhgPNanHdHFqFvPJLHqFwQqbIA4jhDxcNsOCCQLDomaL/dr5lyJaJU6FxPFjO3JOh3kVMcROo8u+C+jo05GjMF3P3/FuDLn5x2M04xXULPwaS6hBYki+MrMdZJSgPHlcB7nCR5bJ9Kr5ACUn9jk5kivdd8tk95SOGrtqu9lr2IhK65ZtEl7ZKrp7DrqwZfRUSN1el7+7NJxZbywOC8neNKTch5vsTEMNsoCCqHBCqIPRjIPkm0BjvFODGtto99rCl+d3wmHkW0FPdpZtC7MMcVtGFQjJLX5bdQ2+x9ypdc313uj8xlsrfuLgWXz1cRhZvJYX0iNVBRcVcmCXZs6aEf3RQF2WI/TcCbKmGU3IOoDJGDdDub0+hYckt6PlGu2BcxmhbTdj/klhccLGJMcqRjMJP1jW2ETqLSWJ/29MAoORluJ+6LPffBZbi5gqi5h6catQpmOT7/OFf5UorRpLzCqcMltBLhwd1are3kztrSzXO0LUbXRQcdLh/RdSZ+swRm819REDrtqzC4es6Gw4JCKlSnjYVpo0xeq33PrADbFLL3RuCmObVmPN+24kfa+AojDuM4umKe2QwCf6EN906HwjujaitDs5o0s1y+k3lgbT2W2i7FJdnwbLXhJUBq/9liTctSmFC/0OqUinb0QddTWamtjbHRFuWJJ6NpqZ8vO3fZJ37Db+2GkaPYLGHs7XTTdiFQJ68SkVJFVmY6McR5UycflNCsccHFaV9FNbR4NttLxw4pQ7wJd066Z0ohVbzihaxHVExd/ay04oxUKWt+AsdiQ9OUyZ2krzN19IZIwafSTFgIBnMV73ADj7V/K8u1MaY2sJp2HWm0f41tqwajEvdHWOJs510MaAqN4aoSiPCXtN2KSi46dUxHdaMquar82O1x5jqhDGvqmoE9LfxcY3zqA7/x3HA67r9ZG4O6Cuxu12/+TP+eLP+I+HErqDDCDVmBDO4larujNe7x8om2rMug0MX0rL1+IWwdwfR+p1TNTyNmVJ85ljWzbWuGv8/C7HD/izjkHNZNYlhZcUOKVzKFUxsxxN/kax+8zPWPSFKw80rJr9Tizyj3o1gEsdwgWGoxPezDdZ1TSENE1dLdNvuKL+I84nxKesZgxXVA1VA1OcL49dFlpFV5yJMhzyCmNQ+a4BqusPJ2bB+xo8V9u3x48VVIEPS/mc3DvAbXyoYr6VgDfh5do5hhHOCXMqBZUPhWYbWZECwVJljLgMUWOCB4MUuMaxGNUQDVI50TQ+S3kFgIcu2qKkNSHVoM0SHsgoZxP2d5HH8B9woOk4x5bPkKtAHucZsdykjxuIpbUrSILgrT8G7G5oCW+K0990o7E3T6AdW4TilH5kDjds+H64kS0mz24grtwlzDHBJqI8YJQExotPvoC4JBq0lEjjQkyBZ8oH2LnRsQ4Hu1QsgDTJbO8fQDnllitkxuVskoiKbRF9VwzMDvxHAdwB7mD9yCplhHFEyUWHx3WtwCbSMMTCUCcEmSGlg4gTXkHpZXWQ7kpznK3EmCHiXInqndkQjunG5kxTKEeGye7jWz9cyMR2mGiFQ15ENRBTbCp+Gh86vAyASdgmJq2MC6hoADQ3GosP0QHbnMHjyBQvQqfhy/BUbeHd5WY/G/9LK/8Ka8Jd7UFeNWEZvzPb458Dn8DGLOe3/wGL/4xP+HXlRt+M1PE2iLhR8t+lfgxsuh7AfO2AOf+owWhSZRYQbd622hbpKWKuU+XuvNzP0OseRDa+mObgDHJUSc/pKx31QdKffQ5OIJpt8GWjlgTwMc/w5MPCR/yl1XC2a2Yut54SvOtMev55Of45BOat9aWG27p2ZVORRvnEk1hqWMVUmqa7S2YtvlIpspuF1pt0syuZS2NV14mUidCSfzQzg+KqvIYCMljIx2YK2AO34fX4GWdu5xcIAb8MzTw+j/lyWM+Dw/gjs4GD6ehNgA48kX/AI7XXM/XAN4WHr+9ntywqoCakCqmKP0rmQrJJEErG2Upg1JObr01lKQy4jskWalKYfJ/EDLMpjNSHFEUAde2fltaDgmrNaWQ9+AAb8I5vKjz3L1n1LriB/BXkG/wwR9y/oRX4LlioHA4LzP2inzRx/DWmutRweFjeP3tNeSGlaE1Fde0OS11yOpmbIp2u/jF1n2RRZviJM0yBT3IZl2HWImKjQOxIyeU325b/qWyU9Moj1o07tS0G7qJDoGHg5m8yeCxMoEH8GU45tnrNM84D2l297DQ9t1YP7jki/7RmutRweEA77/HWXOh3HCxkRgldDQkAjNTMl2Iloc1qN5JfJeeTlyTRzxURTdn1Ixv2uKjs12AbdEWlBtmVdk2k7FFwj07PCZ9XAwW3dG+8xKzNFr4EnwBZpy9Qzhh3jDXebBpYcpuo4fQ44u+fD1dweEnHzI7v0xuuOALRUV8rXpFyfSTQYkhd7IHm07jpyhlkCmI0ALYqPTpUxXS+z4jgDj1Pflvmz5ecuItpIBxyTHpSTGWd9g1ApfD/bvwUhL4nT1EzqgX7cxfCcNmb3mPL/qi9SwTHJ49oj5ZLjccbTG3pRmlYi6JCG0mQrAt1+i2UXTZ2dv9IlQpN5naMYtviaXlTrFpoMsl3bOAFEa8sqPj2WCMrx3Yjx99qFwO59Aw/wgx+HlqNz8oZvA3exRDvuhL1jMQHPaOJ0+XyA3fp1OfM3qObEVdhxjvynxNMXQV4+GJyvOEFqeQBaIbbO7i63rpxCltdZShPFxkjM2FPVkn3TG+Rp9pO3l2RzFegGfxGDHIAh8SteR0C4HopXzRF61nheDw6TFN05Ebvq8M3VKKpGjjO6r7nhudTEGMtYM92HTDaR1FDMXJ1eThsbKfywyoWwrzRSXkc51flG3vIid62h29bIcFbTGhfV+faaB+ohj7dPN0C2e2lC96+XouFByen9AsunLDJZ9z7NExiUc0OuoYW6UZkIyx2YUR2z6/TiRjyKMx5GbbjLHvHuf7YmtKghf34LJfx63Yg8vrvN2zC7lY0x0tvKezo4HmGYDU+Gab6dFL+KI761lDcNifcjLrrr9LWZJctG1FfU1uwhoQE22ObjdfkSzY63CbU5hzs21WeTddH2BaL11Gi7lVdlxP1nkxqhnKhVY6knS3EPgVGg1JpN5cP/hivujOelhXcPj8HC/LyI6MkteVjlolBdMmF3a3DbsuAYhL44dxzthWSN065xxUd55Lmf0wRbOYOqH09/o9WbO2VtFdaMb4qBgtFJoT1SqoN8wPXMoXLb3p1PUEhxfnnLzGzBI0Ku7FxrKsNJj/8bn/H8fPIVOd3rfrklUB/DOeO+nkghgSPzrlPxluCMtOnDL4Yml6dK1r3vsgMxgtPOrMFUZbEUbTdIzii5beq72G4PD0DKnwjmBULUVFmy8t+k7fZ3pKc0Q4UC6jpVRqS9Umv8bxw35flZVOU1X7qkjnhZlsMbk24qQ6Hz7QcuL6sDC0iHHki96Uh2UdvmgZnjIvExy2TeJdMDZNSbdZyAHe/Yd1xsQhHiKzjh7GxQ4yqMPaywPkjMamvqrYpmO7Knad+ZQC5msCuAPWUoxrxVhrGv7a+KLXFhyONdTMrZ7ke23qiO40ZJUyzgYyX5XyL0mV7NiUzEs9mjtbMN0dERqwyAJpigad0B3/zRV7s4PIfXSu6YV/MK7+OrYe/JvfGMn/PHJe2fyUdtnFrKRNpXV0Y2559aWPt/G4BlvjTMtXlVIWCnNyA3YQBDmYIodFz41PvXPSa6rq9lWZawZ4dP115HXV/M/tnFkkrBOdzg6aP4pID+MZnTJ1SuuB6iZlyiox4HT2y3YBtkUKWooacBQUDTpjwaDt5poBHl1/HXltwP887lKKXxNUEyPqpGTyA699UqY/lt9yGdlUKra0fFWS+36iylVWrAyd7Uw0CZM0z7xKTOduznLIjG2Hx8cDPLb+OvK6Bv7n1DYci4CxUuRxrjBc0bb4vD3rN5Zz36ntLb83eVJIB8LiIzCmn6SMPjlX+yNlTjvIGjs+QzHPf60Aj62/jrzG8j9vYMFtm1VoRWCJdmw7z9N0t+c8cxZpPeK4aTRicS25QhrVtUp7U578chk4q04Wx4YoQSjFryUlpcQ1AbxZ/XVMknIU//OGl7Q6z9Zpxi0+3yFhSkjUDpnCIUhLWVX23KQ+L9vKvFKI0ZWFQgkDLvBoylrHNVmaw10zwCPrr5tlodfnf94EWnQ0lFRWy8pW9LbkLsyUVDc2NSTHGDtnD1uMtchjbCeb1mpxFP0YbcClhzdLu6lfO8Bj6q+bdT2sz/+8SZCV7VIxtt0DUn9L7r4cLYWDSXnseEpOGFuty0qbOVlS7NNzs5FOGJUqQpl2Q64/yBpZf90sxbE+//PGdZ02HSipCbmD6NItmQ4Lk5XUrGpDMkhbMm2ZVheNYV+VbUWTcv99+2NyX1VoafSuC+AN6q9bFIMv5X/eagNWXZxEa9JjlMwNWb00akGUkSoepp1/yRuuqHGbUn3UdBSTxBU6SEVklzWRUkPndVvw2PrrpjvxOvzPmwHc0hpmq82npi7GRro8dXp0KXnUQmhZbRL7NEVp1uuZmO45vuzKsHrktS3GLWXODVjw+vXXLYx4Hf7njRPd0i3aoAGX6W29GnaV5YdyDj9TFkakje7GHYzDoObfddHtOSpoi2SmzJHrB3hM/XUDDEbxP2/oosszcRlehWXUvzHv4TpBVktHqwenFo8uLVmy4DKLa5d3RtLrmrM3aMFr1183E4sewf+85VWeg1c5ag276NZrM9IJVNcmLEvDNaV62aq+14IAOGFsBt973Ra8Xv11YzXwNfmft7Jg2oS+XOyoC8/cwzi66Dhmgk38kUmP1CUiYWOX1bpD2zWXt2FCp7uq8703APAa9dfNdscR/M/bZLIyouVxqJfeWvG9Je+JVckHQ9+CI9NWxz+blX/KYYvO5n2tAP/vrlZ7+8/h9y+9qeB/Hnt967e5mevX10rALDWK//FaAT5MXdBXdP0C/BAes792c40H+AiAp1e1oH8HgH94g/Lttx1gp63op1eyoM/Bvw5/G/7xFbqJPcCXnmBiwDPb/YKO4FX4OjyCb289db2/Noqicw4i7N6TVtoz8tNwDH+8x/i6Ae7lmaQVENzJFb3Di/BFeAwz+Is9SjeQySpPqbLFlNmyz47z5a/AF+AYFvDmHqibSXTEzoT4Gc3OALaqAP4KPFUJ6n+1x+rGAM6Zd78bgJ0a8QN4GU614vxwD9e1Amy6CcskNrczLx1JIp6HE5UZD/DBHrFr2oNlgG4Odv226BodoryjGJ9q2T/AR3vQrsOCS0ctXZi3ruLlhpFDJYl4HmYtjQCP9rhdn4suySLKDt6wLcC52h8xPlcjju1fn+yhuw4LZsAGUuo2b4Fx2UwQu77uqRHXGtg92aN3tQCbFexc0uk93vhTXbct6y7MulLycoUljx8ngDMBg1tvJjAazpEmOtxlzclvj1vQf1Tx7QlPDpGpqgtdSKz/d9/hdy1vTfFHSmC9dGDZbLiezz7Ac801HirGZsWjydfZyPvHXL/Y8Mjzg8BxTZiuwKz4Eb8sBE9zznszmjvFwHKPIWUnwhqfVRcd4Ck0K6ate48m1oOfrX3/yOtvAsJ8zsPAM89sjnddmuLuDPjX9Bu/L7x7xpMzFk6nWtyQfPg278Gn4Aekz2ZgOmU9eJ37R14vwE/BL8G3aibCiWMWWDQ0ZtkPMnlcGeAu/Ag+8ZyecU5BPuy2ILD+sQqyZhAKmn7XZd+jIMTN9eBL7x95xVLSX4On8EcNlXDqmBlqS13jG4LpmGbkF/0CnOi3H8ETOIXzmnmtb0a16Tzxj1sUvQCBiXZGDtmB3KAefPH94xcUa/6vwRn80GOFyjEXFpba4A1e8KQfFF+259tx5XS4egYn8fQsLGrqGrHbztr+uByTahWuL1NUGbDpsnrwBfePPwHHIf9X4RnM4Z2ABWdxUBlqQ2PwhuDxoS0vvqB1JzS0P4h2nA/QgTrsJFn+Y3AOjs9JFC07CGWX1oNX3T/yHOzgDjwPn1PM3g9Jk9lZrMEpxnlPmBbjyo2+KFXRU52TJM/2ALcY57RUzjObbjqxVw++4P6RAOf58pcVsw9Daje3htriYrpDOonre3CudSe6bfkTEgHBHuDiyu5MCsc7BHhYDx7ePxLjqigXZsw+ijMHFhuwBmtoTPtOxOrTvYJDnC75dnUbhfwu/ZW9AgYd+peL68HD+0emKquiXHhWjJg/UrkJYzuiaL3E9aI/ytrCvAd4GcYZMCkSQxfUg3v3j8c4e90j5ZTPdvmJJGHnOCI2nHS8081X013pHuBlV1gB2MX1YNmWLHqqGN/TWmG0y6clJWthxNUl48q38Bi8vtMKyzzpFdSDhxZ5WBA5ZLt8Jv3895DduBlgbPYAj8C4B8hO68FDkoh5lydC4FiWvBOVqjYdqjiLv92t8yPDjrDaiHdUD15qkSURSGmXJwOMSxWAXYwr3zaAufJ66l+94vv3AO+vPcD7aw/w/toDvL/2AO+vPcD7aw/wHuD9tQd4f+0B3l97gPfXHuD9tQd4f+0B3l97gG8LwP8G/AL8O/A5OCq0Ys2KIdv/qOIXG/4mvFAMF16gZD+2Xvu/B8as5+8bfllWyg0zaNO5bfXj6vfhhwD86/Aq3NfRS9t9WPnhfnvCIw/CT8GLcFTMnpntdF/z9V+PWc/vWoIH+FL3Znv57PitcdGP4R/C34avw5fgRVUInCwbsn1yyA8C8zm/BH8NXoXnVE6wVPjdeCI38kX/3+Ct9dbz1pTmHFRu+Hm4O9Ch3clr99negxfwj+ER/DR8EV6B5+DuQOnTgUw5rnkY+FbNU3gNXh0o/JYTuWOvyBf9FvzX663HH/HejO8LwAl8Hl5YLTd8q7sqA3wbjuExfAFegQdwfyDoSkWY8swzEf6o4Qyewefg+cHNbqMQruSL/u/WWc+E5g7vnnEXgDmcDeSGb/F4cBcCgT+GGRzDU3hZYburAt9TEtHgbM6JoxJ+6NMzzTcf6c2bycv2+KK/f+l6LBzw5IwfqZJhA3M472pWT/ajKxnjv4AFnMEpnBTPND6s2J7qHbPAqcMK74T2mZ4VGB9uJA465It+/eL1WKhYOD7xHOkr1ajK7d0C4+ke4Hy9qXZwpgLr+Znm/uNFw8xQOSy8H9IzjUrd9+BIfenYaylf9FsXr8fBAadnPIEDna8IBcwlxnuA0/Wv6GAWPd7dDIKjMdSWueAsBj4M7TOd06qBbwDwKr7oleuxMOEcTuEZTHWvDYUO7aHqAe0Bbq+HEFRzOz7WVoTDQkVds7A4sIIxfCQdCefFRoIOF/NFL1mPab/nvOakSL/Q1aFtNpUb/nFOVX6gzyg/1nISyDfUhsokIzaBR9Kxm80s5mK+6P56il1jXic7nhQxsxSm3OwBHl4fFdLqi64nDQZvqE2at7cWAp/IVvrN6/BFL1mPhYrGMBfOi4PyjuSGf6wBBh7p/FZTghCNWGgMzlBbrNJoPJX2mW5mwZfyRffXo7OFi5pZcS4qZUrlViptrXtw+GQoyhDPS+ANjcGBNRiLCQDPZPMHuiZfdFpPSTcQwwKYdRNqpkjm7AFeeT0pJzALgo7g8YYGrMHS0iocy+YTm2vyRUvvpXCIpQ5pe666TJrcygnScUf/p0NDs/iAI/nqDHC8TmQT8x3NF91l76oDdQGwu61Z6E0ABv7uO1dbf/37Zlv+Zw/Pbh8f1s4Avur6657/+YYBvur6657/+YYBvur6657/+YYBvur6657/+aYBvuL6657/+VMA8FXWX/f8zzcN8BXXX/f8zzcNMFdbf93zP38KLPiK6697/uebtuArrr/u+Z9vGmCusP6653/+1FjwVdZf9/zPN7oHX339dc//fNMu+irrr3v+50+Bi+Zq6697/uebA/jz8Pudf9ht/fWv517J/XUzAP8C/BAeX9WCDrUpZ3/dEMBxgPcfbtTVvsYV5Yn32u03B3Ac4P3b8I+vxNBKeeL9dRMAlwO83959qGO78sT769oB7g3w/vGVYFzKE++v6wV4OMD7F7tckFkmT7y/rhHgpQO8b+4Y46XyxPvrugBeNcB7BRiX8sT767oAvmCA9woAHsoT76+rBJjLBnh3txOvkifeX1dswZcO8G6N7sXyxPvr6i340gHe3TnqVfLE++uKAb50gHcXLnrX8sR7gNdPRqwzwLu7Y/FO5Yn3AK9jXCMGeHdgxDuVJ75VAI8ljP7PAb3/RfjcZfePHBB+79dpfpH1CanN30d+mT1h9GqAxxJGM5LQeeQ1+Tb+EQJrElLb38VHQ94TRq900aMIo8cSOo+8Dp8QfsB8zpqE1NO3OI9Zrj1h9EV78PqE0WMJnUdeU6E+Jjyk/hbrEFIfeWbvId8H9oTRFwdZaxJGvziW0Hn0gqYB/wyZ0PwRlxJST+BOw9m77Amj14ii1yGM/txYQudN0qDzGe4EqfA/5GJCagsHcPaEPWH0esekSwmjRxM6b5JEcZ4ww50ilvAOFxBSx4yLW+A/YU8YvfY5+ALC6NGEzhtmyZoFZoarwBLeZxUhtY4rc3bKnjB6TKJjFUHzJoTOozF2YBpsjcyxDgzhQ1YRUse8+J4wenwmaylB82hC5w0zoRXUNXaRBmSMQUqiWSWkLsaVqc/ZE0aPTFUuJWgeTei8SfLZQeMxNaZSIzbII4aE1Nmr13P2hNHjc9E9guYNCZ032YlNwESMLcZiLQHkE4aE1BFg0yAR4z1h9AiAGRA0jyZ03tyIxWMajMPWBIsxYJCnlITU5ShiHYdZ94TR4wCmSxg9jtB5KyPGYzymAYexWEMwAPIsAdYdV6aObmNPGD0aYLoEzaMJnTc0Ygs+YDw0GAtqxBjkuP38bMRWCHn73xNGjz75P73WenCEJnhwyVe3AEe8TtKdJcYhBl97wuhNAObK66lvD/9J9NS75v17wuitAN5fe4D31x7g/bUHeH/tAd5fe4D3AO+vPcD7aw/w/toDvL/2AO+vPcD7aw/w/toDvAd4f/24ABzZ8o+KLsSLS+Pv/TqTb3P4hKlQrTGh+fbIBT0Axqznnb+L/V2mb3HkN5Mb/nEHeK7d4IcDld6lmDW/iH9E+AH1MdOw/Jlu2T1xNmY98sv4wHnD7D3uNHu54WUuOsBTbQuvBsPT/UfzNxGYzwkP8c+Yz3C+r/i6DcyRL/rZ+utRwWH5PmfvcvYEt9jLDS/bg0/B64DWKrQM8AL8FPwS9beQCe6EMKNZYJol37jBMy35otdaz0Bw2H/C2Smc7+WGB0HWDELBmOByA3r5QONo4V+DpzR/hFS4U8wMW1PXNB4TOqYz9urxRV++ntWCw/U59Ty9ebdWbrgfRS9AYKKN63ZokZVygr8GZ/gfIhZXIXPsAlNjPOLBby5c1eOLvmQ9lwkOy5x6QV1j5TYqpS05JtUgUHUp5toHGsVfn4NX4RnMCe+AxTpwmApTYxqMxwfCeJGjpXzRF61nbcHhUBPqWze9svwcHJ+S6NPscKrEjug78Dx8Lj3T8D4YxGIdxmJcwhi34fzZUr7olevZCw5vkOhoClq5zBPZAnygD/Tl9EzDh6kl3VhsHYcDEb+hCtJSvuiV69kLDm+WycrOTArHmB5/VYyP6jOVjwgGawk2zQOaTcc1L+aLXrKeveDwZqlKrw8U9Y1p66uK8dEzdYwBeUQAY7DbyYNezBfdWQ97weEtAKYQg2xJIkuveAT3dYeLGH+ShrWNwZgN0b2YL7qznr3g8JYAo5bQBziPjx7BPZ0d9RCQp4UZbnFdzBddor4XHN4KYMrB2qHFRIzzcLAHQZ5the5ovui94PCWAPefaYnxIdzRwdHCbuR4B+tbiy96Lzi8E4D7z7S0mEPd+eqO3cT53Z0Y8SV80XvB4Z0ADJi/f7X113f+7p7/+UYBvur6657/+YYBvur6657/+aYBvuL6657/+aYBvuL6657/+aYBvuL6657/+aYBvuL6657/+VMA8FXWX/f8z58OgK+y/rrnf75RgLna+uue//lTA/CV1V/3/M837aKvvv6653++UQvmauuve/7nTwfAV1N/3fM/fzr24Cuuv+75nz8FFnxl9dc9//MOr/8/glixwRuUfM4AAAAASUVORK5CYII="}getSearchTexture(){return"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEIAAAAhCAAAAABIXyLAAAAAOElEQVRIx2NgGAWjYBSMglEwEICREYRgFBZBqDCSLA2MGPUIVQETE9iNUAqLR5gIeoQKRgwXjwAAGn4AtaFeYLEAAAAASUVORK5CYII="}},t.SSAARenderPass=class extends Uf{constructor(t,e,n,r){super(),this.scene=t,this.camera=e,this.sampleLevel=4,this.unbiased=!0,this.clearColor=void 0!==n?n:0,this.clearAlpha=void 0!==r?r:0,this._oldClearColor=new Li,void 0===If&&console.error("THREE.SSAARenderPass relies on CopyShader");const i=If;this.copyUniforms=bs.clone(i.uniforms),this.copyMaterial=new _s({uniforms:this.copyUniforms,vertexShader:i.vertexShader,fragmentShader:i.fragmentShader,premultipliedAlpha:!0,transparent:!0,blending:S,depthTest:!1,depthWrite:!1}),this.fsQuad=new Bf(this.copyMaterial)}dispose(){this.sampleRenderTarget&&(this.sampleRenderTarget.dispose(),this.sampleRenderTarget=null)}setSize(t,e){this.sampleRenderTarget&&this.sampleRenderTarget.setSize(t,e)}render(t,e,n){this.sampleRenderTarget||(this.sampleRenderTarget=new ir(n.width,n.height,{minFilter:Mt,magFilter:Mt,format:Gt}),this.sampleRenderTarget.texture.name="SSAARenderPass.sample");const r=Yf[Math.max(0,Math.min(this.sampleLevel,5))],i=t.autoClear;t.autoClear=!1,t.getClearColor(this._oldClearColor);const s=t.getClearAlpha(),a=1/r.length;this.copyUniforms.tDiffuse.value=this.sampleRenderTarget.texture;const o={fullWidth:n.width,fullHeight:n.height,offsetX:0,offsetY:0,width:n.width,height:n.height},l=Object.assign({},this.camera.view);l.enabled&&Object.assign(o,l);for(let n=0;n<r.length;n++){const i=r[n];this.camera.setViewOffset&&this.camera.setViewOffset(o.fullWidth,o.fullHeight,o.offsetX+.0625*i[0],o.offsetY+.0625*i[1],o.width,o.height);let s=a;this.unbiased&&(s+=.03125*((n+.5)/r.length-.5)),this.copyUniforms.opacity.value=s,t.setClearColor(this.clearColor,this.clearAlpha),t.setRenderTarget(this.sampleRenderTarget),t.clear(),t.render(this.scene,this.camera),t.setRenderTarget(this.renderToScreen?null:e),0===n&&(t.setClearColor(0,0),t.clear()),this.fsQuad.render(t)}this.camera.setViewOffset&&l.enabled?this.camera.setViewOffset(l.fullWidth,l.fullHeight,l.offsetX,l.offsetY,l.width,l.height):this.camera.clearViewOffset&&this.camera.clearViewOffset(),t.autoClear=i,t.setClearColor(this._oldClearColor,s)}},t.GammaCorrectionShader={uniforms:{tDiffuse:{value:null}},vertexShader:"\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvUv = uv;\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t}",fragmentShader:"\n\n\t\tuniform sampler2D tDiffuse;\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvec4 tex = texture2D( tDiffuse, vUv );\n\n\t\t\tgl_FragColor = LinearTosRGB( tex );\n\n\t\t}"},t.SAOPass=$f,t.SobelOperatorShader=nm,t.SSRPass=cm,t.BokehPass=class extends Uf{constructor(t,e,n){super(),this.scene=t,this.camera=e;const r=void 0!==n.focus?n.focus:1,i=void 0!==n.aspect?n.aspect:e.aspect,s=void 0!==n.aperture?n.aperture:.025,a=void 0!==n.maxblur?n.maxblur:1,o=n.width||window.innerWidth||1,l=n.height||window.innerHeight||1;this.renderTargetDepth=new ir(o,l,{minFilter:xt,magFilter:xt}),this.renderTargetDepth.texture.name="BokehPass.depth",this.materialDepth=new pl,this.materialDepth.depthPacking=nn,this.materialDepth.blending=M,void 0===hm&&console.error("THREE.BokehPass relies on BokehShader");const c=hm,h=bs.clone(c.uniforms);h.tDepth.value=this.renderTargetDepth.texture,h.focus.value=r,h.aspect.value=i,h.aperture.value=s,h.maxblur.value=a,h.nearClip.value=e.near,h.farClip.value=e.far,this.materialBokeh=new _s({defines:Object.assign({},c.defines),uniforms:h,vertexShader:c.vertexShader,fragmentShader:c.fragmentShader}),this.uniforms=h,this.needsSwap=!1,this.fsQuad=new Bf(this.materialBokeh),this._oldClearColor=new Li}render(t,e,n){this.scene.overrideMaterial=this.materialDepth,t.getClearColor(this._oldClearColor);const r=t.getClearAlpha(),i=t.autoClear;t.autoClear=!1,t.setClearColor(16777215),t.setClearAlpha(1),t.setRenderTarget(this.renderTargetDepth),t.clear(),t.render(this.scene,this.camera),this.uniforms.tColor.value=n.texture,this.uniforms.nearClip.value=this.camera.near,this.uniforms.farClip.value=this.camera.far,this.renderToScreen?(t.setRenderTarget(null),this.fsQuad.render(t)):(t.setRenderTarget(e),t.clear(),this.fsQuad.render(t)),this.scene.overrideMaterial=null,t.setClearColor(this._oldClearColor),t.setClearAlpha(r),t.autoClear=i}},t.CSM=class{constructor(t){t=t||{},this.camera=t.camera,this.parent=t.parent,this.cascades=t.cascades||3,this.maxFar=t.maxFar||1e5,this.mode=t.mode||"practical",this.shadowMapSize=t.shadowMapSize||2048,this.shadowBias=t.shadowBias||1e-6,this.lightDirection=t.lightDirection||new lr(1,-1,1).normalize(),this.lightIntensity=t.lightIntensity||1,this.lightNear=t.lightNear||1,this.lightFar=t.lightFar||2e3,this.lightMargin=t.lightMargin||200,this.customSplitsCallback=t.customSplitsCallback,this.fade=!1,this.mainFrustum=new dm,this.frustums=[],this.breaks=[],this.lights=[],this.shaders=new Map,this.createLights(),this.updateFrustums(),this.injectInclude()}createLights(){for(let t=0;t<this.cascades;t++){const t=new nd(16777215,this.lightIntensity);t.castShadow=!0,t.shadow.mapSize.width=this.shadowMapSize,t.shadow.mapSize.height=this.shadowMapSize,t.shadow.camera.near=this.lightNear,t.shadow.camera.far=this.lightFar,t.shadow.bias=this.shadowBias,this.parent.add(t),this.parent.add(t.target),this.lights.push(t)}}initCascades(){const t=this.camera;t.updateProjectionMatrix(),this.mainFrustum.setFromProjectionMatrix(t.projectionMatrix,this.maxFar),this.mainFrustum.split(this.breaks,this.frustums)}updateShadowBounds(){const t=this.frustums;for(let e=0;e<t.length;e++){const t=this.lights[e].shadow.camera,n=this.frustums[e],r=n.vertices.near,i=n.vertices.far,s=i[0];let a;a=s.distanceTo(i[2])>s.distanceTo(r[2])?i[2]:r[2];let o=s.distanceTo(a);if(this.fade){const t=this.camera,e=Math.max(t.far,this.maxFar),r=n.vertices.far[0].z/(e-t.near);o+=.25*Math.pow(r,2)*(e-t.near)}t.left=-o/2,t.right=o/2,t.top=o/2,t.bottom=-o/2,t.updateProjectionMatrix()}}getBreaks(){const t=this.camera,e=Math.min(t.far,this.maxFar);switch(this.breaks.length=0,this.mode){case"uniform":n(this.cascades,t.near,e,this.breaks);break;case"logarithmic":r(this.cascades,t.near,e,this.breaks);break;case"practical":!function(t,e,i,s,a){xm.length=0,ym.length=0,r(t,e,i,ym),n(t,e,i,xm);for(let e=1;e<t;e++)a.push(Xn.lerp(xm[e-1],ym[e-1],.5));a.push(1)}(this.cascades,t.near,e,0,this.breaks);break;case"custom":void 0===this.customSplitsCallback&&console.error("CSM: Custom split scheme callback not defined."),this.customSplitsCallback(this.cascades,t.near,e,this.breaks)}function n(t,e,n,r){for(let i=1;i<t;i++)r.push((e+(n-e)*i/t)/n);r.push(1)}function r(t,e,n,r){for(let i=1;i<t;i++)r.push(e*(n/e)**(i/t)/n);r.push(1)}}update(){const t=this.camera,e=this.frustums;for(let n=0;n<e.length;n++){const r=this.lights[n],i=r.shadow.camera,s=(i.right-i.left)/this.shadowMapSize,a=(i.top-i.bottom)/this.shadowMapSize;r.shadow.camera.updateMatrixWorld(!0),fm.multiplyMatrices(r.shadow.camera.matrixWorldInverse,t.matrixWorld),e[n].toSpace(fm,mm);const o=mm.vertices.near,l=mm.vertices.far;vm.makeEmpty();for(let t=0;t<4;t++)vm.expandByPoint(o[t]),vm.expandByPoint(l[t]);vm.getCenter(gm),gm.z=vm.max.z+this.lightMargin,gm.x=Math.floor(gm.x/s)*s,gm.y=Math.floor(gm.y/a)*a,gm.applyMatrix4(r.shadow.camera.matrixWorld),r.position.copy(gm),r.target.position.copy(gm),r.target.position.x+=this.lightDirection.x,r.target.position.y+=this.lightDirection.y,r.target.position.z+=this.lightDirection.z}}injectInclude(){zs.lights_fragment_begin=pm.lights_fragment_begin,zs.lights_pars_begin=pm.lights_pars_begin}setupMaterial(t){t.defines=t.defines||{},t.defines.USE_CSM=1,t.defines.CSM_CASCADES=this.cascades,this.fade&&(t.defines.CSM_FADE="");const e=[],n=this,r=this.shaders;t.onBeforeCompile=function(i){const s=Math.min(n.camera.far,n.maxFar);n.getExtendedBreaks(e),i.uniforms.CSM_cascades={value:e},i.uniforms.cameraNear={value:n.camera.near},i.uniforms.shadowFar={value:s},r.set(t,i)},r.set(t,null)}updateUniforms(){const t=Math.min(this.camera.far,this.maxFar);this.shaders.forEach((function(e,n){if(null!==e){const n=e.uniforms;this.getExtendedBreaks(n.CSM_cascades.value),n.cameraNear.value=this.camera.near,n.shadowFar.value=t}!this.fade&&"CSM_FADE"in n.defines?(delete n.defines.CSM_FADE,n.needsUpdate=!0):this.fade&&!("CSM_FADE"in n.defines)&&(n.defines.CSM_FADE="",n.needsUpdate=!0)}),this)}getExtendedBreaks(t){for(;t.length<this.breaks.length;)t.push(new jn);t.length=this.breaks.length;for(let e=0;e<this.cascades;e++){const n=this.breaks[e],r=this.breaks[e-1]||0;t[e].x=r,t[e].y=n}}updateFrustums(){this.getBreaks(),this.initCascades(),this.updateShadowBounds(),this.updateUniforms()}remove(){for(let t=0;t<this.lights.length;t++)this.parent.remove(this.lights[t])}dispose(){const t=this.shaders;t.forEach((function(t,e){delete e.onBeforeCompile,delete e.defines.USE_CSM,delete e.defines.CSM_CASCADES,delete e.defines.CSM_FADE,null!==t&&(delete t.uniforms.CSM_cascades,delete t.uniforms.cameraNear,delete t.uniforms.shadowFar),e.needsUpdate=!0})),t.clear()}},t.GLTFLoader=Mm,t.GLTFExporter=hg,t.OBJExporter=class{parse(t){let e="",n=0,r=0,i=0;const s=new lr,a=new Li,o=new lr,l=new jn,c=[];return t.traverse((function(t){!0===t.isMesh&&function(t){let a=0,h=0,u=0;const d=t.geometry,p=new Yn;if(!0!==d.isBufferGeometry)throw new Error("THREE.OBJExporter: Geometry is not of type THREE.BufferGeometry.");const f=d.getAttribute("position"),m=d.getAttribute("normal"),g=d.getAttribute("uv"),v=d.getIndex();if(e+="o "+t.name+"\n",t.material&&t.material.name&&(e+="usemtl "+t.material.name+"\n"),void 0!==f)for(let n=0,r=f.count;n<r;n++,a++)s.x=f.getX(n),s.y=f.getY(n),s.z=f.getZ(n),s.applyMatrix4(t.matrixWorld),e+="v "+s.x+" "+s.y+" "+s.z+"\n";if(void 0!==g)for(let t=0,n=g.count;t<n;t++,u++)l.x=g.getX(t),l.y=g.getY(t),e+="vt "+l.x+" "+l.y+"\n";if(void 0!==m){p.getNormalMatrix(t.matrixWorld);for(let t=0,n=m.count;t<n;t++,h++)o.x=m.getX(t),o.y=m.getY(t),o.z=m.getZ(t),o.applyMatrix3(p).normalize(),e+="vn "+o.x+" "+o.y+" "+o.z+"\n"}if(null!==v)for(let t=0,s=v.count;t<s;t+=3){for(let e=0;e<3;e++){const s=v.getX(t+e)+1;c[e]=n+s+(m||g?"/"+(g?r+s:"")+(m?"/"+(i+s):""):"")}e+="f "+c.join(" ")+"\n"}else for(let t=0,s=f.count;t<s;t+=3){for(let e=0;e<3;e++){const s=t+e+1;c[e]=n+s+(m||g?"/"+(g?r+s:"")+(m?"/"+(i+s):""):"")}e+="f "+c.join(" ")+"\n"}n+=a,r+=u,i+=h}(t),!0===t.isLine&&function(t){let r=0;const i=t.geometry,a=t.type;if(!0!==i.isBufferGeometry)throw new Error("THREE.OBJExporter: Geometry is not of type THREE.BufferGeometry.");const o=i.getAttribute("position");if(e+="o "+t.name+"\n",void 0!==o)for(let n=0,i=o.count;n<i;n++,r++)s.x=o.getX(n),s.y=o.getY(n),s.z=o.getZ(n),s.applyMatrix4(t.matrixWorld),e+="v "+s.x+" "+s.y+" "+s.z+"\n";if("Line"===a){e+="l ";for(let t=1,r=o.count;t<=r;t++)e+=n+t+" ";e+="\n"}if("LineSegments"===a)for(let t=1,r=t+1,i=o.count;t<i;t+=2,r=t+1)e+="l "+(n+t)+" "+(n+r)+"\n";n+=r}(t),!0===t.isPoints&&function(t){let r=0;const i=t.geometry;if(!0!==i.isBufferGeometry)throw new Error("THREE.OBJExporter: Geometry is not of type THREE.BufferGeometry.");const o=i.getAttribute("position"),l=i.getAttribute("color");if(e+="o "+t.name+"\n",void 0!==o)for(let n=0,i=o.count;n<i;n++,r++)s.fromBufferAttribute(o,n),s.applyMatrix4(t.matrixWorld),e+="v "+s.x+" "+s.y+" "+s.z,void 0!==l&&(a.fromBufferAttribute(l,n),e+=" "+a.r+" "+a.g+" "+a.b),e+="\n";e+="p ";for(let t=1,r=o.count;t<=r;t++)e+=n+t+" ";e+="\n",n+=r}(t)})),e}},t.DRACOLoader=class extends Du{constructor(t){super(t),this.decoderPath="",this.decoderConfig={},this.decoderBinary=null,this.decoderPending=null,this.workerLimit=4,this.workerPool=[],this.workerNextTaskID=1,this.workerSourceURL="",this.defaultAttributeIDs={position:"POSITION",normal:"NORMAL",color:"COLOR",uv:"TEX_COORD"},this.defaultAttributeTypes={position:"Float32Array",normal:"Float32Array",color:"Float32Array",uv:"Float32Array"}}setDecoderPath(t){return this.decoderPath=t,this}setDecoderConfig(t){return this.decoderConfig=t,this}setWorkerLimit(t){return this.workerLimit=t,this}load(t,e,n,r){const i=new Uu(this.manager);i.setPath(this.path),i.setResponseType("arraybuffer"),i.setRequestHeader(this.requestHeader),i.setWithCredentials(this.withCredentials),i.load(t,(t=>{const n={attributeIDs:this.defaultAttributeIDs,attributeTypes:this.defaultAttributeTypes,useUniqueIDs:!1};this.decodeGeometry(t,n).then(e).catch(r)}),n,r)}decodeDracoFile(t,e,n,r){const i={attributeIDs:n||this.defaultAttributeIDs,attributeTypes:r||this.defaultAttributeTypes,useUniqueIDs:!!n};this.decodeGeometry(t,i).then(e)}decodeGeometry(t,e){for(const t in e.attributeTypes){const n=e.attributeTypes[t];void 0!==n.BYTES_PER_ELEMENT&&(e.attributeTypes[t]=n.name)}const n=JSON.stringify(e);if(Ag.has(t)){const e=Ag.get(t);if(e.key===n)return e.promise;if(0===t.byteLength)throw new Error("THREE.DRACOLoader: Unable to re-decode a buffer with different settings. Buffer has already been transferred.")}let r;const i=this.workerNextTaskID++,s=t.byteLength,a=this._getWorker(i,s).then((n=>(r=n,new Promise(((n,s)=>{r._callbacks[i]={resolve:n,reject:s},r.postMessage({type:"decode",id:i,taskConfig:e,buffer:t},[t])}))))).then((t=>this._createGeometry(t.geometry)));return a.catch((()=>!0)).then((()=>{r&&i&&this._releaseTask(r,i)})),Ag.set(t,{key:n,promise:a}),a}_createGeometry(t){const e=new Ki;t.index&&e.setIndex(new Ii(t.index.array,1));for(let n=0;n<t.attributes.length;n++){const r=t.attributes[n],i=r.name,s=r.array,a=r.itemSize;e.setAttribute(i,new Ii(s,a))}return e}_loadLibrary(t,e){const n=new Uu(this.manager);return n.setPath(this.decoderPath),n.setResponseType(e),n.setWithCredentials(this.withCredentials),new Promise(((e,r)=>{n.load(t,e,void 0,r)}))}preload(){return this._initDecoder(),this}_initDecoder(){if(this.decoderPending)return this.decoderPending;const t="object"!=typeof WebAssembly||"js"===this.decoderConfig.type,e=[];return t?e.push(this._loadLibrary("draco_decoder.js","text")):(e.push(this._loadLibrary("draco_wasm_wrapper.js","text")),e.push(this._loadLibrary("draco_decoder.wasm","arraybuffer"))),this.decoderPending=Promise.all(e).then((e=>{const n=e[0];t||(this.decoderConfig.wasmBinary=e[1]);const r=Eg.toString(),i=["/* draco decoder */",n,"","/* worker */",r.substring(r.indexOf("{")+1,r.lastIndexOf("}"))].join("\n");this.workerSourceURL=URL.createObjectURL(new Blob([i]))})),this.decoderPending}_getWorker(t,e){return this._initDecoder().then((()=>{if(this.workerPool.length<this.workerLimit){const t=new Worker(this.workerSourceURL);t._callbacks={},t._taskCosts={},t._taskLoad=0,t.postMessage({type:"init",decoderConfig:this.decoderConfig}),t.onmessage=function(e){const n=e.data;switch(n.type){case"decode":t._callbacks[n.id].resolve(n);break;case"error":t._callbacks[n.id].reject(n);break;default:console.error('THREE.DRACOLoader: Unexpected message, "'+n.type+'"')}},this.workerPool.push(t)}else this.workerPool.sort((function(t,e){return t._taskLoad>e._taskLoad?-1:1}));const n=this.workerPool[this.workerPool.length-1];return n._taskCosts[t]=e,n._taskLoad+=e,n}))}_releaseTask(t,e){t._taskLoad-=t._taskCosts[e],delete t._callbacks[e],delete t._taskCosts[e]}debug(){console.log("Task load: ",this.workerPool.map((t=>t._taskLoad)))}dispose(){for(let t=0;t<this.workerPool.length;++t)this.workerPool[t].terminate();return this.workerPool.length=0,this}},t.BasisTextureLoader=wy,t.KTX2Loader=Ty,t.USDZExporter=class{async parse(t){const e={"model.usda":null};let n='#usda 1.0\n(\n    customLayerData = {\n        string creator = "Three.js USDZExporter"\n    }\n    metersPerUnit = 1\n    upAxis = "Y"\n)\n\n';const r={},i={};t.traverseVisible((t=>{if(t.isMesh)if(t.material.isMeshStandardMaterial){const i=t.geometry,s=t.material,a="geometries/Geometry_"+i.id+".usd";if(!(a in e)){const t=function(t){return`\ndef "Geometry"\n{\n  ${function(t){const e=t.attributes,n=e.position.count;return`\n    def Mesh "Geometry"\n    {\n        int[] faceVertexCounts = [${function(t){const e=null!==t.index?t.index.count:t.attributes.position.count;return Array(e/3).fill(3).join(", ")}(t)}]\n        int[] faceVertexIndices = [${function(t){const e=t.index,n=[];if(null!==e)for(let t=0;t<e.count;t++)n.push(e.getX(t));else{const e=t.attributes.position.count;for(let t=0;t<e;t++)n.push(t)}return n.join(", ")}(t)}]\n        normal3f[] normals = [${Jx(e.normal,n)}] (\n            interpolation = "vertex"\n        )\n        point3f[] points = [${Jx(e.position,n)}]\n        float2[] primvars:st = [${function(t,e){if(void 0===t)return console.warn("USDZExporter: UVs missing."),Array(e).fill("(0, 0)").join(", ");const n=[];for(let e=0;e<t.count;e++){const r=t.getX(e),i=t.getY(e);n.push(`(${r.toPrecision(7)}, ${1-i.toPrecision(7)})`)}return n.join(", ")}(e.uv,n)}] (\n            interpolation = "vertex"\n        )\n        uniform token subdivisionScheme = "none"\n    }\n`}(t)}\n}\n`}(i);e[a]=function(t){let e='#usda 1.0\n(\n    customLayerData = {\n        string creator = "Three.js USDZExporter"\n    }\n    metersPerUnit = 1\n    upAxis = "Y"\n)\n\n';return e+=t,Cx(e)}(t)}s.uuid in r||(r[s.uuid]=s),n+=function(t,e,n){const r="Object_"+t.id,i=function(t){const e=t.elements;return`( ${Zx(e,0)}, ${Zx(e,4)}, ${Zx(e,8)}, ${Zx(e,12)} )`}(t.matrixWorld);return t.matrixWorld.determinant()<0&&console.warn("THREE.USDZExporter: USDZ does not support negative scales",t),`def Xform "${r}" (\n    prepend references = @./geometries/Geometry_${e.id}.usd@</Geometry>\n)\n{\n    matrix4d xformOp:transform = ${i}\n    uniform token[] xformOpOrder = ["xformOp:transform"]\n\n    rel material:binding = </Materials/Material_${n.id}>\n}\n\n`}(t,i,s)}else console.warn("THREE.USDZExporter: Unsupported material type (USDZ only supports MeshStandardMaterial)",t)})),n+=function(t,e){const n=[];for(const r in t){const i=t[r];n.push(Kx(i,e))}return`def "Materials"\n{\n${n.join("")}\n}\n\n`}(r,i),e["model.usda"]=Cx(n),n=null;for(const t in i){const n=i[t],r=t.split("_")[1],s=1023===n.format,a=Qx(n.image,r),o=await new Promise((t=>a.toBlob(t,s?"image/png":"image/jpeg",1)));e[`textures/Texture_${t}.${s?"png":"jpg"}`]=new Uint8Array(await o.arrayBuffer())}let s=0;for(const t in e){const n=e[t];s+=34+t.length;const r=63&s;if(4!==r){const i=new Uint8Array(64-r);e[t]=[n,{extra:{12345:i}}]}s=n.length}return Gx(e,{level:0})}},t.ConvexGeometry=class extends Ki{constructor(t){super();const e=[],n=[];void 0===ay&&console.error("THREE.ConvexBufferGeometry: ConvexBufferGeometry relies on ConvexHull");const r=(new ay).setFromPoints(t).faces;for(let t=0;t<r.length;t++){const i=r[t];let s=i.edge;do{const t=s.head().point;e.push(t.x,t.y,t.z),n.push(i.normal.x,i.normal.y,i.normal.z),s=s.next}while(s!==i.edge)}this.setAttribute("position",new Vi(e,3)),this.setAttribute("normal",new Vi(n,3))}},t.BufferGeometryUtils=r.BufferGeometryUtils,t.GeometryUtils=i.GeometryUtils,t.UnrealBloomPass=em,t.RGBELoader=class extends ku{constructor(t){super(t),this.type=Ut}parse(t){const e=function(t,e){switch(t){case 1:console.error("THREE.RGBELoader Read Error: "+(e||""));break;case 2:console.error("THREE.RGBELoader Write Error: "+(e||""));break;case 3:console.error("THREE.RGBELoader Bad File Format: "+(e||""));break;default:console.error("THREE.RGBELoader: Error: "+(e||""))}return-1},n=function(t,e,n){e=e||1024;let r=t.pos,i=-1,s=0,a="",o=String.fromCharCode.apply(null,new Uint16Array(t.subarray(r,r+128)));for(;0>(i=o.indexOf("\n"))&&s<e&&r<t.byteLength;)a+=o,s+=o.length,r+=128,o+=String.fromCharCode.apply(null,new Uint16Array(t.subarray(r,r+128)));return-1<i&&(!1!==n&&(t.pos+=s+i+1),a+o.slice(0,i))},r=function(t,e,n,r){const i=t[e+3],s=Math.pow(2,i-128)/255;n[r+0]=t[e+0]*s,n[r+1]=t[e+1]*s,n[r+2]=t[e+2]*s},i=function(t,e,n,r){const i=t[e+3],s=Math.pow(2,i-128)/255;n[r+0]=jp.toHalfFloat(Math.min(t[e+0]*s,65504)),n[r+1]=jp.toHalfFloat(Math.min(t[e+1]*s,65504)),n[r+2]=jp.toHalfFloat(Math.min(t[e+2]*s,65504))},s=new Uint8Array(t);s.pos=0;const a=function(t){const r=/^\s*GAMMA\s*=\s*(\d+(\.\d+)?)\s*$/,i=/^\s*EXPOSURE\s*=\s*(\d+(\.\d+)?)\s*$/,s=/^\s*FORMAT=(\S+)\s*$/,a=/^\s*\-Y\s+(\d+)\s+\+X\s+(\d+)\s*$/,o={valid:0,string:"",comments:"",programtype:"RGBE",format:"",gamma:1,exposure:1,width:0,height:0};let l,c;if(t.pos>=t.byteLength||!(l=n(t)))return e(1,"no header found");if(!(c=l.match(/^#\?(\S+)/)))return e(3,"bad initial token");for(o.valid|=1,o.programtype=c[1],o.string+=l+"\n";l=n(t),!1!==l;)if(o.string+=l+"\n","#"!==l.charAt(0)){if((c=l.match(r))&&(o.gamma=parseFloat(c[1],10)),(c=l.match(i))&&(o.exposure=parseFloat(c[1],10)),(c=l.match(s))&&(o.valid|=2,o.format=c[1]),(c=l.match(a))&&(o.valid|=4,o.height=parseInt(c[1],10),o.width=parseInt(c[2],10)),2&o.valid&&4&o.valid)break}else o.comments+=l+"\n";return 2&o.valid?4&o.valid?o:e(3,"missing image size specifier"):e(3,"missing format specifier")}(s);if(-1!==a){const t=a.width,n=a.height,o=function(t,n,r){const i=n;if(i<8||i>32767||2!==t[0]||2!==t[1]||128&t[2])return new Uint8Array(t);if(i!==(t[2]<<8|t[3]))return e(3,"wrong scanline width");const s=new Uint8Array(4*n*r);if(!s.length)return e(4,"unable to allocate buffer space");let a=0,o=0;const l=4*i,c=new Uint8Array(4),h=new Uint8Array(l);let u=r;for(;u>0&&o<t.byteLength;){if(o+4>t.byteLength)return e(1);if(c[0]=t[o++],c[1]=t[o++],c[2]=t[o++],c[3]=t[o++],2!=c[0]||2!=c[1]||(c[2]<<8|c[3])!=i)return e(3,"bad rgbe scanline format");let n,r=0;for(;r<l&&o<t.byteLength;){n=t[o++];const i=n>128;if(i&&(n-=128),0===n||r+n>l)return e(3,"bad scanline data");if(i){const e=t[o++];for(let t=0;t<n;t++)h[r++]=e}else h.set(t.subarray(o,o+n),r),r+=n,o+=n}const d=i;for(let t=0;t<d;t++){let e=0;s[a]=h[t+e],e+=i,s[a+1]=h[t+e],e+=i,s[a+2]=h[t+e],e+=i,s[a+3]=h[t+e],a+=4}u--}return s}(s.subarray(s.pos),t,n);if(-1!==o){let e,s,l,c;switch(this.type){case It:c=o.length/4;const t=new Float32Array(3*c);for(let e=0;e<c;e++)r(o,4*e,t,3*e);e=t,s=Ht,l=It;break;case Ut:c=o.length/4;const n=new Uint16Array(3*c);for(let t=0;t<c;t++)i(o,4*t,n,3*t);e=n,s=Ht,l=Ut;break;default:console.error("THREE.RGBELoader: unsupported type: ",this.type)}return{width:t,height:n,data:e,header:a.string,gamma:a.gamma,exposure:a.exposure,format:s,type:l}}}return null}setDataType(t){return this.type=t,this}load(t,e,n,r){return super.load(t,(function(t,n){switch(t.type){case It:case Ut:t.encoding=$e,t.minFilter=Mt,t.magFilter=Mt,t.generateMipmaps=!1,t.flipY=!0}e&&e(t,n)}),n,r)}},t.EXRLoader=class extends ku{constructor(t){super(t),this.type=Ut}parse(t){const n=65536,r=14,i=65537,s=Math.pow(2.7182818,2.2),a={l:0,c:0,lc:0};function o(t,e,n,r,i){for(;n<t;)e=e<<8|B(r,i),n+=8;n-=t,a.l=e>>n&(1<<t)-1,a.c=e,a.lc=n}const l=new Array(59);function c(t){return 63&t}function h(t){return t>>6}const u={c:0,lc:0};function d(t,e,n,r){t=t<<8|B(n,r),e+=8,u.c=t,u.lc=e}const p={c:0,lc:0};function f(t,e,n,r,i,s,a,o,l,c){if(t==e){r<8&&(d(n,r,i,a),n=u.c,r=u.lc);var h=n>>(r-=8);if(h=new Uint8Array([h])[0],l.value+h>c)return!1;for(var f=o[l.value-1];h-- >0;)o[l.value++]=f}else{if(!(l.value<c))return!1;o[l.value++]=t}p.c=n,p.lc=r}function m(t){return 65535&t}function g(t){var e=m(t);return e>32767?e-65536:e}const v={a:0,b:0};function x(t,e){var n=g(t),r=g(e),i=n+(1&r)+(r>>1),s=i,a=i-r;v.a=s,v.b=a}function y(t,e){var n=m(t),r=m(e),i=n-(r>>1)&65535,s=r+i-32768&65535;v.a=s,v.b=i}function w(t,e,n,r,i,s,a){for(var o,l=a<16384,c=n>i?i:n,h=1;h<=c;)h<<=1;for(o=h>>=1,h>>=1;h>=1;){for(var u,d,p,f,m=0,g=m+s*(i-o),w=s*h,b=s*o,_=r*h,M=r*o;m<=g;m+=b){for(var T=m,S=m+r*(n-o);T<=S;T+=M){var A=T+_,E=(C=T+w)+_;l?(x(t[T+e],t[C+e]),u=v.a,p=v.b,x(t[A+e],t[E+e]),d=v.a,f=v.b,x(u,d),t[T+e]=v.a,t[A+e]=v.b,x(p,f),t[C+e]=v.a,t[E+e]=v.b):(y(t[T+e],t[C+e]),u=v.a,p=v.b,y(t[A+e],t[E+e]),d=v.a,f=v.b,y(u,d),t[T+e]=v.a,t[A+e]=v.b,y(p,f),t[C+e]=v.a,t[E+e]=v.b)}if(n&h){var C=T+w;l?x(t[T+e],t[C+e]):y(t[T+e],t[C+e]),u=v.a,t[C+e]=v.b,t[T+e]=u}}if(i&h)for(T=m,S=m+r*(n-o);T<=S;T+=M)A=T+_,l?x(t[T+e],t[A+e]):y(t[T+e],t[A+e]),u=v.a,t[A+e]=v.b,t[T+e]=u;o=h,h>>=1}return m}function b(t,e,n,s,m,g){var v=n.value,x=O(e,n),y=O(e,n);n.value+=4;var w=O(e,n);if(n.value+=4,x<0||x>=i||y<0||y>=i)throw"Something wrong with HUF_ENCSIZE";var b=new Array(i),_=new Array(16384);if(function(t){for(var e=0;e<16384;e++)t[e]={},t[e].len=0,t[e].lit=0,t[e].p=null}(_),function(t,e,n,r,s,c,h){for(var u=n,d=0,p=0;s<=c;s++){if(u.value-n.value>r)return!1;o(6,d,p,t,u);var f=a.l;if(d=a.c,p=a.lc,h[s]=f,63==f){if(u.value-n.value>r)throw"Something wrong with hufUnpackEncTable";o(8,d,p,t,u);var m=a.l+6;if(d=a.c,p=a.lc,s+m>c+1)throw"Something wrong with hufUnpackEncTable";for(;m--;)h[s++]=0;s--}else if(f>=59){if(s+(m=f-59+2)>c+1)throw"Something wrong with hufUnpackEncTable";for(;m--;)h[s++]=0;s--}}!function(t){for(var e=0;e<=58;++e)l[e]=0;for(e=0;e<i;++e)l[t[e]]+=1;var n=0;for(e=58;e>0;--e){var r=n+l[e]>>1;l[e]=n,n=r}for(e=0;e<i;++e){var s=t[e];s>0&&(t[e]=s|l[s]++<<6)}}(h)}(t,0,n,s-(n.value-v),x,y,b),w>8*(s-(n.value-v)))throw"Something wrong with hufUncompress";!function(t,e,n,i){for(;e<=n;e++){var s=h(t[e]),a=c(t[e]);if(s>>a)throw"Invalid table entry";if(a>r){if((d=i[s>>a-r]).len)throw"Invalid table entry";if(d.lit++,d.p){var o=d.p;d.p=new Array(d.lit);for(var l=0;l<d.lit-1;++l)d.p[l]=o[l]}else d.p=new Array(1);d.p[d.lit-1]=e}else if(a){var u=0;for(l=1<<r-a;l>0;l--){var d;if((d=i[(s<<r-a)+u]).len||d.p)throw"Invalid table entry";d.len=a,d.lit=e,u++}}}}(b,x,y,_),function(t,e,n,i,s,a,o,l,m,g){for(var v=0,x=0,y=l,w=Math.trunc(s.value+(a+7)/8);s.value<w;)for(d(v,x,n,s),v=u.c,x=u.lc;x>=r;)if((T=e[v>>x-r&16383]).len)x-=T.len,f(T.lit,o,v,x,n,0,s,m,g,y),v=p.c,x=p.lc;else{if(!T.p)throw"hufDecode issues";var b;for(b=0;b<T.lit;b++){for(var _=c(t[T.p[b]]);x<_&&s.value<w;)d(v,x,n,s),v=u.c,x=u.lc;if(x>=_&&h(t[T.p[b]])==(v>>x-_&(1<<_)-1)){x-=_,f(T.p[b],o,v,x,n,0,s,m,g,y),v=p.c,x=p.lc;break}}if(b==T.lit)throw"hufDecode issues"}var M=8-a&7;for(v>>=M,x-=M;x>0;){var T;if(!(T=e[v<<r-x&16383]).len)throw"hufDecode issues";x-=T.len,f(T.lit,o,v,x,n,0,s,m,g,y),v=p.c,x=p.lc}}(b,_,t,0,n,w,y,g,m,{value:0})}function _(t){for(var e=1;e<t.length;e++){var n=t[e-1]+t[e]-128;t[e]=n}}function M(t,e){for(var n=0,r=Math.floor((t.length+1)/2),i=0,s=t.length-1;!(i>s||(e[i++]=t[n++],i>s));)e[i++]=t[r++]}function T(t){for(var e=t.byteLength,n=new Array,r=0,i=new DataView(t);e>0;){var s=i.getInt8(r++);if(s<0){e-=1+(o=-s);for(var a=0;a<o;a++)n.push(i.getUint8(r++))}else{var o=s;e-=2;var l=i.getUint8(r++);for(a=0;a<o+1;a++)n.push(l)}}return n}function S(t,e,n){for(var r,i=1;i<64;)65280==(r=e[t.value])?i=64:r>>8==255?i+=255&r:(n[i]=r,i++),t.value++}function A(t){const e=.5*Math.cos(.7853975),n=.5*Math.cos(3.14159/16),r=.5*Math.cos(3.14159/8),i=.5*Math.cos(3*3.14159/16),s=.5*Math.cos(.981746875),a=.5*Math.cos(3*3.14159/8),o=.5*Math.cos(1.374445625);for(var l=new Array(4),c=new Array(4),h=new Array(4),u=new Array(4),d=0;d<8;++d){var p=8*d;l[0]=r*t[p+2],l[1]=a*t[p+2],l[2]=r*t[p+6],l[3]=a*t[p+6],c[0]=n*t[p+1]+i*t[p+3]+s*t[p+5]+o*t[p+7],c[1]=i*t[p+1]-o*t[p+3]-n*t[p+5]-s*t[p+7],c[2]=s*t[p+1]-n*t[p+3]+o*t[p+5]+i*t[p+7],c[3]=o*t[p+1]-s*t[p+3]+i*t[p+5]-n*t[p+7],h[0]=e*(t[p+0]+t[p+4]),h[3]=e*(t[p+0]-t[p+4]),h[1]=l[0]+l[3],h[2]=l[1]-l[2],u[0]=h[0]+h[1],u[1]=h[3]+h[2],u[2]=h[3]-h[2],u[3]=h[0]-h[1],t[p+0]=u[0]+c[0],t[p+1]=u[1]+c[1],t[p+2]=u[2]+c[2],t[p+3]=u[3]+c[3],t[p+4]=u[3]-c[3],t[p+5]=u[2]-c[2],t[p+6]=u[1]-c[1],t[p+7]=u[0]-c[0]}for(var f=0;f<8;++f)l[0]=r*t[16+f],l[1]=a*t[16+f],l[2]=r*t[48+f],l[3]=a*t[48+f],c[0]=n*t[8+f]+i*t[24+f]+s*t[40+f]+o*t[56+f],c[1]=i*t[8+f]-o*t[24+f]-n*t[40+f]-s*t[56+f],c[2]=s*t[8+f]-n*t[24+f]+o*t[40+f]+i*t[56+f],c[3]=o*t[8+f]-s*t[24+f]+i*t[40+f]-n*t[56+f],h[0]=e*(t[f]+t[32+f]),h[3]=e*(t[f]-t[32+f]),h[1]=l[0]+l[3],h[2]=l[1]-l[2],u[0]=h[0]+h[1],u[1]=h[3]+h[2],u[2]=h[3]-h[2],u[3]=h[0]-h[1],t[0+f]=u[0]+c[0],t[8+f]=u[1]+c[1],t[16+f]=u[2]+c[2],t[24+f]=u[3]+c[3],t[32+f]=u[3]-c[3],t[40+f]=u[2]-c[2],t[48+f]=u[1]-c[1],t[56+f]=u[0]-c[0]}function E(t){for(var e=0;e<64;++e){var n=t[0][e],r=t[1][e],i=t[2][e];t[0][e]=n+1.5747*i,t[1][e]=n-.1873*r-.4682*i,t[2][e]=n+1.8556*r}}function C(t,e,n){for(var r=0;r<64;++r)e[n+r]=jp.toHalfFloat((i=t[r])<=1?Math.sign(i)*Math.pow(Math.abs(i),2.2):Math.sign(i)*Math.pow(s,Math.abs(i)-1));var i}function P(t){return new DataView(t.array.buffer,t.offset.value,t.size)}function L(t){var e=t.viewer.buffer.slice(t.offset.value,t.offset.value+t.size),n=new Uint8Array(T(e)),r=new Uint8Array(n.length);return _(n),M(n,r),new DataView(r.buffer)}function R(t){var n=t.array.slice(t.offset.value,t.offset.value+t.size);void 0===e&&console.error("THREE.EXRLoader: External library fflate.min.js required.");var r=gx(n),i=new Uint8Array(r.length);return _(r),M(r,i),new DataView(i.buffer)}function F(t){for(var e=t.viewer,r={value:t.offset.value},i=new Uint16Array(t.width*t.scanlineBlockSize*(t.channels*t.type)),s=new Uint8Array(8192),a=0,o=new Array(t.channels),l=0;l<t.channels;l++)o[l]={},o[l].start=a,o[l].end=o[l].start,o[l].nx=t.width,o[l].ny=t.lines,o[l].size=t.type,a+=o[l].nx*o[l].ny*o[l].size;var c=W(e,r),h=W(e,r);if(h>=8192)throw"Something is wrong with PIZ_COMPRESSION BITMAP_SIZE";if(c<=h)for(l=0;l<h-c+1;l++)s[l+c]=z(e,r);var u=new Uint16Array(n),d=function(t,e){for(var r=0,i=0;i<n;++i)(0==i||t[i>>3]&1<<(7&i))&&(e[r++]=i);for(var s=r-1;r<n;)e[r++]=0;return s}(s,u),p=O(e,r);for(b(t.array,e,r,p,i,a),l=0;l<t.channels;++l)for(var f=o[l],m=0;m<o[l].size;++m)w(i,f.start+m,f.nx,f.size,f.ny,f.nx*f.size,d);!function(t,e,n){for(var r=0;r<n;++r)e[r]=t[e[r]]}(u,i,a);for(var g=0,v=new Uint8Array(i.buffer.byteLength),x=0;x<t.lines;x++)for(var y=0;y<t.channels;y++){var _=(f=o[y]).nx*f.size,M=new Uint8Array(i.buffer,2*f.end,2*_);v.set(M,g),g+=2*_,f.end+=_}return new DataView(v.buffer)}function D(t){var n=t.array.slice(t.offset.value,t.offset.value+t.size);void 0===e&&console.error("THREE.EXRLoader: External library fflate.min.js required.");var r=gx(n);const i=t.lines*t.channels*t.width,s=1==t.type?new Uint16Array(i):new Uint32Array(i);let a=0,o=0;const l=new Array(4);for(let e=0;e<t.lines;e++)for(let e=0;e<t.channels;e++){let e=0;switch(t.type){case 1:l[0]=a,l[1]=l[0]+t.width,a=l[1]+t.width;for(let n=0;n<t.width;++n)e+=r[l[0]++]<<8|r[l[1]++],s[o]=e,o++;break;case 2:l[0]=a,l[1]=l[0]+t.width,l[2]=l[1]+t.width,a=l[2]+t.width;for(let n=0;n<t.width;++n)e+=r[l[0]++]<<24|r[l[1]++]<<16|r[l[2]++]<<8,s[o]=e,o++}}return new DataView(s.buffer)}function I(t){var e=t.viewer,n={value:t.offset.value},r=new Uint8Array(t.width*t.lines*(t.channels*t.type*2)),i={version:k(e,n),unknownUncompressedSize:k(e,n),unknownCompressedSize:k(e,n),acCompressedSize:k(e,n),dcCompressedSize:k(e,n),rleCompressedSize:k(e,n),rleUncompressedSize:k(e,n),rleRawSize:k(e,n),totalAcUncompressedCount:k(e,n),totalDcUncompressedCount:k(e,n),acCompression:k(e,n)};if(i.version<2)throw"EXRLoader.parse: "+Z.compression+" version "+i.version+" is unsupported";for(var s=new Array,a=W(e,n)-2;a>0;){var o=U(e.buffer,n),l=z(e,n),c=l>>2&3,h=new Int8Array([(l>>4)-1])[0],u=z(e,n);s.push({name:o,index:h,type:u,compression:c}),a-=o.length+3}for(var d=Z.channels,p=new Array(t.channels),f=0;f<t.channels;++f){var m=p[f]={},g=d[f];m.name=g.name,m.compression=0,m.decoded=!1,m.type=g.pixelType,m.pLinear=g.pLinear,m.width=t.width,m.height=t.lines}for(var v={idx:new Array(3)},x=0;x<t.channels;++x)for(m=p[x],f=0;f<s.length;++f){var y=s[f];m.name==y.name&&(m.compression=y.compression,y.index>=0&&(v.idx[y.index]=x),m.offset=x)}if(i.acCompressedSize>0)switch(i.acCompression){case 0:var w=new Uint16Array(i.totalAcUncompressedCount);b(t.array,e,n,i.acCompressedSize,w,i.totalAcUncompressedCount);break;case 1:var _=gx(t.array.slice(n.value,n.value+i.totalAcUncompressedCount));w=new Uint16Array(_.buffer),n.value+=i.totalAcUncompressedCount}if(i.dcCompressedSize>0){var M={array:t.array,offset:n,size:i.dcCompressedSize},P=new Uint16Array(R(M).buffer);n.value+=i.dcCompressedSize}if(i.rleRawSize>0){var L=T((_=gx(t.array.slice(n.value,n.value+i.rleCompressedSize))).buffer);n.value+=i.rleCompressedSize}var F=0,D=new Array(p.length);for(f=0;f<D.length;++f)D[f]=new Array;for(var I=0;I<t.lines;++I)for(var N=0;N<p.length;++N)D[N].push(F),F+=p[N].width*t.type*2;for(function(t,e,n,r,i,s){var a,o,l=new DataView(s.buffer),c=n[t.idx[0]].width,h=n[t.idx[0]].height,u=Math.floor(c/8),d=Math.ceil(c/8),p=Math.ceil(h/8),f=c-8*(d-1),m=h-8*(p-1),g={value:0},v=new Array(3),x=new Array(3),y=new Array(3),w=new Array(3),b=new Array(3);for(let n=0;n<3;++n)b[n]=e[t.idx[n]],v[n]=n<1?0:v[n-1]+d*p,x[n]=new Float32Array(64),y[n]=new Uint16Array(64),w[n]=new Uint16Array(64*d);for(let e=0;e<p;++e){var _=8;e==p-1&&(_=m);var M=8;for(let t=0;t<d;++t){t==d-1&&(M=f);for(let t=0;t<3;++t)y[t].fill(0),y[t][0]=i[v[t]++],S(g,r,y[t]),a=y[t],(o=x[t])[0]=V(a[0]),o[1]=V(a[1]),o[2]=V(a[5]),o[3]=V(a[6]),o[4]=V(a[14]),o[5]=V(a[15]),o[6]=V(a[27]),o[7]=V(a[28]),o[8]=V(a[2]),o[9]=V(a[4]),o[10]=V(a[7]),o[11]=V(a[13]),o[12]=V(a[16]),o[13]=V(a[26]),o[14]=V(a[29]),o[15]=V(a[42]),o[16]=V(a[3]),o[17]=V(a[8]),o[18]=V(a[12]),o[19]=V(a[17]),o[20]=V(a[25]),o[21]=V(a[30]),o[22]=V(a[41]),o[23]=V(a[43]),o[24]=V(a[9]),o[25]=V(a[11]),o[26]=V(a[18]),o[27]=V(a[24]),o[28]=V(a[31]),o[29]=V(a[40]),o[30]=V(a[44]),o[31]=V(a[53]),o[32]=V(a[10]),o[33]=V(a[19]),o[34]=V(a[23]),o[35]=V(a[32]),o[36]=V(a[39]),o[37]=V(a[45]),o[38]=V(a[52]),o[39]=V(a[54]),o[40]=V(a[20]),o[41]=V(a[22]),o[42]=V(a[33]),o[43]=V(a[38]),o[44]=V(a[46]),o[45]=V(a[51]),o[46]=V(a[55]),o[47]=V(a[60]),o[48]=V(a[21]),o[49]=V(a[34]),o[50]=V(a[37]),o[51]=V(a[47]),o[52]=V(a[50]),o[53]=V(a[56]),o[54]=V(a[59]),o[55]=V(a[61]),o[56]=V(a[35]),o[57]=V(a[36]),o[58]=V(a[48]),o[59]=V(a[49]),o[60]=V(a[57]),o[61]=V(a[58]),o[62]=V(a[62]),o[63]=V(a[63]),A(x[t]);E(x);for(let e=0;e<3;++e)C(x[e],w[e],64*t)}let s=0;for(let r=0;r<3;++r){const i=n[t.idx[r]].type;for(let t=8*e;t<8*e+_;++t){s=b[r][t];for(let e=0;e<u;++e){const n=64*e+8*(7&t);l.setUint16(s+0*i,w[r][n+0],!0),l.setUint16(s+2*i,w[r][n+1],!0),l.setUint16(s+4*i,w[r][n+2],!0),l.setUint16(s+6*i,w[r][n+3],!0),l.setUint16(s+8*i,w[r][n+4],!0),l.setUint16(s+10*i,w[r][n+5],!0),l.setUint16(s+12*i,w[r][n+6],!0),l.setUint16(s+14*i,w[r][n+7],!0),s+=16*i}}if(u!=d)for(let t=8*e;t<8*e+_;++t){const e=b[r][t]+8*u*2*i,n=64*u+8*(7&t);for(let t=0;t<M;++t)l.setUint16(e+2*t*i,w[r][n+t],!0)}}}for(var T=new Uint16Array(c),P=(l=new DataView(s.buffer),0);P<3;++P){n[t.idx[P]].decoded=!0;var L=n[t.idx[P]].type;if(2==n[P].type)for(var R=0;R<h;++R){const t=b[P][R];for(var F=0;F<c;++F)T[F]=l.getUint16(t+2*F*L,!0);for(F=0;F<c;++F)l.setFloat32(t+2*F*L,V(T[F]),!0)}}}(v,D,p,w,P,r),f=0;f<p.length;++f)if(!(m=p[f]).decoded){if(2!==m.compression)throw"EXRLoader.parse: unsupported channel compression";var O=0,B=0;for(I=0;I<t.lines;++I){for(var H=D[f][O],G=0;G<m.width;++G){for(var X=0;X<2*m.type;++X)r[H++]=L[B+X*m.width*m.height];B++}O++}}return new DataView(r.buffer)}function U(t,e){for(var n=new Uint8Array(t),r=0;0!=n[e.value+r];)r+=1;var i=(new TextDecoder).decode(n.slice(e.value,e.value+r));return e.value=e.value+r+1,i}function N(t,e){var n=t.getInt32(e.value,!0);return e.value=e.value+4,n}function O(t,e){var n=t.getUint32(e.value,!0);return e.value=e.value+4,n}function B(t,e){var n=t[e.value];return e.value=e.value+1,n}function z(t,e){var n=t.getUint8(e.value);return e.value=e.value+1,n}function k(t,e){var n=Number(t.getBigInt64(e.value,!0));return e.value+=8,n}function H(t,e){var n=t.getFloat32(e.value,!0);return e.value+=4,n}function G(t,e){return jp.toHalfFloat(H(t,e))}function V(t){var e=(31744&t)>>10,n=1023&t;return(t>>15?-1:1)*(e?31===e?n?NaN:1/0:Math.pow(2,e-15)*(1+n/1024):n/1024*6103515625e-14)}function W(t,e){var n=t.getUint16(e.value,!0);return e.value+=2,n}function X(t,e){return V(W(t,e))}function j(t,e,n,r,i){return"string"===r||"stringvector"===r||"iccProfile"===r?function(t,e,n){var r=(new TextDecoder).decode(new Uint8Array(t).slice(e.value,e.value+n));return e.value=e.value+n,r}(e,n,i):"chlist"===r?function(t,e,n,r){for(var i=n.value,s=[];n.value<i+r-1;){var a=U(e,n),o=N(t,n),l=z(t,n);n.value+=3;var c=N(t,n),h=N(t,n);s.push({name:a,pixelType:o,pLinear:l,xSampling:c,ySampling:h})}return n.value+=1,s}(t,e,n,i):"chromaticities"===r?function(t,e){return{redX:H(t,e),redY:H(t,e),greenX:H(t,e),greenY:H(t,e),blueX:H(t,e),blueY:H(t,e),whiteX:H(t,e),whiteY:H(t,e)}}(t,n):"compression"===r?function(t,e){return["NO_COMPRESSION","RLE_COMPRESSION","ZIPS_COMPRESSION","ZIP_COMPRESSION","PIZ_COMPRESSION","PXR24_COMPRESSION","B44_COMPRESSION","B44A_COMPRESSION","DWAA_COMPRESSION","DWAB_COMPRESSION"][z(t,e)]}(t,n):"box2i"===r?function(t,e){return{xMin:O(t,e),yMin:O(t,e),xMax:O(t,e),yMax:O(t,e)}}(t,n):"lineOrder"===r?function(t,e){return["INCREASING_Y"][z(t,e)]}(t,n):"float"===r?H(t,n):"v2f"===r?function(t,e){return[H(t,e),H(t,e)]}(t,n):"v3f"===r?function(t,e){return[H(t,e),H(t,e),H(t,e)]}(t,n):"int"===r?N(t,n):"rational"===r?function(t,e){return[N(t,e),O(t,e)]}(t,n):"timecode"===r?function(t,e){return[O(t,e),O(t,e)]}(t,n):"preview"===r?(n.value+=i,"skipped"):void(n.value+=i)}const Y=new DataView(t),q=new Uint8Array(t),Q={value:0},Z=function(t,e,n){const r={};if(20000630!=t.getUint32(0,!0))throw"THREE.EXRLoader: provided file doesn't appear to be in OpenEXR format.";r.version=t.getUint8(4,!0);const i=t.getUint8(5,!0);r.spec={singleTile:!!(1&i),longName:!!(2&i),deepFormat:!!(4&i),multiPart:!!(8&i)},n.value=8;for(var s=!0;s;){var a=U(e,n);if(0==a)s=!1;else{var o=U(e,n),l=j(t,e,n,o,O(t,n));void 0===l?console.warn(`EXRLoader.parse: skipped unknown header attribute type '${o}'.`):r[a]=l}}if(0!=i)throw console.error("EXRHeader:",r),"THREE.EXRLoader: provided file is currently unsupported.";return r}(Y,t,Q),J=function(t,e,n,r,i){const s={size:0,viewer:e,array:n,offset:r,width:t.dataWindow.xMax-t.dataWindow.xMin+1,height:t.dataWindow.yMax-t.dataWindow.yMin+1,channels:t.channels.length,bytesPerLine:null,lines:null,inputSize:null,type:t.channels[0].pixelType,uncompress:null,getter:null,format:null,encoding:null};switch(t.compression){case"NO_COMPRESSION":s.lines=1,s.uncompress=P;break;case"RLE_COMPRESSION":s.lines=1,s.uncompress=L;break;case"ZIPS_COMPRESSION":s.lines=1,s.uncompress=R;break;case"ZIP_COMPRESSION":s.lines=16,s.uncompress=R;break;case"PIZ_COMPRESSION":s.lines=32,s.uncompress=F;break;case"PXR24_COMPRESSION":s.lines=16,s.uncompress=D;break;case"DWAA_COMPRESSION":s.lines=32,s.uncompress=I;break;case"DWAB_COMPRESSION":s.lines=256,s.uncompress=I;break;default:throw"EXRLoader.parse: "+t.compression+" is unsupported"}if(s.scanlineBlockSize=s.lines,1==s.type)switch(i){case It:s.getter=X,s.inputSize=2;break;case Ut:s.getter=W,s.inputSize=2}else{if(2!=s.type)throw"EXRLoader.parse: unsupported pixelType "+s.type+" for "+t.compression+".";switch(i){case It:s.getter=H,s.inputSize=4;break;case Ut:s.getter=G,s.inputSize=4}}s.blockCount=(t.dataWindow.yMax+1)/s.scanlineBlockSize;for(var a=0;a<s.blockCount;a++)k(e,r);s.outputChannels=3==s.channels?4:s.channels;const o=s.width*s.height*s.outputChannels;switch(i){case It:s.byteArray=new Float32Array(o),s.channels<s.outputChannels&&s.byteArray.fill(1,0,o);break;case Ut:s.byteArray=new Uint16Array(o),s.channels<s.outputChannels&&s.byteArray.fill(15360,0,o);break;default:console.error("THREE.EXRLoader: unsupported type: ",i)}return s.bytesPerLine=s.width*s.inputSize*s.channels,4==s.outputChannels?(s.format=Gt,s.encoding=$e):(s.format=Yt,s.encoding=$e),s}(Z,Y,q,Q,this.type),K={value:0},$={R:0,G:1,B:2,A:3,Y:0};for(let t=0;t<J.height/J.scanlineBlockSize;t++){const e=O(Y,Q);J.size=O(Y,Q),J.lines=e+J.scanlineBlockSize>J.height?J.height-e:J.scanlineBlockSize;const n=J.size<J.lines*J.bytesPerLine?J.uncompress(J):P(J);Q.value+=J.size;for(let e=0;e<J.scanlineBlockSize;e++){const r=e+t*J.scanlineBlockSize;if(r>=J.height)break;for(let t=0;t<J.channels;t++){const i=$[Z.channels[t].name];for(let s=0;s<J.width;s++){K.value=(e*(J.channels*J.width)+t*J.width+s)*J.inputSize;const a=(J.height-1-r)*(J.width*J.outputChannels)+s*J.outputChannels+i;J.byteArray[a]=J.getter(n,K)}}}}return{header:Z,width:J.width,height:J.height,data:J.byteArray,format:J.format,encoding:J.encoding,type:this.type}}setDataType(t){return this.type=t,this}load(t,e,n,r){return super.load(t,(function(t,n){t.encoding=n.encoding,t.minFilter=Mt,t.magFilter=Mt,t.generateMipmaps=!1,t.flipY=!1,e&&e(t,n)}),n,r)}},t.RoughnessMipmapper=class{constructor(t){vy=t,vy.compile(fy,my)}generateMipmaps(t){if("roughnessMap"in t==0)return;const{roughnessMap:e,normalMap:n}=t;if(null===e||null===n||!e.generateMipmaps||t.userData.roughnessUpdated)return;t.userData.roughnessUpdated=!0;let r=Math.max(e.image.width,n.image.width),i=Math.max(e.image.height,n.image.height);if(!Xn.isPowerOfTwo(r)||!Xn.isPowerOfTwo(i))return;const s=vy.getRenderTarget(),a=vy.autoClear;vy.autoClear=!1,null!==gy&&gy.width===r&&gy.height===i||(null!==gy&&gy.dispose(),gy=new ir(r,i,{depthBuffer:!1}),gy.scissorTest=!0);const o=new Uc(r,i,e.format);o.wrapS=e.wrapS,o.wrapT=e.wrapT,o.minFilter=e.minFilter,o.magFilter=e.magFilter,t.roughnessMap=o,t.metalnessMap==e&&(t.metalnessMap=t.roughnessMap),t.aoMap==e&&(t.aoMap=t.roughnessMap),t.roughnessMap.offset.copy(e.offset),t.roughnessMap.repeat.copy(e.repeat),t.roughnessMap.center.copy(e.center),t.roughnessMap.rotation=e.rotation,t.roughnessMap.image=e.image,t.roughnessMap.matrixAutoUpdate=e.matrixAutoUpdate,t.roughnessMap.matrix.copy(e.matrix),py.uniforms.roughnessMap.value=e,py.uniforms.normalMap.value=n;const l=new jn(0,0),c=py.uniforms.texelSize.value;for(let e=0;r>=1&&i>=1;++e,r/=2,i/=2)c.set(1/r,1/i),0==e&&c.set(0,0),gy.viewport.set(l.x,l.y,r,i),gy.scissor.set(l.x,l.y,r,i),vy.setRenderTarget(gy),vy.render(fy,my),vy.copyFramebufferToTexture(l,t.roughnessMap,e),py.uniforms.roughnessMap.value=t.roughnessMap;e.dispose(),vy.setRenderTarget(s),vy.autoClear=a}dispose(){py.dispose(),fy.geometry.dispose(),null!=gy&&gy.dispose()}},t.LightProbeHelper=class extends gs{constructor(t,e){const n=new _s({type:"LightProbeHelperMaterial",uniforms:{sh:{value:t.sh.coefficients},intensity:{value:t.intensity}},vertexShader:["varying vec3 vNormal;","void main() {","\tvNormal = normalize( normalMatrix * normal );","\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );","}"].join("\n"),fragmentShader:["#define RECIPROCAL_PI 0.318309886","vec3 inverseTransformDirection( in vec3 normal, in mat4 matrix ) {","\t// matrix is assumed to be orthogonal","\treturn normalize( ( vec4( normal, 0.0 ) * matrix ).xyz );","}","// source: https://graphics.stanford.edu/papers/envmap/envmap.pdf","vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {","\t// normal is assumed to have unit length","\tfloat x = normal.x, y = normal.y, z = normal.z;","\t// band 0","\tvec3 result = shCoefficients[ 0 ] * 0.886227;","\t// band 1","\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;","\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;","\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;","\t// band 2","\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;","\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;","\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );","\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;","\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );","\treturn result;","}","uniform vec3 sh[ 9 ]; // sh coefficients","uniform float intensity; // light probe intensity","varying vec3 vNormal;","void main() {","\tvec3 normal = normalize( vNormal );","\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );","\tvec3 irradiance = shGetIrradianceAt( worldNormal, sh );","\tvec3 outgoingLight = RECIPROCAL_PI * irradiance * intensity;","\tgl_FragColor = linearToOutputTexel( vec4( outgoingLight, 1.0 ) );","}"].join("\n")});super(new Jh(1,32,16),n),this.lightProbe=t,this.size=e,this.type="LightProbeHelper",this.onBeforeRender()}dispose(){this.geometry.dispose(),this.material.dispose()}onBeforeRender(){this.position.copy(this.lightProbe.position),this.scale.set(1,1,1).multiplyScalar(this.size),this.material.uniforms.intensity.value=this.lightProbe.intensity}},t.LightProbeGenerator=class{static fromCubeTexture(t){let e=0;const n=new lr,r=new lr,i=new Li,s=[0,0,0,0,0,0,0,0,0],a=new sd,o=a.coefficients;for(let a=0;a<6;a++){const l=t.image[a],c=l.width,h=l.height,u=document.createElement("canvas");u.width=c,u.height=h;const d=u.getContext("2d");d.drawImage(l,0,0,c,h);const p=d.getImageData(0,0,c,h),f=p.data,m=p.width,g=2/m;for(let l=0,c=f.length;l<c;l+=4){i.setRGB(f[l]/255,f[l+1]/255,f[l+2]/255),xy(i,t.encoding);const c=l/4,h=(c%m+.5)*g-1,u=1-(Math.floor(c/m)+.5)*g;switch(a){case 0:n.set(-1,u,-h);break;case 1:n.set(1,u,h);break;case 2:n.set(-h,1,-u);break;case 3:n.set(-h,-1,u);break;case 4:n.set(-h,u,1);break;case 5:n.set(h,u,-1)}const d=n.lengthSq(),p=4/(Math.sqrt(d)*d);e+=p,r.copy(n).normalize(),sd.getBasisAt(r,s);for(let t=0;t<9;t++)o[t].x+=s[t]*i.r*p,o[t].y+=s[t]*i.g*p,o[t].z+=s[t]*i.b*p}}const l=4*Math.PI/e;for(let t=0;t<9;t++)o[t].x*=l,o[t].y*=l,o[t].z*=l;return new ad(a)}static fromCubeRenderTarget(t,e){let n=0;const r=new lr,i=new lr,s=new Li,a=[0,0,0,0,0,0,0,0,0],o=new sd,l=o.coefficients;for(let o=0;o<6;o++){const c=e.width,h=new Uint8Array(c*c*4);t.readRenderTargetPixels(e,0,0,c,c,h,o);const u=2/c;for(let t=0,d=h.length;t<d;t+=4){s.setRGB(h[t]/255,h[t+1]/255,h[t+2]/255),xy(s,e.texture.encoding);const d=t/4,p=(d%c+.5)*u-1,f=1-(Math.floor(d/c)+.5)*u;switch(o){case 0:r.set(1,f,-p);break;case 1:r.set(-1,f,p);break;case 2:r.set(p,1,-f);break;case 3:r.set(p,-1,f);break;case 4:r.set(p,f,1);break;case 5:r.set(-p,f,-1)}const m=r.lengthSq(),g=4/(Math.sqrt(m)*m);n+=g,i.copy(r).normalize(),sd.getBasisAt(i,a);for(let t=0;t<9;t++)l[t].x+=a[t]*s.r*g,l[t].y+=a[t]*s.g*g,l[t].z+=a[t]*s.b*g}}const c=4*Math.PI/n;for(let t=0;t<9;t++)l[t].x*=c,l[t].y*=c,l[t].z*=c;return new ad(o)}},t.TransformControls=Iy,window.THREE=t,window.ThreeMeshUI=Vw,window.ThreeMeshBVH=s,window.TILES=a})()})();